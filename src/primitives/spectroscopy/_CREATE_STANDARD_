# _CREATE_STANDARD_          -*- perl -*-
#
# creates a standard image

=head1 NAME

CREATE_STANDARD - creates and files a standard image and spectrum

=head1 DESCRIPTION

Takes a reduced group file for an observed standard, extracts a
spectrum from a single row of pixels, divides that spectrum by a
blackbody spectrum of the same temperature as the standard, then grows
the divided spectrum into an image with the same dimensions as the
original observations. The resulting image is then filed as a standard
calibration file.
Also optimally extracts a spectrum of the standard, divides it by the
black body model and files that as a standard calibration file.

=head1 PARAMETER

=over 4

=item TEMP

Defines the temperature of the standard star, in Kelvins.  If this parameter
is not defined by the user, the primitive first tries to determine the spectral
type of the standard from the Bright Standard Catalogue, then from querying
the SIMBAD astronomical database, then defaults to setting the temperature
to 6000 K. See NOTES below.

=item ROW

Defines the positive row to extract as the standard spectrum.
If SEARCH is greater than 1 this will be used to specify the center
of a region to be searched in order to find the best row to use.
If a row is not given, this primitive will default to the value
calculated by L<_DETERMINE_ROW_|_DETERMINE_ROW_>). The ROW
specified here will be passed to _DETERMINE_ROW_ in any case.
(since that primitive is called from this one in order to force
an index entry). This primitive does not use the negative row
for extraction since, in general, standards are bright enough
that this extra step is not required.

=item SEARCH

Number of rows to search in order to determine the best row to
extract.  Best is defined as brightest row. In general it is more
accurate to simply run the _DETERMINE_ROW_ primitive in order to find
the best row for extraction.  Defaults to 1 (i.e., no searching just
take the specified row).


=back

=head1 ORAC

=head2 Engines referenced

KAPPA, FIGARO

=head2 Tasks called

=over 4

=item kappa_mon

cdiv, cmult, div, stats, ndfcopy, pixdupe

=item figaro1

optextract, profile

=item figaro2

fwconv

=item figaro4

bbody

=item ndfpack_mon

axlabel, axunits, ndftrace, settitle, setorigin, setbound

=back

=head2 Objects addressed

$Grp

=head2 OUTPUT FILES

Following output files are created and filed:

=over 4

=item C<std_N>

The standard grown to the same dimension as the array. This is
simply extracted from the specified extraction row and divided by 
the black body.
This spectrum can not be displayed.

=item C<std_N_sp>

Optimally extracted standard spectrum, divided by the black body.

=item C<gc..._sp> 

Optimally extracted spectrum of the standard star.

=head2 INDEX FILES

The standards are written to an index file.

=head1 NOTES

If the spectral type of the standard cannot be found in the Bright
Star Catalogue (which should exist in the $ORAC_DATA_CAL directory),
this primitive queries the SIMBAD astronomical database. As this query
requires a network connection of some sort, it will fail if no network
connection exists.  The timeout for this query is currently set to 20
seconds; this can be modified if it is found that this timeout is too
short (for flaky network connections) or too long (for no network
connection at all).

In addition to the previous note, it must also be noted that this
primitive parses the web page one receives from SIMBAD. As this web
page is likely to change in the future, this primitive must also
change in how it parses the web page. The format of this web page may
be seen by going to the SIMBAD web site (
http://simbad.harvard.edu/Simbad or http://simbad.u-strasbg.fr/Simbad) 
and doing a sample query. Also, it currently assumes that the first
source returned by SIMBAD is the relevant one. This should be correct
in most cases but the SIMBAD database is such that occasionally queries
return sources at the same position with varying V magnitudes and spectral
types. User be warned if accuracy is required!

This primitive uses a conversion chart between spectral type and
temperature as found on the web page at
http://huey.jpl.nasa.gov/~gerard/q_refs/sptype_temp.html This web page
obtained this information from Dyck et al. (1996) and Allen (1976).
Checking this information against a third reference (Lang, 1991)
showed a good correspondence.

If a v magnitude or spectral type can not be determined obviously
incorrect values are stored in the header and flux calibration
will not proceed.

=head2 REVISION

 $Id$

=head1 AUTHOR

b.cavanagh@jach.hawaii.edu

modified by p.hirst@jach.hawaii.edu

=cut

# Validation
# ==========
    my $groupname = $Grp->file;
    if ( !( $Grp->file_exists ) ) {
       orac_print "\nReduced group file $groupname does not exist.\n";
       orac_print "Cannot create standard until later.\n";

    } elsif ( ! $Frm->uhdr( "PAIR_COMPLETE" ) ) {
       orac_print "\nPair not yet complete.  Will not create new standard yet.\n";
    } else {

# We need to get the star parameters.  Since this is sometimes costly
# we only do this if we have not already done it for this group!
# This does not force a new determination in the case where the
# network was down and is now up for this particular star...
    my ( $vmag, $temperature, $spectype );
    unless ( defined $Grp->uhdr( "TEMPERATURE" ) &&
             defined $Grp->uhdr( "VMAG" ) &&
	     defined $Grp->uhdr( "SPECTYPE" ) ) {

# Get the temperature parameter.
# ==============================

# If the temperature parameter is not defined, check configuration table
# for spectral type.  If that fails, inquire SIMBAD for the spectral type.
# If SIMBAD fails, default to 6000.
       $temperature = ($_CREATE_STANDARD_{TEMP} || undef);
       my %spectotemp = (
                          O5 => 40000,
                          O6 => 37000,
                          O7 => 35000,
                          O8 => 34000,
                          O9 => 33000,
                          B0 => 30000,
                          B1 => 25400,
                          B2 => 22000,
                          B3 => 18700,
                          B4 => 17000,
                          B5 => 15400,
                          B6 => 14000,
                          B7 => 13000,
                          B8 => 11900,
                          B9 => 10500,
                          A0 => 9520,
                          A1 => 9230,
                          A2 => 8970,
                          A3 => 8720,
                          A4 => 8500,
                          A5 => 8200,
                          A6 => 8000,
                          A7 => 7850,
                          A8 => 7580,
                          A9 => 7400,
                          F0 => 7200,
                          F1 => 7000,
                          F2 => 6890,
                          F3 => 6700,
                          F4 => 6500,
                          F5 => 6440,
                          F6 => 6350,
                          F7 => 6275,
                          F8 => 6200,
                          F9 => 5900,
                          G0 => 5930,
                          G1 => 5880,
                          G2 => 5830,
                          G3 => 5785,
                          G4 => 5740,
                          G5 => 5680,
                          G6 => 5620,
                          G7 => 5525,
                          G8 => 5430,
                          G9 => 5335,
                          K0 => 5240,
                          K1 => 5125,
                          K2 => 5010,
                          K3 => 4785,
                          K4 => 4560,
                          K5 => 4340,
                          K6 => 4185,
                          K7 => 4030,
                          K8 => 3950,
                          K9 => 3875,
                          M0 => 3800,
                          M1 => 3680,
                          M2 => 3530,
                          M3 => 3380,
                          M4 => 3180,
                          M5 => 3030,
                          M6 => 2850,
                        );

# Try the Bright Star Catalogue
# -----------------------------
# First check the calibration table for spectral type of the standard.
       if ( !defined( $temperature ) ) {
          my $type;
          my $objname = $Frm->uhdr( "ORAC_OBJECT" );
          orac_print "Searching Bright Star Catalogue for $objname.\n";

# Name must be bs (case insensitive) followed by zero or one space and
# one to four digits.
          if ( $objname =~ /bs\s?([0-9]{1,4})/i ) {
             my $bsnum = $1;

# Open the catalogue and define a format specifier for it.
             my $calfile = $ENV{'ORAC_DATA_CAL'} . "/bsc5.dat";
             open BSFILE, $calfile;
             my $template = "a4a10a2a9a6a6a4a1a1a1a5a2a9a2a2a4a1a2a2" .
                            "a2a2a2a4a1a2a2a2a6a6a5a1a1a5a1a5a1a5a1" .
                            "a20a1a6a6a1a5a4a4a2a3a1a4a6a4a2a1\n";

# Read the file and form an array of the values.
             while ( <BSFILE> ) {
                my @data = unpack( $template, $_ );
                if ( $1 == $data[0] ) {

# Remove the first two characters from $data[38] (spectral type).
                   my $revdata = reverse $data[38];
                   chop $revdata;
                   chop $revdata;
                   $data[38] = reverse $revdata;

# Determine the spectral type from the first two characters.
                   if ( $data[38] =~ /^([a-z][0-9])/i ) {
                      $spectype = $1;
                      orac_print "     Object is spectral type $spectype\n";
                      ( $vmag = $data[29] ) =~ s/\s+//g;

# Hence derive the temperature.
                      $temperature = $spectotemp{$spectype};
                      orac_print "     Setting temperature to $temperature K.\n";
                      orac_print "     V magnitude is $vmag.\n";
                   }
                   last;
                }
             }
             close BSFILE;
          }
       }

# Find the spectral type from SIMBAD.
# -----------------------------------
       if ( ( !defined( $temperature ) ) && 
            ( defined( &LWP::Simple::get ) ) ) {
      
          orac_print "Object not found in Bright Star Catalogue.\n";
          orac_print "Querying SIMBAD for spectral type...\n";

          my $meanra = $Frm->uhdr( "ORAC_RABASE" );
          my $meandec = $Frm->uhdr( "ORAC_DECBASE" );
      
          my ( $radeg, $ramin, $rasec ) = dectodms( $meanra );
          my ( $decdeg, $decmin, $decsec ) = dectodms( $meandec );

# Set up the URL.
          my $URL1 = "http://simbad.harvard.edu/sim-id.pl?protocol=html&Ident=" .
                     $radeg . "+" . $ramin . "+";
          my $URL2;
          if ( $decdeg > 0 ) {
             $URL2 = $rasec . "+%2B" . $decdeg . "+" . $decmin . "+" . $decsec .
                     "&NbIdent=1&Radius=10&Radius.unit";
          } else {
             $URL2 = $rasec . "+" . $decdeg . "+" . $decmin . "+" . $decsec .
                     "&NbIdent=1&Radius=10&Radius.unit";
          }
          my $URL3 = "=arcmin&CooFrame=FK5&CooEpoch=2000&CooEqui=2000&output.max=";
          my $URL4 = "all&o.catall=on&output.mesdisp=N&Bibyear1=1983&Bibyear2=1999&Frame1=FK5";
          my $URL5 = "&Frame2=none&Frame3=none&Epoch1=2000.0&Epoch2=1950.0&Epoch3=2000.0&Equi1";
          my $URL6 = "=2000.0&Equi2=1950.0&Equi3=2000.0";
          my $URL = $URL1 . $URL2 . $URL3 . $URL4 . $URL5 . $URL6;

# Attempt to access the URL.  If successful the information is stored in
# the content array with appropriate line breaks.
          $LWP::Simple::ua->timeout(20); # set timeout to 20 seconds
          my @content = split '\n', LWP::Simple::get( $URL );
          if ( !defined( $content[ 0 ] ) ) {
             orac_print "Unable to connect to SIMBAD database.\n";
          } else {
             my $found = 0;

# If the SIMBAD results page changes, this will need to change as well.
# For each line, split the fields into an array.
             foreach my $string ( @content ) { 
                my @array = ();
                @array = split '\|', $string;

# Extract the spectral type.
                if ( ( defined( $array[ 4 ] ) ) &&
                     ( $array[ 4 ] =~ /([a-z][0-9])/i ) && ( $found == 0 ) ) { 
                   $spectype = $1;

# Obtain the standard's equatorial co-ordinates.
                   my @simcoord = split ' ', $array[ 2 ];
                   my $format = "%2d %2d %4.2f";
                   my $rastring = sprintf( $format, $radeg, $ramin, $rasec );
                   my $decstring = sprintf( $format, $decdeg, $decmin, $decsec );
                   my $srastring = sprintf( $format, $simcoord[ 0 ],
                                   $simcoord[ 1 ], $simcoord[ 2 ] );
                   my $sdecstring = sprintf( $format, $simcoord[ 3 ],
                                             $simcoord[ 4 ], $simcoord[ 5 ] );

# Keep the user informed.
                   orac_print "    Header RA: $rastring Decl: $decstring.\n";
                   orac_print "    SIMBAD RA: $srastring Decl: $sdecstring.\n";
                   orac_print "    Object is spectral type $spectype.\n";
                   $temperature = $spectotemp{$spectype};
                   orac_print "    Setting temperature to $temperature K.\n";

# Record the match.
                   $found = 1;

# Find the V magnitude.  Simply look for the last number surrounded by
# spaces, rather than looking for 'Number Number' which sometimes
# fails since occasionally SIMBAD inserts a character between
# the numbers.
                   $array[ 3 ] =~ /([\d\.]+)\s*$/;
                   $vmag = $1;
                   if ( defined $vmag ) {
                      orac_print "    V magnitude is $vmag (from $array[ 3 ] ).\n";
                   } else {
                      orac_warn "V magnitude information did not match " .
                                "the expected pattern.\n";
                      orac_warn "Got: '$array[ 3 ]' expected  'Number ? ".
                                "Number' (where ? is an optional character).\n";
                      orac_warn "V magnitude could not be determined.\n";
                   }
            
                }
             }

             if ( ! $found  ) {
                my $format = "%2d %2d %4.2f";
                my $rastring = sprintf($format,$radeg,$ramin,$rasec);
                my $decstring = sprintf($format,$decdeg,$decmin,$decsec);
                orac_print "Object at RA: $rastring Decl: $decstring " .
                           "is not classified in SIMBAD.\n";
             }
          }
       }

# Use defaults if other methods have failed.
# ------------------------------------------
# If SIMBAD failed to set the temperature, default to 6000
       unless (defined $temperature) {
          $temperature = 6000.0;
          orac_print "    Temperature could not be determined.  " .
                     "Defaulting to $temperature K.\n";
      
       }

# Write a obviously wrong V magnitude, if not set.
       unless ( defined $vmag ) {
          $vmag = -1000.0;
          orac_warn "    Could not determine the V magnitude.\n";
       }

# Default the spectral type.
       unless ( defined $spectype ) {
          $spectype = "UNKNOWN";
          orac_warn "Could not determine spectral type.\n";
       }

# Store or read values to or from the headers.
# ============================================

# Store the values in the header.
       $Grp->uhdr( "VMAG", $vmag );
       $Grp->uhdr( "TEMPERATURE", $temperature );
       $Grp->uhdr( "SPECTYPE", $spectype );

# Values are already stored, so access them.
    } else {
       $vmag = $Grp->uhdr( "VMAG" );
       $temperature = $Grp->uhdr( "TEMPERATURE" );
       $spectype = $Grp->uhdr( "SPECTYPE" );

       orac_print "\nUsing previously determined values of " .
                  "Vmag=$vmag, SPECTYPE=$spectype, TEMP=$temperature.\n";
    }

# Get other arguments.
# ====================

# Determine the extraction rows.   Check to see if we are overriding
# the extraction row.
    my $defrow;
    if ( exists $_CREATE_STANDARD_{ROW} ) {
       $defrow = $_CREATE_STANDARD_{ROW};
       orac_print "\nUsing row $defrow provided by user.\n";
       _DETERMINE_ROW_ POSROW=$defrow
    } else {

# Retrieve the correct row from the calibration object
# There is no override.  This either works or fails.
       _DETERMINE_ROW_
       my @rows = $Cal->rows;
       $defrow = $rows[ 0 ];
       orac_print "\nUsing row $defrow read from index file\n";
    }
    my $extractrow = $defrow;

# Get the search box (make sure it is at least size 1)
    my $search = ( exists $_CREATE_STANDARD_{SEARCH} &&
                   defined $_CREATE_STANDARD_{SEARCH} &&
                   $_CREATE_STANDARD_{SEARCH} > 1
                   ? $_CREATE_STANDARD_{SEARCH} : 1 );

# Get the reference wavelength.  The blackbody flux will be normalized
# to the flux at this wavelength.  The units are in metres.
    my $refwave = $Frm->uhdr( "ORAC_GRATING_WAVELENGTH" ) / 1000000;


# Determine standard from extraction row.
# =======================================

# Get Y dimension.
    my $ORAC_STATUS;
    $Mon{'ndfpack_mon'}->obeyw( "ndftrace", "ndf=$groupname quiet=true" );

    ( $ORAC_STATUS, my @dims ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "dims" );
    ( $ORAC_STATUS, my @ubound ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "ubound" );
    my $ydim = $dims[ 1 ];

# Complain if the row is outside the bounds.
    if ( $extractrow > $ubound[ 1 ] ) {
       orac_warn "Extraction row is larger than Y size of array.  ";
       orac_warn "Setting extraction row to the default of $defrow.\n";
       $extractrow = $defrow;
    }

# Start the processing.
    my $in = $Grp->file;
    my $out = "std_" . $Grp->name; # assumes the name is something short
  
# If the spectral type is known, set the SPECTYPE header.
    if ( defined $spectype ) {
       no warnings 'misc';
       _SET_GROUP_FITS_ITEM_ KEY=SPECTYPE VALUE=$spectype COMMENT=spectral|type
    }

    if ( defined $vmag ) {
       no warnings 'misc';
       _SET_GROUP_FITS_ITEM_ KEY=VMAG VALUE=$vmag COMMENT=V|magnitude
    }

# If the search box is larger than 1, we need to run STATS on a section
# of the array to determine the brightest line.
     if ( $search > 1 ) {
        my $min = $extractrow - int( ( $search +1 ) / 2 );
        my $max = $extractrow + int( ( $search +1 ) / 2 );
        $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$in(,$min:$max)" );

# Read the statistics to find the position of the pixel with the largest
# value.
       ( $ORAC_STATUS, my @maxpos ) = $Mon{'kappa_mon'}->get( "stats", "maxpos" );

# We want the second number, i.e the row not the column.
       orac_print "Extraction row calculated to be at row $maxpos[ 1 ] " .
                  "(cf. $extractrow originally).\n";
       $extractrow = $maxpos[ 1 ];

     } else {
       orac_print "Using extraction row $extractrow.\n";
     }

# Extract the row specified above into $specname.
     my $spec = new ORAC::TempFile;
     my $specname = $spec->file;
     my $param = "in=$in(,$extractrow) out=$specname";

# One problem with ndfcopy is that earlier versions retain the pixel
# co-ordinates of the section even if a 1-D slice is extracted.  This is
# configurable from V0.15-9, so collapse the null axis..
     if ( starversion_gt( "KAPPA", "0.15-8" ) ) {
        $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "$param trim" );
     } else {
        $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "$param" );

# For old KAPPA, change the pixel co-ordinates so that the Y slice is
# at 1.  Simply set the pixel origin to 1,1.
        $Mon{'ndfpack_mon'}->obeyw( "setorigin", "ndf=$specname origin=[1,1]" );
     }

# Set axis information (assuming wavelength units are microns).
# Do not need to set the units since they are inherited from the NDFCOPY.
# However, we do need to set the axis label, since that is not recognised if
# it contains 'estimated wavelength' rather than 'wavelength'.
     $Mon{'ndfpack_mon'}->obeyw( "axlabel", "ndf=$specname label=wavelength dim=1" );

# Assume that _WAVELENGTH_CALIBRATE_BY_ESTIMATION_ has correctly used 'micron'.
# Uncomment if this is not true or if you want to make sure.
     $Mon{'ndfpack_mon'}->obeyw( "axunits", "ndf=$specname units=micron dim=1" );

# Create a blackbody spectrum and apply it.
# =========================================

# Create a blackbody in $bbname using axis information from $specname.
     my $bb = new ORAC::TempFile;
     my $bbname = $bb->file;
     $param = "logar=no temp=$temperature in=$specname out=$bbname";
     $Mon{'figaro4'}->obeyw( "bbody", "$param" );

# Convert the blackbody units from F-nu to F-lambda.
     $Mon{'figaro2'}->obeyw( "fwconv", "spectrum=$bbname flux_unit=erg output=$bbname" );

# Convert the blackbody units from CGS F-lambda to MKS F-lambda.  It
# would be more efficient to calculate the multiplication factor
# once so that we don't have to perform two independent arithmetic
# operations.
     my $bbmks = new ORAC::TempFile;
     my $bbmksname = $bbmks->file;
     $Mon{'kappa_mon'}->obeyw( "cmult", "in=$bbname scalar=0.1 out=$bbmksname" );

# Calculate the flux at the reference wavelength (flux units are Jy/sr).
     my $const1 = 1.1910439e-16;
     my $const2 = 0.01438769;
     my $refflux = ( $const1 / ( $refwave ** 5 ) ) /
                   ( exp( $const2 / ( $refwave * $temperature ) ) - 1 );

# Normalize the blackbody by the reference flux.
     my $normbb = new ORAC::TempFile;
     my $normbbname = $normbb->file;
     $param = "in=$bbmksname out=$normbbname scalar=$refflux";
     $Mon{'kappa_mon'}->obeyw( "cdiv", "$param" );

# Set the variance to be zero in the black-body curve.
     $Mon{'ndfpack_mon'}->obeyw( "setvar", "ndf=$normbbname variance=0" );

# Divide the extracted spectrum by the normalized blackbody spectrum
     my $div = new ORAC::TempFile;
     my $divname = $div->file;
     $param = "in1=$specname in2=$normbbname out=$divname";
     $Mon{'kappa_mon'}->obeyw( "div", "$param" );

# Grow the blackbody-normalized spectrum into a 2-D image.
# ========================================================

# Note that this is now truly a 1-D spectrum (and not a 2-D image of size
# 1 in the second dimension (which is what it was after the extraction if
# an old NDFCOPY is used)).  We need to turn it into a 2-D image again 
# before PIXDUPE will work.  Would be better if PIXDUPE assumed you wanted
# to add the extra dim.
     $Mon{'ndfpack_mon'}->obeyw( "setbound", "ndf=$divname(,1)" );
     $Mon{'kappa_mon'}->obeyw( "pixdupe", "in=$divname out=$out expand=[1,$ydim]" );

# Set the pixel co-ordinates to be the same as the input image.
     $Mon{'ndfpack_mon'}->obeyw( "setorigin", "ndf=$out like=$in" );

# Now we need to set the AXIS co-ordinate for Y so that it will
# display correctly.  If the LIKE parameter is available, we want to
# copy the whole the AXIS component.  Otherwise do it piecemeal.
     if ( starversion_gt( "KAPPA", "0.15-8" ) ) {
        $Mon{'ndfpack_mon'}->obeyw( "setaxis", "ndf=$out like=$in" );
     } else {
        $Mon{'ndfpack_mon'}->obeyw( "setaxis","ndf=$out dim=2 mode=expr exprs=index" );
        $Mon{'ndfpack_mon'}->obeyw( "axlabel","ndf=$out label='detector row' dim=2" );
        $Mon{'ndfpack_mon'}->obeyw( "axunits","ndf=$out units=pixel dim=2" );
     }

# Set the title of the output image.
     my $objname = $Frm->uhdr( "ORAC_OBJECT" );
     my $title = "$objname (T=$temperature K Vmag=$vmag)";
     $Mon{'ndfpack_mon'}->obeyw( "settitle", "ndf=$out title='$title'" );

# Print congratulatory message.
     orac_print "$in to $out: Standard created.\n";

# File the standard.
# ==================
     $Cal->standard( $out );
     orac_print "$out filed as the current standard.\n";

# Store it in the index file.  First need to take a copy of the
# header so that we can store extra header information.
     my %hdr = %{ $Grp->hdr };
     $hdr{NDIMS} = 2;  # This is the grown standard
     $Cal->standardindex->add( $out, \%hdr );
  
     orac_print "$out added to index file\n";


# Determine standard by optimal extraction.
# =========================================

# Set output file name to something else, and make sure it has a suffix
# recognisable from the display system
     $out = $Grp->raw . "_sp";

# Profile the image.  First create some temporary-file names.
     my $prof = new ORAC::TempFile;
     my $proffile = $prof->file;
     my $tmp  = new ORAC::TempFile;
     my $tmpfile = $tmp->file;

# Find the cross-section/spatial profile, using any variance
# information to weight the points.  It uses a fifth-order polynomial
# to fit to the rows, rejecting the worst five points in each row.  This
# assumes minimal tilt of the spectra with respect to the X axis.
     my $start = $extractrow - 2;
     my $end   = $extractrow + 2;
     my $args = "degree=5 nreject=5 weight=yes residual=$tmpfile";
     $param = "profile=$proffile ystart=$start yend=$end";
     $Mon{'figaro1'}->obeyw( "profile", "image=$in $param $args" ); 

# Now do the optimal extaction with variance weighting.
     $param = "image=$in profile=$proffile spectrum=$out weight=yes";
     $Mon{'figaro1'}->obeyw( "optextract", "$param" );

# Add an informative title for display purposes.
     $Mon{'ndfpack_mon'}->obeyw( "settitle", "ndf=$out title='$title'" );

# Report the good news.
     orac_print "$in to $out: Optimally extracted spectrum created.\n";

# Normalize by the corresponding blackbody.
# =========================================

# Take the spectrum and divide it by the black body.
     my $gcsp = $out;
     $out = "std_" . $Grp->name . "_sp";

# Do the division.
     $Mon{'kappa_mon'}->obeyw( "div", "in1=$gcsp in2=$normbbname out=$out" );

# Set the title and some other stuff.
     $objname = $Frm->uhdr( "ORAC_OBJECT" );
     $title = "$objname (T=$temperature K Vmag=$vmag)";
     $Mon{'ndfpack_mon'}->obeyw( "settitle", "ndf=$out title='$title'" );

# Print congratulatory message.
     orac_print "$gcsp to $out: Standard spectrum created.\n";
 
# Store the standard and its dimensionality in the index file.
     $hdr{NDIMS} = 1; # Cos err, it's a spectrum.
     $Cal->standardindex->add( $out, \%hdr );

     orac_print "$out added to index file\n";

# Display optimally extracted spectrum.
# =====================================

# Get the current file name
     my $current = $Grp->file;
  
# Set the group output name for the display system.
     $Grp->file( $out );

# Display the optimally extracted spectrum.
     $Display->display_data( $Grp ) if defined $Display;

# Now reset the output filename since we don't want the group
# to reference the optimally extracted spectrum.
     $Grp->file( $current );

   }
