=head1 NAME

_EXTRACT_FIND_ROWS_

=head1 DESCRIPTION

Finds the rows in a group image at which to centre the spectra 
extraction windows.

=head1 AUTHOR

Paul Hirst <p.hirst@jach.hawaii.edu>

=cut

# Get the input filename. We won't actually use $out here - we just add
# some entries to the group uhdr.
my $in=$Grp->raw;

# Variables we're going to set:

# Central rows of each beam
my @row;

# We get the number of beams there should be from the Grp->uhdr - should have been put
# there by _EXTRACT_DETERMINE_NBEAMS_

my $nbeams = $Grp->uhdr("NBEAMS");


# The methodolgy of this is as follows: 
#   1) try to detect beams simply by looking at the frame image
#      If we detect them with sufficient confindence, we use them
#      otherwise we fall back to:
#   2) Consult index.rows 
#      If this fails:
#   3) Can we determine where the beams should be from the headers
#      - this includes pair reduction where we know the offset.
#      If not, we fall back to:
#      If this fails, we fall back to the last resort:
#   4) Assume rows 102 and 140.


# First, try to detect beams in the image.

# Collapse the image along the dispersion axis into a tmp file

my $colfile = $in."_ypr";
$Mon{'kappa_mon'}->obeyw("collapse", "in=$in out=$colfile axis=1");

# Send the Y PRofile file off to display
my $yprFrm = new $Frm;
$yprFrm->file($colfile);
$Display->display_data( $yprFrm ) if defined $Display;

my $ncol = new ORAC::TempFile;
my $ncolfile = $ncol->file;
$Mon{'kappa_mon'}->obeyw("cmult", "in=$colfile scalar=-1 out=$ncolfile");

# We do +ve beams first.
# How many +ve beams should there be?
my $posbeams=0;
$posbeams=1 if ($nbeams==1);
$posbeams=1 if ($nbeams==2);
$posbeams=1 if ($nbeams==3);
$posbeams=2 if ($nbeams==4);

# the beam multiplier
my $mult = 1;
$mult = 2 if($nbeams==3);

if($posbeams) {
   # Call figaro emlt on the collapsed file
   $Mon{'figaro2'}->obeyw("emlt", "spectrum=$colfile xstart=min xend=max lines=$posbeams");

   # Do not put a semi-colon on the end of the following line
   _PARSE_EMLT_LIS_ FIRST=1 NLINES=$posbeams MULT=$mult
}

# Now do the -ve beams;
my $negbeams=0;
$negbeams=0 if($nbeams==1);
$negbeams=1 if($nbeams==2);
$negbeams=2 if($nbeams==3);
$negbeams=2 if($nbeams==4);
$mult = -1;

if($negbeams) {
   # Call figaro emlt on the negated collapsed file
   $Mon{'figaro2'}->obeyw("emlt", "spectrum=$ncolfile xstart=min xend=max lines=$negbeams");

   my $first = $posbeams+1;
   # Do not put a semi-colon on the end of the following line
   _PARSE_EMLT_LIS_ FIRST=$first NLINES=$negbeams MULT=$mult
}
   
if ($nbeams == 0) {
   # Didn't find any beams so far. fall back to rows calibration
   my @rows = $Cal->rows;
   if (defined $rows[0]) {
      $nbeams++;
      $row[$nbeams] = $rows[0];
   }
   if (defined $rows[1]) {
      $nbeams++;
      $row[$nbeams] = $rows[1];
   }
}

if ($nbeams == 0) {
   # Didn't find any beams so far. fall back to guessing
   
   # The main beam is probably at row 96
   $nbeams++;
   $row[$nbeams]=96;

   # is this a pairwise sequence?
   if (defined ($Frm->uhdr("PAIR_COMPLETE"))) {
      # Yes, it's pairwise

      # Is the sky position close?
      # This should really compare the angle to the slit angle too
      # And look at the slit length...

      my $skyraoff=$Grp->uhdr("SKY_RAOFF");
      my $skydecoff=$Grp->uhdr("SKY_DECOFF");  
      my $noddist = sqrt($skyraoff * $skyraoff * $skydecoff * $skydecoff);
      if ($noddist < 50) {
         # Chances are we're on the slit
	 # Guess the pixel scale for now
	 my $pixsize = 0.6;
	 my $offset = $noddist / $pixsize;
	 $nbeams++;
	 $row[$nbeams] = 96+$offset;
       }
   } else {
     # No, it's not pairwise
     # Assume there's no offset beam.
   }
}

orac_print "\n";
