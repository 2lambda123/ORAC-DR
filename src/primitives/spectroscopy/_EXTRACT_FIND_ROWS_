=head1 NAME

_EXTRACT_FIND_ROWS_

=head1 DESCRIPTION

Finds the rows in a group image at which to centre the spectra 
extraction windows.

=head1 AUTHOR

Paul Hirst <p.hirst@jach.hawaii.edu>

=cut

# Get the input filename. We won't actually use $out here - we just add
# some entries to the group uhdr.
my $in=$Grp->file;

# Variables we're going to set:

# Central rows of each beam
my @row;

# We get the number of beams there should be from the Grp->uhdr - should have been put
# there by _EXTRACT_DETERMINE_NBEAMS_

my $nbeams = $Grp->uhdr("NBEAMS");


# The methodolgy of this is as follows: 
#   1) try to detect beams simply by looking at the frame image
#      If we detect them with sufficient confindence, we use them
#      otherwise we fall back to:
#   2) Consult index.rows 
#      If this fails:
#   3) Can we determine where the beams should be from the headers
#      - this includes pair reduction where we know the offset.
#      If not, we fall back to:
#      If this fails, we fall back to the last resort:
#   4) Assume rows 102 and 140.


# First, try to detect beams in the image.

# Collapse the image along the dispersion axis into a tmp file

my $colfile = $in."_ypr";
$Mon{'kappa_mon'}->obeyw("collapse", "in=$in out=$colfile axis=1");

# Send the Y PRofile file off to display
my $yprFrm = new $Frm;
$yprFrm->file($colfile);
$Display->display_data( $yprFrm ) if defined $Display;

my $ncol = new ORAC::TempFile;
my $ncolfile = $ncol->file;
$Mon{'kappa_mon'}->obeyw("cmult", "in=$colfile scalar=-1 out=$ncolfile");

# We do +ve beams first.
# How many +ve beams should there be?
my $posbeams=0;
$posbeams=1 if ($nbeams==1);
$posbeams=1 if ($nbeams==2);
$posbeams=1 if ($nbeams==3);
$posbeams=2 if ($nbeams==4);

# the beam multiplier
my $mult = 1;
$mult = 2 if($nbeams==3);

my $tmp = new ORAC::TempFile;
my $tmpfile = $tmp->file;

my $posbeamsfound=0;
if($posbeams) {
   # Need to thresh to only see the +ve half
   $Mon{'kappa_mon'}->obeyw("thresh", "in=$colfile out=$tmpfile thrlo=0 newlo=0 thrhi=1000000 newhi=1000000"); 

   # Call figaro emlt on the +ve half of the collapsed file
   $Mon{'figaro2'}->obeyw("emlt", "spectrum=$tmpfile xstart=min xend=max lines=$posbeams");

   $posbeamsfound = $Mon{'figaro2'}->get("emlt", "EMLT_LINES");
   orac_print "Detected $posbeamsfound of $posbeams positive beams\n";

   # loop over the detected beams, writing the details to the group user header
   my @pix = $Mon{'figaro2'}->get("emlt", "EMLT_POS");
   my @peak = $Mon{'figaro2'}->get("emlt", "EMLT_PEAK");
   for (my $i=1; $i<=$posbeamsfound; $i++) {
      my $keyword = 'BEAM_POSITION_'.$i;
      my $pixvalue = $pix[$i];
      $Grp->uhdr($keyword, $pixvalue);
      $keyword = 'BEAM_MULT_'.$i;
      $Grp->uhdr($keyword, $mult);
      my $peakvalue = $peak[$i];
      
      orac_print "Found beam $i (factor $mult) at: pixel $pixvalue; peak mean strength = $peakvalue\n";
   }
}

# Now do the -ve beams;
my $negbeams=0;
$negbeams=0 if($nbeams==1);
$negbeams=1 if($nbeams==2);
$negbeams=2 if($nbeams==3);
$negbeams=2 if($nbeams==4);
$mult = -1;

my $negbeamsfound=0;
if($negbeams) {
   # Need to thresh to only see the +ve half of the negated file
   $Mon{'kappa_mon'}->obeyw("thresh", "in=$ncolfile out=$tmpfile thrlo=0 newlo=0 thrhi=1000000 newhi=1000000");

   # Call figaro emlt on the negated collapsed file
   $Mon{'figaro2'}->obeyw("emlt", "spectrum=$tmpfile xstart=min xend=max lines=$negbeams");

   $negbeamsfound = $Mon{'figaro2'}->get("emlt", "EMLT_LINES");
   orac_print "Detected $negbeamsfound of $negbeams negative beams\n";

   # loop over the detected beams, writing the details to the group user header
   my @pix = $Mon{'figaro2'}->get("emlt", "EMLT_POS");
   my @peak = $Mon{'figaro2'}->get("emlt", "EMLT_PEAK");
   for (my $i=1; $i<=$negbeamsfound; $i++) {
      my $j = $i + $posbeamsfound;
      my $keyword = 'BEAM_POSITION_'.$j;
      my $pixvalue = $pix[$i];
      $Grp->uhdr($keyword, $pixvalue);
      $keyword = 'BEAM_MULT_'.$j;
      $Grp->uhdr($keyword, $mult);
      my $peakvalue = $peak[$i];
      
      orac_print "Found beam $j (factor $mult) at: pixel $pixvalue; peak mean strength = $peakvalue\n";
   }
}
   
if ($nbeams == 0) {
   # Didn't find any beams so far. fall back to rows calibration
   my @rows = $Cal->rows;
   if (defined $rows[0]) {
      $nbeams++;
      $row[$nbeams] = $rows[0];
   }
   if (defined $rows[1]) {
      $nbeams++;
      $row[$nbeams] = $rows[1];
   }
}

if ($nbeams == 0) {
   # Didn't find any beams so far. fall back to guessing
   
   # The main beam is probably at row 96
   $nbeams++;
   $row[$nbeams]=96;

   # is this a pairwise sequence?
   if (defined ($Frm->uhdr("PAIR_COMPLETE"))) {
      # Yes, it's pairwise

      # Is the sky position close?
      # This should really compare the angle to the slit angle too
      # And look at the slit length...

      my $skyraoff=$Grp->uhdr("SKY_RAOFF");
      my $skydecoff=$Grp->uhdr("SKY_DECOFF");  
      my $noddist = sqrt($skyraoff * $skyraoff * $skydecoff * $skydecoff);
      if ($noddist < 50) {
         # Chances are we're on the slit
	 # Guess the pixel scale for now
	 my $pixsize = 0.6;
	 my $offset = $noddist / $pixsize;
	 $nbeams++;
	 $row[$nbeams] = 96+$offset;
       }
   } else {
     # No, it's not pairwise
     # Assume there's no offset beam.
   }
}

orac_print "\n";
