# _COADD_PAIRS_AND_GROUP_  -*-perl-*-

=head1 NAME

COADD_PAIRS_AND_GROUP - co-add observations taken in OBJECT/SKY pairs into group file

=head1 DESCRIPTION

Co-adds observations taken in the standard OBJECT/SKY pairs and adds
the result to a group file.

=head1 PARAMETERS

=over 4

none

=back

=head1 ORAC

=head2 Engines referenced

KAPPA

=head2 Tasks called

=over 4

=item kappa_mon

sub, cmult, add, cdiv

=item ndfpack_mon

erase

=back

=head2 Objects addressed

$Frm, $Grp

=head1 NOTES

This primitive is meant to act on observations taken in the standard
OBJECT/SKY pairing.  It does not assume that the pairings come in any
specific order, only that for each pair of observations, one is OBJECT
and one is SKY (i.e. observations taken in OSSOOSSO are reduced
properly, whereas observations taken in OSOOSO are not).

To determine whether an observation is OBJECT or SKY, this primitives
relies on correct telescope offset information being placed in the
header.  More specifically, OBJECT observations have R.A. and
Dec. offsets of zero, and SKY observations have either R.A., Decl., or
both set as non-zero.  If these offsets are set incorrectly, the
primitive will not work correctly.

This primitive does work with the C<-resume> flag but does not work
with the C<-batch> flag.

Assumes that by the time this primitive is called, there is only 
one file associated with the frame object.

=head2 REVISION

  $Id$

=head1 AUTHOR

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>,
Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

=cut

# Form the group image using the current and previous frames.
# ===========================================================

# Obtain the number of the current observation.
    my $obsnum = $Frm->number;
    my $param1;

# We're using $Grp->raw so that the primitive will -always- co-add to
# the base group file.  If some other steps were done after this (i.e.
# ratioing by a standard), then $Grp->file would be the name of the file
# after the other steps, thus sending the entire primitive into a pit of
# despair from which it would be quite difficult to return.
    my $groupname = $Grp->raw;

# Now update the groupname with this value so that all the methods will
# methods will look in the right place.
    $Grp->file( $groupname );

    unless ( defined $Frm->uhdr( "PAIR_COMPLETE" ) ) {
       orac_err "PAIR_COMPLETE is not present.  Have you run the steering primitive?";
       my $ORAC_STATUS = ORAC__ERROR;
    }

    unless ( defined $Frm->uhdr( "ON_SOURCE" ) ) {
       orac_err "ON_SOURCE is not present.  Have you run the steering primitive?";
       my $ORAC_STATUS = ORAC__ERROR;
    }

# Check whether or not we have an even number of observations in the
# group.
    if ( $Frm->uhdr( "PAIR_COMPLETE" ) ) {

# Calculate the previous observation number, and hence access the frame
# of the previous group member.  This assumes we are not using -batch
# mode.
       my $prevFrm = ($Grp->members)[-2];
       my $prevobs = $prevFrm->number;

# Set the object and sky frames; this is set within the steering file.
       my ( $sky, $object );
       if ( $Frm->uhdr( "ON_SOURCE" ) ) {

# RA and Decl. offsets are zero, so assume that the current frame is the
# object frame, and the previous is sky.
          $object = $Frm->file;
          $sky = $prevFrm->file;

       } else {

# RA and/or Decl. offsets are non-zero, so assume that the current frame
# is sky, and previous is object.
         $object = $prevFrm->file;
         $sky    = $Frm->file;
       }

       if ( ! ( $Grp->file_exists ) ) {

# The group file doesn't exist, so copy the co-added pair into it.
# Need the temporary file so that the header propagation is correct.
# The primary array headers (IN1) are propagated, and for reasons
# described in a long comment below, we need the sky headers for the
# offsets.  One could use MATHS with expression IB-IA to achieve the
# same effect.
          my $tmp = new ORAC::TempFile;
          my $tmpname = $tmp->file;

          $param1 = "in1=$sky in2=$object out=$tmpname title=$groupname";
          $Mon{'kappa_mon'}->obeyw( "sub", "$param1" );

          $param1 = "in=$tmpname scalar=-1 out=$groupname";
          $Mon{'kappa_mon'}->obeyw( "cmult", "$param1" );
          orac_print "Subtracting $sky (SKY) from $object (OBJECT) and " .
                     "creating group $groupname.\n";

# Update the group header.
          $Grp->readhdr;

# If you're looking through this code and wondering why a sky minus
# object is calculated, instead of object minus sky, here's the reason.
# When extracting the spectrum, the primitive that does that needs to
# calculate where the negative row is.  This calculation is done using
# the ORAC_TRAOFF and ORAC_TDECOFF (RA and Decl. offsets) header values.
# These two values are zero for object observations, and non-zero for
# sky observations.  If the pair was added as object-sky, instead of
# -(sky-object), then the header for the object would be placed in the
# reduced group file.  Remember how ORAC_TRAOFF and ORAC_DECOFF are zero
# for object observations?  When the spectrum extraction primitive does
# its calculations, it would calculate that the negative row is zero
# rows away from the positive row, and this is (generally) not the
# case.  Thus, if we copy in the headers from the sky observations, we
# preserve the ORAC_TRAOFF and ORAC_DECOFF values, and can thus correctly
# calculate the position of the negative row for spectrum extraction.
# PLEASE DO NOT CHANGE THIS!  If you change this, then the spectrum
# extraction will be broken, much to the dismay of astronomers and
# support scientists and others who might like to get accurate spectra
# from their hard-earned observations at UKIRT.
#
# This is repeated in a later segment as well.

# Since we have co-added a pair we need to store this information in the
# group file coadds array.
          $Grp->coaddspush( $prevobs, $obsnum );

# Create the group of differenced frames.
# =======================================

# To compute the variance, well at least for now, we need to store the
# differenced-pair images.  For this we create a new group.

# Create group of difference frames and inherit the group file name \
# from the main group.
          my $diffGrp = $Grp->new;
          $diffGrp->file( $Grp->file );

# Store the pointer to the group in the main Group user header.
          $Grp->uhdr( "DIFFERENCE_GROUP", $diffGrp );

# The differenced pair is in the initial group image.  As the group
# image will change, make a copy.
          my ( $in, $out ) = $Frm->inout( "_dp" );
          $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$groupname out=$out" );

# Create a new frame to store the differenced pair image.
# ORAC::Frame::CGS4 expects to be created with raw data and not an
# arbritrary file, so a simple invocation of the new method is
# inadequate.
          my $tempFrm = $Frm->new();
          $Frm->files( $out );
#          my $tempFrm = $Frm->new( $out );

# Need to propagate the raw frame as ORAC-DR pattern matches for files
# ending in a number to set the $Frm->number, which is needed for the
# template method.
          $tempFrm->raw( $Frm->raw );

# Transfer the headers to the differenced frame, being sure to transfer
# from the primary frame.
          if ( $Frm->uhdr( "ON_SOURCE" ) ) {
             %{$tempFrm->hdr} = ( %{$prevFrm->hdr} );
             %{$tempFrm->uhdr} = ( %{$prevFrm->uhdr} );
          } else {

# The primary frame is the current one, so transfer its headers to
# the differenced frame.
             %{$tempFrm->hdr} = ( %{$Frm->hdr} );
             %{$tempFrm->uhdr} = ( %{$Frm->uhdr} );
          }


# Edit the group FITS headers to reflect the combination.
# =======================================================

# Now update the FITS header to reflect the new end airmass, using the
# value from the current frame.  Using the internal header, obtain the
# name of the external keyword.
          my $amendname = "ORAC_AIRMASS_END";
          my $amend  = $Frm->uhdr( $amendname );
          my %keywords = $Frm->translate_hdr( $amendname );
          my @amendkey = keys( %keywords );
          no warnings 'misc';
          _SET_GROUP_FITS_ITEM_ KEY=$amendkey[ 0 ] VALUE=$amend

# Do likewise for the end UT time.
          my $utendname = "ORAC_UTEND";
          my $utend  = $Frm->uhdr( $utendname );
          %keywords = $Frm->translate_hdr( $utendname );
          my @utendkey = keys( %keywords );
          _SET_GROUP_FITS_ITEM_ KEY=$utendkey[ 0 ] VALUE=$utend

# We should also store the start UT and airmass to ensure that the start
# airmass of the previous frame is in the header regardless of the order
# sky and object were taken.  We only need to do this for the first
# pair.  Again we used the internal name to translate to the actual
# keyword.
          my $amstartname = "ORAC_AIRMASS_START";
          my $amstart  = $Frm->uhdr( $amstartname );
          %keywords = $Frm->translate_hdr( $amstartname );
          my @amstartkey = keys( %keywords );
          _SET_GROUP_FITS_ITEM_ KEY=$amstartkey[ 0 ] VALUE=$amstart

# Do likewise for the start UT time.
          my $utstartname = "ORAC_UTSTART";
          my $utstart  = $Frm->uhdr( $utstartname );
          %keywords = $Frm->translate_hdr( $utstartname );
          my @utstartkey = keys( %keywords );
          _SET_GROUP_FITS_ITEM_ KEY=$utstartkey[ 0 ] VALUE=$utstart

       } elsif ( $Grp->coaddspresent( $obsnum ) &&
                 $Grp->coaddspresent( $prevobs ) ) {

# Already been co-added.
          orac_print "This pair ($prevobs, $obsnum) have already been " .
                     "co-added.  Skipping.\n";

       } elsif ( $Grp->coaddspresent( $obsnum ) ||
                 $Grp->coaddspresent( $prevobs ) ) {

# This should not happen.  The co-adds array should not contain one of
# the pairs.
          orac_err "Something has gone wrong.  One of the pair " .
                   "[$prevobs, $obsnum], has been coadded without the other!\n";
          my $ORAC_STATUS = ORAC__ERROR;

       } else {

# Update the group image using the current and previous frame.
# ============================================================

# The group file exists and this is not the first pair.  First we need to
# determine how many pairs have been added to the group;

# The number of observations added previously is from coadds
          my $numobsadded = scalar(@{ scalar($Grp->coadds) } );
          my $numpairadded = $numobsadded / 2;

# Now we need to "unaverage" the group file.  A temporary file is needed
# for this.
          my $unavg = new ORAC::TempFile;
          my $unavgname = $unavg->file;
          $param1 = "in=$groupname scalar=$numpairadded out=$unavgname";
          $Mon{'kappa_mon'}->obeyw( "cmult", "$param1" );

# Now subtract SKY from OBJECT to create the pair.  A temporaryy file
# is needed.  Need the temp file so that the header propagation is
# correct
          my $pair = new ORAC::TempFile;
          my $pairname = $pair->file;
          my $tmp = new ORAC::TempFile;
          my $tmpname = $tmp->file;
          $param1 = "in1=$sky in2=$object out=$tmpname";
          $Mon{'kappa_mon'}->obeyw( "sub", "$param1" );

          $param1 = "in=$tmpname scalar=-1 out=$pairname";
          $Mon{'kappa_mon'}->obeyw( "cmult", "in=$tmpname scalar=-1 out=$pairname");

# Now add the pair to the unaveraged group.  A temporay file is needed.
          my $addgroup = new ORAC::TempFile;
          my $addgroupname = $addgroup->file;
          $param1 = "in1=$unavgname in2=$pairname out=$addgroupname";
          $Mon{'kappa_mon'}->obeyw( "add", "$param1" );

# Now average the result.
          my $avgscalar = $numpairadded + 1;
          $param1 = "scalar=$avgscalar out=$groupname title=$groupname";
          $Mon{'kappa_mon'}->obeyw("cdiv","in=$addgroupname $param1" );
          orac_print "Subtracting $sky (SKY) from $object (OBJECT) " .
                     "and adding to group $groupname.\n";

# Print an informative message (I don't think it will ever get here
# with only a single pair since the early if should catch it.
          if ( $avgscalar == 1 ) {
             orac_print "Group file now contains observations from one pair.\n";
          } else {
             orac_print "Group file now contains observations from $avgscalar pairs.\n";
          }

# Since we have co-added a pair we need to store this information.
# in the group file coadds array.
          $Grp->coaddspush( $prevobs, $obsnum );

# Augment the group of differenced frames.
# ========================================

# To compute the variance, well at least for now, we need to store the
# differenced-pair images.  For this we use a special group.

# Does the Group of difference frames exist?  If not create it and
# inherit the group file name from the main group.
          my $diffGrp = $Grp->uhdr( "DIFFERENCE_GROUP" );
          if ( ! defined( $diffGrp ) ) {
             $diffGrp = $Grp->new;
             $diffGrp->file( $Grp->file );

#  Store the pointer to the group in the main Group user header.
             $Grp->uhdr( "DIFFERENCE_GROUP", $diffGrp );
          }

# The differenced pair is in the initial group image.  As the group
# image will change, make a copy.
          my ( $in, $out ) = $Frm->inout( "_dp" );
          $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$pairname out=$out" );

# Create a new frame to store the differenced pair image.
# ORAC::Frame::CGS4 expects to be created with raw data and not an
# arbritrary file, so a simple invocation of the new method is
# inadequate.
          my $tempFrm = $Frm->new();
          $Frm->files( $out );
#          my $tempFrm = $Frm->new( $out );

# Need to propagate the raw frame as ORAC-DR pattern matches for files
# ending in a number to set the $Frm->number, which is needed for the
# template method.
          $tempFrm->raw( $Frm->raw );

# Transfer the headers to the differenced frame, being sure to transfer
# from the primary frame.
          if ( $Frm->uhdr( "ON_SOURCE" ) ) {
             %{$tempFrm->hdr} = ( %{$prevFrm->hdr} );
             %{$tempFrm->uhdr} = ( %{$prevFrm->uhdr} );
          } else {

# The primary frame is the current one, so transfer its headers to
# the differenced frame.
             %{$tempFrm->hdr} = ( %{$Frm->hdr} );
             %{$tempFrm->uhdr} = ( %{$Frm->uhdr} );
          }

# Form and store the variance array
# =================================

# Can only compute the variance once there are at least three frames
# combined in the group.
          my ( $ndf, $padnum );
          if ( $avgscalar >= 3 ) {

# MSTATS has a terrible user interface (for now).  Create copies of the files
# with the naming convention required, some name followed by a four-digit
# number.  The number increments for each frame.
             foreach my $i ( 1..$avgscalar ) {
                $ndf = $diffGrp->frame( $i - 1 )->file;
                $padnum = "0" x ( 4 - length( "$i" ) ) . $i;
                $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$ndf out=mstats$padnum" );
             }

# Form the array of standard deviations.
             my $means = "mstatsmean$$";
             my $sigmas = "mstatssigma$$";
             $param1 = "inmode=Sequential pixmode=Box numseq=$avgscalar noordrst";
             my $param2 = "firstfile=mstats0001 mean=$means stddev=$sigmas";
             $Mon{'kappa_mon'}->obeyw( "mstats", "$param1 $param2 reset accept" );

# Form a variance array (the data array being standard deviations).
             $param1 = "ndf=$sigmas variance=data**2";
             $Mon{'ndfpack_mon'}->obeyw( "setvar", "$param1" );

# Because MSTATS is an IMAGE-format task, and SETVAR currently does not
# permit copying variance from another NDF, we have to kludge a copy
# of the variance.  A side effect of this is that the VARIANCE copied
# must be a structure, not an array, in case the origin of the data array
# of the co-added frame is not at 1,1.  The cleanest way to deal with
# this is to find the origin in the co-added group frame, and set the
# origin of the MSTATS variance array to this origin.

# Extract the lower bounds of the frame, i.e. the origin.
             $Mon{"ndfpack_mon"}->obeyw( "ndftrace", "ndf=$groupname" );
             ( my $ORAC_STATUS, my @lbnd ) = $Mon{"ndfpack_mon"}->get( "ndftrace", "lbound" );
             ( $ORAC_STATUS, my $varpresent ) = $Mon{"ndfpack_mon"}->get( "ndftrace", "variance" );

# Set the origin in our file of variances.
             $param1 = "ndf=$sigmas origin=[$lbnd[0],$lbnd[1]]";
             $Mon{"ndfpack_mon"}->obeyw( "setorigin", "$param1" );

# Finally copy the variance array just created to the co-added frame.
# COPOBJ does not clobber existing components, so an existing VARIANCE
# must be removed first.
             if ( $avgscalar > 3 &&
                  $varpresent eq "TRUE" ) {
                $param2 = "object=${groupname}.variance ok=true";
                $Mon{'ndfpack_mon'}->obeyw( "erase", "$param2" );
             }
             $param1 = "source=${sigmas}.variance object=${groupname}.variance";
             $Mon{'figaro1'}->obeyw( "copobj", "$param1" );
             orac_print "Group file now contains variance derived from $avgscalar frames.\n";
          }

# Edit the group FITS headers to reflect the combination.
# =======================================================

# Now update the FITS header to reflect the new end airmass, using the
# value from the current frame.  Using the internal header, obtain the
# name of the external keyword.
          my $amendname = "ORAC_AIRMASS_END";
          my $amend  = $Frm->uhdr( $amendname );
          my %keywords = $Frm->translate_hdr( $amendname );
          my @amendkey = keys( %keywords );
          no warnings 'misc';
          _SET_GROUP_FITS_ITEM_ KEY=$amendkey[ 0 ] VALUE=$amend

# Do likewise for the end UT time.
          my $utendname = "ORAC_UTEND";
          my $utend  = $Frm->uhdr( $utendname );
          %keywords = $Frm->translate_hdr( $utendname );
          my @utendkey = keys( %keywords );
          _SET_GROUP_FITS_ITEM_ KEY=$utendkey[ 0 ] VALUE=$utend

# Housekeeping
# ============
          if ( $avgscalar >= 3 ) {
             _DELETE_A_FRAME_ FRAME=mstatsmean$$
             _DELETE_A_FRAME_ FRAME=mstatssigma$$

             foreach my $i ( 1..$avgscalar ) {
                $padnum = "0" x ( 4 - length( "$i" ) ) . $i;
                _DELETE_A_FRAME_ FRAME=mstats$padnum
             }
          }

# Since we have co-added a pair, we need to store this information
# in the group file coadds array.
          $Grp->coaddspush($prevobs, $obsnum);
       }

# How do you control this from disp.dat as it doesn't have a _suffix?
# Hack it into a new window for now (Sorry, PH 2000-09-12).
       $Display->display_data( $Grp, {WINDOW => 1, TOOL => 'GAIA', 
                               REGION => 0, TYPE => 'IMAGE'}, 0 ) if defined $Display;
    }
