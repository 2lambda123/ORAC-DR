=head1 NAME

_NIGHT_LOG_SPECT_ - Produces a text listing a summary of a frame's headers.

=head1 DESCRIPTION

Produces a line of text in a log file summarising the header values of
the frame. Is used both as part of the generall data reduction, so as
to produce an on-the-fly listing of what has been reduced so far, and
as part of the NIGHT_LOG recipe to provide a summary of a set (usually
the whole night's worth) of observations.

=head1 ARGUMENTS

The following arguments are available:

=over 4

=item OUT

When set (to any value) the log file is written to F<$ORAC_DATA_OUT>
rather than to F<$ORAC_DATA_IN>.

=back

=head1 OUTPUT DATA

The text log file F<E<lt>dateE<gt>.nightlog>, where
E<lt>dateE<gt> is the UT date.

The file is in F<$ORAC_DATA_IN> by default, or in F<$ORAC_DATA_OUT> if
the OUT argument is set. This primitive is called from
_SPECTROSCOPY_HELLO_ with the OUT argument set, so the on-the-fly
nightlog appears in F<$ORAC_DATA_OUT>, and without the argument from
the NIGHT_LOG recipe, so that we can create a summary of a night's
observations in F<$ORAC_DATA_IN>.

The on-the-fly log in F<$ORAC_DATA_OUT> is always appended to, being
created only if it doesn't exist.  Thus multiple entries for the same
observation may exist in the on-the-fly log if the pipeline is rerun.

The "clean" log file in F<$ORAC_DATA_IN> is re-started if the observation
number equals 1 and is appended to otherwise, being created as necessary.

=head1 NOTES

=over 4

=item *

The logfile created by this primitive does not follow the standard
ORAC-DR naming convention (F<log.xxxx>) since it can be used to write
log files to directories other than F<$ORAC_DATA_OUT> and unique file
names are required.

=item *

No external algorithm engines are required by this primitive.

=item *

Run with the oracdr option -resume to prevent deletion of allready existing group files

=item *

Run with the oracdr option -noeng for efficiency

=back

=head1 AUTHORS

Frossie Economou (JAC)

Paul Hirst (JAC) <p.hirst@jach.hawaii.edu>

Tim Jenness (JAC)

=head1 COPYRIGHT

Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut

# Obtain the frame number and UT date.
    my $obsnum = $Frm->number;
    my $obsdate = $Frm->uhdr( "ORAC_UTDATE" );

# Specify the location of the nightly log file. [depends on the arguments]
    my $nightlog;
    if ( exists $_NIGHT_LOG_SPECT_{"OUT"} ) {

# ORAC_DATA_OUT is the current directory and the default location for
# log files.
       $nightlog = "${obsdate}.nightlog";

# If we're working in ORAC_DATA_OUT, always append to the file, creating
# the logfile if it doesn't exist.
    } else {
  
# A non-standard location so full path is required
       $nightlog = $ENV{ "ORAC_DATA_IN" } . "/${obsdate}.nightlog";
  
# If we're working in ORAC_DATA_IN, start fresh if this is frame 1
# We don't care about the return value from unlink.
       unlink $nightlog if $obsnum == 1;
    }

# Flag to indicate whether or not the log is there already.
    my $is_there;
    $is_there = ( -e $nightlog ? 1 : 0 );

# Create a new log object.
    my $log = new ORAC::LogFile( $nightlog );

# Only proceed if we have a valid object
    if ( defined $log ) {

       if ( $is_there ) {
          orac_print "Appending to Log: $nightlog\n";
       } else {
          orac_print "Log created as $nightlog\n";
       }
 
# Print the header.
# =================

# Create the headings.
       if ( defined $_NIGHT_LOG_SPECT_{LONG} ) {
          $log->header(
            " Obs | Grp  M|   Object  Std|Obstype|Slit   PA  |RA    |Dec    |RAoff|DECof| UT     | AM |DExpT |Nxp|MODE    |Sstp|Snum|rowXcol|Filter|Grating Ord|Glamda|CNFidx|   DR Recipe    |",
            "-----|-------|--------------|-------|----|------|------|-------|-----|-----|--------|----|------|---|--------|----|----|---x---|------|-----------|------|------|----------------|");

#           "12345|12345|1|123456789012|1|1234567|1234|123456|123456|1234567|12345|12345|12345678|1234|123456|123|12345678|1234|1234|123x123|123456|12345678|12|123456|123456|1234567890123456|";

#            0        1         2         3         4         5         6         7         8         9         0         1         2         3         4         5         6 
#            123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678
       } else {
          $log->header(
            " Obs | Grp  M|   Object  Std|Obstype|Slit   PA  |RAoff|DECof| UT     | AM |DExpT |Num|Filtr|Grating Ord|Galmda|   DR Recipe    |",
            "-----|-------|--------------|-------|----|------|-----|-----|--------|----|------|---|-----|-----------|------|----------------|");

#           "12345|12345|1|123456789012|1|1234567|1234|123456|12345|12345|12345678|1234|123456|123|12345|12345678|12|123456|1234567890123456|";

#            0        1         2         3         4         5         6         7         8         9         0         1         2         3
#            123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
       }

# Set the Y/N values.
       my $isstd = $Frm->uhdr( "ORAC_STANDARD" );
       if ( $isstd eq "1" ) { $isstd = "Y"; }
       if ( $isstd eq "0" ) { $isstd = "N"; }

# Present the slit name nicely.
       my $slitname = $Frm->uhdr( "ORAC_SLIT_NAME" );
       $slitname = "1pix" if ( $slitname eq "0m" );
       $slitname = "2pix" if ( $slitname eq "0w" );
       $slitname = "4pix" if ( $slitname eq "0ew" );
       $slitname = "2p-e" if ( $slitname eq "36.9w" );
       $slitname = "1p-e" if ( $slitname eq "36.9m" );

# Format the UT start in hours, minutes, and seconds from decimal hours.
       my $ut = $Frm->uhdr( "ORAC_UTSTART" );
       my $uthours = int $ut;
       $ut -= $uthours;
       $ut *= 60.0;
       my $utmins = int $ut;
       $ut -= $utmins;
       $ut *= 60.0;
       my $utsecs = int $ut;
       $ut = sprintf "%02d:%02d:%02d", $uthours, $utmins, $utsecs;

# Obtain the array dimensions.
       my $xdim = $Frm->uhdr( "ORAC_X_DIM" );
       my $ydim = $Frm->uhdr( "ORAC_Y_DIM" );

# Cope with the missing headers by accessing the array dimensions of
# the frame.
# NO - SHOULD BL**DY WELL BE IN THE HEADERS
#       if ( !( defined $xdim && defined $ydim ) ) {
#          my $param = "ndf=" . $Frm->file;
#          $Mon{"ndfpack_mon"}->obeyw( "ndftrace", "$param" );

# Extract the dimensions of the frame.
#          ( my $ORAC_STATUS, my @dims ) = $Mon{"ndfpack_mon"}->get( "ndftrace", "dims" );
#          $xdim = $dims[ 0 ];
#          $ydim = $dims[ 1 ];
#       }
       my $rowxcol = "${xdim}x${ydim}";

       if ( defined $_NIGHT_LOG_SPECT_{LONG} ) {

# Define the Perl format for each long entry in the log.
          my $format = "%5d %5d %1s %12.12s %1s %7.7s %4.4s %6.1f %6.3f %7.3f %5.1f %5.1f %8s %4.2f %6.2f %3d %8s %4.2f %4.2f %7s %6.6s %8.8s %2d %6.3f %6s %-16s";
    
# Write the record using the prescribed format.
          $log->addentry( sprintf( $format,
                                   $obsnum,
                                   $Frm->findgroup,
                                   $Frm->isgood,
                                   $Frm->uhdr( "ORAC_OBJECT" ),
                                   $isstd,
                                   $Frm->uhdr( "ORAC_OBSERVATION_TYPE" ),
                                   $slitname,
                                   $Frm->uhdr( "ORAC_SLIT_ANGLE" ),
                                   $Frm->uhdr( "ORAC_RA_BASE" ),
                                   $Frm->uhdr( "ORAC_DEC_BASE" ),
                                   $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET" ),
                                   $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET" ),
                                   $ut,
                                   $Frm->uhdr( "ORAC_AIRMASS_START" ),
                                   $Frm->uhdr( "ORAC_EXPOSURE_TIME" ),
                                   $Frm->uhdr( "ORAC_NUMBER_OF_EXPOSURES" ),
                                   $Frm->uhdr( "ORAC_DETECTOR_MODE" ),
                                   $Frm->uhdr( "ORAC_SCAN_INCREMENT" ),
                                   $Frm->uhdr( "ORAC_NSCAN_POSITIONS" ),
                                   $rowxcol,
                                   $Frm->uhdr( "ORAC_FILTER" ),
                                   $Frm->uhdr( "ORAC_GRATING_NAME" ),
                                   $Frm->uhdr( "ORAC_GRATING_ORDER" ),
                                   $Frm->uhdr( "ORAC_GRATING_WAVELENGTH" ),
                                   $Frm->uhdr( "ORAC_CONFIGURATION_INDEX" ),
                                   $Frm->recipe
                                 )
                        );
       } else {

# Define the Perl format for each normal entry in the log.
          my $format = "%5d %5d %1s %12.12s %1s %7.7s %4.4s %6.1f %5.1f %5.1f %8s %4.2f %6.2f %3d %5.5s %8.8s %2d %6.3f %-16s";

# Write the record using the prescribed format.
          $log->addentry( sprintf( $format,
                                   $obsnum,
                                   $Frm->findgroup,
                                   $Frm->isgood,
                                   $Frm->uhdr( "ORAC_OBJECT" ),
                                   $isstd,
                                   $Frm->uhdr( "ORAC_OBSERVATION_TYPE" ),
                                   $slitname,
                                   $Frm->uhdr( "ORAC_SLIT_ANGLE" ),
                                   $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET" ),
                                   $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET" ),
                                   $ut,
                                   $Frm->uhdr( "ORAC_AIRMASS_START" ),
                                   $Frm->uhdr( "ORAC_EXPOSURE_TIME" ),
                                   $Frm->uhdr( "ORAC_NUMBER_OF_EXPOSURES" ),
                                   $Frm->uhdr( "ORAC_FILTER" ),
                                   $Frm->uhdr( "ORAC_GRATING_NAME" ),
                                   $Frm->uhdr( "ORAC_GRATING_ORDER" ),
                                   $Frm->uhdr( "ORAC_GRATING_WAVELENGTH" ),
                                   $Frm->recipe
                                 )
                        );
       }

    } else {
        orac_warn "Could not create nightlog $nightlog.\n";
    }
