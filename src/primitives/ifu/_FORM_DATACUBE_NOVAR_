# -*- perl -*-


# Podule
# ======

=head1 NAME

_FORM_DATACUBE_NOVAR_ -- Re-formats an IFU frame into a datacube.

=head1 DESCRIPTION

This primitive will not propagate the variance array. It is intended
that this primitive, using Figaro routines to assemble the cube, will
only be used when Kappa 1.0 or newer is not available.

The slices are extracted and placed in the datacube in the order in which
their positions are given in the IFU_start and IFU_end arrays contained
in the user header of the frame. The number of slices is given by the 
IFU_slices header.
 
Each area extracted from the input frame becomes one y,lambda plane of
the datacube (with y->y, x->lambda).
  
This primitive is intended for use on a straightened, wavelength calibrated
frame, but the IFU_xshift values are read and used, so it will work any 
time after the headers have been written (by _LOCATE_SLICES_). If the
image has not been scrunched when it is run then the wavelength axis will
be in pixels (not Angstroms) and there will be small offsets (~1 pixel)
in the wavelength axis from one slice to another.

=head1 NOTES

=over 4

=item *

The variance array will be lost.

=item *

The locations of the slices and the shifts which should be applied are
taken from the user headers IFU_start, IFU_end, IFU_xshift and
IFU_yshift. Each of these is an array with an element for each slice.

=item *

The number of slices is read from the IFU_slices user header.

=back

=head1 OUTPUT DATA

=over 4

=item *

The input frame is reformatted into a datacube with suffix _cube.

=back

=head1 TASKS

ndfpack_mon: ndfcopy, setorigin, setbound
figaro1: ishift, growyt

=head1 AUTHORS

SPT: Stephen P. Todd (Edinburgh University/UKATC)

=head1 COPYRIGHT

Copyright (C) 1998-2002 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut


my ($in, $out);

my $use_group = $_FORM_DATACUBE_{GRP} || 0;

if ($use_group) {
    $in = $Grp->file;
    $out = $Grp->raw . "_cub";
} else {
    ($in, $out) = $Frm->inout( "_cub" );
}


my $n_slices = $Frm->uhdr("IFU_slices");

# We're going to need some temporary files
use ORAC::TempFile;

my $ymin = 0;
my $ymax = 60;

# and some temporary files
my $tmp=new ORAC::TempFile;
my $tmp_slice = $tmp->file
;
my $tmp2=new ORAC::TempFile;
my $tmp_slice2 = $tmp2->file;

# The first time through we want to force creation of a new datacube
my $new = "t";

my $param;

# We need to work out the bounds that should be applied to all the slice images
# when cut out of the main image, so that y shifts can be applied without 
# losing tops or bottoms of slices, and keeping all slice images the same
# size for putting into the datacube

# y_min should be the most negative y shift
# y_max should be the most positive (y shift + (y_end - y_start) + 1)

my ($y_min, $y_max);

for my $n (0..($n_slices-1)) {
   
    my $ystart = $Frm->uhdr->{"IFU_start"}->[$n];
    my $yend = $Frm->uhdr->{"IFU_end"}->[$n];
    my $yshift = $Frm->uhdr->{"IFU_yshift"}->[$n];

    if (!defined($y_min) || $yshift + 1 < $y_min) {
	$y_min = $yshift + 1;
    }

    if(!defined($y_max) || ($yshift + $yend - $ystart + 1) > $y_max) {
	$y_max = $yshift + $yend - $ystart + 1;
    }
}
$y_max = int($y_max) + 1;
$y_min = int($y_min) - 1;

orac_print "Forming datacube ";

for my $n (0..($n_slices-1)) {
    
    # Read the position of the nth slice as written into the headers

    my $ystart = $Frm->uhdr->{"IFU_start"}->[$n];
    my $yend = $Frm->uhdr->{"IFU_end"}->[$n];
    my $xshift = $Frm->uhdr->{"IFU_xshift"}->[$n];
    my $yshift = $Frm->uhdr->{"IFU_yshift"}->[$n];
    
    # Keep the user aware of progress
    orac_print ".";
    
    # Copy the area of the input frame containing the required slice
    # to a temporary file.
    $param = "in=$in(,$ystart:$yend) out=$tmp_slice";
    $Mon{"ndfpack_mon"}->obeyw( "ndfcopy", "$param" );

    $param = "$tmp_slice [1,1]";  
    $Mon{"ndfpack_mon"}->obeyw("setorigin", "$param");

    # set the y bounds on the slice
    $Mon{"ndfpack_mon"}->obeyw("setbound", "$tmp_slice(,$y_min:$y_max)");

    # Shift it in the y-direction (and x if necessary)
    $param = "image=$tmp_slice xshift=$xshift yshift=$yshift xsplit=1 ysplit=1 output=$tmp_slice";
    $Mon{"figaro1"}->obeyw( "ishift", "$param" );


    # Grow it into the datacube
    $param = "image=$tmp_slice cube=$out xstart=" . ($n+1) . " xend=" . ($n+1) . " new=$new xsize=$n_slices";
    $Mon{"figaro1"}->obeyw( "growyt", "$param" );

    my $yshift = int($yshift) + 1;
    my $section = "'" . ($n+1) . ",:$yshift,'";
    $Mon{"kappa_mon"}->obeyw( "chpix", "in=$out out=$tmp_slice section=$section newval=bad" ); 

    my $top = $yend - $ystart + $yshift;
    my $section = "'" . ($n+1) . ",$top:,'";
    $Mon{"kappa_mon"}->obeyw( "chpix", "in=$tmp_slice out=$out section=$section newval=bad" ); 
    
    # We no longer want to force the creation of a new datacube
    $new="f";
}


orac_print "\n";
orac_warn "Variance array lost.\n";

    if ($use_group) {
	$Grp->file($out);
    } else {
	$Frm->file( $out );
    }
    
    $Grp->uhdr("NDIMS", 3);
    $Frm->uhdr("NDIMS", 3);  









