# -*- perl -*-


# Podule
# ======

=head1 NAME

_FORM_DATACUBE_ -- Re-formats an IFU frame into a datacube.

=head1 DESCRIPTION

The slices are extracted and placed in the datacube in the order in which
their positions are given in the IFU_start and IFU_end arrays contained
in the user header of the frame. The number of slices is given by the 
IFU_slices header.
 
Each area extracted from the input frame becomes one y,lambda plane of
the datacube (with y->y, x->lambda).
  
This primitive is intended for use on a straightened, wavelength calibrated
frame, but the IFU_xshift values are read and used, so it will work any 
time after the headers have been written (by _LOCATE_SLICES_). If the
image has not been scrunched when it is run then the wavelength axis will
be in pixels (not Angstroms) and there will be small offsets (~1 pixel)
in the wavelength axis from one slice to another.

=head1 NOTES

=over 4

=item *

This primitive is written for the UIST IFU.

=item *

The locations of the slices and the shifts which should be applied are
taken from the user headers IFU_start, IFU_end, IFU_xshift and
IFU_yshift. Each of these is an array with an element for each slice.

=item *

The number of slices is read from the IFU_slices user header.

=back

=head1 OUTPUT DATA

=over 4

=item *

The input frame is reformatted into a datacube with suffix _cube.

=back

=head1 TASKS

ndfpack_mon: ndfcopy, setorigin, setbound
figaro1: ishift, growyt

=head1 AUTHORS

SPT: Stephen P. Todd (Edinburgh University/UKATC)

=head1 COPYRIGHT

Copyright (C) 1998-2002 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut



# Permaxes only runs from the monolith in Kappa > 1.0, so if we have 
# an older kappa version then we need to user the old Figaro based 
# primative.

if (starversion_gt('kappa', '1.0-0') ) {
    my ($in, $out);

    if ($_FORM_DATACUBE_{GRP} == 1) {
	$in = $Grp->file;
	$out = $Grp->raw . "_cub";
    } else {
	($in, $out) = $Frm->inout( "_cub" );
    }

    my $n_slices = $Frm->uhdr("IFU_slices");
    
# We're going to need some temporary files
    use ORAC::TempFile;
    
    my $ymin = 0;
    my $ymax = 60;
    
    # and some temporary files
    my $tmp=new ORAC::TempFile;
    my $tmp_slice = $tmp->file;
    my $tmp2=new ORAC::TempFile;
    my $tmp_paste = $tmp2->file;
    
    my $param;
    my $expand = 0;
    
    my $pos = 1;
    
    orac_print "Forming datacube from $in ";

    for my $n (0..($n_slices-1)) {
	
	# Read the position of the nth slice as written into the headers

	my $ystart = $Frm->uhdr->{"IFU_start"}->[$n];
	my $yend = $Frm->uhdr->{"IFU_end"}->[$n];
	my $xshift = $Frm->uhdr->{"IFU_xshift"}->[$n];
	my $yshift = $Frm->uhdr->{"IFU_yshift"}->[$n];
    
	# Keep the user aware of progress
	orac_print ".";
	
	# Copy the area of the input frame containing the required slice
	# to a temporary file.
	$param = "in=$in(,$ystart:$yend) out=$tmp_slice";
	$Mon{"ndfpack_mon"}->obeyw( "ndfcopy", "$param" );
	
	# add a third dimension
	$Mon{"ndfpack_mon"}->obeyw("setbound", "$tmp_slice(,,1:1)");
	
	# Set the origin
	$param = "$tmp_slice [1,1,$pos]";  
	$Mon{"ndfpack_mon"}->obeyw("setorigin", "$param");
	
	if ($expand) {
	    $pos += 2;
	} else {
	    $pos++;
	}
	
	# Shift it in the y-direction (and x if necessary)
	$param = "image=$tmp_slice xshift=$xshift yshift=$yshift xsplit=1 ysplit=1 output=$tmp_slice";
	$Mon{"figaro1"}->obeyw( "ishift", "$param" );
	
	
	# If this is not the first slice then paste it onto what we've
	# already got (stored in the other temporary file) and write it
	# to $out.
	if ($n > 0) { 
	    $param = "$tmp_paste $tmp_slice out=$out title=ifu_data";
	    $Mon{"kappa_mon"}->obeyw("paste", "$param");
	    
	    # Copy the current $out to $tmp_paste for use next time round.
	    $param = "in=$out out=$tmp_paste";
	    $Mon{"ndfpack_mon"}->obeyw( "ndfcopy", "$param" );
	} else {
	    # If it is the first slice then just copy it to $tmp_paste
	    # ready for use next time round and set $flag to true.
	    $param = "in=$tmp_slice out=$tmp_paste";
	    $Mon{"ndfpack_mon"}->obeyw( "ndfcopy", "$param" );
	}
    }
    
    orac_print "\n";

    # Permute the axes from (lambda, y, x) to (x, y, lambda)
    $param = "in=$tmp_paste out=$out perm=[3,2,1]";
    $Mon{"kappa_mon"}->obeyw( "permaxes", "$param" );
    

    if ($_FORM_DATACUBE_{GRP} == 1) {
	$Grp->file($out);
	$Grp->uhdr("NDIMS", 3);
    } else {
	$Frm->file( $out );
	$Frm->uhdr("NDIMS", 3);  
    }
 

} else {
    orac_warn "Kappa version 1.0 or greater is strongly recommended.\n"; 
	
    _FORM_DATACUBE_NOVAR_
}

_CREATE_WCS_










