# 		-*-perl-*-

=head1 NAME

_SCRUNCH_TO_COMMON_WAVELENGTH_SCALE_ -- Straightens and wavelength calibrates an IFU frame.

=head1 DESCRIPTION

This primitive scrunches an IFU frame, simultaneously straightening
the spectra and applying a wavelength calibration to them. The .iar
file used for the calibration should have been previously generated
from an IFU arc spectrum and filed in the calibration system

The input frame should have been approximately straightened (to a pixel
or so), probably by the _EXTRACT_SLICES_ primitive. The wavelength range
to which the frame should be scrunched is obtained from the grism data
file returned by the calibration system. 


=head1 NOTES

=over 4

=item *

This primitive is written for the UIST IFU.

=item *

The frame should previously have been approximately straightened.

=item *

The wavelength calibrations previously measured from an arc spectrum
are applied, and simultaneously straighten the spectra.

=item *

The wavelength range to which the frame should be scrunched is obtained
from the arlines.lis file used to wavelength clibrate the frame.

=back

=head1 OUTPUT DATA

=over 4

=item *

The output frame is scrunched to a linear wavelength scale, common to
all slices. The output file has a suffix of _scr.

=back

=head1 TASKS

figaro1: creobj, copobj
figaro3: iscrunch
ndfpack_mon: ndftrace, ndfcopy
kappa_mon: thresh

=head1 AUTHORS

SPT: Stephen P. Todd (Edinburgh University/UKATC)

=head1 COPYRIGHT

Copyright (C) 1998-2002 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut


# We're going to need some temporary files
use ORAC::TempFile;

(my $in, my $out) = $Frm->inout( "_scr" );
 
# get the appropriate iar file
my $iarfile = $Cal->iar;

orac_print "Using $iarfile to wavelength calibrate and straighten frame \n"; 

my $numpix = 1024;



# Determine the wavelength range required from the arlines.lis file
my $arlines_file = $ENV{ORAC_DATA_CAL} . "/" . $Cal->arlines; 
orac_print "Getting wavelength range from $arlines_file \n";

my $order;      # The order of the wavelength calibration
my $fit = "";   # The coefficients as read from the arlines.lis file
my @coeffs;     # The coefficients converted to a more useful form

# Read the arlines.lis file
open(my $file, $arlines_file) || die "Could not open $arlines_file \n";
while (<$file>) {
    # We are only interested in the bit after the Order of fit line really
    if (defined $order) {
	chomp;
	$fit .= $_; 
    }

    # Find the order of the fit
    if (/Order of fit:\s+(\d+)/) {$order = $1}
}
close $file;

# Substitute E for D in the scientific form numbers (Fortran->Perl)
$fit =~ s/D/E/g;

# Read the coefficients into @coeffs (in reverse order, as they appear
# in the arlines.lis file)
while ($fit =~ /(-? [\d\.]+ E[+-]\d\d)/gx) {push @coeffs, $1}

# Use the coeficients to calculate the maximum and minimum wavelengths.
# It seems to be useful to knock 100 Ang or so off each end of the range
# otherwise Iscrunch doesn't behave very well
my $min = 0;
for my $n (0..$order) {$min += $coeffs[-1-$n] * 1024**$n;}

$min = int($min) + 100;
my $max = int($coeffs[-1]) - 100;

# Check that min and max are the right way round (otherwise Iscrunch
# does nothing).
if ($min > $max) {($min, $max) = ($max, $min)}

orac_print "Scrunching to $numpix pixels from $min to $max Angstroms.\n";

# And scrunch it
my $param = "image=$in file=$iarfile wstart=$min wend=$max bins=$numpix output=$out log=f linear=t density=f";
$Mon{'figaro3'}->obeyw("iscrunch", "$param"); 

orac_print "Scrunched, now in $out\n";

# We need to copy the variance array and scrunch it separately
$Mon{ "ndfpack_mon" }->obeyw( "ndftrace", "ndf=$in" );
(my $ORAC_STATUS, my $variance) = $Mon{ "ndfpack_mon" }->get( "ndftrace", "variance" );

orac_print "Variance = $variance\n";

if ( $variance eq "TRUE" ) {
# create some temporary files
    orac_print "Scrunching variance array.\n";
    
    my $tmpfile1 = new ORAC::TempFile;
    my $tmpfile2 = new ORAC::TempFile;

    my $tmp = $tmpfile1->file;
    my $tmp2 = $tmpfile2->file;

    $Mon{'figaro1'}->obeyw("creobj", "type=NDF dims=0 object=$tmp");

    $Mon{'figaro1'}->obeyw("copobj", "source=$in.variance object=$tmp.data_array"); 

    my $param = "image=$tmp file=$iarfile wstart=$min wend=$max bins=$numpix output=$tmp2 log=f quad=t density=f";
    $Mon{'figaro3'}->obeyw("iscrunch", "$param"); 
    
    $Mon{'figaro1'}->obeyw("copobj", "source=$tmp2.data_array object=$out.variance");

    $Mon{'ndfpack_mon' }->obeyw("ndfcopy", "$out $tmp");
    $Mon{'kappa_mon'}->obeyw("thresh", "in=$tmp comp=Variance out=$out thrlo=0 newlo=bad thrhi=1E6 newhi=bad");
}

# Set the name of the output frame
$Frm->file( $out );

# And display it
$Display->display_data($Frm) if defined $Display;






