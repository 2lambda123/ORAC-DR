
# 		-*-perl-*-

=head1 NAME

_SCRUNCH_TO_COMMON_WAVELENGTH_SCALE_ -- Straightens and wavelength calibrates an IFU frame.

=head1 DESCRIPTION

This primitive scrunches an IFU frame, simultaneously straightening
the spectra and applying a wavelength calibration to them. The .iar
file used for the calibration should have been previously generated
from an IFU arc spectrum and filed in the calibration system

The input frame should have been approximately straightened (to a pixel
or so), probably by the _EXTRACT_SLICES_ primitive. The wavelength range
to which the frame should be scrunched is obtained from the grism data
file returned by the calibration system. 


=head1 NOTES

=over 4

=item *

The frame should previously have been approximately straightened.

=item *

The wavelength calibrations previously measured from an arc spectrum
are applied, and simultaneously straighten the spectra.

=item *

The file containing the wavelengths to be applied is obtained from the
calibration system. The format of the entry in index.iar is
file.iar:min:max where min and max are the minimum and maximum
wavelengths that should be used when the frame is scrunched.

=item *

The variance array is scrunched separately and copied back into the
output frame (not strictly correct because errors on adjacent pixels
are correlated after resampling, but better than nothing).

=item *

Sets the ORAC_GRATING_WAVELENGTH to the central wavelength in
Angstroms (with one digit after decimal point so that it is not
interpreted as a pixel coordinate in later routines.

=back

=head1 OUTPUT DATA

=over 4

=item *

The output frame is scrunched to a linear wavelength scale, common to
all slices. The output file has a suffix of _scr.

=back

=head1 TASKS

figaro3: iscrunch
ndfpack_mon: ndftrace, ndfcopy
kappa_mon: thresh

=head1 AUTHORS

SPT: Stephen P. Todd (Edinburgh University/UKATC)

=head1 COPYRIGHT

Copyright (C) 1998-2002 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut

# Bring in Starlink::HDSPACK
use Starlink::HDSPACK qw/ copy_hdsobj create_hdsobj /;

# We're going to need some temporary files
use ORAC::TempFile;

(my $in, my $out) = $Frm->inout( "_scr" );

my $tmpfile0 = new ORAC::TempFile;
my $tmp_out = $tmpfile0->file;
 
# get the appropriate iar file
my ($iarfile, $min, $max) = split(':', $Cal->iar);


orac_print "Using $iarfile to wavelength calibrate and straighten frame \n"; 

unless (-e $iarfile) {
    die "$iarfile does not exist.\n";
}

my $numpix = 1024;

orac_print "Scrunching to $numpix pixels from $min to $max Angstroms.\n";

# And scrunch it
my $param = "image=$in file=$iarfile wstart=$min wend=$max bins=$numpix output=$tmp_out log=f linear=t density=f";
$Mon{'figaro3'}->obeyw("iscrunch", "$param");

# Iscrunch does not complain, even if it has failed, so we should check
# that it has created an output file
unless (-e "$tmp_out.sdf") {orac_err "Iscrunch failed.\n"};

# We need to copy the variance array and scrunch it separately
$Mon{ "ndfpack_mon" }->obeyw( "ndftrace", "ndf=$in" );
(my $ORAC_STATUS, my $variance) = $Mon{ "ndfpack_mon" }->get( "ndftrace", "variance" );

orac_print "Variance = $variance\n";


if ( $variance eq "TRUE" ) {
# create some temporary files
    orac_print "Scrunching variance array.\n";

    my $tmpfile1 = new ORAC::TempFile;
    my $tmpfile2 = new ORAC::TempFile;

    my $tmp = $tmpfile1->file;
    my $tmp2 = $tmpfile2->file;

    my $ORAC_STATUS = ( create_hdsobj( $tmp, 'NDF', [ 0 ] ) ? ORAC__OK : ORAC__ERROR );

    $ORAC_STATUS = ( copy_hdsobj( "$in.VARIANCE", "$tmp.DATA_ARRAY" ) ? ORAC__OK : ORAC__ERROR );

    my $param = "image=$tmp file=$iarfile wstart=$min wend=$max bins=$numpix output=$tmp2 log=f quad=t density=f";
    $Mon{'figaro3'}->obeyw("iscrunch", "$param"); 

    $ORAC_STATUS = ( copy_hdsobj( "$tmp2.DATA_ARRAY", "$tmp_out.VARIANCE" ) ? ORAC__OK : ORAC__ERROR );

    $Mon{'ndfpack_mon' }->obeyw("ndfcopy", "$tmp_out $tmp");
    $Mon{'kappa_mon'}->obeyw("thresh", "in=$tmp comp=Variance out=$tmp_out thrlo=0 newlo=bad thrhi=1E6 newhi=bad");
}


$Mon{'figaro1' }->obeyw("xcdiv", "image=$tmp_out output=$out factor=10000");
$Mon{'ndfpack_mon'}->obeyw("axunits", "ndf=$out dim=1 units=micron");

orac_print "Scrunched. now in $out\n";  
orac_print "Wavelengths converted to microns\n";   

$min /= 10000;
$max /= 10000;

# Set the name of the output frame
$Frm->file( $out );

$Frm->uhdr( "ORAC_GRATING_WAVELENGTH" => sprintf("%.4f", ($max + $min)/2));
orac_print "ORAC_GRATING_WAVELENGTH set to " . sprintf("%.4f", ($max + $min)/2) . "\n";

$Frm->uhdr( "lambda_min" => "$min");
$Frm->uhdr( "lambda_max" => "$max");

# And display it
$Display->display_data($Frm) if defined $Display;









