# _MAKE_MOSAIC_EXTENDED_     -*- perl -*-
#
# Forms a mosaic for Quadrant jittering.
#
# TASK: KAPPA - TRANJOIN; CCDPACK - TRANLIST, MAKEMOS
#

# Selection
# =========

# This should only be performed on OBJECT frames.
    if ( $Frm->hdr( "OBSTYPE" ) eq "OBJECT" ||
         $Frm->hdr( "OBSTYPE" ) eq "SKY") {

# Obtain the current row number.
       my $ext_row = $Frm->hdr( "EXTENDED_ROW" );

# Determine whether it is time to make a mosaic.
       my $makemosaic = $Frm->hdr( "MAKE_MOSAIC" );
       my $grandmosaic = $Frm->hdr( "MAKE_GRAND_MOSAIC" );
       if ( $makemosaic || $grandmosaic ) {

# Determine whether the full mosaic is required, otheriwse make the
# mosaic for the current row.
          my $tarGrp;
          if ( $grandmosaic ) {

# Form a subgroup comprising all the target frames.
             $tarGrp = $Grp->subgrp( TARGET_OR_SKY => "target" );

          } else {

# Form a subgroup comprising all the target frames in the current row.
             $tarGrp = $Grp->subgrp( TARGET_OR_SKY => "target",
                                     EXTENDED_ROW => $ext_row );
          }

# Form a list of the input and ouptut target file names for CCDPACK tasks.
          ( my $inref, my $outref ) = $tarGrp->inout( "_trn" );

# Specify the mosaic suffix.
          my $osuffix = "_mos";

# Convert the list to a comma-separated list as needed by CCDPACK (GRP).
          my $inlist = join(",", @$inref);
          my $outlist= join(",", @$outref);

# Concatenate rotation to transformation
# ======================================

# Specify the other parameters for the TRANJOIN stage.  Note that the
# rotation occurs first and the translation seconds as we are using 
# offsets measured in equatorial not Cartesian co-ordinates.
          my ( $header, $hidden );
#          $hidden = "in1=".$Cal->rotation." dest=second"; 

# Join the rotation transformation to each of the CCDPACK extensions.
# The rotation transformation follows the shift-of-origin and is stored
# in the input frame.  Unfortunately, CCDEDIT doesn't support joining
# transformations, and KAPPA/TRANJOIN does operate on lists of files.
# Write the input file names to the text files.
#          foreach $flatted (@$inref) {
#             $header = "in2=${flatted}.more.ccdpack.transform";
#             $Mon{"kappa_mon"}->obeyw("tranjoin","$header $hidden accept");
#          }

# Report the status.
#          orac_print "Orac says: Rotation transformation joined\n";

# Resampling
# ==========

# Create text files to hold the list of input and output files, one per line.
# This is needed because expanded lists of files may make the command line
# too long for the ADAM message system.
          unlink( "tranndf.inlist$$", "tranndf.outlist$$" );

          open( INLIST, ">tranndf.inlist$$" );
          print INLIST join( "\n", @$inref ), "\n";
          close( INLIST );

          open( OUTLIST, ">tranndf.outlist$$" );
          print OUTLIST join( "\n", @$outref ), "\n";
          close( OUTLIST );

# Assign the other parameters.  Determime the bounds automatically.  It takes
# the origin from the first target frame.
          $header = "in='^tranndf.inlist$$' out='^tranndf.outlist$$'";
          $hidden = "shape=auto method=linint title=!";

# Shift and resample the flat-field object frames.  This determines
# the bounds automatically.  It takes the origin from the first object
# frame.
          $Mon{"ccdpack_reg"}->obeyw("tranndf","$header $hidden");

# Report the processing status.
          orac_print "Orac says: Frames $inlist resampled\n";

# Make mosaic.
# ============

# Derive a reasonable number of overlaps to generate a mosaic, yet not
# make all the possible comparisons for efficiency.
          my $optov;
          if ( $grandmosaic ) {
             $optov = 6;
          } else {
             $optov = 2;
          }

# Assign other parameters.  The scale might become a user parameter.
# We should presumably set the Grp output name when we construct
# $outname.  Do not change the output name if we have already
# appended the output suffix the previous time around.
          my $outname;
          if ( $grandmosaic ) {
             $outname = $Grp->file . $osuffix unless $Grp->file =~ /$osuffix$/;
          } else {
             $outname = $Grp->file . $osuffix . "_" . $ext_row;
          }

          $header = "in='^tranndf.outlist$$' out=$outname title=!";
          $hidden = "zero optov=$optov";

# Make the mosaic correcting for differences in offset.
          $Mon{"ccdpack_reg"}->obeyw("makemos","$header $hidden");
          unlink( "tranndf.inlist$$", "tranndf.outlist$$" );

# Set the group name in the Group object...
          if ( $grandmosaic ) {
             $Grp->file( $outname );

# ...and read the header.
             $Grp->header( $Grp->readhdr );
          }

# Report the processing status.
          orac_print "Orac says: mosaic $outname formed\n";

# Display the resultant mosaic.
          _DISPLAY_GROUP_IMAGE_

       }
    }
