# _MAKE_MOSAIC_EXTENDED_     -*- perl -*-
#
# Forms a mosaic for Quadrant jittering.
#
# TASK: KAPPA - TRANJOIN; CCDPACK - TRANLIST, MAKEMOS
#

# Arguments
# =========

# Obtain the value for the interpolation.
    my $intmethod = ( $_MAKE_MOSAIC_EXTENDED_{INT_METHOD} || "linint" );

# Determine whether or not to resample.
    my $resample = $_MAKE_MOSAIC_EXTENDED_{RESAMPLE};
    $resample = defined( $resample ) ? $resample : 1;

# Selection
# =========

# This should only be performed on OBJECT frames.
    if ( $Frm->hdr( "OBSTYPE" ) eq "OBJECT" ||
         $Frm->hdr( "OBSTYPE" ) eq "SKY") {

# Obtain the current row number.
       my $ext_row = $Frm->hdr( "EXTENDED_ROW" );

# Determine whether it is time to make a mosaic.
       my $makemosaic = $Frm->hdr( "MAKE_MOSAIC" );
       my $grandmosaic = $Frm->hdr( "MAKE_GRAND_MOSAIC" );
       if ( $makemosaic || $grandmosaic ) {

# Determine whether the full mosaic is required, otherwise make the
# mosaic for the current row.
          my $tarGrp;
          if ( $grandmosaic ) {

# Form a subgroup comprising all the target frames.
             $tarGrp = $Grp->subgrp( TARGET_OR_SKY => "target" );

          } else {

# Form a subgroup comprising all the target frames in the current row.
             $tarGrp = $Grp->subgrp( TARGET_OR_SKY => "target",
                                     EXTENDED_ROW => $ext_row );
          }

# Form a list of the input and ouptut target file names for CCDPACK tasks.
          ( my $inref, my $outref ) = $tarGrp->inout( "_trn" );

# Specify the mosaic suffix.
          my $osuffix = "_mos";

# Convert the list to a comma-separated list as needed by CCDPACK (GRP).
          my $inlist = join( ",", @$inref );
          my $outlist= join( ",", @$outref );

# Concatenate rotation to transformation
# ======================================

# Specify the other parameters for the TRANJOIN stage.  Note that the
# rotation occurs first and the translation seconds as we are using 
# offsets measured in equatorial not Cartesian co-ordinates.
          my ( $header, $hidden );
          if ( $resample ) {

#             $hidden = "in1=".$Cal->rotation." dest=second"; 

# Join the rotation transformation to each of the CCDPACK extensions.
# The rotation transformation follows the shift-of-origin and is stored
# in the input frame.  Unfortunately, CCDEDIT doesn't support joining
# transformations, and KAPPA/TRANJOIN does operate on lists of files.
# Write the input file names to the text files.
#             foreach $flatted (@$inref) {
#                $header = "in2=${flatted}.more.ccdpack.transform";
#                $Mon{"kappa_mon"}->obeyw("tranjoin","$header $hidden accept");
#             }

# Report the status.
#             orac_print "Orac says: Rotation transformation joined\n";

# Resampling
# ==========

# Create text files to hold the list of input and output files, one per line.
# This is needed because expanded lists of files may make the command line
# too long for the ADAM message system.
             unlink( "tranndf.inlist$$", "tranndf.outlist$$" );

             open( INLIST, ">tranndf.inlist$$" );
             print INLIST join( "\n", @$inref ), "\n";
             close( INLIST );

             open( OUTLIST, ">tranndf.outlist$$" );
             print OUTLIST join( "\n", @$outref ), "\n";
             close( OUTLIST );

# Assign the other parameters.  Determime the bounds automatically.  It takes
# the origin from the first target frame.
             $header = "in='^tranndf.inlist$$' out='^tranndf.outlist$$'";
             $hidden = "shape=auto method=$intmethod title=!";

# Shift and resample the flat-field object frames.  This determines
# the bounds automatically.  It takes the origin from the first object
# frame.
             $Mon{"ccdpack_reg"}->obeyw("tranndf","$header $hidden");

# Report the processing status.
             orac_print "Orac says: Frames $inlist resampled\n";

          } else {

# Derive the offsets
# ==================

# Open the offset files and store the co-ordinates.  Note that this
# assumes central-source or telescope offsets have been used, and that there
# is but one position in each.
             my @xoffsets = ();
             my @yoffsets = ();
             foreach my $Frame ( $tarGrp->members ) {
                my $offfile = $Frame->file . ".off";

                if ( ! -e $offfile ) {
                   orac_err "Missing $offfile offset text file.\n";
                }
                open( OFFFILE, "<$offfile" );

# Store the offsets.
                my $offfound = 0;
                foreach my $line ( <OFFFILE> ) {

# Match 1 followed by a space in case there are more than nine
# objects, unlikely but possible.
                   my @fields;
                   if ( $line =~ /^1\s/ ) {
                      @fields = split( /\s+/, $line );
                      push( @xoffsets, $fields[1] );
                      push( @yoffsets, $fields[2] );
                      $offfound = 1 ;
                      last;
                   }
                }
                close( OFFFILE );

# Cannot proceed unless the x-y offsets were found.
                if ( ! $offfound ) {
                   orac_err "No object #1 in $offfile offset text file.\n";
                }
             }

# Convert the offsets to be displacements of the origin to the nearest pixel.
             my $framecount = 0;
             foreach my $frame ( @xoffsets ) {
                $xoffsets[$framecount] = -int( $xoffsets[$framecount] + 0.5 );
                $yoffsets[$framecount] = -int( $yoffsets[$framecount] + 0.5 );
                $framecount++;
             }

# Change of origin
# ================

# Loop through all the members of the group, as KAPPA task can only handle
# one data file at a time.
             foreach my $Frame ( $tarGrp->members ) {
                my $frame = $Frame->file;

# Assign the other parameters.  Use the original bounds.  Note we do not
# resample the main mosaic if one exists.
                $header = "ndf=$frame origin=[$xoffsets[0],$yoffsets[0]]";

# Shift the first item from the lists of displacements.
                shift( @xoffsets );
                shift( @yoffsets );

# Apply change of origin to the current frame.
                $Mon{"ndfpack_mon"}->obeyw("setorigin","$header");
             }

# Create text files to hold the list of 'output' files, one per line.
# The files are modified in situ, but are the equivalent of the output files
# if resampling is performed.  This is needed because the command may be long.
# Expanded lists of files may make the command line too long for the ADAM
# message system.
             unlink( "tranndf.outlist$$" );

             open( INLIST, ">tranndf.outlist$$" );
             print INLIST join( "\n", @$inref ), "\n";
             close( INLIST );

# Report the processing status.
             orac_print "Orac says: Frames $inlist have origin shifted.\n";
          } 

# Make mosaic.
# ============

# Derive a reasonable number of overlaps to generate a mosaic, yet not
# make all the possible comparisons for efficiency.
          my $optov;
          if ( $grandmosaic ) {
             $optov = 6;
          } else {
             $optov = 2;
          }

# Define the name of the mosaic, and hence the group name.  Do not
# change the output name if we have already appended the output suffix
# the previous time around.
          my $outname;
          if ( $grandmosaic ) {
             $outname = $Grp->file . $osuffix unless $Grp->file =~ /$osuffix$/;
          } else {
             $outname = $Grp->file . $osuffix . "_" . $ext_row;
          }

# Assign other parameters.  The scale might become a user parameter.
          $header = "in='^tranndf.outlist$$' out=$outname title=!";
          $hidden = "zero optov=$optov";

# Make the mosaic correcting for differences in offset.
          $Mon{"ccdpack_reg"}->obeyw("makemos","$header $hidden");
          unlink( "tranndf.inlist$$", "tranndf.outlist$$" );

# Report the processing status.
          orac_print "Orac says: mosaic $outname formed\n";

# Display the resultant mosaic.
          $tarGrp->file( $outname );
          $Display->display_data( $tarGrp ) if (defined $Display);

# Set the group name in the Group object...
          if ( $grandmosaic ) {
             $Grp->file( $outname );

# ...and read the header.
             $Grp->readhdr;
          }

       }
    }
