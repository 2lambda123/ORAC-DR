# _FIXED__APERTURE_PHOTOMETRY_         -*- perl -*-
#
# Perform aperture photometry on a standard star.
#
# TASK: PHOTOM - AUTOPHOTOM
#
#    _FIND_SOURCE_CENTROID_:        CENTRE

# Input arguments recognised by this primitive:
#    SKYEST, ZP, INNER, OUTER

# Determine whether it is time to do aperture photometry.
# We have to specify this since we have to decide whether we
# are using $Frm or $Grp and in general this routine is run
# on reduced images.
    $do_aphot = $Frm->hdr( "DO_APHOT" );
    if ( $do_aphot ) {

# This should only be performed on OBJECT frames.
       if ( $Frm->hdr( "OBSTYPE" ) eq "OBJECT" ) {
          $incflag = "T";

# Form new group
# ==============
#
# Create a temporary frame object.  Use the new method rather than
# new ORAC::Frame for generality (otherwise we would have to do
# new ORAC::Frame::UFTI for UFTI primitives and so on) to inherit
# from the current Frame.

# Set the file method for this frame.  $Grp->file is name of the main
# mosaic.  There's a bug/feature that requires a header to have been read
# in before it is accessed.  So cannot use file method to associate
# the group frame; do it with the new method.
          $tmpfrm = $Frm->new( $Grp->file );

# Create a temporary group object as used by _FAO_.  Use the new method
# rather than new ORAC::Group for generality to inherit from the current
# group.
          $photgrp = $Grp->new;

# Push the members of the existing group into the temporary group.  Exclude
# any sky frames.
          $targrp = $Grp->subgrp( TARGET_OR_SKY => "target" );
          $photgrp->push( $targrp->members );

# Push the temporary frame into the temporary group.  Note that the
# Orac::Group class can contain anything.  However in ORAC-DR we want
# to stick with Frame objects for generality.  So now $reggrp is a
# group consisting of the current group members and group file.
          $photgrp->push( $tmpfrm );

# Perform photometry for all the individual jitter frames and the final
# mosaic.
          foreach $Frm ( $photgrp->members ) {

# Open the results file
# =====================

# Create log file if necessary.
             $logfile = "aphot_results.txt";
             if ( ! -e $logfile ) {
                _MAKE_PHOTOMETRY_TABLE_ FILE=$logfile
             }

# Open the file for appending results.
             open ( LOGFILE, ">>$logfile" );

# Get information from the headers
# ================================

# Obtain the filter from the FITS headers.
             $filter = $Frm->hdr( "FILTER" );

# Obtain the mean extinction coefficient.
             SWITCH: {
                if ( $filter =~ /^J/ ) {
                   $extinction = 0.102; $catcol = 0; last SWITCH;
                }
                if ( $filter =~ /^H/ ) { 
                   $extinction = 0.059; $catcol = 1; last SWITCH;
                }
                if ( $filter =~ /^K/ ) {
                   $extinction = 0.088; $catcol = 2; last SWITCH;
                }
                $extinction = 0.0; $catcol = -1;
             }

# Obtain the airmass from the FITS headers.  Find the approximate
# mean airmass from the start and end values.  This should be
# adequate unless it is a long integration with the source crossing
# the meridian.
             $amstart = $Frm->hdr( "AMSTART" );
             $amend   = $Frm->hdr( "AMEND" );
             $airmass = 0.5 * ( $amstart + $amend );
             $extcor = $airmass * $extinction;

# Obtain the object name, exposure time, time of observation and the
# pixelscale.
             $exptime = $Frm->hdr( "INT_TIME" );
             $objname = $Frm->hdr( "OBJECT" );
             $ut = $Frm->hdr( "UTSTART" );
             $pixelscale = $Frm->hdr( "CDELT1" );
             $padu = 7;

# Extract the system magnitude of faint standards
# ===============================================

# Faint standards have name FSn, where n is the number.  Only JHK
# magnitudes are tabulated.
             if ( substr( $objname, 0, 2 ) =~ /FS/i && $catcol > -1 ) {
                $stdno = substr( $objname, 2, 2 );

# Open the faint-standards file and store its records in an array.
                if (  -e "/ukirt_sw/ircamdr/fs.dat" ) {
                   $fs_standards = "/ukirt_sw/ircamdr/fs.dat";
                } else {
                   $fs_standards = "fs.dat";
                }
                open( FS_STANDARDS, "<$fs_standards" ) || 
                      die "JHK Standards file not found";
                @stds = <FS_STANDARDS>;

# Assume the ordered but non-relational format rather than searching for
# lines with the object name, and using the next line.
                $recno = 2 * $stdno + 1;

# Extract the magnitudes.
                @mags = split( / +/, $stds[ $recno ] );

# Obtain the desired magnitude.
                $catmag = $mags[ $catcol ];

# Close the stamdards data file.
                close( FS_STANDARDS );

             } else {
                $catmag = 999.99;
             }

# Find location and dimensions of the aperture and annulus
# ========================================================

# Locate the image centre.
             _FIND_SOURCE_CENTROID_
             $centre = $_FIND_SOURCE_CENTROID_{CENTRE};

# Obtain the aperture diameter in arcseconds.
             $as_aperture = ( $_FIXED_APERTURE_PHOTOMETRY_{APERTURE} || 7 );
 
# Calculate the radius of the inner and outer extent of the aperture.
             $inner = ( $_FIXED_APERTURE_PHOTOMETRY_{INNER} || 1.5 );
             $outer = ( $_FIXED_APERTURE_PHOTOMETRY_{OUTER} || 2.5 );
             $inner = min( 3.0, max( $inner, 1.2 ) );
             $outer = min( 5.0, max( $inner + 0.3, $outer, 1.5 ) );

# Automatic photometry
# ====================
#
# The automatic photometry task needs a text file to control the
# type and location of the photometry, and the size and shape of the
# aperture.  In this primitive these are fixed except the size, but
# we could use parameters for these in a hierarchy of scripts.  We have a
# circular aperture obtaining the sky from an annulus between the INNER
# and OUTER times the diameter of the main aperture.
             $rapture = 0.5 * $as_aperture / $pixelscale;
             open ( PHOTOM, ">photom$$.dat" );
             print PHOTOM "#ANN 1 $inner $outer\n";
             print PHOTOM "1 @$centre 0.0 0.0 0.0 0.0 OK $rapture 0.0 0.0 annulus circle\n";
             close ( PHOTOM );

# Specify the user parameters.
             $skyest = ( $_FIXED_APERTURE_PHOTOMETRY_{SKY_EST} || "3" );
             $zp = ( $_FIXED_APERTURE_PHOTOMETRY_{ZP} || "0.0" );
             $user = "skyest=$skyest skymag=$zp";
 
# Specify the other parameters for AUTOPHOTOM.  Strictly we should check the
# headers for the readout mode
             $header = "in=".$Frm->file." infile=photom$$.dat outfile=photom$$.res";
             $hidden = "nocentro padu=$padu biasle=0 photon=2 positive sature=12000 nousemask";

# Perform the photometry, however, for this case compute a centroid
# about which to integrate.
             $Mon{"photom_mon"}->obeyw("autophotom","$header $user $hidden");

# Extract and present the results.
# ================================
#
# The magnitude and error are the fourth and fifth fields in the output
# file.  The sky estimate is the sixth.  The erro coder is the eighth.
             open ( PHOTOM, "photom$$.res" );
             @results = map { (split)[3..7] } <PHOTOM>;
             close ( PHOTOM );

# Normalise by the exposure time.  Use more lucid variable names.
             $magnorm = $results[0] + 2.5 * log10( $exptime );
             $magerr = $results[1];
             $sky_level = $results[2] / $padu;
             $errcode = $results[4];

# Correct for the mean extinction.
             $magext = $magnorm - $extcor;

# Convert annulus radii into arcseconds.
             $inner = $inner * $as_aperture;
             $outer = $outer * $as_aperture;

# Format the results to give a sensible number of significant figures.
             $fs_mag = sprintf( "%7.3f", $magnorm );
             $fs_mag =~ s/ //g;
             $fs_sky = sprintf( "%9.3f", $sky_level );
             $fs_sky =~ s/ //g;
             $fs_airmass = sprintf( "%6.4f", $extcor );
             $fs_apdiam = sprintf( "%5.2f", $as_aperture );
             $fs_apdiam =~ s/ //g;
             $fs_inner =  sprintf( "%5.2f", $inner );
             $fs_inner =~ s/ //g;
             $fs_outer =  sprintf( "%5.2f", $outer );
             $fs_outer =~ s/ //g;
             if ( $catmag < 999 ) {
                $magdif = $catmag - $magext;
                $fs_magdif =  sprintf( "%6.3f", $magdif );
             }

# Print the results.
             orac_print "\n";
             orac_print "Frame:                  ".$Frm->file."\n";
             orac_print "Filter:                 $filter\n";
             if ( $errcode ne "OK" ) {
                orac_print "Instrumental Magnitude: $fs_mag +/- $magerr (error $errcode)\n";
             } else {
                orac_print "Instrumental Magnitude: $fs_mag +/- $magerr\n";
             }
             orac_print "Airmass correction:     $fs_airmass\n";
             if ( $catmag < 999 ) {
                orac_print "Catalogue Magnitude:    $catmag\n";
                orac_print "Magnitude difference:   $fs_magdif\n"
             }
             orac_print "Sky:                    $fs_sky\n";
             orac_print "Aperture diameter:      $fs_apdiam arcsec\n";
             orac_print "Annulus radii:          $fs_inner to $fs_outer arcsec\n";
             orac_print "\n";

# Remove the photometry text file.
             unlink( "photom$$.res" );

# Write the results for the current observation to the logfile.  Use sprintf
# to format the statistics in the specified formats for the columns of
# the table.  Append the formatted row to the logging file.  Note in case
# some of the header information is null, output the results as strings
# rather than integer or real; and assume a fixed format in the FITS headers
# matching the STL format when the keywords are present.
             printf LOGFILE ( "%18s %12s %8.5f %7s %5.3f %7.3f %7.3f %6.3f %2s %5.2f %6.3f %5.2f %5.2f %5.2f %8.2f %1s \n",
             $Frm->file, $objname, $ut, $filter, $airmass, $magnorm,
             $magext, $magerr, $errcode, $zp, $catmag, $as_aperture, $inner, $outer,
             $sky_level, $incflag );

          };

# Close the results file.
          close ( LOGFILE );
       }
    }
