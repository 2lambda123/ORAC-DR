#+
# Name:
#    _MAKE_OBJECTS_MASK_
#
# Purpose:
#    Makes an ARD mask of objects within the current frame.
#
# Language:
#    Perl5
#
# Description:
#    This primitive performs an inventory of the the shapes and
#    orientations of the sources in the current frame.  It creates
#    an ARD (ASCII Region Definition cf. SUN/183) file containing
#    elliptical regions corresponding to the measured extents of the
#    sources.  A circular central occulting mask is also written to
#    the ARD file; this is because the object detection around bright
#    sources (as might be expected near frame centre) is uneven and
#    can leave many small blobs.  `Central' refers to offset 0,0,
#    therefore on jittered frames, the bright target is still masked
#    as it appears in different pixel locations in the frame.
#
#    The inventory engine, PISA, is rather old and needs the data to
#    lie in the range 0 to 32765 and to not contain any bad pixels.
#    Therefore the script has first to remove all the bad pixel, and
#    then scale the data to this range.
#
#    The primitive reports the successful creation of the ARD file
#    and the various intermiediate frames made during processing.
#
# Arguments:
#    MASKFILE = CHARACTER (Returned)
#       The name of the ARD (ASCII Region Definition cf. SUN/183)
#       text file to contain the regions spanning the objects in the
#       frame.  It is set to "<frame>_objects.ard", where <frame> is
#       the name of the current frame when the primitive is invoked.  []
#    MINPIX = INTEGER (Given)
#       The minimum number of connected pixels needed before a set
#       of pixels can be considered as an object in the inventory.
#       [12]
#    OCCULT = REAL (Given)
#       The diameter of the central occulting mask in arcseconds. [7]
#
# Notes:
#    -  This primitive is suitable for both UFTI and IRCAM.
#    Instrument-specific headers are obtained where appropriate.
#    -  Processing only occurs for object and sky frames.
#    -  $Frm->file is updated during an pre-processing for the
#    inventory.  It is not reset to its value on entry.
#    -  The statistics of the input frame are found to derive the
#    mean, extreme values, and the number of bad pixels present.
#    -  Bad pixels are removed by first substituting the median of
#    each bad pixel's eight neighbours.  If any bad pixels remain, they
#    are replaced by the average pixel value of the frame.  That's
#    not a problem because residual bad pixels are usually areas
#    at the frames edge where the data  quality is known to be poor.
#    -  Depending on the data range, the data may be scaled or merely
#    offset to make the pixel values lie between 0 and 32765.
#    -  PISA does not let the threshold for object detection to be
#    specified in terms of sky noise, but demands a constant
#    displacement above sky.  Thus the script obtains the values at
#    +/- one sigma about the median using percentiles.  Empirical tests
#    have shown that using the values at 28 and 72 percentiles, rather
#    than 31.7 and 68.3 give a more-accurate value, probably because
#    the data are not Normally distributed.  The threshold offset is
#    constrained to be between 1.5 and 10 based upon more empirical
#    tests.  If set too low most of the signal is lost, and if too
#    high many objects are not detected.
#    -  The data are smoothed with a 3-by-3 pixel Hanning filter
#    prior to making the inventory in order to reduce artifacts
#    being masked and noise breaking up the outer parts of bright
#    objects into small, and hence undetected, blobs. 
#    -  An isophotal analysis is used for the inventory.
#    -  The primitive parses the inventory file and derives the
#    major and minor axis lengths and orientation to make the ARD file.
#    -  The intermediate frames cannot be displayed.
#    -  The title of the current frame when the task is invoked is
#    propagated to any intermediate frames.
#
# Output Data:
#    -  Various intermediate files depending on the supplied data.  They
#    all inherit the current frame's name but with different suffices.
#    The suffices and meanings are as follows: _dg for the frames
#    with bad pixels replaced by the local median (deglitched); _sbp
#    for frames with residual bad pixels bad pixels: _sc for scaled
#    or offset data.
#
# Deficiencies:
#    -  Should now use SExtractor to avoid the pre-processing.  It's also
#    allegedly faster than PISA.
#
# Tasks:
#    KAPPA: CSUB, GLITCH, HISTAT, MATHS, STATS; PISA: PISAFIND.
#
# Authors:
#    MJC: Malcolm J. Currie (JAC)
#
# Copyright:
#    Copyright (C) 1998-2000 Particle Physics and Astronomy Research
#    Council.  All Rights Reserved.
#
#-

# Selection
# =========

# This should only be performed on OBJECT frames.
    if ( $Frm->hdr( "OBSTYPE" ) eq "OBJECT" ||
         $Frm->hdr( "OBSTYPE" ) eq "SKY" ) {

# Note the root file name as the Frm->file will change during this
# primitive.
       my $root = $Frm->file;
       my ( $header, $hidden, $ORAC_STATUS );

# Arguments
# =========

# Obtain the diameter of the occulting circle in arcseconds.
       my $occultangle = ( $_MAKE_OBJECTS_MASK_{OCCULT} || 7 );

# Obtain the minimum number of pixels in the objects.
       my $minpix = ( $_MAKE_OBJECTS_MASK_{MINPIX} || 12 );

# Define rotation matrix
# ======================

# Obtain the rotation angle in degrees.
       my $rotangle = $Frm->hdr( "CROTA2" );
       $rotangle = defined( $rotangle ) ? $rotangle : 0.0;

# Define some useful variables to apply the rotation matrix.
       my $pi = atan2( 1, 1 ) * 4;
       my $dtor = $pi / 180.0;
       my $cosrot = cos( $rotangle * $dtor );
       my $sinrot = sin( $rotangle * $dtor );

# Locate the "central" circle
# ===========================

# We want to find where a bright point source or compact galaxy is usually
# placed so the source can be fully masked.

# Obtain the plate scales and the telescope offsets.
       my ( $xpixelscale, $ypixelscale );

# Find the Cartesian offsets in pixels.
       _GET_CARTESIAN_TELESCOPE_OFFSETS_
       my $xoff = $_GET_CARTESIAN_TELESCOPE_OFFSETS_{XOFF};
       my $yoff = $_GET_CARTESIAN_TELESCOPE_OFFSETS_{YOFF};

# Obtain the plate scales for the instrument from the headers.
# Primitive _GET_PLATE_SCALE_ has already been invoked by
# _GET_CARTESIAN_TELESCOPE_OFFSETS_ so no need to repeat that here.
       my $xpixelscale = $_GET_PLATE_SCALE_{RASCALE};
       my $ypixelscale = $_GET_PLATE_SCALE_{DECSCALE};

# Find the occulting circle radius in pixels.
       my $occultpix = 0.5 * $occultangle /
                       sqrt( $xpixelscale * $ypixelscale );

# Locate the centre of the frame by inquiring the frame's attributes.
       $Mon{"ndfpack_mon"}->obeyw("ndftrace","ndf=$root");
       ( $ORAC_STATUS, my @lbnd ) = $Mon{"ndfpack_mon"}->get("ndftrace","lbound");
       ( $ORAC_STATUS, my @ubnd ) = $Mon{"ndfpack_mon"}->get("ndftrace","ubound");

# Find the mid points.
       my $xmid = ( ( $lbnd[0] + $ubnd[0] ) / 2.0 );
       my $ymid = ( ( $lbnd[1] + $ubnd[1] ) / 2.0 );

# Derive the centre co-ordinates of the occulting mask.
       my $xcentre = $xmid + $xoff;
       my $ycentre = $ymid + $yoff;

# Perform inventory on the field
# ==============================

# Obtain the range of data values, the mean value, and the number
# of bad pixels within the frame.
       my $in = $root;
       $Mon{"kappa_mon"}->obeyw("stats","ndf=$in");
       ( $ORAC_STATUS, my $wordmin ) = $Mon{"kappa_mon"}->get("stats","minimum");
       ( $ORAC_STATUS, my $wordmax ) = $Mon{"kappa_mon"}->get("stats","maximum");
       ( $ORAC_STATUS, my $mean ) = $Mon{"kappa_mon"}->get("stats","mean");
       ( $ORAC_STATUS, my $numbad ) = $Mon{"kappa_mon"}->get("stats","numbad");

# Estimate the spread around the sky.
# -----------------------------------

# PISA doesn't allow the threshold to be specified in terms of sky noise,
# only absolute counts above sky.   Determine +/- one sigma about the
# median (deemed to be the sky) using percentiles.  There is a strange
# effect to be investigated where the preliminary flat-field often gives
# too small (2-3x) a range using 31.7 and 68.3 percentiles compared with
# the reasonable statistics for corrected flat-field.  Hence the range is
# expanded slightly.
       $Mon{"kappa_mon"}->obeyw("histat","ndf=$in percentiles=[28,72]");
       ( $ORAC_STATUS, my @perc ) = $Mon{"kappa_mon"}->get("histat","perval");

# Remove bad pixels
# -----------------

# PISAFIND cannot cope with bad pixels, so these must be substituted.
       ( $ORAC_STATUS, my $numbad ) = $Mon{"kappa_mon"}->get("stats","numbad");
       if ( $numbad > 0 ) {

# Generate the input and output file names.
          ( my $indg, my $outdg ) =  $Frm->inout( "_dg" );

# Remove the isolated bad pixels, replacing them with the median of the
# surrounding pixels.
# Remove the isolated bad pixels, replacing them with the median of the
# surrounding pixels.
          if ( starversion_lt( 'KAPPA', 'V0.15-0' ) ) {
             $header = "inpic=$indg outpic=$outdg again=f where=bad";
          } else {
             $header = "in=$indg out=$outdg mode=bad";
          }
          $Mon{"kappa_mon"}->obeyw("glitch","$header");

# Report the processing status.
          orac_print "Orac says: Isolated bad pixels in $indg replaced with median of neighbours in $outdg\n";

# Record the new file name in the frame object.
          $Frm->file( $outdg );

       }

# Obtain the range of data values and count the number of bad pixels
# within the frame.
       $in = $Frm->file;
       $Mon{"kappa_mon"}->obeyw("stats","ndf=$in");

# There may be some residual bad pixels at the periphery.  Replace these
# with the mean value, which should not bias the object detection
# significantly.
       ( $ORAC_STATUS, $numbad ) = $Mon{"kappa_mon"}->get("stats","numbad");
       if ( $numbad > 0 ) {

# Generate the input and output file names.
          ( my $insbp, my $outsbp ) =  $Frm->inout( "_sbp" );

# Substitute the bad pixels, replacing them with the average value
# of the frame.
          $header = "in=$insbp out=$outsbp repval=$mean";
          $Mon{"kappa_mon"}->obeyw("nomagic","$header");

# Report the processing status.
          orac_print "Orac says: Remaining bad pixels in $insbp replaced with frame mode in $outsbp\n";

# Record the new file name in the frame object.
          $Frm->file( $outsbp );
       }

# Scale the data
# --------------

# Scale the data to the range 0 to 32765 to keep the data within
# the PISAFIND range. 
       my $wscale = 1.0;
       my $imin = nint( $wordmin-0.5 );
       my $imax = nint( $wordmax );

# Is an offset correction required?  After application the maximum must
# not exceed the PISAFIND maximum.  We have shhaved off one to allow for
# rounding.
       my ( $insc, $outsc );
       if ( $imin < 0 && ( $imax - $imin ) <= 32765 ) {

# Generate the input and output file names.
          ( $insc, $outsc ) =  $Frm->inout( "_sc" );

# Apply the offset so that the data are all positive.
          $header = "in=$insc out=$outsc scalar=$wordmin";
          $Mon{"kappa_mon"}->obeyw("csub","$header");

# Report the processing status.
          orac_print "Orac says: Applied offset to $insc to make all pixels positive in $outsc\n";

# Record the new file name in the frame object.
          $Frm->file( $outsc );

# Is scaling required?
       } elsif ( $imin < 0 || $imax > 32765 ) {

# Generate the input and output file names.
          ( $insc, $outsc ) = $Frm->inout( "_sc" );

# Scale the data.
          my $wscale = 32765.0 / ( $wordmax - $wordmin );
          $header = "ia=$insc out=$outsc exp=$wscale*(IA-($wordmin))";
          $Mon{"kappa_mon"}->obeyw("maths","$header");

# Report the processing status.
          orac_print "Orac says: Scaled $insc by $wscale to make pixels fit allowed range in $outsc\n";

# Record the new file name in the frame object.
          $Frm->file( $outsc );
       }

# Locate the objects
# ------------------

# Generate the input file name.
       my $inpisa = $Frm->file;

# Specify the PISAFIND parameters.  Use the standard deviation (albeit
# unclipped) to specify the threshold, scaled to a new range, if
# applicable.
       my $resfile = $root . ".res";
       my $thresh = max( 1.5, min( 10, $wscale * ( $perc[1] - $perc[0] ) ) );
       $header = "in=$inpisa method=0 results=$resfile";
       $hidden = "minpix=$minpix thresh=$thresh ismoo";

# Report the processing status.
       orac_print "Orac says: Detecting objects in $inpisa with at least $minpix connected pixels at $thresh units above sky\n";

# Derive an inventory of the images in $resfile.
       my $pisa_status = $Mon{"pisa_mon"}->obeyw("pisafind","$header $hidden accept");

# Remove any intermediate text data files.  Data frames will be cleared
# by the pipeline tidy.  If none exist it means the supplied flat-fielded
# image has no bad pixels and all of its values lie within the range
# 0 to 32765.
       unlink( "pisafind.dat" );     # Unused results file.

# We can handle a failure here by making a null ARD file.  So we test a
# local status rather than let ORAC go on to the next file.
       if ( $pisa_status == ORAC__OK ) {

# Read the results file into an array.  Obtain the number of objects.
# Remove the results file.
          open (RESFILE, "< $resfile");
          my @lines = <RESFILE>;
          my $numobject = $#lines + 1;
          close (RESFILE);

# Form the ARD file
# =================

# Generate the ARD file name using the raw frame name.  Export the file
# for use by masking primitive.
          my $ardfile = $root . "_objects.ard";
          $_MAKE_OBJECTS_MASK_{MASKFILE} = $ardfile;

# Remove any existing ARD object file.
          unlink( $ardfile );

# Create an ARD file.
          open( ARDFILE, "> $ardfile" );

# Create a circle mask around the central region to ensure that a bright
# and possibly extended source is fully masked.  The faint outer parts are
# occasionaly ignored by PISA.
          printf ARDFILE "CIRCLE( %10.3f, %10.3f, %5.1f )\n",
                $xcentre, $ycentre, $occultpix;

# Read each line of the PISAFIND results file, and split the fields.
          for ( my $ifd = 0; $ifd < $numobject; $ifd++) {
             my @fields = split(/\s+/, $lines[$ifd]);

# Relevant fields are:
# 2  x co-ordinate of centre
# 3  y co-ordinate of centre
# 5  number of pixels above the threshold
# 7  ellipticity
# 8  orientation measured in degrees anti-clockwise from y axis
#
# The first two can be used directly in the ARD description, but the
# other three are used to generate the semi-major axes, and the ARD
# ELLIPSE orientation.
             my $ea = sqrt($fields[5] / 3.14159 /max((1.0 - @fields[7]), 0.99999));
             $ea = min($ea, 0.5 * $fields[5]);
             my $eb = $ea * (1.0 - $fields[7]);
             my $orient = ( $fields[8] - 90.0 ) % 360.0;

#  Write the ARD description.
             printf ARDFILE "ELLIPSE( %10.3f, %10.3f, %8.3f, %8.3f, %5.1f )\n",
                $fields[2], $fields[3], $ea, $eb, $orient;
          }
          close( ARDFILE );

# Report the processing status.
          orac_print "Orac says: Mask for $root stored in ARD file $ardfile\n";
       }

    }

# Podule
# ======

=head1 NAME

_MAKE_OBJECTS_MASK_ -- Makes an ARD mask of objects within the current frame.

=head1 DESCRIPTION

This primitive performs an inventory of the the shapes and
orientations of the sources in the current frame.  It creates
an ARD (ASCII Region Definition cf. SUN/183) file containing
elliptical regions corresponding to the measured extents of the
sources.  A circular central occulting mask is also written to
the ARD file; this is because the object detection around bright
sources (as might be expected near frame centre) is uneven and
can leave many small blobs.  `Central' refers to offset 0,0,
therefore on jittered frames, the bright target is still masked
as it appears in different pixel locations in the frame.

The inventory engine, PISA, is rather old and needs the data to
lie in the range 0 to 32765 and to not contain any bad pixels.
Therefore the script has first to remove all the bad pixel, and
then scale the data to this range.

The primitive reports the successful creation of the ARD file
and the various intermiediate frames made during processing.

=head1 ARGUMENTS

=over 4

=item MASKFILE = CHARACTER (Returned)

The name of the ARD (ASCII Region Definition cf. SUN/183)
text file to contain the regions spanning the objects in the
frame.  It is set to "E<lt>frameE<gt>_objects.ard", where E<lt>frameE<gt> is
the name of the current frame when the primitive is invoked.  []

=item MINPIX = INTEGER (Given)

The minimum number of connected pixels needed before a set
of pixels can be considered as an object in the inventory. [12]

=item OCCULT = REAL (Given)

The diameter of the central occulting mask in arcseconds. [7]

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for both UFTI and IRCAM.
Instrument-specific headers are obtained where appropriate.

=item *

Processing only occurs for object and sky frames.

=item *

$Frm-E<gt>file is updated during an pre-processing for the
inventory.  It is not reset to its value on entry.

=item *

The statistics of the input frame are found to derive the
mean, extreme values, and the number of bad pixels present.

=item *

Bad pixels are removed by first substituting the median of
each bad pixel's eight neighbours.  If any bad pixels remain, they
are replaced by the average pixel value of the frame.  That's
not a problem because residual bad pixels are usually areas
at the frames edge where the data quality is known to be poor.

=item *

Depending on the data range, the data may be scaled or merely
offset to make the pixel values lie between 0 and 32765.

=item *

PISA does not let the threshold for object detection to be
specified in terms of sky noise, but demands a constant
displacement above sky.  Thus the script obtains the values at
+/- one sigma about the median using percentiles.  Empirical tests
have shown that using the values at 28 and 72 percentiles, rather
than 31.7 and 68.3 give a more-accurate value, probably because
the data are not Normally distributed.  The threshold offset is
constrained to be between 1.5 and 10 based upon more empirical
tests.  If set too low most of the signal is lost, and if too
high many objects are not detected.

=item *

The data are smoothed with a 3-by-3 pixel Hanning filter
prior to making the inventory in order to reduce artifacts
being masked and noise breaking up the outer parts of bright
objects into small, and hence undetected, blobs. 

=item *

An isophotal analysis is used for the inventory.

=item *

The primitive parses the inventory file and derives the
major and minor axis lengths and orientation to make the ARD file.

=item *

The intermediate frames cannot be displayed.

=item *

The title of the current frame when the task is invoked is propagated
to any intermediate frames.

=back

=head1 OUTPUT DATA

=over 4

=item *

Various intermediate files depending on the supplied data.  They
all inherit the current frame's name but with different suffices.
The suffices and meanings are as follows: _dg for the frames
with bad pixels replaced by the local median (deglitched); _sbp
for frames with residual bad pixels bad pixels: _sc for scaled
or offset data.

=back

=head1 DEFICIENCIES

=over 4

=item *

Should use now SExtractor to avoid the pre-processing.  It's also
allegedly faster than PISA.

=back

=head1 TASKS

KAPPA: CSUB, GLITCH, HISTAT, MATHS, STATS; PISA: PISAFIND.

=head1 AUTHORS

MJC: Malcolm J. Currie (JAC)

=head1 COPYRIGHT

Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut
