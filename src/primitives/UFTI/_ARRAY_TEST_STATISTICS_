# _ARRAY_TEST_STATISTICS_
#
# Tasks: KAPPA - HISTAT, STATS

# Create the results file if needed.
# ==================================
       
# Create a results file if one does not exist.
     $results = "/ukirt_sw/logs/ufti_array_tests.log";
     if ( !(-e $results) ) {
        $openresult = ">/ukirt_sw/logs/ufti_array_tests.log";
        open (RESULTS, $openresult);
        orac_print "Creating a new results file called $results\n";

# Write the column headings into the result file.
        print RESULTS " UT  Date       ND_STARE_RN      Dark Current\n";
        print RESULTS "----------      -----------      ------------\n";

     } else {
        $openresult = ">>/ukirt_sw/logs/ufti_array_tests.log";
        open (RESULTS, $openresult);
     };

# Compute the statistics.
# =======================

# Wait until all the array tests are completed.  Should be four frames.
# <FROSSIE>
# Change to be "every four frames" rather than "four frames" to
# compensate for current lack of implementation of UFTI groups
#     if ( $Grp->num == 3 ) {
if (($Grp->num+1)%4 ==0) {
# </FROSSIE>

# Set some parameters.
        my $exptime = 60.0;
        my $adu = 7.0;

# Obtain the names of the group members.
        @frames = $Grp->membernames;

# Difference the first two (ND_STARE) frames.  The first ARRAY_TESTS frame
# is ignored.
        $Mon{"kappa_mon"}->obeyw("sub","in1=$frames[1] in2=$frames[2] out=array_test");

# Find the standard deviation of the difference frame after a 3-sigma clipping.
        $Mon{"kappa_mon"}->obeyw("stats","ndf=array_test clip=3");
        ($ORAC_STATUS, $nd_stare_sigma) = $Mon{"kappa_mon"}->get("stats","sigma");
        $nd_stare_rn = $nd_stare_sigma / sqrt( 2.0 ) * $adu;

# Find the clipped mean of the fourth frame, a dark frame.
        $Mon{"kappa_mon"}->obeyw("stats","ndf=$frames[3] clip=3");
        ($ORAC_STATUS, $mean) = $Mon{"kappa_mon"}->get("stats","mean");
        $dark = $mean / $exptime * $adu;

# Obtain the date.  Use DATE for the time being as DATE-OBS is blank.
        $utdate = substr( $Frm->hdr( "DATE" ), 0, 10 );

# Remove the temporary file.
        unlink ( "array_test.sdf" );

# Output the results.
# ===================

# Format the results.
        $fs_nsr = sprintf( "%9.2f", $nd_stare_rn );
        $fs_dark = sprintf( "%9.2f", $dark );

# Write the results to the engineering file, which is then closed.
        printf RESULTS "%10s %16s %17s\n", $utdate, $fs_nsr, $fs_dark;
        close (RESULTS);

# Remove leading spaces.
        $fs_nsr =~ s/ //;
        $fs_dark =~ s/ //;

# Report the results to the user.
        orac_print "\n";
        orac_print "ND_STARE mode readout noise (e-) = $fs_nsr\n";
        orac_print "Dark current (e-/sec)            = $fs_dark\n";
        orac_print "\n";

# Report upon the status of the results.
# ======================================

# ND_STARE readout noise.  May need to make the nominal value a parameter.
        if ( $nd_stare_rn < 8.0 ) {
           orac_warn "ND_STARE readout noise is LOW with respect to nominal 23e-.  Repeat the exec.\n";
        } elsif ( $nd_stare_rn > 30.0 ) {
           orac_warn "ND_STARE readout noise is HIGH with respect to nominal 23e-\n";
        } else {
           orac_print "** ND_STARE readout noise is nominal **\n";
        };

# Dark current.  May need to make the nominal value a parameter.
        if ( $dark < 0.0 ) {
           orac_warn "Dark current is NEGATIVE, wierd; nominal is 0 to 1e-/sec\n\n";
        } elsif ( $dark > 1.0 ) {
           orac_warn "Dark current is HIGH with respect to nominal 0 to 1e-/sec\n\n";
        } else {
           orac_print "** Dark current is nominal **\n\n";
        };
     };
