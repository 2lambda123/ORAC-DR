# _MAKE_MOSAIC_     -*- perl -*-
#
# Forms a mosaic
#
# TASK: KAPPA - TRANJOIN; CCDPACK - TRANLIST, MAKEMOS
#

# Selection
# =========

# This should only be performed on OBJECT frames.
    if ( $Frm->hdr( "OBSTYPE" ) eq "OBJECT" ) {

# Test whether or not it is time to make a mosaic.
       $makemos = $Frm->hdr( "MAKE_MOSAIC" );
       if ( $makemos ) {

# Specify the mosaic suffix.
          $osuffix = "_mos";

# Form a list of input file names for the CCDPACK tasks.  We need to
# generate an input list for TRANJOIN and TRANNDF and an output list
# using a hard-wired suffix of '_trn'
          ($inref, $outref) = $Grp->inout('_trn');

# Convert the list to a comma-separated list as needed by CCDPACK (GRP).
          $objlist = join(",", @$inref);
          $outlist= join(",", @$outref);

# Create text files to hold the list of input and output files, one per line.
# This is needed because expanded lists of files may make the command line
# too long for the ADAM message system.
          unlink ("tranndf.inlist$$", "tranndf.outlist$$");

          open (INLIST, ">tranndf.inlist$$");
          print INLIST join( "\n", @$inref ), "\n";
          close (INLIST);

          open (OUTLIST, ">tranndf.outlist$$");
          print OUTLIST join( "\n", @$outref ), "\n";
          close (OUTLIST);

# Concatenate rotation to transformation
# ======================================

# Specify the other parameters for the TRANJOIN stage.
#          $hidden = "in2=".$Cal->rotation." dest=first"; 

# Join the rotation transformation to each of the CCDPACK extensions.
# The rotation transformation follows the shift-of-origin and is stored
# in the '_ff' frame.  Unfortunately, CCDEDIT doesn't support joining
# transformations, and KAPPA/TRANJOIN does operate on lists of files.
# Write the input file names to the text files.
#          foreach $flatted (@$inref) {
#             $header = "in1=${flatted}.more.ccdpack.transform";
#             $Mon{"kappa_mon"}->obeyw("tranjoin","$header $hidden accept");
#          }

# Report the status.
#          orac_print "Orac says: Rotation transformation joined\n";

# Resampling
# ==========

# Inquire the original bounds.
          $xl = $Frm->hdr( "RDOUT_X1" );
          $yl = $Frm->hdr( "RDOUT_Y1" );
          $xu = $Frm->hdr( "RDOUT_X2" );
          $yu = $Frm->hdr( "RDOUT_Y2" );

# Assign the other parameters.  Use the original bounds.
          $header = "in='^tranndf.inlist$$' out='^tranndf.outlist$$'";
          $hidden = "shape=specify lbound=[".$xl.",".$yl."] ubound=[".$xu.",".$yu."]";

# Shift and resample the flat-field object frames.  This determines
# the bounds automatically.  It takes the origin from the first object
# frame.
          $Mon{"ccdpack_reg"}->obeyw("tranndf","$header $hidden");

# Report the processing status.
          orac_print "Orac says: Frames $objlist resampled\n";

# Assign other parameters.  The scale might become a user parameter.
# We should presumably set the Grp output name when we construct
# $outname.  Do not change the output name if we have already
# appended the output suffix the previous time around.
          $outname = $Grp->file . $osuffix unless $Grp->file =~ /$osuffix$/;
          $header = "in='^tranndf.outlist$$' out='$outname' title=Mosaic";
          $hidden = "zero";
#         $user = "scale";

# Make the mosaic correcting for differences in offset.
          $Mon{"ccdpack_reg"}->obeyw("makemos","$header $hidden");
          unlink ("tranndf.inlist$$", "tranndf.outlist$$");

# Set the group name in the Group object...
          $Grp->file($outname);

# ...and read the header.
          $Grp->header($Grp->readhdr);

# Report the processing status.
          orac_print "Orac says: mosaic $outname formed\n";

# Display the resultant mosaic.
          _DISPLAY_GROUP_IMAGE_

       };
    };
