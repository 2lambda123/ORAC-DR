# _MAKE_MOSAIC_     -*- perl -*-
#
# Forms a mosaic
#
# TASK: KAPPA - TRANJOIN; CCDPACK - TRANLIST, MAKEMOS
#

# Selection
# =========

# This should only be performed on OBJECT frames.
    if ( $Frm->hdr( "OBSTYPE" ) eq "OBJECT" ) {

# Test whether or not it is time to make a mosaic.
       my $makemos = $Frm->hdr( "MAKE_MOSAIC" );
       if ( $makemos ) {

# Obtain the cycle number.  Default to zero if undefined, so that recipes
# which do not support this feature will continue to work.
          my $cycleno = ( $Frm->hdr( "CYCLE_NUMBER" ) || 0 );

# Obtain the cycle period.  Default to 9 if undefined, so that recipes
# which do not support this feature will continue to work.  This assumes
# that nine is the maximum number of jitters.
          my $period = $Frm->hdr( "JITTER_NUMBER" || 9 );

# Select those members in the current cycle.
          my $cycleGrp = $Grp->subgrp( CYCLE_NUMBER => $cycleno );

# Specify the mosaic suffix.
          my $osuffix = "_mos";

# Form a list of input file names for the CCDPACK tasks.  We need to
# generate an input list for TRANJOIN and TRANNDF and an output list
# using a hard-wired suffix of '_trn'
          (my $inref, my $outref) = $cycleGrp->inout('_trn');

# Convert the list to a comma-separated list as needed by CCDPACK (GRP).
          my $objlist = join(",", @$inref);
          my $outlist= join(",", @$outref);

# Concatenate rotation to transformation
# ======================================

# Specify the other parameters for the TRANJOIN stage.
          my ( $header, my $hidden );
#          $hidden = "in2=".$Cal->rotation." dest=first"; 

# Join the rotation transformation to each of the CCDPACK extensions.
# The rotation transformation follows the shift-of-origin and is stored
# in the '_ff' frame.  Unfortunately, CCDEDIT doesn't support joining
# transformations, and KAPPA/TRANJOIN does operate on lists of files.
# Write the input file names to the text files.
#          foreach $flatted (@$inref) {
#             my $header = "in1=${flatted}.more.ccdpack.transform";
#             $Mon{"kappa_mon"}->obeyw("tranjoin","$header $hidden accept");
#          }

# Report the status.
#          orac_print "Orac says: Rotation transformation joined\n";

# Resampling
# ==========

# Create text files to hold the list of input and output files, one per line.
# This is needed because expanded lists of files may make the command line
# too long for the ADAM message system.
          unlink( "tranndf.inlist$$", "tranndf.outlist$$" );

          open( INLIST, ">tranndf.inlist$$" );
          print INLIST join( "\n", @$inref ), "\n";
          close( INLIST );

          open( OUTLIST, ">tranndf.outlist$$" );
          print OUTLIST join( "\n", @$outref ), "\n";
          close( OUTLIST );

# Inquire the original bounds.
          my $xl = $Frm->hdr( "RDOUT_X1" );
          my $yl = $Frm->hdr( "RDOUT_Y1" );
          my $xu = $Frm->hdr( "RDOUT_X2" );
          my $yu = $Frm->hdr( "RDOUT_Y2" );

# Assign the other parameters.  Use the original bounds.
          $header = "in='^tranndf.inlist$$' out='^tranndf.outlist$$' title=!";
          $hidden = "shape=specify lbound=[".$xl.",".$yl."] ubound=[".$xu.",".$yu."]";

# Shift and resample the flat-field object frames.  This determines
# the bounds automatically.  It takes the origin from the first object
# frame.
          $Mon{"ccdpack_reg"}->obeyw("tranndf","$header $hidden");

# Report the processing status.
          orac_print "Orac says: Frames $objlist resampled\n";

# Make mosaic.
# ============

# Derive a reasonable number of overlaps.  The default is only three
# but with 9-point jitters it could be as high as 8 for the central
# region.  As non-overlaps will not be included, it's probably better to
# err on the high side.  So here we've assumed that all the jittered
# frames could overlap.
          my $optov = $period - 1;

# Define the mosaic name.  We should presumably set the Grp output name
# when we construct $mosname.  Do not change the output name if we have
# already appended the output suffix the previous time around.
# The first cycle mosaic becomes the main mosaic.  Subsequent mosaics of
# four are co-add (after registration) into the main mosaic, hence these
# require a different name.
          my $mosname = $Grp->file . $osuffix unless $Grp->file =~ /$osuffix$/;
          if ( $cycleno > 0 ) {
             $mosname = $Grp->file . "_" . $cycleno;
          }

# Assign other parameters.
          $header = "in='^tranndf.outlist$$' out=$mosname title=!";
          $hidden = "zero optov=$optov";

# Make the mosaic correcting for differences in offset.
          $Mon{"ccdpack_reg"}->obeyw("makemos","$header $hidden");
          unlink ("tranndf.inlist$$", "tranndf.outlist$$");

# Report the processing status.
          orac_print "Orac says: mosaic $mosname formed\n";

# Set the group name in the Group object...
          if ( $cycleno == 0 ) {
             $Grp->file( $mosname );

# ...and read the header.
             $Grp->readhdr;
          }

# Display the resultant mosaic.
          _DISPLAY_GROUP_IMAGE_

# On the second and subsequent cycle, we just need to co-add the
# single-cycle mosaic into the main mosaic.
          if ( $cycleno > 0 ) {

# Make a duplicate of the main mosaic.
             my $tmpmos = "mainmos$$";
             $header = "in=" . $Grp->file . " out=$tmpmos";
             $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$header" );

# Co-add the frames.
             $header = "in1=$tmpmos in2=$mosname out=" . $Grp->file;
             $Mon{ "kappa_mon" }->obeyw( "add", "$header" );

# Remove the temporary copy unless its the first.  This leaves the
# mosaics for each and every individual jitter to be examined later.
             if ( $cycleno > 1 ) {
                _DELETE_A_FRAME_ FRAME=$tmpmos
             } else {
                $header = "in=$tmpmos out=" . $Grp->file . "_0";
                $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$header" );
             }

             orac_print "Orac says: Frame $mosname co-added into main mosaic " . $Grp->file . "\n";

# Display the main mosaic.
             _DISPLAY_GROUP_IMAGE_
          }
       }
    }
