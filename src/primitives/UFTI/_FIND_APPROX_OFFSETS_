# _FIND_APPROX_OFFSETS_       -*- perl -*-
#
#  Finds the offsets assuming the main object is within
#  a small box located at the frame centre or displaced by
#  the offsets given in the headers.

# This should only be performed on OBJECT frames.
    if ( $Frm->hdr( "OBSTYPE" ) eq "OBJECT" ||
         $Frm->hdr( "OBSTYPE" ) eq "SKY" ) {

# Obtain the name of the group to register.
#       my $reggrp = ( $_FIND_APPROX_OFFSETS_{GROUP} || $Grp );

# Determine whether or not to use the central-box search.
       my $usebox = ( $_FIND_APPROX_OFFSETS_{SEARCH_BOX} || "TRUE" );

# Derive the boxsize in arcseconds.
       my $boxangle = ( $_FIND_APPROX_OFFSETS_{BOXSIZE} || 5 );

# Obtain a list of the filenames of the group members.
       @frames = $reggrp->membernames;
       $objlist = join(",",@frames);

# Create text file to hold the list of input files, one per line.  This
# is needed because expanded lists of files may make the command line too
# long for the ADAM message system.
       unlink ("faolist.inlist$$");
       open (INLIST, ">faolist.inlist$$");
       print INLIST join( "\n", @objects ), "\n";
       close (INLIST);

# Create a file for storing the filenames of the offset files.
       $offlist = "ssoff.lis$$";
       unlink ( "$offlist" );
       open ( OFFLIST, "> $offlist" );

# Loop through all the frames.
       foreach $frame ( $reggrp->members ) {

# Obtain the plate scale.
          $xpixelscale =  $frame->hdr( "CDELT1" );
          $ypixelscale =  $frame->hdr( "CDELT2" );

# Find the boxsize in pixels.
          $boxpix = $boxangle / $xpixelscale;

# Obtain the offsets.  Try the xhead offsets first.
          $xoff = $frame->hdr( "TRAOFF" );
          $yoff = $frame->hdr( "TDECOFF" );
          $offtype = "crosshead";

# If the values are both zero or there was an error (presumably arising
# when the keyword is absent), this means the crosshead offsets are not
# used.  Instead use the telescope offsets.  Also cope when there is an
# error.
          if ( ( $xoff == 0 && $yoff == 0 ) ) {
             $xoff = $frame->hdr( "TRAOFF" );
             $yoff = $frame->hdr( "TDECOFF" );
             $offtype = "telescope";
          }

# Convert to pixel offsets of the object in the Cartesian sense.
          $xoff = $xoff / $xpixelscale;
          $yoff = -1.0 * $yoff / $ypixelscale;

# Locate the centre of the frame by inquiring the frame's attributes.
          $ndf = $frame->file;
          $Mon{"ndfpack_mon"}->obeyw("ndftrace","ndf=$ndf");
          ( $ORAC_STATUS, @lbnd ) = $Mon{"ndfpack_mon"}->get("ndftrace","lbound");
          ( $ORAC_STATUS, @ubnd ) = $Mon{"ndfpack_mon"}->get("ndftrace","ubound");

# Find the mid points.
          $xmid = ( ( $lbnd[0] + $ubnd[0] ) / 2.0 );
          $ymid = ( ( $lbnd[1] + $ubnd[1] ) / 2.0 );

# Search in box?
          if ( $usebox =~ /TRUE/ ) {

# Derive the centre co-ordinates of the box.
             $xcentre = $xmid + $xoff;
             $ycentre = $ymid + $yoff;

# Define pixel limits of the detection box.
             $xlbox = $xcentre - 0.5 * $boxpix;
             $xubox = $xcentre + 0.5 * $boxpix;

             $ylbox = $ycentre - 0.5 * $boxpix;
             $yubox = $ycentre + 0.5 * $boxpix;

# Open FINDOBJ file.
             $findfile = $ndf . ".find";
             open ( FINDFILE, "< $findfile" );

# Find the object nearest to the centre and within the box.
             $nearest = 0;
             $objnum = 0;
             $mindist = 999999;
             foreach $line ( <FINDFILE> ) {

# Ignore the comments.  Data lines begin with an integer identifier.
                if ( $line =~ /^[1-9]/ ) {

# Break the space-separated fields.   Obtain the x-y positions.
                   @fields = split( /\s+/, $line );
                   $xpos = $field[1];
                   $ypos = $field[2];

# Increment the object count.
                   $objnum++;

# See if the object is within the box.
                   if ( $xpos > $xlbox && $xpos < $xubox &&
                        $ypos > $ylbox && $ypos < $yubox ) {
                      $dist = sqrt( ( $xpos - $xcentre ) **2 + 
                                    ( $ypos - $ycentre ) **2 );
                      if ( $dist < $mindist ) {
                         $mindist = dist;
                         $nearest = $objnum;
                         $xnear = $xpos;
                         $ynear = $ypos;
                      }
                   }
                }
             }
             close ( FINDFILE );
          }

# Specify the offsets to be used.  If the minimum distance is unchanged
# just use the headers, otherwise find the displacement.
          if ( $mindist == 999999 || !( $usebox =~ /TRUE/ ) ) {
             $xoffset = $xoff;
             $yoffset = $yoff;
             orac_print "Orac says: using $offtype offsets ($xoffset,$yoffset) for frame $ndf\n";

          } else {
             $xoffset = $xnear - $xoff;
             $yoffset = $ynear - $yoff;
             orac_print "Orac says: using central-source offsets ($xoffset,$yoffset) for frame $ndf\n";
          }

# Create an offset file as used by CCDPACK's REGISTER task.  Store the
# the frame name and offsets within the file.
          $off_file = $ndf . ".off";
          unlink ( "$off_file" );
          open ( OFFSET, "> $off_file" );
          print OFFSET "1  $xoffset  $yoffset\n";
          close ( OFFSET );

# Record the name offset file in GRP indirection file for use by CCDEDIT.
          print OFFLIST "$off_file\n";
       }
    }
    close ( OFFLIST );

# Create text file to hold the list of input files, one per line.  This
# is needed because expanded lists of files may make the command line too
# long for the ADAM message system.
    unlink ("reglist.inlist$$");
    open (INLIST, ">reglist.inlist$$");
    print INLIST join( "\n", @frames), "\n";
    close (INLIST);

# Specify parameters for editing CCDPACK headers.
    $header = "in='^faolist.inlist$$' inlist=\'^$offlist\'";
    $hidden = "mode=alist"; 

# Associate the position-list files with the current object frames.
    $Mon{"ccdpack_reg"}->obeyw("ccdedit","$header $hidden");
    unlink( "faolist.inlist$$" );
