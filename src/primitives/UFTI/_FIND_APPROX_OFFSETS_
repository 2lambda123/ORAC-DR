# _FIND_APPROX_OFFSETS_       -*- perl -*-
#
#  Finds the offsets assuming the main object is within
#  a small box located at the frame centre or displaced by
#  the offsets given in the headers.

# This should only be performed on OBJECT frames.
    if ( $Frm->hdr( "OBSTYPE" ) eq "OBJECT" ||
         $Frm->hdr( "OBSTYPE" ) eq "SKY" ) {

# Obtain parameter values.
# ========================

# Determine whether or not to use the central-box search.
       my $usebox = ( $_FIND_APPROX_OFFSETS_{SEARCH_BOX} || "TRUE" );

# Derive the boxsize in arcseconds.
       my $boxangle = ( $_FIND_APPROX_OFFSETS_{BOXSIZE} || 5 );

# Obtain the rotation angle in degrees.  The default is UFTI and time
# specific.
       my $rotangle = ( $_FIND_APPROX_OFFSETS_{ANGLE} || 0.65 );

# Define some useful variables to apply the rotation matrix.
       $pi = atan2( 1, 1 ) * 4;
       $dtor = $pi / 180.0;
       $cosrot = cos( $rotangle * $dtor );
       $sinrot = sin( $rotangle * $dtor );

# Create text files
# =================

# Obtain a list of the filenames of the group members.  Exclude the first
# (reference) frame.
       @regnames = $Grp->membernames;
       $junk = shift( @regnames );

# Create text file to hold the list of input files, one per line.  This
# is needed because expanded lists of files may make the command line too
# long for the ADAM message system.
       unlink ("faolist.inlist$$");
       open (INLIST, ">faolist.inlist$$");
       print INLIST join( "\n", @regnames ), "\n";
       close (INLIST);

# Create a file for storing the filenames of the offset files.
       $offlist = "ssoff.lis$$";
       unlink ( "$offlist" );
       open ( OFFLIST, "> $offlist" );

# Loop through all the frames.
       $first = 1;
       foreach $frame ( $Grp->members ) {

# Obtain the plate scale.  Header is inaccurate.  Hardwire until
# more precise figure is used.  Note this is UFTI specific.
           $xpixelscale = 0.09075;
           $ypixelscale = 0.09075;
#          $xpixelscale = $frame->hdr( "CDELT1" );
#          $ypixelscale = $frame->hdr( "CDELT2" );

# Find the boxsize in pixels.
          $boxpix = $boxangle / $xpixelscale;

# Obtain the offsets.  Try the xhead offsets first. (Currently not available
# so use the telescope offsets.)
          $xoff = $frame->hdr( "TRAOFF" );
          $yoff = $frame->hdr( "TDECOFF" );
          $offtype = "telescope";

# If the values are both zero or there was an error (presumably arising
# when the keyword is absent), this means the crosshead offsets are not
# used.  Instead use the telescope offsets.  Also cope when there is an
# error.
          if ( ( $xoff == 0 && $yoff == 0 ) ) {
             $xoff = $frame->hdr( "TRAOFF" );
             $yoff = $frame->hdr( "TDECOFF" );
             $offtype = "telescope";
          }

# Convert to pixel offsets of the object in the Cartesian sense.
          $xoff = $xoff / $xpixelscale;
          $yoff = -1.0 * $yoff / $ypixelscale;

# Apply the rotation matrix.
          $xoff = $xoff * $cosrot - $yoff * $sinrot;
          $yoff = $xoff * $sinrot + $yoff * $cosrot;

# Locate the centre of the frame by inquiring the frame's attributes.
          $ndf = $frame->file;
          $Mon{"ndfpack_mon"}->obeyw("ndftrace","ndf=$ndf");
          ( $ORAC_STATUS, @lbnd ) = $Mon{"ndfpack_mon"}->get("ndftrace","lbound");
          ( $ORAC_STATUS, @ubnd ) = $Mon{"ndfpack_mon"}->get("ndftrace","ubound");

# Find the mid points.
          $xmid = ( ( $lbnd[0] + $ubnd[0] ) / 2.0 );
          $ymid = ( ( $lbnd[1] + $ubnd[1] ) / 2.0 );

# Initialise minimum distance.  It acts as an indicator of whether or not
# central-source offsets have been found.
          $mindist = 999999;

# Search in box?  For this the corresponding find file from FINDOBJ must 
# exist.
          $findfile = $ndf . ".find";
          if ( $usebox =~ /TRUE/ && -e $findfile && ! $first ) {

# Derive the centre co-ordinates of the box.
             $xcentre = $xmid + $xoff;
             $ycentre = $ymid + $yoff;

# Define pixel limits of the detection box.
             $xlbox = $xcentre - 0.5 * $boxpix;
             $xubox = $xcentre + 0.5 * $boxpix;

             $ylbox = $ycentre - 0.5 * $boxpix;
             $yubox = $ycentre + 0.5 * $boxpix;

# Open FINDOBJ file.
             $findfile = $ndf . ".find";
             open ( FINDFILE, "< $findfile" );

# Find the object nearest to the centre and within the box.
             $nearest = 0;
             $objnum = 0;
             foreach $line ( <FINDFILE> ) {

# Ignore the comments.  Data lines begin with an integer identifier.
                if ( $line =~ /^[1-9]/ ) {

# Break the space-separated fields.   Obtain the x-y positions.
                   @fields = split( /\s+/, $line );
                   $xpos = $fields[1];
                   $ypos = $fields[2];

# Increment the object count.
                   $objnum++;

# See if the object is within the box.
                   if ( $xpos > $xlbox && $xpos < $xubox &&
                        $ypos > $ylbox && $ypos < $yubox ) {
                      $dist = sqrt( ( $xpos - $xcentre ) **2 + 
                                    ( $ypos - $ycentre ) **2 );
                      if ( $dist < $mindist ) {
                         $mindist = $dist;
                         $nearest = $objnum;
                         $xnear = $xpos;
                         $ynear = $ypos;

                      }
                   }
                }
             }
             close ( FINDFILE );
          }

# Need an origin for the header offsets.  The frame centre does this for
# the centre-source offsets, unless there is an existing co-ordinate origin with
# which to align.  Do not report these offsets or store them in the offset file.
          if ( $first ) {
             $xorigin = $xoff;
             $yorigin = $yoff;
             $first = 0;

# Specify the offsets to be used.  If the minimum distance is unchanged
# just use the headers, otherwise find the displacement.  
          } else {
             if ( $mindist != 999999 && $usebox =~ /TRUE/ && -e $findfile ) {
                $xoffset = $xnear - $xmid;
                $yoffset = $ynear - $ymid;
                orac_print "Orac says: using central-source offsets ($xoffset,$yoffset) for frame $ndf\n";

             } else {
                $xoffset = $xoff - $xorigin;
                $yoffset = $yoff - $yorigin;
                orac_print "Orac says: using $offtype offsets ($xoffset,$yoffset) for frame $ndf\n";
             }

# Create an offset file as used by CCDPACK's REGISTER task.  Store the
# the frame name and offsets within the file.
             $off_file = $ndf . ".off";
             unlink ( "$off_file" );
             open ( OFFSET, "> $off_file" );
             print OFFSET "1  $xoffset  $yoffset\n";
             close ( OFFSET );

# Record the name offset file in GRP indirection file for use by CCDEDIT.
             print OFFLIST "$off_file\n";
          }
       }
    }
    close ( OFFLIST );

# Specify parameters for editing CCDPACK headers.
    $header = "in='^faolist.inlist$$' inlist=\'^$offlist\'";
    $hidden = "mode=alist"; 

# Associate the position-list files with the current object frames.
    $Mon{"ccdpack_reg"}->obeyw("ccdedit","$header $hidden");
    unlink( "faolist.inlist$$" );
