# _ESTIMATE_PSF_
#
# Estimates the PSF of a standard star.
#
# TASK: KAPPA - CENTROID, PSF, NDFTRACE, STATS
#
# Exports:
#    PSFNAME, Reference to @CENTRE, FWHM
#  
# This method acts on a reduced group.

# Determine whether it is time to do aperture photometry.
# We have to specify this since we have to decide whether we
# are using $Frm or $Grp and in general this routine is run
# on reduced images.
    my $do_aphot = $Frm->hdr( "DO_APHOT" );
    if ( $do_aphot ) {

# This should only be performed on OBJECT frames.
       if ( $Grp->hdr( "OBSTYPE" ) eq "OBJECT" ) {

# Declare variables.
          my ( $ORAC_STATUS, $header, $hidden );

# Run a task to obtain details of the frame.
          $header = "ndf=".$Grp->file;
          $Mon{"ndfpack_mon"}->obeyw("ndftrace", "$header");

# Extract the bounds of the frame.
          ( $ORAC_STATUS, my @lbnd ) = $Mon{"ndfpack_mon"}->get("ndftrace","lbound");
          ( $ORAC_STATUS, my @ubnd ) = $Mon{"ndfpack_mon"}->get("ndftrace","ubound");

# Find the mid points.
          my $xmid = nint( ( $lbnd[0] + $ubnd[0] ) / 2 );
          my $ymid = nint( ( $lbnd[1] + $ubnd[1] ) / 2 );

# Define the size of the box in arcseconds, and hence pixels. 
          my $boxsize = ( $_ESTIMATE_PSF_{BOXSIZE} || 5 );
          my $pixelscale = $Grp->hdr( "PIXELSIZ" );
          my $pixbox = nint( $boxsize / $pixelscale );
          my $ndfsect = $Grp->file."(~$pixbox,~$pixbox)";

# Locate the main object within a central box.
          $Mon{"kappa_mon"}->obeyw("stats", "$ndfsect");

# Extract the location of the maximum pixel bounds of the frame.
          ($ORAC_STATUS, my @maxpos) = $Mon{"kappa_mon"}->get("stats","maxpos");

# Shift the search box to be centred on the highest value within the 
# search box.
          $ndfsect = $Grp->file."($maxpos[0]~$pixbox,$maxpos[1]~$pixbox)";

# Specify the other parameters for the CENTROID stage.
          $header = "ndf=$ndfsect";
          $hidden = "mode=interface init=[$maxpos[0],$maxpos[1]] cosys=w"; 

# Find the centroid of the object.  For the moment start the search at
# the frame centre.  The standard position may be displaced from this,
# and should be written to the headers.
          $Mon{"kappa_mon"}->obeyw("centroid","$header $hidden");

# Store the located centroid within a text file of the format PSF expects.
# (There should be some rationalisation in KAPPA and CCDPACK to use
# Clive Davenhall's small tables.  In that case this would be altered.)
          ( $ORAC_STATUS, my @centre ) = $Mon{"kappa_mon"}->get("centroid","centre");

          open( PSFIN, ">centre$$.dat" );
          print PSFIN "@centre\n";
          close( PSFIN );

# Store the centre information for later use.
          $_ESTIMATE_PSF_{CENTRE} = \@centre;

# Assign the other parameters.
          my $psfname = ( $_ESTIMATE_PSF_{PSF} || "psf$$" );

# Specify the other parameters for the PSF stage.
          $header = "in=".$Grp->file." out=$psfname";
          $hidden = "cut=1E-20 device=! cofile=centre$$.dat";

# Calculate the psf, using the standard star alone.  Make an image of
# the psf, which goes to a very low signal.  It's needed to compute the
# light beyond the aperture.
          $Mon{"kappa_mon"}->obeyw("psf","$header $hidden");

# Obtain the average FWHM of the point-spread function and export it.
          ( $ORAC_STATUS, my $fwhm ) = $Mon{"kappa_mon"}->get("psf","fwhm");
          ( $ORAC_STATUS, my $axisratio ) = $Mon{"kappa_mon"}->get("psf","axisr");
          $_ESTIMATE_PSF_{FWHM} = $fwhm * sqrt( $axisratio );

# Store the PSF name in the primitives hash.
          $_ESTIMATE_PSF_{"PSFNAME"} = $psfname;

# Now we can remove the temporary ascii file
          unlink( "centre$$.dat" );

# Report the processing status.
          orac_print "Orac says: PSF of standard star in frame ".$Grp->file." determined\n";
       }
   }
