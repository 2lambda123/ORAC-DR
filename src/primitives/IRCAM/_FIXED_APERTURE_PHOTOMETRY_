# _FIXED_APERTURE_PHOTOMETRY_         -*- perl -*-
#
# Perform aperture photometry on a standard star.
#
# TASK: PHOTOM - AUTOPHOTOM
#
#    _FIND_SOURCE_CENTROID_:        CENTRE

# Input arguments recognised by this primitive:
#    SKYEST, ZP, INNER, OUTER

# Determine whether it is time to do aperture photometry.
# We have to specify this since we have to decide whether we
# are using $Frm or $Grp and in general this routine is run
# on reduced images.
    my $do_aphot = $Frm->hdr( "DO_APHOT" );
    if ( $do_aphot ) {

# This should only be performed on OBJECT frames.
       if ( $Frm->hdr( "OBSTYPE" ) eq "OBJECT" ) {
          my $incflag = "T";

# Define a useful variable for a null catalogue magnitude.
          my $nullmag = 99.999;

# Form new group
# ==============
#
# Create a temporary frame object.  Use the new method rather than
# new ORAC::Frame for generality (otherwise we would have to do
# new ORAC::Frame::UFTI for UFTI primitives and so on) to inherit
# from the current Frame.

# Set the file method for this frame.  $Grp->file is name of the main
# mosaic.  There's a bug/feature that requires a header to have been read
# in before it is accessed.  So cannot use file method to associate
# the group frame; do it with the new method.
          my $tmpFrm = $Frm->new( $Grp->file );

# Create a temporary group object as used by _FAO_.  Use the new method
# rather than new ORAC::Group for generality to inherit from the current
# group.
          my $phoGrp = $Grp->new;

# Push the members of the existing group into the temporary group.  Exclude
# any sky frames.
          my $targrp = $Grp->subgrp( TARGET_OR_SKY => "target" );
          $phoGrp->push( $targrp->members );

# Push the temporary frame into the temporary group.  Note that the
# Orac::Group class can contain anything.  However in ORAC-DR we want
# to stick with Frame objects for generality.  So now $reggrp is a
# group consisting of the current group members and group file.
          $phoGrp->push( $tmpFrm );

# Perform photometry for all the individual jitter frames and the final
# mosaic.
          my ( $catmag, $fs_magdif_ext, $magdif, $magdif_ext );
          foreach $Frm ( $phoGrp->members ) {

# Open the results file
# =====================

# Create log file if necessary.
             my $logfile = "aphot_results.txt";
             if ( ! -e $logfile ) {
                _MAKE_PHOTOMETRY_TABLE_ FILE=$logfile
             }

# Open the file for appending results.
             open ( LOGFILE, ">>$logfile" );

# Get information from the headers
# ================================

# Obtain the filter from the FITS headers.
             my $filter = $Frm->hdr( "FILTER" );

# Obtain the mean extinction coefficient.  Specify the corresponding catalogue
# column number for the filter.
             my ( $catcol, $extinction );
             SWITCH: {
                if ( $filter =~ /^J/ ) {
                   $extinction = 0.08; $catcol = 0; last SWITCH;
                }
                if ( $filter =~ /^H/ ) { 
                   $extinction = 0.03; $catcol = 1; last SWITCH;
                }
                if ( $filter =~ /^K/ ) {
                   $extinction = 0.07; $catcol = 2; last SWITCH;
                }
                $extinction = 0.0; $catcol = -1;
             }

# Obtain the airmass from the FITS headers.  Find the approximate
# mean airmass from the start and end values.  This should be
# adequate unless it is a long integration with the source crossing
# the meridian.
             my $amstart = $Frm->hdr( "AMSTART" );
             my $amend   = $Frm->hdr( "AMEND" );
             my $airmass = 0.5 * ( $amstart + $amend );

# Derive the extinction-correction using the IR standard of one airmass.
             my $extcor = ( $airmass - 1.0 ) * $extinction;

# Obtain the instrument name.
             if ( $Frm->hdr( "INSTRUME" ) =~ /^UFTI/ ) {

# Obtain the object name, exposure time, time of observation, the
# pixelscale, and the number of electrons per data number.
                my $exptime = $Frm->hdr( "EXP_TIME" );
                my $objname = $Frm->hdr( "OBJECT" );
                my $ut = $Frm->hdr( "UTSTART" );
                my $pixelscale = $Frm->hdr( "CDELT1" );
                my $padu =  $Frm->hdr( "GAIN" );

# Likewise from IRCAM and TUFTI equivalent headers.
             } else {
                my $exptime = $Frm->hdr( "DEXPTIME" );
                my $objname = $Frm->hdr( "OBJECT" );
                my $ut = $Frm->hdr( "RUTSTART" );
                my $pixelscale = $Frm->hdr( "PIXELSIZ" );
                my $padu =  $Frm->hdr( "DEPERDN" );
             }

# Extract the system magnitude of faint standards
# ===============================================

# Remove spaces from the name, and convert to uppercase for later
# comparison.
             ( my $starname = uc( $objname ) ) =~ s/ //g;

# Faint standards have name FSn, where n is the number.  Only JHK
# magnitudes are tabulated.
             if ( $catcol > -1 ) {
                my $fs_standards;

# Open the faint-standards file and store its records in an array.
                if (  -e "/ukirt_sw/ircamdr/fs99.dat" ) {
                   $fs_standards = "/ukirt_sw/ircamdr/fs99.dat";
                } else {
                   $fs_standards = "fs99.dat";
                }
                open( FS_STANDARDS, "<$fs_standards" ) || 
                      die "JHK Standards file not found";
                my @stds = <FS_STANDARDS>;

# Remove trailing blanks and newline.
                for ( @stds ) {
                   chomp;
                   s/\s+$//;
                }

# Search through the table finding a line containing the object name.  The
# file currently consists of some column headings, then a relational table.
# Columns in the table include the star name, K magnitudes, (J-H) and (H-K)
# colours.

# Look at each line.  Extract the name, stripping the blanks.  Proceed
# until an uppercase match is found.
                my $recno = 1;
                my $name = " ";
                until ( uc( $name ) eq $starname || $recno > $#stds ) {
                   $recno++;
                   $name = substr( $stds[ $recno ], 0, 9 );
                   $name =~ s/ //g;
                }

# Check that a match has been found.  Use a special value to indicate
# a null magnitude.
                if ( $recno > $#stds ) {
                   orac_warn "Standard $objname has no tabulated JHK magnitudes in $fs_standards\n";
                   $catmag = $nullmag;
                } else {

# Extract the columns.
                   my @fields = split( / +/, $stds[ $recno ] );

# Extract and evaluate the magnitudes from the colours.  This could be done
# more succinctly, but use more friendly intermediate variables.
                   my $Kmag = $fields[ 7 ];
                   my $Hmag = $Kmag + $fields[ 13 ];
                   my $Jmag = $Hmag + $fields[ 10 ];
                   my @mags = ( $Jmag, $Hmag, $Kmag );

# Obtain the desired magnitude.
                   $catmag = $mags[ $catcol ];
                }

# Close the stamdards data file.
                close( FS_STANDARDS );

             } else {
                $catmag = $nullmag;
             }

# Find location and dimensions of the aperture and annulus
# ========================================================

# Locate the image centre.
             _FIND_SOURCE_CENTROID_
             my $centre = $_FIND_SOURCE_CENTROID_{CENTRE};

# Obtain the aperture diameter in arcseconds.
             my $as_aperture = ( $_FIXED_APERTURE_PHOTOMETRY_{APERTURE} || 6 );
 
# Calculate the radius of the inner and outer extent of the aperture.
             my $inner = ( $_FIXED_APERTURE_PHOTOMETRY_{INNER} || 1.5 );
             my $outer = ( $_FIXED_APERTURE_PHOTOMETRY_{OUTER} || 2.5 );
             $inner = min( 3.0, max( $inner, 1.2 ) );
             $outer = min( 5.0, max( $inner + 0.3, $outer, 1.5 ) );

# Automatic photometry
# ====================
#
# The automatic photometry task needs a text file to control the
# type and location of the photometry, and the size and shape of the
# aperture.  In this primitive these are fixed except the size, but
# we could use parameters for these in a hierarchy of scripts.  We have a
# circular aperture obtaining the sky from an annulus between the INNER
# and OUTER times the diameter of the main aperture.
             my $rapture = 0.5 * $as_aperture / $pixelscale;
             open ( PHOTOM, ">photom$$.dat" );
             print PHOTOM "#ANN 1 $inner $outer\n";
             print PHOTOM "1 @$centre 0.0 0.0 0.0 0.0 OK $rapture 0.0 0.0 annulus circle\n";
             close ( PHOTOM );

# Specify the user parameters.
             my $skyest = ( $_FIXED_APERTURE_PHOTOMETRY_{SKY_EST} || "3" );
             my $zp = 0.0;
             my $user = "skyest=$skyest skymag=$zp";
 
# Specify the other parameters for AUTOPHOTOM.  Strictly we should check the
# headers for the readout mode
             my $header = "in=".$Frm->file." infile=photom$$.dat outfile=photom$$.res";
             my $hidden = "nocentro padu=$padu biasle=0 photon=2 positive sature=12000 nousemask";

# Perform the photometry, however, for this case compute a centroid
# about which to integrate.
             $Mon{"photom_mon"}->obeyw("autophotom","$header $user $hidden");

# Extract and present the results.
# ================================
#
# The magnitude and error are the fourth and fifth fields in the output
# file.  The sky estimate is the sixth.  The error code is the eighth.
             open ( PHOTOM, "photom$$.res" );
             my @results = map { (split)[3..7] } <PHOTOM>;
             close ( PHOTOM );

# Use more lucid variable names for the results.  Normalise by the
# exposure time.  The magnitude returned by AUTOPHOTOM is calculated
# using the expression -2.5log10( photons/s ).  However, the UKIRT
# standard is to use -2.5log10( counts/s ), so correct the instrumental
# magnitude by the ADU factor, and convert the sky level back to counts.
             my $magnorm = $results[0] + 2.5 * log10( $exptime * $padu );
             my $magerr = $results[1];
             my $sky_level = $results[2] / $padu;
             my $errcode = $results[4];

# Correct for the mean extinction.
             my $magext = $magnorm - $extcor;

# Convert annulus radii into arcseconds.
             $inner = $inner * $as_aperture;
             $outer = $outer * $as_aperture;

# Format the results to give a sensible number of significant figures.
             my ( $fs_mag, $fs_sky, $fs_airmass, $fs_apdiam, $fs_inner, $fs_outer );
             $fs_mag = sprintf( "%7.3f", $magnorm );
             $fs_mag =~ s/ //g;
             $fs_sky = sprintf( "%9.3f", $sky_level );
             $fs_sky =~ s/ //g;
             $fs_airmass = sprintf( "%6.4f", $extcor );
             $fs_apdiam = sprintf( "%5.2f", $as_aperture );
             $fs_apdiam =~ s/ //g;
             $fs_inner =  sprintf( "%5.2f", $inner );
             $fs_inner =~ s/ //g;
             $fs_outer =  sprintf( "%5.2f", $outer );
             $fs_outer =~ s/ //g;

             if ( $catmag < $nullmag ) {
                $magdif = $catmag - $magnorm;
                $magdif_ext = $catmag - $magext;
                $fs_magdif_ext =  sprintf( "%6.3f", $magdif_ext );
             }

# Print the results.
             orac_print "\n";
             orac_print "Frame:                  ".$Frm->file."\n";
             orac_print "Filter:                 $filter\n";
             if ( $errcode ne "OK" ) {
                orac_print "Instrumental Magnitude: $fs_mag +/- $magerr (error $errcode)\n";
             } else {
                orac_print "Instrumental Magnitude: $fs_mag +/- $magerr\n";
             }
             orac_print "Airmass correction:     $fs_airmass\n";
             if ( $catmag < $nullmag ) {
                orac_print "Catalogue Magnitude:    $catmag\n";
                orac_print "Calculated zeropoint:   $fs_magdif_ext\n"
             }
             orac_print "Sky:                    $fs_sky\n";
             orac_print "Aperture diameter:      $fs_apdiam arcsec\n";
             orac_print "Annulus radii:          $fs_inner to $fs_outer arcsec\n";
             orac_print "\n";

# Remove the photometry text file.
             unlink( "photom$$.res" );

# Write the results for the current observation to the logfile.  Use sprintf
# to format the statistics in the specified formats for the columns of
# the table.  Append the formatted row to the logging file.  Note in case
# some of the header information is null, output the results as strings
# rather than integer or real; and assume a fixed format in the FITS headers
# matching the STL format when the keywords are present.
             printf LOGFILE ( "%19s %12s %8.5f %7s %5.3f %7.3f %7.3f %6.3f %2s %5.1f".
                              "%5.1f %5.1f %8.2f %1s %6.3f %6.3f %6.3f \n",
             $Frm->file, $objname, $ut, $filter, $airmass, $magnorm,
             $magext, $magerr, $errcode, $as_aperture, $inner, $outer,
             $sky_level, $incflag, $catmag, $magdif, $magdif_ext );

          };

# Close the results file.
          close ( LOGFILE );
       }
    }
