# _GENERATE_OFFSETS_JITTER_       -*- perl -*-
#
# Function:
#    Find the offsets between the frames in a JITTER_SELF_FLAT recipes.
#
# Primitives Called:
#    _GENERATE_OFFSETS_, _TELE_OFFSETS_
#
# Arguments:
#    COMPLETE = REAL (Given)
#       Completeness of matched features for registration between two
#       frames to be accepted.  It must be in the range 0.2 to 1.0. [0.4]
#    MINPIX = INTEGER (Given)
#       Minimum number of contiguous pixels above the PERCENTILE level
#       to be considered a registration feature.  It must be at least 6.
#       [6]
#    MOVING_TARGET = LOGICAL (Read)
#       If TRUE (1), the source is a moving target and frames are to
#       register the moving target not the fixed stars.  [0]
#    PERCENTILE = REAL (Given)
#       Percentile threshold for locating objects to register frames. 
#       It must be in the range 75 to 99.9. [96]
#    TELEOFF = LOGICAL (Given)
#       If true (1), it will just use the telescope offsets to register.
#       If false (0), it will attempt automatic registration.

# Arguments
# =========

# Determine whether or not telescope offsets should only be used.
    my $usetele = $_GENERATE_OFFSETS_JITTER_{TELEOFF};
    $usetele = defined( $usetele ) ? $usetele : 0;

# Obtain the parameters for the detection.
    my ( $complete, $minpix, $percentile );
    if ( ! $usetele ) {
       $percentile = ( $_GENERATE_OFFSETS_JITTER_{PERCENTILE} || 96 );
       $minpix = ( $_GENERATE_OFFSETS_JITTER_{MINPIX} || 6 );
       $complete = ( $_GENERATE_OFFSETS_JITTER_{COMPLETE} || 0.4 );
    }

# Is there a moving target?
    my $moving_target = $_GENERATE_OFFSETS_JITTER_{MOVING_TARGET};
    $moving_target = defined( $moving_target ) ? $moving_target : 0;

# Selection
# =========

# This should only be performed on OBJECT frames.
    if ( $Frm->hdr( "OBSTYPE" ) eq "OBJECT" ||
         $Frm->hdr( "OBSTYPE" ) eq "SKY" ) {

# Test whether or not it is time to make a mosaic.
       my $makemos = $Frm->hdr( "MAKE_MOSAIC" );
       if ( $makemos ) {

# Obtain the cycle number from the header.
          my $cycleno = $Frm->hdr( "CYCLE_NUMBER" );
          if ( ! $cycleno ) {
             $cycleno = 0;
          }

# Select those members in the current cycle.
          my $cycleGrp = $Grp->subgrp( CYCLE_NUMBER => $cycleno );

# Form the group to process.
# ==========================

# For the first cycle of a single cycle mosaic, make a local $Grp
# containing just the current cycle.  Note the { to start a new context.
          my $tempGrp;
          if ( $cycleno == 0 ) {
             $tempGrp = $cycleGrp;

# For a moving target we want to register to the first frame, because
# it is the reference frame for the moving target.  The motions are
# calculated with respect to its time of observation.  We do not
# register to the co-added mosaic (as happens for stationary sources)
# or even the first cycle mosaic, because the fiducial stars are
# extended and thus shifts the centroid of the sources.  There is no
# guarantee that telscope offsets will be used.  The mosaic stellar
# images are also possibly multiple, which can confuse the registration. 
          } elsif ( $moving_target ) {
             $tempGrp = new $Grp;
             $tempGrp->push( $Grp->frame(0) );
             $tempGrp->push( $cycleGrp->members );
 
# On later cycles a mosaic file should exist, and we shall to register
# with that as the reference frame.  So place the file into a temporary
# frame pushed onto a temporary $Grp-like group.  Then append the members
# of the subgroup.  
          } else {
             my $tempFrm = new $Frm( $Grp->file );
             $tempGrp = new $Grp;
             $tempGrp->push( $tempFrm );
             $tempGrp->push( $cycleGrp->members );
          }

# Telescope offsets
# =================
          if ( $usetele ) {

# Make a local $Grp.
             my $Grp = $tempGrp;

# Form a list of input file names for CCDPACK tasks.
             my @objects = $Grp->membernames;

# Convert list to comma-separated list.
             my $objlist = join( ",", @objects );

# Create text file to hold the list of input files, one per line.  This
# is needed because expanded lists of files may make the command line too
# long for the ADAM message system.
             unlink( "objlist.inlist$$" );
             open( INLIST, ">objlist.inlist$$" );
             print INLIST join( "\n", @objects ), "\n";
             close( INLIST );

# Use telescope offsets from the headers.
             _TELE_OFFSETS_ MOVING_TARGET=$moving_target

# Register
# ========

# Specify the other parameters for the REGISTER stage.
             my $header = "inlist='^objlist.inlist$$'";
             my $hidden = "fittype=1"; 

# Register the frames using a shift of origin.  Create the CCDPACK
# TRANSFORM extensions.
             $Mon{"ccdpack_reg"}->obeyw("register","$header $hidden accept");
             unlink( "objlist.inlist$$" );

# Report processing status.
             orac_print "Orac says: frames $objlist registered\n";

# Attempt automatic registration
# ==============================
          } else {

# Generate the offsets
# ====================

# Call the generic primitive which does most of the work.  Use central
# source as a backup.  Use the reference mosaic's co-ordinate system so ensure
# that central-source offsets are with respect to that, if the 
# CENTRAL_SOURCE flag is switched.
             my $Grp = $tempGrp;
             _GENERATE_OFFSETS_ PERCENTILE=$percentile MINPIX=$minpix COMPLETE=$complete CENTRAL_SOURCE=FALSE MOVING_TARGET=$moving_target

# End of scope of local $Grp aka $tempGrp.
          }
       }
    }
