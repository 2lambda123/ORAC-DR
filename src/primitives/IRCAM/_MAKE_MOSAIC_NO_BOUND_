# _MAKE_MOSAIC_NO_BOUND_     -*- perl -*-
#
# Forms a mosaic, not constraining the bounds of the created mosaic.
#
# TASK: KAPPA - TRANJOIN; CCDPACK - TRANLIST, MAKEMOS
#

# Arguments
# =========

# Obtain the value for the interpolation.
    my $intmethod = ( $_MAKE_MOSAIC_NO_BOUND_{INT_METHOD} || "linint" );

# Determine whether or not to fill bad pixels.
    my $fillbad = $_MAKE_MOSAIC_NO_BOUND_{FILLBAD};
    $fillbad = defined( $fillbad ) ? $fillbad : 1;

# Determine whether or not to resample.
    my $resample = $_MAKE_MOSAIC_NO_BOUND_{RESAMPLE};
    $resample = defined( $resample ) ? $resample : 1;

# Selection
# =========

# This should only be performed on OBJECT frames.
    if ( $Frm->hdr( "OBSTYPE" ) eq "OBJECT" ||
         $Frm->hdr( "OBSTYPE" ) eq "SKY") {

# Test whether or not it is time to make a mosaic.
       my $makemos = $Frm->hdr( "MAKE_MOSAIC" );
       if ( $makemos ) {

# Obtain the cycle number.  Default to zero if undefined, so that recipes
# which do not support this feature will continue to work.
          my $cycleno = $Frm->hdr( "CYCLE_NUMBER" );
          $cycleno = defined( $cycleno ) ? $cycleno : 0;

# Obtain the cycle period.  Default to 9 if undefined, so that recipes
# which do not support this feature will continue to work.  This assumes
# that nine is the maximum number of jitters.
          my $period = $Frm->hdr( "JITTER_NUMBER" || 9 );

# Select those members in the current cycle.
          my $cycleGrp = $Grp->subgrp( CYCLE_NUMBER => $cycleno );

# Specify the mosaic suffix.
          my $osuffix = "_mos";

# Form a list of input file names for the CCDPACK tasks.  We need to
# generate an input list for TRANJOIN and TRANNDF and an output list
# using a hard-wired suffix of "_trn".
          ( my $inref, my $outref ) = $cycleGrp->inout( "_trn" );

# Convert the list to a comma-separated list as needed by CCDPACK (GRP).
          my $objlist = join( ",", @$inref );
          my $outlist= join( ",", @$outref );

# Concatenate rotation to transformation
# ======================================
          my ( $header, $hidden );
          if ( $resample ) {

# Specify the other parameters for the TRANJOIN stage.
#             my ( $header, $hidden );
#             $hidden = "in2=".$Cal->rotation." dest=first"; 

# Join the rotation transformation to each of the CCDPACK extensions.
# The rotation transformation follows the shift-of-origin and is stored
# in the '_ff' frame.  Unfortunately, CCDEDIT doesn't support joining
# transformations, and KAPPA/TRANJOIN does operate on lists of files.
# Write the input file names to the text files.
#             foreach $flatted (@$inref) {
#                $header = "in1=${flatted}.more.ccdpack.transform";
#                $Mon{"kappa_mon"}->obeyw("tranjoin","$header $hidden accept");
#             }

# Report the status.
#             orac_print "Orac says: Rotation transformation joined\n";

# Resampling
# ==========

# Create text files to hold the list of input and output files, one per line.
# This is needed because expanded lists of files may make the command line
# too long for the ADAM message system.
             unlink ("tranndf.inlist$$", "tranndf.outlist$$");

             open( INLIST, ">tranndf.inlist$$" );
             print INLIST join( "\n", @$inref ), "\n";
             close( INLIST );

             open( OUTLIST, ">tranndf.outlist$$" );
             print OUTLIST join( "\n", @$outref ), "\n";
             close( OUTLIST );

# Assign the other parameters.  Use the original bounds.
             $header = "in='^tranndf.inlist$$' out='^tranndf.outlist$$'";
             $hidden = "shape=auto method=linint title=!";

# Shift and resample the flat-field object frames.  This determines
# the bounds automatically.  It takes the origin from the first object
# frame.
             $Mon{"ccdpack_reg"}->obeyw("tranndf","$header $hidden");

# Report the processing status.
             orac_print "Orac says: Frames $objlist resampled\n";

          } else {

# Derive the offsets
# ==================

# Open the offset files and store the co-ordinates.  Note that this
# assumes central-source or telescope offsets have been used, and that there
# is but one position in each.
             my @xoffsets = ();
             my @yoffsets = ();
             foreach my $Frame ( $cycleGrp->members ) {
                my $offfile = $Frame->file . ".off";

                if ( ! -e $offfile ) {
                   orac_err "Missing $offfile offset text file.\n";
                }
                open( OFFFILE, "<$offfile" );

# Store the offsets.
                my $offfound = 0;
                foreach my $line ( <OFFFILE> ) {

# Match 1 followed by a space in case there are more than nine
# objects, unlikely but possible.
                   my @fields;
                   if ( $line =~ /^1\s/ ) {
                      @fields = split( /\s+/, $line );
                      push( @xoffsets, $fields[1] );
                      push( @yoffsets, $fields[2] );
                      $offfound = 1 ;
                      last;
                   }
                }
                close( OFFFILE );

# Cannot proceed unless the x-y offsets were found.
                if ( ! $offfound ) {
                   orac_err "No object #1 in $offfile offset text file.\n";
                }
             }

# Convert the offsets to be displacements of the origin to the nearest pixel.
             my $framecount = 0;
             foreach my $frame ( @xoffsets ) {
                $xoffsets[$framecount] = -int( $xoffsets[$framecount] + 0.5 );
                $yoffsets[$framecount] = -int( $yoffsets[$framecount] + 0.5 );
                $framecount++;
             }

# Change of origin
# ================

# Loop through all the members of the group, as KAPPA task can only handle
# one data file at a time.
             foreach my $Frame ( $cycleGrp->members ) {
                my $frame = $Frame->file;

# Assign the other parameters.  Use the original bounds.  Note we do not
# resample the main mosaic if one exists.
                $header = "ndf=$frame origin=[$xoffsets[0],$yoffsets[0]]";

# Shift the first item from the lists of displacements.
                shift( @xoffsets );
                shift( @yoffsets );

# Apply change of origin to the current frame.
                $Mon{"ndfpack_mon"}->obeyw("setorigin","$header");
             }

# Create text files to hold the list of 'output' files, one per line.
# The files are modified in situ, but are the equivalent of the output files
# if resampling is performed.  This is needed because the command may be long
# for a four-cycle quadrant jitter.  Expanded lists of files may make the
# command line too long for the ADAM message system.
             unlink( "tranndf.outlist$$" );

             open( INLIST, ">tranndf.outlist$$");
             print INLIST join( "\n", @$inref ), "\n";
             close( INLIST );

# Report the processing status.
             orac_print "Orac says: Frames $objlist have origin shifted.\n";
          } 

# Make mosaic.
# ============

# Derive a reasonable number of overlaps.  The default is only three
# but with 9-point jitters it could be as high as 8 for the central
# region.  As non-overlaps will not be included, it's probably better to
# err on the high side.  So here we've assumed that all the jittered
# frames could overlap.
          my $optov = $period - 1;

# Define the mosaic name.
          my ( $grproot, $outname );
          if ( $cycleno == 0 ) {
             $grproot = $Grp->file;

          } else {
             $grproot = $Grp->hdr( "ROOT_NAME" );
          }
          $outname = $grproot . "_mu"; 

# Assign other parameters.
          $header = "in='^tranndf.outlist$$' out=$outname title=!";
          $hidden = "zero optov=$optov";

# Make the mosaic correcting for differences in offset.
          $Mon{"ccdpack_reg"}->obeyw("makemos","$header $hidden");
          unlink( "tranndf.inlist$$", "tranndf.outlist$$" );

# Report the processing status.
          orac_print "Orac says: mosaic $outname formed\n";

# Remove bad pixels
# =================

# Bad pixels can accumulate as the mosaics are co-added.  Thus they may
# need to be removed.

# Assign parameters.  We should presumably set the Grp output name
# when we construct $mosname.  Do not change the output name if we have
# already appended the output suffix the previous time around.
# The first cycle mosaic becomes the main mosaic.  Subsequent mosaics of
# four are co-add (after registration) into the main mosaic, hence these
# require a different name.
          my $mosname = $Grp->file . $osuffix unless $Grp->file =~ /$osuffix$/;
          if ( $cycleno > 0 ) {
             $mosname = $Grp->file . "_" . $cycleno;
           }

# Only fill bad pixels when requested.
          if ( $fillbad ) {

# Fill in the bad pixels.
             $header = "in=$outname out=$mosname niter=4 size=4";
             $Mon{ "kappa_mon" }->obeyw( "fillbad", "$header" );

# Report the processing status.
             orac_print "Orac says: Bad pixels filled in mosaic $outname to form $mosname\n";

# Discard the intermediate group file.
             _DELETE_A_FRAME_ FRAME=$outname

# We need to keep the names matching so make a copy of mosaic containing
# bad pixels.
          } else {
             $header = "in=$outname out=$mosname";
             $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$header" );
          }


# Set the group name in the Group object...
          my $mosaic_origin;
          if ( $cycleno == 0 ) {
             $Grp->file( $mosname );

# ...and read the header.
             $Grp->readhdr;

# Store the root name.
             $Grp->hdr( "ROOT_NAME", $grproot );

# Obtain its bounds, and hence an NDF origin string.
#             $Mon{ "ndfpack_mon" }->obeyw( "ndftrace", "ndf=$mosname" );
              my $ORAC_STATUS;
#             ( $ORAC_STATUS, @mosaic_lbnd ) = $Mon{"ndfpack_mon"}->get("ndftrace","lbound");
#             $mosaic_origin = join( ",", @mosaic_lbnd );
          }

# Display the resultant mosaic.
          _DISPLAY_GROUP_IMAGE_

# On the second and subsequent cycle, we just need to co-add the
# single-cycle mosaic into the main mosaic.
          if ( $cycleno > 0 ) {

# Make a duplicate of the main mosaic.
             my $tmpmos = "mainmos$$";
             $header = "in=" . $Grp->file . " out=$tmpmos";
             $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$header" );

# Change the bounds of the new mosaic to match that of the grand mosaic.
#             $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "ndf=$mosname origin=[$mosaic_origin]" );

# Co-add the frames.
             $header = "in1=$tmpmos in2=$mosname out=" . $Grp->file;
             $Mon{ "kappa_mon" }->obeyw( "add", "$header" );

# Remove the temporary copy unless its the first.  This leaves the
# mosaics for each and every individual jitter to be examined later.
             if ( $cycleno > 1 ) {
                _DELETE_A_FRAME_ FRAME=$tmpmos
             } else {
                $header = "in=$tmpmos out=" . $Grp->file . "_0";
                $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$header" );
             }

             orac_print "Orac says: Frame $mosname co-added into main mosaic " . $Grp->file . "\n";

# Display the main mosaic.
             _DISPLAY_GROUP_IMAGE_
          }
       }
    }
