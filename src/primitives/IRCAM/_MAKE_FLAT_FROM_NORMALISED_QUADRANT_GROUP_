# _MAKE_FLAT_FROM_NORMALISED_QUADRANT_GROUP_    -*- perl -*-
#
# Forms a flat-field from a group of object frames.  Each member of the
# group is expected to be masked in the quadrant containing the major
# source, and be normalised to one of the frames.  The primitive uses
# a median to combine pre-normalised frames pixel by pixel.
#
# TASK: CCDPACK - MAKECAL, KAPPA - CDIV, KAPPA - STATS
#

# Selection
# =========

# This should only be performed on OBJECT frames.
    if ( $Frm->hdr( "OBSTYPE" ) eq "OBJECT" ||
         $Frm->hdr( "OBSTYPE" ) eq "SKY" ) {

# Test whether or not it is time to make a flat.
       $makeflat = $Frm->hdr( "MAKE_FLAT" );
       if ( $makeflat ) {

# Form a list of input file names for MAKECAL from the other members
# of the group.  This is not as obvious as it sounds since we are
# trying to do this by looking at the current file values for each
# Frame object in the loop.  First time around everything is fine.
# Second time around we realise that the previous frames now have the
# wrong names since they have been flat-fielded etc.  We now have to
# construct the input names from the template.  The template is the
# current frame name.
          $Grp->template($Frm->file);

# Make lists of files to process
# ==============================

# Form a list of input file names for CCDPACK tasks.  Set up the object
# list assuming that everything in the Group members list contains the
# file pointer to pre-flatfielded data.
          @objects = $Grp->membernames;
          $objlist = join(",", @objects);

# Create text file to hold the list of input files, one per line.  This
# is needed because expanded lists of files may make the command line too
# long for the ADAM message system.
          unlink ("objlist.inlist$$");
          open (INLIST, ">objlist.inlist$$");
          print INLIST join( "\n", @objects ), "\n";
          close (INLIST);

# Make a flat which is not normalised
# ===================================

# Assign the other parameters.  Note that output flat is hardwired for
# the moment.
          $uflat = $Grp->name."_uflat";
          $header = "in='^objlist.inlist$$' out=$uflat";
          $hidden = "sigmas=2.0 expose=1 reset accept"; 
          $user = "method=median";

# Median filter the intra-normalised and quadrant-masked frames to produce
# an un-normalised flatfield.
          $Mon{"ccdpack_red"}->obeyw("makecal","$header $user $hidden");
          unlink ("objlist.inlist$$");

# Normalise the flat
# ==================

# Obtain the mean of the combined frame.
          $Mon{"kappa_mon"}->obeyw("stats","ndf=$uflat");

# Extract the mean of the frame.
          ($ORAC_STATUS, $mean) = $Mon{"kappa_mon"}->get("stats","mean");

# Get the cycle number.  Supply a default for recipes not supporting
# this yet.
          my $cycleno = ( $Frm->hdr( "CYCLE_NUMBER" ) || 0 );

# Generate the output flat name. Note that output flat is hardwired for the
# moment.
          if ( $ cycleno > 0 ) {
             $out = $Grp->name.'_flat_'.$cycleno;
          } else {
             $out = $Grp->name.'_flat';
          }

# Assign the parameters.
          $header = "in=$uflat out=$out scalar=$mean title=\'Flat field\'";

# Normalise the flat field to have a mean of one.  Remove the temporary not-normalised
# flat.
          $Mon{"kappa_mon"}->obeyw("cdiv","$header");
          _DELETE_A_FRAME FRAME=$uflat

# Record and display the flat
# ===========================

# Set the current flat in the calibration object.
          _FILE_FLAT_ NAME=$out
     
# Report the status of the processing.
          orac_print "Orac says: frames $objlist used for flat\n";

# Display the image.
          _DISPLAY_FLAT_IMAGE_

       };
    };
