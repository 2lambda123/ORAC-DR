# _DIVIDE_BY_FLAT_FROM_EXTENDED_         -*- perl -*-
#
# Divides by a flat-field for extended sources.
#
# TASK: CCDPACK - FLATCOR
#
# This should only be performed on OBJECT frames.
    if ($Frm->hdr(OBSTYPE) =~ /OBJECT/ || $Frm->hdr(OBSTYPE) =~ /SKY/) {

# Obtain the cycle frequency of skies.  A value of 2 means the object and
# sky frames alternate.
       $cycle = $Frm->hdr( "SKY_FREQ" );
       
# Test whether or not this is an object frame or a sky frame. 
       $class = $Frm->hdr( "TARGET_OR_SKY" );

# Need to record the last target frame, so we can use as a template.
       if ( $class =~ /target/ ) { $template = $Frm->file; }

# Here we want to apply the flat field when a new flat has been calculated,
# provided that there are at least three blank-sky frames.  Thus the current
# frame must be a sky.
       if ( $class =~ /sky/ && ($Grp->num + 1) >= 3 * $cycle ) {

# Form a subgroup comprising the target frames.
          $targrp = $Grp->subgrp( TARGET_OR_SKY => "target" );
          $numfiles = $targrp->num + 1;

# Form a list of input file names for MAKECAL from the other members
# of the group.  This is not as obvious as it sounds since we are
# trying to do this by looking at the current file values for each
# Frame object in the loop.  First time around everything is fine.
# Second time around we realise that the previous frames now have the
# wrong names since they have been flat-fielded etc.  We now have to
# construct the input names from the template.  The template is the
# current frame name.
          $targrp->template($template);

# Form a list of the input and ouptut target file names for CCDPACK tasks.
          ( $inref, $outref ) = $targrp->inout( "_ff" );

# Convert arrays to comma-separated lists.
          $inlist = join(",", @$inref);
          $outlist= join(",", @$outref);

# Create text files to hold the list of input and output files, one per
# line.  This is needed because expanded lists of files may make the
# command line too long for the ADAM message system.
          unlink ("flatcor.inlist", "flatcor.outlist");
          open (INLIST, ">flatcor.inlist");
          open (OUTLIST, ">flatcor.outlist");
          for ( $i = 0; $i < $numfiles; $i++ ) {
             print INLIST @$inref[$i],"\n";
             print OUTLIST @$outref[$i],"\n";
          }
          close (INLIST);
          close (OUTLIST);

# Set the parameters for the task.
          $header = "in=\'^flatcor.inlist\' flat=".$Cal->flat." out=\'^flatcor.outlist\'";
          $hidden = "title=\'Flat-fielded\'";

# Flatfield all the object frames.  Generate output names from the
# input list, switching filename suffices.
          $ORAC_STATUS = $Mon{"ccdpack_red"}->control('par_reset');
          $Mon{"ccdpack_red"}->obeyw("flatcor","$header $hidden");
          unlink ("flatcor.inlist", "flatcor.outlist");

# Report the processing status.
          orac_print "Orac says: frames $inlist flat-fielded\n";

# Now update the output filenames for each member of the group.  This
# is fine until we come round again and find that we are trying to
# flat-field files that were flatfielded last time.  It is up to the
# _MAKE_FLAT_FROM_NORMALISED_EXTENDED_ primitive to work out which
# files are meant to be used for input here.
          $targrp->membernames(@$outref);

       };
    };
