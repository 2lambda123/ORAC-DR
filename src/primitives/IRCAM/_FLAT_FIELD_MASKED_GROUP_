#+
# Name:
#    _FLAT_FIELD_MASKED_GROUP_
#
# Purpose:
#    Self-flat fields a group of frames.
#
# Language:
#    Perl5
#
# Description:
#    This primitive creates and applies self-flat field for the current
#    group of frames.  It makes a flat from the group and then divides
#    the group members by that flat field.  There is also optional
#    object masking to make an improved flat; objects in the flattened
#    frames are detected above brightness and size thresholds, and the
#    frames combined to make a new flat field.  The improved flat is 
#    then applied to the original input group.  Four other primitives
#    do most of the work.
#
# Notes:
#    -  This primitive is suitable for both UFTI and IRCAM.
#    -  Processing only occurs for object and sky frames.
#    -  The steering header JITTER_NUMBER defines the number of
#    frames in a cycle.
#
# Arguments:
#    MASK = LOGICAL (Given)
#       Perform object masking only if it is true.
#
# Output Data:
#    None.  However, the invoked primitives _MAKE_FLAT_FROM_GROUP_,
#    _DIVIDE_BY_FLAT_FROM_GROUP_, _MAKE_OBJECTS_MASK_, and
#    _MASK_OBJECTS_ do create new frames.  The bottom line is that
#    a flat field frame is filed and indexed, and there are
#    flat-fielded frames each inheriting the corresponding input
#    frame's name but with an _ff suffix.  Various intermediate
#    frames are normally removed by a tidy primitive.
#
# Authors:
#    MJC: Malcolm J. Currie (JAC)
#
#-
#  

# Determine whether or not to mask objects.
    my $mask_obj;
    if ( defined $_FLAT_FIELD_MASKED_GROUP_{MASK} ) {
       $mask_obj = $_FLAT_FIELD_MASKED_GROUP_{MASK};
    } else {
       $mask_obj = 1;
    }

# Create a group based upon the current frame name.
    $Grp->template( $Frm->file );

# Record the group identifier.
    my $mainGrp = $Grp;

# Obtain the number of frames in the jitter or cycle.  Nine is the expected
# maximum number.
    my $period = ( $Frm->hdr( "JITTER_NUMBER" ) || 9 );

# Specify the cycle number.
    my $cycleno = int( $Grp->num / $period );

# Extract from the main group those frames belonging to this group.
    my $cycleGrp = $Grp->subgrp( CYCLE_NUMBER => $cycleno );

# Make this the main group for the moment.
    $Grp = $cycleGrp;

# Record the group members at this point.
    my @sky_names = $Grp->membernames;

# Make a first pass at a flat using the jittered frames of the group.
    _MAKE_FLAT_FROM_GROUP_

# Reset the group names to be the ones to flat field.
    $Grp->membernames( @sky_names );

# Apply the flat field.
    _DIVIDE_BY_FLAT_FROM_GROUP_

# Test whether or not it is time to mask objects.  Use global
# argument first, then frame by frame.
    if ( $mask_obj ) {
       my $maskobjects = $Frm->hdr( "MASK_OBJECTS" );
       my ( @maskfiles, @masked_names, $maskfile, $file );
       if ( $maskobjects ) {

# Create an array to store the names of the mask files. 
          @maskfiles = ();

# Compute a mask of the objects for each member of the flat-field
# group, using a local $Frm.
          foreach $Frm ( $Grp->members ) {
             _MAKE_OBJECTS_MASK_

# Record the mask filename into an array.
             push (@maskfiles, $_MAKE_OBJECTS_MASK_{MASKFILE});
          }

# Create an array to store the names of the masked datasets. 
          @masked_names = ();

# Mask the objects in each frame.  Make a copy of the @sky_names
# so we can shift its elements.  Again use a local $Frm.
          my @local_sky_names = @sky_names;
          foreach $Frm ( $Grp->members ) {
             $file = shift( @local_sky_names );
             $maskfile = shift( @maskfiles );
             $Frm->file( $file );
             _MASK_OBJECTS_ MASKFILE=$maskfile

# Record the masked (or unmasked file if the masking has failed)
# filename into an array.
             push ( @masked_names, $Frm->file );
          }

# Set the group names to be the masked ones to form improved flat field.
          $Grp->membernames( @masked_names );

# Generate the new flat field using the jittered masked frames.
          _MAKE_FLAT_FROM_GROUP_ 

# Reset the group names to be the ones to flat field.
          $Grp->membernames( @sky_names );

# Apply the better flat field.
          _DIVIDE_BY_FLAT_FROM_GROUP_
       }
    }

# Restore the original group.
    $Grp = $mainGrp;
    $Grp->template( $Frm->file );

# Podule
# ======

=head1 NAME

FLAT_FIELD_MASKED_GROUP -- Self-flat fields a group of frames.

=head1 DESCRIPTION

This primitive creates and applies self-flat field for the current
group of frames.  It makes a flat from the group and then divides
the group members by that flat field.  There is also optional
object masking to make an improved flat; objects in the flattened
frames are detected above brightness and size thresholds, and the
frames combined to make a new flat field.  The improved flat is 
then applied to the original input group.  Four other primitives
do most of the work.

=head1 NOTES

=over 4

=item *

This primitive is suitable for both UFTI and IRCAM.

=item *

Processing only occurs for object and sky frames.

=item *

The steering header JITTER_NUMBER defines the number of
frames in a cycle.

=back

=head1 ARGUMENTS

=over 4

=item MASK = LOGICAL (Given)

Perform object masking only if it is true.

=back

=head1 OUTPUT DATA

None.  However, the invoked
primitives _MAKE_FLAT_FROM_GROUP_, _DIVIDE_BY_FLAT_FROM_GROUP_, _MAKE_OBJECTS_MASK_,
and _MASK_OBJECTS_ do create new frames.  The bottom line is that
a flat field frame is filed and indexed, and there are
flat-fielded frames each inheriting the corresponding input
frame's name but with an _ff suffix.  Various intermediate
frames are normally removed by a tidy primitive.

=head1 AUTHORS

MJC: Malcolm J. Currie (JAC)

=cut
