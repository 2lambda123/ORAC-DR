# _MAKE_MOSAIC_QUADRANT_OPTIMISED_     -*- perl -*-
#
# Forms a mosaic for Quadrant jittering.
#
# TASK: KAPPA - TRANJOIN; CCDPACK - TRANLIST, MAKEMOS
#

# Selection
# =========

# This should only be performed on OBJECT frames.
    if ( $Frm->hdr(OBSTYPE) =~ /OBJECT/ ) {

# Test whether or not it is time to make a mosaic.
       $makemos = $Frm->hdr( "MAKE_MOSAIC" );
       if ( $makemos ) {

# Obtain the cycle number.
          $cycleno = $Frm->hdr( "CYCLE_NUMBER" );

# Specify the mosaic suffix.
          $osuffix = "_mos";

# Select those members in the current cycle.
          $cyclegrp = $Grp->subgrp( CYCLE_NUMBER => $cycleno );

# Form a list of input file names for the CCDPACK tasks.  We need to
# generate an input list for TRANJOIN and TRANNDF and an output list
# using a hard-wired suffix of '_trn'.
          ($inref, $outref) = $cyclegrp->inout('_trn');

# Convert the list to a comma-separated list as needed by CCDPACK (GRP).
          $objlist = join(",", @$inref);
          $outlist= join(",", @$outref);

# Resampling
# ==========

# Create text files to hold the list of input and output files, one per line.
# This is needed because the command may be long for a four-cycle quadrant
# jitter.  Expanded lists of files may make the command line too long for the
# ADAM message system.
          unlink ("tranndf.inlist$$", "tranndf.outlist$$");

          open (INLIST, ">tranndf.inlist$$");
          print INLIST join( "\n", @$inref ), "\n";
          close (INLIST);

          open (OUTLIST, ">tranndf.outlist$$");
          print OUTLIST join( "\n", @$outref ), "\n";
          close (OUTLIST);

# Assign the other parameters.  Use the original bounds.  Note we do not
# resample the main mosaic if one exists.
          $header = "in='^tranndf.inlist$$' out='^tranndf.outlist$$'";
          $hidden = "shape=auto method=linint";

# Shift and resample the flat-field object frames.  This determines
# the bounds automatically.  It takes the origin from the first object
# frame.
          $Mon{"ccdpack_reg"}->obeyw("tranndf","$header $hidden");

# Report the processing status.
          orac_print "Orac says: Frames $objlist resampled\n";

# Make mosaic.
# ============

# Derive a reasonable number of overlaps to generate a mosaic with
# small steps between former quadrants, yet not make all the possible
# comparisons for efficiency.
          $optov = 2 + int( ( $Grp->num + 4 ) / 4 );

# Assign other parameters.
          if ( $cycleno == 0 ) {
             $mmqo_grproot = $Grp->file;
          }
          $outname = $mmqo_grproot . "_mu"; 
          $header = "in='^tranndf.outlist$$' out=$outname title=Mosaic";
          $hidden = "zero optov=$optov";

# Make the mosaic correcting for differences in offset.
          $Mon{"ccdpack_reg"}->obeyw("makemos","$header $hidden");
          unlink ("tranndf.inlist$$", "tranndf.outlist$$");

# Report the processing status.
          orac_print "Orac says: mosaic $outname formed\n";

# Remove bad pixels
# =================

# Bad pixels can accumulate as the mosaics are co-added.  Thus they need to
# be removed.

# Assign parameters.  We should presumably set the Grp output name
# when we construct $mosname.  Do not change the output name if we have
# already appended the output suffix the previous time around.
# The first cycle mosaic becomes the main mosaic.  Subsequent mosaics of
# four are co-add (after registration) into the main mosaic, hence these
# require a different name.
          $mosname = $Grp->file . $osuffix unless $Grp->file =~ /$osuffix$/;
          if ( $cycleno > 0 ) {
             $mosname = $Grp->file . "_" . $cycleno;
          }
          $header = "in=$outname out=$mosname niter=4 size=4";

# Fill in the bad pixels.
          $Mon{ "kappa_mon" }->obeyw( "fillbad", "$header" );

# Report the processing status.
          orac_print "Orac says: Bad pixels filled in mosaic $outname to form $mosname\n";

# Set the group name in the Group object...
          if ( $cycleno == 0 ) {
             $Grp->file( $mosname );

# ...and read the header.
             $Grp->header( $Grp->readhdr );
          }

# Report the processing status.
          orac_print "Orac says: mosaic $mosname formed\n";

# Display the resultant mosaic.
          _DISPLAY_GROUP_IMAGE_

# On the second and subsequent cycle, we just need to co-add the
# single-cycle mosaic into the main mosaic.
          if ( $cycleno > 0 ) {

# Make a duplicate of the main mosaic.
             $tmpmos = "mainmos$$";
             $header = "in=" . $Grp->file . " out=$tmpmos";
             $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$header" );

# Co-add the frames.
             $header = "in1=$tmpmos in2=$mosname out=" . $Grp->file;
             $Mon{ "kappa_mon" }->obeyw( "add", "$header" );
             unlink( $tmpmos . ".sdf" );

             orac_print "Orac says: Frame $mosname co-added into main mosaic " . $Grp->file . "\n";

# Display the main mosaic.
             _DISPLAY_GROUP_IMAGE_
          }

       };
    };
