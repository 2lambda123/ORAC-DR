# _MAKE_MOSAIC_QUADRANT_OPTIMISED_     -*- perl -*-
#
# Forms a mosaic for Quadrant jittering.
#
# TASK: KAPPA - TRANJOIN; CCDPACK - TRANLIST, MAKEMOS
#

# Arguments
# =========

# Obtain the value for the interpolation.
    my $intmethod = ( $_MAKE_MOSAIC_QUADRANT_OPTIMISED_{INT_METHOD} || "linint" );

# Determine whether or not to fill bad pixels.
    my $fillbad = $_MAKE_MOSAIC_QUADRANT_OPTIMISED_{FILLBAD};
    $fillbad = defined( $fillbad ) ? $fillbad : 1;

# Determine whether or not to resample.
    my $resample = $_MAKE_MOSAIC_QUADRANT_OPTIMISED_{RESAMPLE};
    $resample = defined( $resample ) ? $resample : 1;

# Selection
# =========

# This should only be performed on OBJECT frames.
    if ( $Frm->hdr( "OBSTYPE" ) =~ /OBJECT/ ) {

# Test whether or not it is time to make a mosaic.
       my $makemos = $Frm->hdr( "MAKE_MOSAIC" );
       if ( $makemos ) {

# Obtain the cycle number.
          my $cycleno = $Frm->hdr( "CYCLE_NUMBER" );

# Specify the mosaic suffix.
          my $osuffix = "_mos";

# Select those members in the current cycle.
          my $cycleGrp = $Grp->subgrp( CYCLE_NUMBER => $cycleno );

# Form a list of input file names for the CCDPACK tasks.  We need to
# generate an input list for TRANJOIN and TRANNDF and an output list
# using a hard-wired suffix of '_trn'.
          ( my $inref, my $outref ) = $cycleGrp->inout( "_trn" );

# Convert the list to a comma-separated list as needed by CCDPACK (GRP).
          my $objlist = join( ",", @$inref );
          my $outlist = join( ",", @$outref );


# Resampling
# ==========

          my ( $header, $hidden );
          if ( $resample ) {

# Create text files to hold the list of input and output files, one per line.
# This is needed because the command may be long for a four-cycle quadrant
# jitter.  Expanded lists of files may make the command line too long for the
# ADAM message system.
             unlink( "tranndf.inlist$$", "tranndf.outlist$$" );

             open( INLIST, ">tranndf.inlist$$");
             print INLIST join( "\n", @$inref ), "\n";
             close( INLIST );

             open( OUTLIST, ">tranndf.outlist$$");
             print OUTLIST join( "\n", @$outref ), "\n";
             close( OUTLIST );

# Assign the other parameters.  Use the original bounds.  Note we do not
# resample the main mosaic if one exists.
             $header = "in='^tranndf.inlist$$' out='^tranndf.outlist$$'";
             $hidden = "shape=auto method=$intmethod title=!";

# Shift and resample the flat-field object frames.  This determines
# the bounds automatically.  It takes the origin from the first object
# frame.
             $Mon{"ccdpack_reg"}->obeyw("tranndf","$header $hidden");

# Report the processing status.
             orac_print "Orac says: Frames $objlist resampled\n";

          } else {

# Derive the offsets
# ==================

# Open the offset files and store the co-ordinates.  Note that this
# assumes central-source or telescope offsets have been used, and that there
# is but one position in each.
             my @xoffsets = ();
             my @yoffsets = ();
             foreach my $Frame ( $cycleGrp->members ) {
                my $offfile = $Frame->file . ".off";

                if ( ! -e $offfile ) {
                   orac_err "Missing $offfile offset text file.\n";
                }
                open( OFFFILE, "<$offfile" );

# Store the offsets.
                my $offfound = 0;
                foreach my $line ( <OFFFILE> ) {

# Match 1 followed by a space in case there are more than nine
# objects, unlikely but possible.
                   my @fields;
                   if ( $line =~ /^1\s/ ) {
                      @fields = split( /\s+/, $line );
                      push( @xoffsets, $fields[1] );
                      push( @yoffsets, $fields[2] );
                      $offfound = 1 ;
                      last;
                   }
                }
                close( OFFFILE );

# Cannot proceed unless the x-y offsets were found.
                if ( ! $offfound ) {
                   orac_err "No object #1 in $offfile offset text file.\n";
                }
             }

# Convert the offsets to be displacements of the origin to the nearest pixel.
             my $framecount = 0;
             foreach my $frame ( @xoffsets ) {
                $xoffsets[$framecount] = -int( $xoffsets[$framecount] + 0.5 );
                $yoffsets[$framecount] = -int( $yoffsets[$framecount] + 0.5 );
                $framecount++;
             }

# Change of origin
# ================

# Loop through all the members of the group, as KAPPA task can only handle
# one data file at a time.
             foreach my $Frame ( $cycleGrp->members ) {
                my $frame = $Frame->file;

# Assign the other parameters.  Use the original bounds.  Note we do not
# resample the main mosaic if one exists.
                $header = "ndf=$frame origin=[$xoffsets[0],$yoffsets[0]]";

# Shift the first item from the lists of displacements.
                shift( @xoffsets );
                shift( @yoffsets );

# Apply change of origin to the current frame.
                $Mon{"ndfpack_mon"}->obeyw("setorigin","$header");
             }

# Create text files to hold the list of 'output' files, one per line.
# The files are modified in situ, but are the equivalent of the output files
# if resampling is performed.  This is needed because the command may be long
# for a four-cycle quadrant jitter.  Expanded lists of files may make the
# command line too long for the ADAM message system.
             unlink( "tranndf.outlist$$" );

             open( INLIST, ">tranndf.outlist$$");
             print INLIST join( "\n", @$inref ), "\n";
             close( INLIST );

# Report the processing status.
             orac_print "Orac says: Frames $objlist have origin shifted.\n";
          } 

# Make mosaic.
# ============

# Derive a reasonable number of overlaps to generate a mosaic with
# small steps between former quadrants, yet not make all the possible
# comparisons for efficiency.
          my $optov = 2 + int( ( $Grp->num + 4 ) / 4 );

# Define the mosaic name.
          my ( $grproot, $outname );
          if ( $cycleno == 0 ) {
             $grproot = $Grp->file;

          } else {
             $grproot = $Grp->hdr( "ROOT_NAME" );
          }
          $outname = $grproot . "_mu"; 

# Assign other parameters.
          $header = "in='^tranndf.outlist$$' out=$outname title=!";
          $hidden = "zero optov=$optov";

# Make the mosaic correcting for differences in offset.
          $Mon{"ccdpack_reg"}->obeyw("makemos","$header $hidden");
          unlink( "tranndf.inlist$$", "tranndf.outlist$$" );

# Report the processing status.
          orac_print "Orac says: mosaic $outname formed\n";

# Remove bad pixels
# =================

# Bad pixels can accumulate as the mosaics are co-added.  Thus they may
# need to be removed.

# First define the name of the group mosaic.  We should presumably set the
# Grp output name when we construct $mosname.  Do not change the output
# name if we have already appended the output suffix the previous time
# around.  The first cycle mosaic becomes the main mosaic.  Subsequent
# mosaics of four are co-added (after registration) into the main mosaic,
# hence these require a different name.
          my $mosname = $Grp->file . $osuffix unless $Grp->file =~ /$osuffix$/;
          if ( $cycleno > 0 ) {
             $mosname = $Grp->file . "_" . $cycleno;
          }

# Normally filling bad pixels will not be done in this primitive.
          if ( $fillbad ) {

# Fill in the bad pixels.
             $header = "in=$outname out=$mosname niter=4 size=4";
             $Mon{ "kappa_mon" }->obeyw( "fillbad", "$header" );

# Report the processing status.
             orac_print "Orac says: Bad pixels filled in mosaic $outname to form $mosname\n";

# We need to keep the names matching so make a copy of mosaic containing
# bad pixels.
          } else {
             $header = "in=$outname out=$mosname";
             $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$header" );
          }

# Discard the intermediate group file.
          _DELETE_A_FRAME_ FRAME=$outname

# Define the group file and headers.
# ==================================

# Set the group name in the Group object...
          if ( $cycleno == 0 ) {
             $Grp->file( $mosname );

# ...and read the header.
             $Grp->readhdr;

# Store the root name.
             $Grp->hdr( "ROOT_NAME", $grproot );
          }

# Report the processing status.
          orac_print "Orac says: mosaic $mosname formed\n";

# Display the resultant mosaic.
          _DISPLAY_GROUP_IMAGE_

# Change the end airmass to reflect the last frame included in the mosaic.  Note this
# is done to the physical file as well as the ORAC-DR internal header.  This will
# change the grand mosaic only on the first cycle.
          my $amend = $cycleGrp->frame( $cycleGrp->num )->hdr( "AMEND" );
          $cycleGrp->hdr( "AMEND", $amend );
          my $header = "ndf=$mosname keyword=AMEND edit=update value=$amend position=!";
          $Mon{"ndfpack_mon"}->obeyw( "fitsmod", "$header comment=\\\$C" );

# Co-add the current mosaic into the grand mosaic.
# ================================================

# On the second and subsequent cycle, we just need to co-add the
# single-cycle mosaic into the main mosaic.
          if ( $cycleno > 0 ) {

# Make a duplicate of the main mosaic.
             my $tmpmos = "mainmos$$";
             $header = "in=" . $Grp->file . " out=$tmpmos";
             $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$header" );

# Co-add the frames.
             $header = "in1=$tmpmos in2=$mosname out=" . $Grp->file;
             $Mon{ "kappa_mon" }->obeyw( "add", "$header" );

# Obtain the name of the exposure time header.
             my $exptimename;
             if ( $Grp->hdr( "INSTRUME" ) =~ /^UFTI/ ) {
                $exptimename = "EXP_TIME";
             } else {
                $exptimename = "DEXPTIME";
             }

# Change the integration time of the grand mosaic by summing the current
# value and that of the primary NDF used to make the latest mosaic.  Note
# this is done to the physical file as well as the ORAC-DR internal header,
# and only to the coadded (grand) mosaic.
             my $exptime = $Grp->hdr( $exptimename ) +
                           $Grp->frame( 0 )->hdr( $exptimename );
             $Grp->hdr( $exptimename, $exptime );
             my $header = "ndf=". $Grp->file .
                          " keyword=$exptimename edit=update value=$exptime position=!";
             $Mon{"ndfpack_mon"}->obeyw( "fitsmod", "$header comment=\\\$C" );

# Change the end airmass to reflect the last frame included in the grand mosaic.  Note this
# is done to the physical file as well as the ORAC-DR internal header.
             $Grp->hdr( "AMEND", $amend );
             my $header = "ndf=" . $Grp->file . " keyword=AMEND edit=update value=$amend position=!";
             $Mon{"ndfpack_mon"}->obeyw( "fitsmod", "$header comment=\\\$C" );

# Remove the temporary copy unless its the first.  This leaves the
# mosaics for each and every individual jitter to be examined later.
             if ( $cycleno > 1 ) {
                _DELETE_A_FRAME_ FRAME=$tmpmos

             } else {
                $header = "in=$tmpmos out=" . $Grp->file . "_0";
                $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$header" );

             }
             orac_print "Orac says: Frame $mosname co-added into main mosaic " . $Grp->file . "\n";

# Display the main mosaic.
             _DISPLAY_GROUP_IMAGE_
          }

       }
    }
