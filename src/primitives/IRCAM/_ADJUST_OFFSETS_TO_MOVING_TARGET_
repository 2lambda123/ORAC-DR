# _ADJUST_OFFSETS_TO_MOVING_TARGET_     -*- perl -*-
#
# Description:
#   Shifts the telescope offsets of the frames such that they track a
#   moving target.  The motion of the target is read from an emphemeris
#   text file, and the positions in the offset text files of the group
#   members are adjusted by the motion.  One emphemeris file should be
#   used per night.
#
# Emphemeris-file Format:
#   The current format of the emphemeris file is one line per object
#   comprising three space-separated fields in the following order:
#     - the objectname, which may contain embedded spaces; 
#     - the motion in the plane of the sky in arcsec/second for right
#     ascension then declination.
#
#   Note that the right ascension motion is the change in right ascension
#   multiplied by the cosine of the declination.  The format will change
#   to include UT and possibly date.
#
# Arguments:
#    FILE = CHARACTER (Read)
#       Name of the emphemeris text file. ["target_emphem.dat"]

# Validate data
# =============

# This should only be performed on OBJECT frames.
    if ( $Frm->hdr( "OBSTYPE" ) eq "OBJECT" ||
         $Frm->hdr( "OBSTYPE" ) eq "SKY" ) {

# It should also only be performed when we are about to make a mosaic.
       my $makemosaic = $Frm->hdr( "MAKE_MOSAIC" );
       if ( $makemosaic ) {

# Obtain the motions of the target.
# =================================

# Remove spaces from the name, and convert to uppercase for later
# comparison.
          my $objname = $Frm->hdr( "OBJECT"  );
          ( my $targetname = uc( $objname ) ) =~ s/ //g;

# Obtain the name of the text file containing the motions.
          my $ephemfile = ( $_ADJUST_OFFSETS_TO_MOVING_TARGET_{FILE} || "target_ephem.dat" );

# Open the file for read access.
          open( TARGET_EPHEM, "<$ephemfile" ) || 
                orac_err "Target ephemeris file not found.\n";
          my @ephems = <TARGET_EPHEM>;

# Remove trailing blanks and newline.
          for ( @ephems ) {
             chomp;
             s/\s+$//;
          }

# Search through the table finding a line containing the object name.  The
# file format is a space-separated list, one per object comprising name
# (which must equal that given through the OBJECT keyword), the RA and Dec
# motions in arcseconds per hour.
          my ( @words, $ramotion, $decmotion );

# Look at each line.  Extract the name.  Proceed until an uppercase match
# is found.
          my $recno = -1;
          my $name = " ";
          until ( uc( $name ) eq $targetname || $recno > $#ephems ) {
             $recno++;

# Split the record into words.  Assume for the moment that the object
# name contains no spaces.
             @words = split( / +/, $ephems[ $recno ] );
             $name = $words[ 0 ];

# Allowed for embedded spaces within the object name.  Concatenate all
# parts of the name.  It assumes no spaces in the other data fields.
# The 2(+1) is the number of fields required: object name, right ascension
# and declination motions.  This number must be increased if the number
# of fields is augmented.
             if ( $#words > 2 ) {
                for ( my $i = 1; $i <= $#words - 2; $i++ ) {
                   $name = $name + $words[ $i ];
                }
                $name =~ s/ //g;
             }
          }

# Check that a match has been found.
          my $valid_motion = 1;
          if ( $recno > $#ephems ) {
             orac_warn "$objname has no tabulated motion in $ephemfile.  Using existing offsets.\n";
             $valid_motion = 0;

          } else {

# Extract the columns.
             my @fields = split( / +/, $ephems[ $recno ] );

# Extract the motions.
             $ramotion = $fields[ -2 ];
             $decmotion = $fields[ -1 ];

# Validate that these are numbers in floating point or exponential
# format.
             if ( ! ( $ramotion =~ /^-?(?:\d+(?:\.\d*)?|\.\d+)$/ ||
                  $ramotion =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([DdEe]([+-]?\d+))?$/ ) ) {
                orac_warn "Supplied motion in right ascension ($ramotion) is not a valid number.\n";
                $valid_motion = 0;
             }

             if ( ! ( $decmotion =~ /^-?(?:\d+(?:\.\d*)?|\.\d+)$/ ||
                  $decmotion =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([DdEe]([+-]?\d+))?$/ ) ) {
                orac_warn "Supplied motion in declination ($decmotion) is not a valid number.\n";
                $valid_motion = 0;
             }
          }

# Only proceed if the motions have been obtained.
          if ( $valid_motion ) {
  
# Device-specific keyword translations
# ====================================

# Obtain the instrument name, and hence the keyword names of the UT
# time-limits of these observations.  Also get the names of the
# pixelscales.
             my $instrument = $Frm->hdr( "INSTRUME" );
             my ( $startname, $endname, $xscalename, $yscalename );

             if ( $instrument =~ /^UFTI/ ) {
                $startname = "UTSTART";
                $endname = "UTEND";
                $xscalename = "CDELT1";
                $yscalename = "CDELT2"; 


             } else {
                $startname = "RUTSTART";
                $endname = "RUTEND";
                $xscalename = "PIXELSIZ";
                $yscalename = "PIXELSIZ";
             }

# Obtain the rotation angle in degrees.  The numeric default is UFTI
# and time specific.  For (T)UFTI it should read the rotation angle from
# the CROTA2 header.
             my $defrot = $Frm->hdr( "CROTA2" );
             my $rotangle = defined( $defrot ) ? $defrot : 0.65;

# Define some useful variables to apply the rotation matrix.
             my $pi = atan2( 1, 1 ) * 4;
             my $dtor = $pi / 180.0;
             my $cosrot = cos( $rotangle * $dtor );
             my $sinrot = sin( $rotangle * $dtor );

# Derive the motions for each frame with respect to the reference frame.
# ======================================================================

# Loop for each member of the group.
             my $first = 1;
             my $reftime;
             foreach $Frm ( $Grp->members ) {

# The first frame is the reference frame.  So its time is the reference
# time and its offsets are not changed.  We use the time at mid-exposure.
# The motion of the target is with respect to this time.  Use an existing
# reference time in a multi-cycle process.
                if ( $first ) {
                   $first = 0;

                   if ( defined( $Grp->uhdr( "MOTION_REFTIME" ) ) ) {
                      $reftime = $Grp->uhdr( "MOTION_REFTIME" );

                   } else {
                      $reftime = 0.5 * ( $Frm->hdr( $startname ) +
                                         $Frm->hdr( $endname ) );
                      $Grp->uhdr( "MOTION_REFTIME", $reftime );
                   }

# Find the time elapsed since the reference time.
                } else {
                   my $deltatime = 0.5 * ( $Frm->hdr( $startname ) +
                                   $Frm->hdr( $endname ) ) - $reftime;

# Derive the offsets to track the moving object.  The motions are in arcsec
# per second of time.
                   my $raoff = $ramotion * $deltatime * 3600.0;
                   my $decoff = $decmotion * $deltatime * 3600.0;

# Convert the motions into pixels.
# ================================

# Obtain the plate scales.
                   my $xpixelscale = $Frm->hdr( $xscalename );
                   my $ypixelscale = $Frm->hdr( $yscalename );

# Convert header offsets in arcseconds to pixel offsets of the object
# in the Cartesian sense.
                   my $xoffs = $raoff / $xpixelscale;
                   my $yoffs = -1.0 * $decoff / $ypixelscale;

# Apply the rotation matrix.
                   my $xoff = $xoffs * $cosrot - $yoffs * $sinrot;
                   my $yoff = $xoffs * $sinrot + $yoffs * $cosrot;

# Open files.
# ===========

# Open FINDOFF file.
                   my $ndf = $Frm-> file;
                   my $offfile = $ndf . ".off";
                   open ( OFFFILE, "< $offfile" ) ||
                      orac_err "Cannot read offset file ($offfile).\n";

# Open replacement FINDOFF file to have modified positions.
                   my $modfile = $ndf . ".moff";
                   open ( ADJUSTED, "> $modfile" ) ||
                      orac_err "Cannot create temporary offset file ($modfile).\n";

# Read input file.
# ================

# Loop through the input offset file.
                   foreach my $line ( <OFFFILE> ) {

# Propagate the comments.  Data lines begin with an integer identifier.
                      if ( ! ( $line =~ /^[1-9]/ ) ) {
                         print ADJUSTED $line;

                      } else {

# Break the space-separated fields.   Obtain the x-y positions.
                         my @fields = split( /\s+/, $line );
                         my $ident = $fields[0];
                         my $xpos = $fields[1];
                         my $ypos = $fields[2];

# Apply the motions to the offset-file position.
# ==============================================

# Update the current positions applying the offsets in pixels for the moving
# target.  The offsets should be subtracted to restore the moving target to
# its position in the first frame, but right ascension increases with
# decreasing x, so the right ascension motion is added.  Then there is
# the reversal of telescope motion with respect to pixels.
                         $xpos = $xpos - $xoff;
                         $ypos = $ypos - $yoff; 
# Don't understand why not + sign in last expression!

# Write the edited line to the temporary file.
                         print ADJUSTED "$ident $xpos $ypos\n";
                      }
                   }

# Replace the old file with the new.
                   close( OFFFILE );
                   close( ADJUSTED );
                   rename( $modfile, $offfile ) || 
                      orac_err "Cannot rename temporary offset file to standard name ($offfile).\n";

# Format and report the motion adjustments offsets.
                   my $fs_xoff = sprintf( "%9.3f", $xoff );
                   $fs_xoff =~ s/ //g;
                   my $fs_yoff = sprintf( "%9.3f", -1.0 * $yoff );
                   $fs_yoff =~ s/ //g;

                   orac_print "Orac says: offsets for frame $ndf adjusted by $fs_xoff, $fs_yoff pixels for the motion of $name.\n";
                }
             }
          }
       }
    }
