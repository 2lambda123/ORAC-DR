# _MAKE_FLAT_FROM_NORMALISED_EXTENDED_    -*- perl -*-
#
# Forms a flat-field from a group of object frames.  Each member of the
# group is expected to be of blank sky and be zero-point normalised to
# one of the frames.  The primitive uses a median to combine pre-normalised
# frames pixel by pixel.
#
# TASK: CCDPACK - MAKECAL, KAPPA - CDIV, KAPPA - STATS
#
# Arguments:
#    FLAT_MEDIAN = REAL (Returned)
#       The median value of the reference sky frame.

# Selection
# =========

# This should only be performed on object frames.
    if ( $Frm->hdr( "OBSTYPE" ) eq "OBJECT" ||
         $Frm->hdr( "OBSTYPE" ) eq "SKY" ) {

# Obtain the row number.
       my $ext_row = $Frm->hdr( "EXTENDED_ROW" );

# Determine whether it is time to make a flat.
       my $makeflat = $Frm->hdr( "MAKE_FLAT" );
       if ( $makeflat ) {

# Form a list of the blank-sky file names for CCDPACK tasks by using a
# subgroup.
          my $skyGrp = $Grp->subgrp( TARGET_OR_SKY => "sky",
                                     EXTENDED_ROW => $ext_row );

# Form a list of input file names for MAKECAL from the other members
# of the group.  This is not as obvious as it sounds since we are
# trying to do this by looking at the current file values for each
# Frame object in the loop.  First time around everything is fine.
# Second time around we realise that the previous frames now have the
# wrong names since they have been flat-fielded etc.  We now have to
# construct the input names from the template.  The template is the
# current sky frame name.
          $skyGrp->template( $Frm->file );

# Make lists of files to process
# ==============================

# Obtain an array of the filenames of the sub-group members.
          my @objects = $skyGrp->membernames;

# Form a comma-separated list of the object frames.
          my $objlist = join(",", @objects);

# Create text file to hold the list of input files, one per line.  This
# is needed because expanded lists of files may make the command line too
# long for the ADAM message system.
          unlink( "objlist.inlist$$");
          open( INLIST, ">objlist.inlist$$" );
          print INLIST join( "\n", @objects ), "\n";
          close( INLIST );

# Make a flat which is not normalised
# ===================================

# Assign the other parameters.  Note that output flat is hardwired for
# the moment.
          my $uflat = "uflat_" . $Grp->name;
          my $header = "in='^objlist.inlist$$' out=$uflat";
          my $hidden = "sigmas=2.0 expose=1 reset accept"; 
          my $user = "method=median";

# Median filter the intra-normalised sky frames to produce an un-normalised
# flatfield.
          $Mon{"ccdpack_red"}->obeyw("makecal","$header $user $hidden");
          unlink( "objlist.inlist$$" );

# Normalise the flat
# ==================

# Obtain the ordered statistics of the combined frame.
          $Mon{"kappa_mon"}->obeyw("histat","ndf=$uflat");

# Extract the median of the frame.  Export the value for later sky
# subtraction.
          ( my $ORAC_STATUS, my $median ) = $Mon{"kappa_mon"}->get("histat","median");
          $_MAKE_FLAT_FROM_NORMALISED_EXTENDED_{FLAT_MEDIAN} = $median;

# Assign the parameters.  Note that output flat is hardwired for the moment.
          my $out = "flat_" . $Grp->name . "_row" . $ext_row;
          $header = "in=$uflat out=$out scalar=$median title=\'Flat field\'";

# Normalise the flat field to have a mean of one.
          $Mon{"kappa_mon"}->obeyw("cdiv","$header");

# Delete the non-normalised flat.
          _DELETE_A_FRAME_ FRAME=$uflat

# Record and display the flat
# ===========================

# Set the current flat in the calibration object.
          _FILE_FLAT_ NAME=$out
     
# Report the status of the processing.
          orac_print "Orac says: frames $objlist used for flat\n";

# Display the image.
          _DISPLAY_FLAT_IMAGE_

       }
    }
