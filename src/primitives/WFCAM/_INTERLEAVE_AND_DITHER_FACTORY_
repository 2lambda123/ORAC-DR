    use Data::Dumper;
    use Proc::Simple;
    use File::Temp qw(tempfile); # using this because I don't want the 
				 # temporary file destroyed when the descriptor
				 # goes out of scope as would happen if I used 
				 # the ORAC temp file module...

    my $ipix = (defined $_INTERLEAVE_AND_DITHER_FACTORY_{IPIX} ? $_INTERLEAVE_AND_DITHER_FACTORY_{IPIX} : 5);
    my $thresh = (defined $_INTERLEAVE_AND_DITHER_FACTORY_{THRESH} ? $_INTERLEAVE_AND_DITHER_FACTORY_{THRESH} : 1.5);
    my $icrowd = (defined $_INTERLEAVE_AND_DITHER_FACTORY_{ICROWD} ? $_INTERLEAVE_AND_DITHER_FACTORY_{ICROWD} : 1);
    my $rcore = (defined $_INTERLEAVE_AND_DITHER_FACTORY_{RCORE} ? $_INTERLEAVE_AND_DITHER_FACTORY_{RCORE} : 3.5);

    # Are we allowed to interleave yet?

    if ($Grp->uhdr("ALLOWED_TO_INTERLEAVE")) {

        # Assuming we get here, we now need a list of all the micro-step
        # sequences that exist in the current group.

        my @allugrps = $Grp->allugroups;
	@allugrps = sort {$a->name <=> $b->name} @allugrps;

        # Right now cycle through each of these

        my @allsuperframes = ();
	my $standard_cpm;
	my $i = 0;
        foreach my $ustepgrp (@allugrps) {
	    $i++;
	    next if ($ustepgrp->uhdr("SUPERFRAME"));
            $standard_cpm = $allugrps[0]->uhdr("SUPERFRAME_CONF") if ($i > 1);
	    my $ustepgrpname = $ustepgrp->name;
	    my @a = $ustepgrp->members;
	    my $n = @a;

	    orac_print("Interleaving microstep sequence $ustepgrpname $n\n") if ($n > 1);
	    my ($superframe,$jnum);
            {
                my $Grp = $ustepgrp;
                my $Frm = ($Grp->members)[0];
	        my $doconf = ($i == 1);
                _INTERLEAVE_ DOCONF=$doconf
                $superframe = $Grp->uhdr("SUPERFRAME");
                $standard_cpm = $Grp->uhdr("SUPERFRAME_CONF") if ($i == 1);
	        my ($retval,$errmsg);
                foreach my $ii (1 .. $superframe->findnsubs) {
		    $retval = cir_update_hdr($superframe->getasubframe($ii)->file,
			"CIR_CPM","STRING",$standard_cpm->getasubframe($ii)->file,
			"Confidence map name",$errmsg);
	            $superframe->getasubframe($ii)->hdr("CIR_CPM",
		        $standard_cpm->getasubframe($ii)->file);
	        }
	        $jnum = $Frm->jgrp;
	        $superframe->jgrp($jnum);
		$superframe->ugrp($Frm->ugrp);
            }
            $Grp->sfgroup->push($superframe);

            # Do an object extraction now...

#	    orac_print("Doing object detection on: " . $superframe->file . "\n");
#            {
#	        $Frm = $superframe;
#                my $prefix = "t";
#                _APM_ PREFIX=$prefix PNOP=50 VERBOSE=0 THRESH=7 GRID=256 CATTYPE=3
#	    }
        }
    }

    # Are we allowed to dither yet?

    if ($Grp->uhdr("ALLOWED_TO_DITHER")) {

	# Get the astrometric source

	my $astrom = $Cal->astrom;
	my ($catsrc,$site,$catpath);

	# Construct a file name for it and attempt to open the file

	my $fname = sprintf("ast_%s.pl",$astrom);
	$fname = File::Spec->catfile($ENV{'ORAC_DATA_CAL'},$fname);
	my $fh;
	open($fh,"<$fname") || orac_throw("Unable to open astrometric standard source definition file");

	# Read and evaluate the expressions in the file...

	my $line = "";
	while (<$fh>) {
	    $line .= $_;
	}
	close($fh);
	eval($line);

        # Get photometric source

        my ($Finfo,$Cinfo);
        my $filt = $Frm->hdr("FILTER");
        _PHOTOMDATA_ FILTER=$filt

        # Find out how many jitters there are in the current group.

        my @alljgroups = $Grp->alljgroups;
        @alljgroups = sort {$a->name <=> $b->name} @alljgroups;

        # Loop for each jitter.  See how many files in each jitter group.

        foreach my $cjgrp (@alljgroups) {
	    my $curjitter = $cjgrp->name;
	    next if ($cjgrp->uhdr("DITHER_FRAME"));
            my $sfg = $Grp->sfgroup->sfjgrp($curjitter);
            my @allfiles = $sfg->members;
	    my @allfnames = ();
	    foreach my $ff (@allfiles) {
	        push @allfnames,$ff->file;
            }
	    my $instructions = {};
	    $instructions->{infiles} = \@allfnames;
	    $instructions->{ipix} = $ipix;
	    $instructions->{thresh} = $thresh;
	    $instructions->{grid} = 64;
	    $instructions->{cattype} = 1;
	    $instructions->{icrowd} = $icrowd;
	    $instructions->{rcore} = 3.5;
	    $instructions->{catsrc} = $catsrc;
	    $instructions->{site} = $site;
	    $instructions->{catpath} = $catpath;
	    $instructions->{finfo} = $Finfo;
	    $instructions->{cinfo} = $Cinfo;
            my $line = Dumper($instructions);
            my ($dtmp,$dfh);
            ($dfh,$dtmp) = tempfile("factoryXXXXXXX");
	    print $dfh "$line\n";
            $dfh->close;
            my $factory = sprintf("%s/recipes/WFCAM/bin/jitter_factory",$ENV{'ORAC_DIR'});
            my $procobj = Proc::Simple->new();
	    $procobj->kill_on_destroy(0);
            my $status = $procobj->start("$^X","-I","$ENV{PERL5LIB}",
		"$factory","$dtmp");
            my $pid = $procobj->pid;
	    orac_print("Dithering jitter sequence $curjitter remotely $pid $status\n");
	    orac_print "Running..." . $procobj->poll . "\n";
        }
    }

=head1 NAME

_INTERLEAVE_AND_DITHER_FACTORY_ -- Interleave and dither the microstep and jitter 
sequences in the current tile group.

=head1 DESCRIPTION

This routine will do interleaf and jitter combinations when requested.  Both
operations require and $Grp->uhdr flag to be set.  For interleaving to take
place the flag ALLOWED_TO_INTERLEAVE must be set.  The flag for dithering is
ALLOWED_TO_DITHER. The interleaving section takes processed frames and creates
superframes.  The dithering section takes superframes and creates stacked 
frames.  Once the dithering is done, then all the further cataloguing and DQC
estimates are done.

=head1 ARGUMENTS

=over 4

=item IPIX

The minimum size that an object can have in the catalogue (in pixels)

=item THRESH

The detection threshold in numbers of sigma above sky

=item ICROWD

If set, then the catalogue generation will include a deblending algorithm to
try and separate merged objects

=item RCORE

The nominal size of the aperture (in pixels)

=head1 NOTES

None

=head1 AUTHORS

JRL: Jim Lewis (CASU, IoA)

=head1 COPYRIGHT

Copyright (C) 2004-2007 Cambridge Astronomy Survey Unit. 
All Rights Reserved

=cut


