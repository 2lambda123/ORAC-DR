    # Ok, split the list of flats into two groups. Sort the files 
    # by flux and divide them in the middle...

    my @usethese = sort 
	{$a->getasubframe(1)->uhdr("CIRMED") <=> 
	 $b->getasubframe(1)->uhdr("CIRMED")} 
	 $Grp->members;
    my $nf2 = @usethese;
    my $midpt = $nf2/2;
    $midpt++ if ($nf2 % 2 != 0);
    my @gg;
    $gg[0] = $Grp->new;
    $gg[1] = $Grp->new;
    $gg[0]->members(@usethese[0..$midpt-1]);
    $gg[1]->members(@usethese[$midpt..$nf2-1]);
    my @fnames = ();

    # Loop for these two groups and create two temporary dome 
    # flat files.

    foreach my $j (0 .. 1) {

	# Get a temporary file name...

	$fnames[$j] = ORAC::TempFile->new(0);
	unlink $fnames[$j]->file;

	# See how many there are in this group. If it's only 1 then
	# just copy the one file over and move on. Otherwise work
	# out scaling for combination.

	my $Grp = $gg[$j];
	my @grpfils = $Grp->members;
	my $ngf = @grpfils;
	if ($ngf == 1) {
	    copy($grpfils[0]->file,$fnames[$j]->file);
	    next;
	}
	_ICSCALE_

	# Now loop for each image extension

	my $nextn = $Frm->findnsubs;
	my $i;
	for ($i = 1; $i <= $nextn; $i++) {

	    # Make a list of the files...

	    my @allf = ();
	    foreach my $frm ($gg[$j]->members) {
		push @allf,$frm->getasubframe($i)->file;
	    }
	    my $nf = @allf;

	    # Output file name specification

	    my $outf = sprintf("%s[%d]",$fnames[$j]->file,
		$Frm->getasubframe($i)->subfrmnumber);

	    # Do the combination now...

	    my ($retval,$errmsg);
	    $retval = cir_imcombine_lite(\@allf,$nf,MEDIANCALC,2,0,
		5.0,"exp_time",$outf,$errmsg);
	    if ($retval != CIR_OK) {
		orac_throw "CIR_IMCOMBINE_LITE: failed in _MAKE_A_BPM_\n$errmsg\n";
	    }
	}
    }

    # Now create the BPM...

    my $bpmbase = sprintf("bpm_%s%s",$Frm->hdr("GRPNUM"),$Frm->fitssuffix);
    my $addit = 1;
    if (-f $bpmbase) {
	unlink $bpmbase;
	$addit = 0;
    }
    for ($i = 1; $i <= $nextn; $i++) {

	# Create an output file name, make a list of inputs and
	# do the combination

	$outfile = sprintf("%s[%d]",$bpmbase,$i);
	my @tmpframes;
	foreach my $j (0 .. 1) {
	    push @tmpframes,sprintf("%s[%d]",$fnames[$j]->file,$i);
	}
	my ($retval,$errmsg);
	$retval = cir_bpmcreate(\@tmpframes,$outfile,5.0,2,0,
	    $errmsg);
	if ($retval != CIR_OK) {
	    orac_throw "CIR_BPMCREATE: failed in _DOME_FLAT_BPM\n$errmsg\n";
	}
    }

    # Ditch the temporary files...

    $fnames[0]->DESTROY;
    $fnames[1]->DESTROY;

    # Write some stuff to the PHU

    my $bpmfrm = $Frm->new($bpmbase);
    $bpmfrm->update_header("WFRTYPE",TSTRING,CALBPM,
	"Calibration frame type");
    $bpmfrm->update_header("MASKTYPE",TINT,MASK_BPM,
	"Bad Pixel Mask");
    if ($addit) {
	_FILE_BPM_ NAME=$bpmbase
    } 

    $_MAKE_A_BPM_{NAME} = $bpmbase;

=head1 NAME

_MAKE_A_BPM_ -- Create a bad pixel mask using dome flat fields.

=head1 DESCRIPTION

The list of input frames is sorted by background median and then split
into two groups. The two groups are each combined to form a mean frame.
The two mean frames are used to create a bad pixel mask. The mean frames
are deleted. The BPM is written to an index file and the name is passed back.

=head1 ARGUMENTS

=over 4

=item NAME = char (Returned)

The name of the output FITS container file for the bad pixel mask.

=back

=head1 NOTES

None

=head1 AUTHORS

JRL: Jim Lewis (CASU, IoA)

=head1 COPYRIGHT

Copyright (C) 2005-2008 Cambridge Astronomy Survey Unit.
All Rights Reserved

=cut
