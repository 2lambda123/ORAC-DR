    # Do background stats on the images and scale find the relevant scale
    # factors for the imcombine

    _ICSCALE_

    # How many are there in the group

    my @members = $Grp->members;
    my $nf = @members;

    # Output file name
 
    my $outfile = "twiflat_" . $Grp->name . $Frm->fitssuffix;
    my $addit = 1;
    if (-f $outfile) {
	unlink $outfile;
	$addit = 0;
    } 

    # If there is only file in the group, then just copy it over

    my $nextn = $Frm->findnsubs;
    my $i;
    if ($nf < 2) {

        copy($members[0]->file,$outfile);

    } else {

        # Now loop for each image extension

        for ($i = 1; $i <= $nextn; $i++) {
	
            # Make a list of the files for this extension

            my @allf = ();
            foreach my $frm ($Grp->members) {
	        push @allf,$frm->getasubframe($i)->file;
            }
            my $nf = @allf;

            # Output file name specification

            my $outf = sprintf("%s[%d]",$outfile,
                $Frm->getasubframe($i)->subfrmnumber);

            # Do the combination now...

            my ($retval,$errmsg);
            $retval = cir_imcombine_lite(\@allf,$nf,MEDIANCALC,2,0,3.0,$outf,
	        $errmsg);
            if ($retval != CIR_OK) {
               orac_throw "CIR_IMCOMBINE_LITE: failed in _TWILIGHT_FLAT_COMBINE_\n$errmsg\n";
            }
        }
    }

    # Now normalise the flats to the common mean...

    my $flatfrm = $Frm->new($outfile);
    {
        my $Frm = $flatfrm;
        _IMSTAT_ HDRUP=1
    }
    my $sum = 0.0;
    foreach $i (1 .. $nextn) {
        $sum += $flatfrm->getasubframe($i)->uhdr("CIRMED");
    }
    $sum /= $nextn;
    foreach $i (1 .. $nextn) {
        my $errmsg;
        my $retval = cir_imdivk($flatfrm->getasubframe($i)->file,$sum,$errmsg);
        if ($retval != CIR_OK) {
            orac_throw "CIR_IMDIVK: failed in _TWILIGHT_FLAT_COMBINE_\n$errmsg\n";
        }
    }

    # Write some stuff to the PHU

    $flatfrm->update_header("CCDMEAN",TFLOAT,$sum,"Ensemble mean background");
    $flatfrm->update_header("WFRTYPE",TSTRING,CALFLAT,"Calibration frame type");
    if ($addit) {
        _FILE_FLAT_ NAME=$outfile
    }

    # See if you have a bad pixel mask at your disposal. If you don't try and
    # make one from the flats you have here.

    my $ok = $Cal->BPMindex->verify($Cal->BPMname,$Cal->thing,0);
    my $bpm;
    if ($ok) {
        $bpm = $Cal->BPMname;
    } elsif (defined $ok) {
        $bpm = $Cal->BPMindex->choosebydt('ORACTIME',$Cal->thing,0);
    }
    if (! $bpm) {
        _MAKE_A_BPM_
        $bpm = $_MAKE_A_BPM_{NAME};
    }
	
    # Make the CPM

    {
        my $Frm = $flatfrm;
        my $cpmfile = sprintf("cpm_%d%s",$Grp->name,$Frm->fitssuffix);
        _MAKE_CONFIDENCE_MAP_ BPM=$bpm OUT=$cpmfile 
    }


=head1 NAME

_TWILIGHT_FLAT_COMBINE_ -- Form a mean flat and confidence map

=head1 DESCRIPTION

This primitive first works out the background values for all the frames
in a group. The provide scaling factors that can be used to scale the images
to a common median during the combine phase. A combination is done for
each image in the frames. Once the images are combined the background value
for each of the resulting frames is calculated. Each frame is divided by
the ensemble mean background.  This should not only ensure that the mean
counts for a frame near the ensemble mean remain the same, but also any
pedestal gain difference between the images is also removed. After finishing
with the flat, it is used to create a confidence map.

=head1 ARGUMENTS

None

=head1 NOTES

=over 4

=item *

Mean flat and confidence maps are filed in index files.

=back

=head1 AUTHORS

JRL: Jim Lewis (CASU, IoA)

=head1 COPYRIGHT

Copyright (C) 2004-2007 Cambridge Astronomy Survey Unit. 
All Rights Reserved

=cut
