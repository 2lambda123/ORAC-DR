    my $minflux = (defined $_DOME_FLAT_BPM_{MIN} ? $_DOME_FLAT_BPM_{MIN} : 0);
    my $maxflux = (defined $_DOME_FLAT_BPM_{MAX} ? $_DOME_FLAT_BPM_{MAX} : 65535);

    # Of course skip any frames that aren't flat...(Some domes may masquarade
    # as objects, though)

    if ($Frm->hdr("OBSTYPE") eq "OBJECT" || $Frm->hdr("OBSTYPE") eq "DOMEFLAT") {

        # Get a subgroup that includes all of the flats of the relevent
        # filter group.

	my $subgrp = $Grp->subgrp("FILTER"=>$Frm->hdr("FILTER"));
	my @f = $subgrp->members;
	my $nf = @f;

        # Define a new group for use later

        my @usethese = ();
        my $newsubgrp = $Grp->new;

        # Don't continue if we don't have at least 2 frames...

        if ($nf >= 2) {

	    # Do background stats on the images and scale find the relevant
	    # scale factors for the imcombine. Remove any that are not in the 
	    # data window specified

	    foreach my $frm ($subgrp->members) {
		my $Frm = $frm;
		_IMSTAT_ HDRUP=1
	        if ($Frm->getasubframe(1)->uhdr("CIRMED") > $minflux &&
		    $Frm->getasubframe(1)->uhdr("CIRMED") < $maxflux) {
	            push @usethese,$Frm;
                }
	    }

            # Only continue if there are at least 2 frames and the most 
	    # recent frame is one of them...
            
            my $nf2 = @usethese;
            if ($nf2 >= 2 && $Frm->file eq $usethese[-1]->file) {

 	        $newsubgrp->members(@usethese);
                {
                    my $Grp = $newsubgrp;
 	            _ICSCALE_
                }

    	        # Output file name

                my $outfile = sprintf("dome_%s_%s%s",$Grp->name,
	            $Frm->hdr("FILTER"),$Frm->fitssuffix);

     	        # If the output file already exists, then just delete it and 
		# do the combination again with the current list of frames. 
		# Also set up a flag to say later on that this dark shouldn't 
		# be added to the index, because it's already there...

		my $addit = 1;
		if (-f $outfile) {
		    unlink $outfile;
		    $addit = 0;
		}

		# Now loop for each image extension

		my $nextn = $Frm->findnsubs;
		my $i;
		for ($i = 1; $i <= $nextn; $i++) {

		    # Make a list of the files...

		    my @allf = ();
		    foreach my $frm ($newsubgrp->members) {
			push @allf,$frm->getasubframe($i)->file;
		    }
		    my $nf = @allf;

		    # Output file name specification

		    my $outf = sprintf("%s[%d]",$outfile,
			$Frm->getasubframe($i)->subfrmnumber);

		    # Do the combination now...

		    my ($retval,$errmsg);
		    $retval = cir_imcombine_lite(\@allf,$nf,MEDIANCALC,2,0,5.0,
			$outf,$errmsg);
		    if ($retval != CIR_OK) {
			orac_throw "CIR_IMCOMBINE_LITE: failed in _DOME_FLAT_BPM_\n$errmsg\n";
		    }
		}

		# Write some stuff to the PHU

		my $domefrm = $Frm->new($outfile);
		$domefrm->update_header("WFRTYPE",TSTRING,CALFLAT,
		    "Calibration frame type");
                {
                    $Frm = $domefrm;
		    _IMSTAT_ HDRUP=1
                }
	        for ($i = 1; $i <= $nextn; $i++) {
                    my $val = $Frm->getasubframe($i)->uhdr("CIRMED");
		    my $errmsg;
                    my $retval = cir_imdivk($Frm->getasubframe($i)->file,
			$val,$errmsg);
                }
		if ($addit) {
		    _FILE_DOME_ NAME=$outfile
		} 

		# Display it

		{
		    my $Frm = $domefrm;
		    _DISPLAY_IMAGE_
		}

                # Now make the BPM

                {
                    $Grp = $newsubgrp;
		    _MAKE_A_BPM_
                }
            }
        }
    }

=head1 NAME

_DARK_COMBINE_ -- Form a mean dark frame

=head1 DESCRIPTION

If there is only one frame in the group then this primtive just copies it
to the output file name. If there are more than one then this primitive first 
works out the background values for all the frames in a group. This provides
scaling factors or zero points that can be used to scale the images
to a common median during the combine phase. A combination is done for
each extension. If the dark frame output file already exists, then it is
deleted and the combination is done again. This is to get around the fact that
currently there is no way of 'grouping' dark exposures together in such a way
that you can flag when a sequence of dark exposures is finished. This shouldn't
be a problem though as the timing should be trivial

=head1 ARGUMENTS

None

=head1 NOTES

=over 4

=item *

Mean dark is filed in index file.

=back

=head1 AUTHORS

JRL: Jim Lewis (CASU, IoA)

=head1 COPYRIGHT

Copyright (C) 2004-2007 Cambridge Astronomy Survey Unit. 
All Rights Reserved

=cut
