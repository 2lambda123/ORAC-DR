    # Get some parameters

    my $catsrc = (defined $_WCSFIT_{CATSRC} ? $_WCSFIT_{CATSRC} : "2mass");
    my $site = (defined $_WCSFIT_{SITE} ? $_WCSFIT_{SITE} : "cds");
    my $catpath = (defined $_WCSFIT_{CATPATH} ? $_WCSFIT_{CATPATH} : "");
    my $equinox = (defined $_WCSFIT_{EQUINOX} ? $_WCSFIT_{EQUINOX} : 2000);
    my $override = (defined $_WCSFIT_{OVERRIDE} ? $_WCSFIT_{OVERRIDE} : 0);
    my $pass = (defined $_WCSFIT_{PASS} ? $_WCSFIT_{PASS} : 2);

    # Set some WCS parameter names

    my %wcsparms = ('CRVAL1' => TDOUBLE,
		    'CRVAL2' => TDOUBLE,
		    'CRPIX1' => TDOUBLE,
		    'CRPIX2' => TDOUBLE,
		    'CD1_1' => TDOUBLE,
		    'CD1_2' => TDOUBLE,
		    'CD2_1' => TDOUBLE,
		    'CD2_2' => TDOUBLE,
		    'CUNIT1' => TSTRING,
		    'CUNIT2' => TSTRING,
		    'CTYPE1' => TSTRING,
		    'CTYPE2' => TSTRING,
		    'WCSPASS' => TINT,
		    'NUMBRMS' => TINT,
		    'STDCRMS' => TDOUBLE,
		    'PROJP1' => TFLOAT,
		    'PROJP3' => TFLOAT
		    'PV2_0' => TFLOAT
		    'PV2_1' => TFLOAT
		    'PV2_2' => TFLOAT
		    'PV2_3' => TFLOAT);

    # Send a friendly message

    orac_print "Fitting Pass $pass WCS to " . $Frm->file . "\n";

    # Now loop for each extension 

    foreach my $j (1 .. $Frm->findnsubs) {
	my $frm = $Frm->getasubframe($j);
	my $dsfile = $frm->file;
	my ($catbase,$retval,$ctmp,$errmsg);

	# Does this frame have a WCS already?

	my $wcspass = $frm->hdr("WCSPASS");
	$wcspass = (defined $wcspass ? $wcspass : -1);

	# Check whether to override the current WCS. If not, then
	# skip this image.

	if ($override || ($wcspass < $pass)) {

            # Get a reference RA and Dec for the current WCS pass

            my $midx = $frm->hdr("NAXIS1")/2;
            my $midy = $frm->hdr("NAXIS2")/2;
            my ($raref1,$decref1);
            $retval = cir_xy2radec($dsfile,$midx,$midy,$raref1,$decref1,$errmsg);
            if ($retval != CIR_OK) {
                orac_err("CIR_XY2RADEC: Failed in _WCSFIT_ for $dsfile\n$errmsg\n");
                next;
            }

	    # If this is a first pass WCS, then do an image detection...

	    if ($pass == 1) {
		$ctmp = ORAC::TempFile->new(0);
		$catbase = $ctmp->file;
		unlink $catbase;
		$retval = cir_apm($dsfile,$catbase,"","",0,25,
		    -2.0,64,0,$errmsg);
		if ($retval != CIR_OK) {
		    orac_err("CIR_APM: Failed in _WCSFIT_ for $dsfile\n$errmsg\n");
		    next;
		}
	    } else {
		$catbase = $frm->uhdr("CATFILE");
		if (! defined $catbase) {
		    my @fspec = $frm->parsefname;
		    $catbase = sprintf("%s_cat%s[%d]",$fspec[0],
			$fspec[2],$fspec[3]);
		}
	    }

	    # Dump the XY info into a temporary file

	    my $tmpxy = ORAC::TempFile->new;
	    my $status = 0;
	    my $fptr = Astro::FITS::CFITSIO::open_file($catbase,READONLY,
		$status);
	    my ($hdutype,$nrows,$col,@xval,@yval,@tval,@elval,$anynul);
	    $fptr->movabs_hdu(2,$hdutype,$status) if ($pass == 1);
	    $fptr->get_num_rows($nrows,$status);
	    $fptr->get_colnum(CASESEN,"X_coordinate",$col,$status);
	    $fptr->read_col(TFLOAT,$col,1,1,$nrows,undef,\@xval,$anynul,$status);
	    $fptr->get_colnum(CASESEN,"Y_coordinate",$col,$status);
	    $fptr->read_col(TFLOAT,$col,1,1,$nrows,undef,\@yval,$anynul,$status);
	    $fptr->get_colnum(CASESEN,"Total_flux",$col,$status);
	    $fptr->read_col(TFLOAT,$col,1,1,$nrows,undef,\@tval,$anynul,$status);
	    $fptr->get_colnum(CASESEN,"Ellipticity",$col,$status);
	    $fptr->read_col(TFLOAT,$col,1,1,$nrows,undef,\@elval,$anynul,$status);
	    $fptr->close_file($status);
	    $ctmp->DESTROY if ($pass == 1);
	    if ($status != 0) {
		orac_err("_WCSFIT_ can't read table $catbase: status = $status\n");
		next;
	    }
	    my $fh = $tmpxy->handle;
	    my $xyfile = $tmpxy->file;
	    my $i;
	    for ($i = 0; $i < $nrows; $i++) {
		next if ($elval[$i] > 0.5);
		print $fh "$xval[$i] $yval[$i] $tval[$i]\n";
	    }
	    $tmpxy->handle->close;

	    # Now get some standard stars 

	    my $tmpstds = ORAC::TempFile->new(0);
	    my $stdsfile = $tmpstds->file;
            unlink $stdsfile if (-e $stdsfile);
	    $retval = cir_getstds($dsfile,$stdsfile,$catsrc,$site,$catpath,
		$equinox,5,$errmsg);
	    if ($retval != CIR_OK) {
		orac_err("CIR_GETSTDS: Failed in _WCSFIT_\n$errmsg\n");
		next;
	    }

	    # Now dump these to a text file

	    my $tmpstds2 = ORAC::TempFile->new;
	    my $stdstxt = $tmpstds2->file;
	    $fptr = Astro::FITS::CFITSIO::open_file($stdsfile,READONLY,$status);
	    $fptr->movabs_hdu(2,$hdutype,$status);
	    $fptr->get_num_rows($nrows,$status);
	    $fptr->get_colnum(CASESEN,"X_coordinate",$col,$status);
	    $fptr->read_col(TFLOAT,$col,1,1,$nrows,undef,\@xval,$anynul,$status);
	    $fptr->get_colnum(CASESEN,"Y_coordinate",$col,$status);
	    $fptr->read_col(TFLOAT,$col,1,1,$nrows,undef,\@yval,$anynul,$status);
	    my (@raval,@decval);
	    $fptr->get_colnum(CASESEN,"ra",$col,$status);
	    $fptr->read_col(TFLOAT,$col,1,1,$nrows,undef,\@raval,$anynul,$status);
	    $fptr->get_colnum(CASESEN,"dec",$col,$status);
	    $fptr->read_col(TFLOAT,$col,1,1,$nrows,undef,\@decval,$anynul,$status);
	    $fptr->close_file($status);
	    if ($status != 0) {
		orac_err("_WCSFIT_ can't read table $catbase: status = $status\n");
		next;
	    }
	    $fh = $tmpstds2->handle;
	    for ($i = 0; $i < $nrows; $i++) {
		print $fh "$xval[$i] $yval[$i] $raval[$i] $decval[$i]\n";
	    }
	    $fh->close;
	    $tmpstds->DESTROY;

	    # Now matchem up...

	    my $maxsize = max($frm->hdr("NAXIS1"),$frm->hdr("NAXIS2"));
	    my $srad = int(0.25*$maxsize);
	    my $tmpmatch = ORAC::TempFile->new(0);
	    my $matchfile = $tmpmatch->file;
	    unlink $matchfile if (-e $matchfile);
	    my $nmatch = 0;
	    $retval = cir_matchstds($xyfile,$stdstxt,$srad,
		$frm->hdr("NAXIS1"),$frm->hdr("NAXIS2"),$matchfile,
		$nmatch,$errmsg);
	    if ($retval != CIR_OK) {
                $tmpxy->DESTROY;
                $tmpstds2->DESTROY;
                $tmpmatch->DESTROY;
		orac_err("CIR_MATCHSTDS: Failed in _WCSFIT_\n$errmsg\n");
		next;
	    } elsif ($nmatch == 0) {
		$tmpxy->DESTROY;
		$tmpstds2->DESTROY;
		$tmpmatch->DESTROY;
		orac_err("CIR_MATCHSTDS: Failed in _WCSFIT_\nNo objects matched\n");
		next;
	    }   

	    # Intermediate tidying

	    $tmpxy->DESTROY;
	    $tmpstds2->DESTROY;

	    # Now do a plate solution

	    $retval = cir_platesol($dsfile,$matchfile,6,$pass,1,$errmsg);
	    if ($retval != CIR_OK) {
		orac_err("CIR_PLATESOL: Failed in _WCSFIT_\n$errmsg");
                $tmpmatch->DESTROY;
		next;
	    }
	    $tmpmatch->DESTROY;

	    # If this is a second pass WCS, then update the catalogue headers

	    if ($pass == 2) {
		my $frm = $Frm->new($dsfile);
		$status = 0;
		my $tptr = Astro::FITS::CFITSIO::open_file($catbase,READWRITE,
                    $status);
		foreach my $parm (keys %wcsparms) {
		    $status = 0;
		    my $val = $frm->hdr($parm);
		    next if (! defined $val);
		    $tptr->update_key($wcsparms{$parm},$parm,$val,"",$status);
		}
		$tptr->close_file($status);
	    }
            my ($raref2,$decref2);
            $retval = cir_xy2radec($dsfile,$midx,$midy,$raref2,$decref2,$errmsg);
            if ($retval != CIR_OK) {
                orac_err("CIR_XY2RADEC: Failed in _WCSFIT_ for $dsfile\n$errmsg\n");
                next;
            }

            # Work out zeropoint shift

	    $raref2 = ($raref2 - $raref1)*3600.0;
	    $decref2 = ($decref2 - $decref1)*3600.0;
	    my $outkey = sprintf("RAZP%d%d",$wcspass,$pass);
	    my $outcom = sprintf("[arcsec] Ref RA shift pass %d to %d (new - old)",
		$wcspass,$pass);
	    $status = 0;
	    $fptr = Astro::FITS::CFITSIO::open_file($dsfile,READWRITE,$status);
	    $fptr->movabs_hdu($j+1,$hdutype,$status);
	    $fptr->update_key(TFLOAT,$outkey,$raref2,$outcom,$status);
	    $outkey = sprintf("DECZP%d%d",$wcspass,$pass);
	    $outcom = sprintf("[arcsec] Ref Dec shift pass %d to %d (new - old)",
		$wcspass,$pass);
	    $fptr->update_key(TFLOAT,$outkey,$decref2,$outcom,$status);
	    $fptr->close_file($status);
            $frm->hdr("WCSPASS",$pass);

	}
    }

=head1 NAME

_WCSFIT_ -- Fit a WCS to an image

=head1 DESCRIPTION

This primitive cycles through all of the image extensions in an input file
and fits a WCS to the objects in each. The routine works in two modes.  In
first pass mode, an image detection is first done. In second pass mode, the
routines uses a pre-existing catalogue. The coverage of the image is calculated
in equatorial coordinates and some astrometric standards are extracted from
a catalogue in that coordinate range.  These are matched up to the coordinates
from the catalogue. (The equatorial coordinates for the object catalogue should
come either from the first pass WCS or a rough WCS).  The X,Y positions of
the matched objects are fitted against the equatorial coordinates to work out
the WCS parameters.  Equatorial coordinates of the centre of each frame are
calculated using the previous WCS and the new one.  This is the astrometric
shift.

=head1 ARGUMENTS

=over 4

=item CATSRC = char (Given)
 
The catalogue to use for astrometric fit. If set to 'local' then CATPATH must
be set.  Otherwise it can either be 'usno' or '2mass'.  These latter require
an internet connection and a value for SITE.

=item SITE
 
The distribution of VizieR that will be used to extract astrometric standards.
Can be:
 
=over 4
 
=item casu
 
CASU, Cambridge, UK
 
=item cds
 
CDS, Strasbourg, France
 
=item ukirt
 
UKIRT, Hawaii, USA
 
=item CATPATH = char (Given)

If CATSRC is 'local' this is the full path to a FITS table with your
astrometric standards

=item EQUINOX = float (Given)

The equinox of output WCS

=item OVERRIDE = int (Given)
 
If set, then any WCS that already exists in the header will be overwritten
 
=item PASS = int (Given)

The pass level of the WCS.  If this is set to 1, then a first pass WCS is fit.
This includes generating a shallow catalogue before fitting.  If this is set
to 2, then a pre-existing catalogue is used.
 
=back

=head1 NOTES

=over 4

=item *

If this is a second pass WCS, then the new WCS parameters are written to the
catalogue header.

=item *

A zeropoint shift is calculated between the input WCS and the output WCS. This 
is written to the file header as RAZPmn and DECZPmn where m is the pass level
of the input WCS and n is the pass level of the output WCS. Units are arcsec.

=back

=head1 AUTHORS

JRL: Jim Lewis (CASU, IoA)

=head1 COPYRIGHT

Copyright (C) 2003-2006 Cambridge Astronomy Survey Unit. 
All Rights Reserved

=cut
