# -*-cperl-*-

=head1 NAME

_MAKEMAP_FRAME_ - convert time-series data into an image

=head1 SYNOPSIS

  _MAKEMAP_FRAME_ PIXSIZE=7.5

  _MAKEMAP_FRAME_ MYCONFIG=1 NUMITER=10 BADFRAC=0.1

=head1 DESCRIPTION

This primitive takes time-series data for the current Frame and uses
SMURF MAKEMAP to construct an image. The user may specify either the
simple rebinning method or the full iterative solution.

For the iterative map-maker a configuration file must be specified. By
default, the system configuration file is used. However, the user may
override any parameter by specifying the B<MYCONFIG> parameter and
listing the name and new value of the parameter. See the documentation
for MAKEMAP for details on the available parameters.

The output file size is kept below 2 GB which in practice corresponds
to an image with about 60 million pixels (7745 pixels on a side, or
6.45 degrees on the sky for 3-arcsec pixels). Currently the primitive
creates a smaller image if the limit is exceeded. Each dimension is
reduced in proportion. The primitive aborts if the memory requirements
for processing the data exceeds that available.

This is a many to one operation, with only a single output file
created.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<INFILES>

A switch to determine how many files are given to makemap.  Valid
values are C<FRAME> (default) for all files in the current Frame
object, C<OBS> for all files which are part of the current
observation, or C<ALL> for all valid files for all Frames in the
current Group object.

=item B<METHOD>

Image reconstruction method. May be C<REBIN> to use a simple rebinning
scheme or C<ITER> to use the iterative map-maker. The default is
C<REBIN>.

=item B<MYCONFIG>

A flag to denote that the a user-defined config file is to be
used. Default is 0 (use system config file).

=item B<PIXSIZE>

Size of the output map pixels in arcsec. The default is wavelength
dependent (6 arcsec at 850 um, 3 arcsec at 450 um).

=item B<SYSTEM>

Coordinate system for output image. May be any supported by
C<AST>. Default is C<TRACKING>.

=item B<SPREAD>

Desired pixel-spreading scheme for the rebin method. May be either
C<NEAREST> for nearest-neighbour resampling or C<LINEAR> for bi-linear
resampling.  Default is C<NEAREST>.

=back

In addition, configuration parameters for B<MAKEMAP> may be specified,
provided the B<MYCONFIG> argument is true. See the B<MAKEMAP>
documentation for supported parameters.

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item SMURF

MAKEMAP

=item ORAC-DR PRIMITIVES

_GET_MAKEMAP_CONFIG_

=back

=head1 NOTES

The user should take care when calling with the B<INFILES> parameter
set to C<ALL> or C<OBS>. It is possible that makemap will be run
multiple times on almost the same set of data files. This is probably
not desireable. See L<_SUMMIT_STEER_|_SUMMIT_STEER_> and
L<_PROCESS_SCAN_DATA_|_PROCESS_SCAN_DATA_> for information on one way
to avoid this.

For B<INFILES>=C<FRAME> it is assumed that the data are not
flatfielded and thus dark frames need to be added to the list of input
files. Conversely, for C<ALL> it is assumed that the input data are
already flatfielded and thus there is no need for dark frames.

=head1 OUTPUT DATA

The Frame C<isgood> flag is set to false if MAKEMAP fails for any
reason.

The Frame uhdr entries C<EXP_TIME>, C<WEIGHTS>, C<SKY_SUBTRACTION> and
C<EXTINCTION> are set to 1 on success.

=head1 OUTPUT FILES

Creates a single output file with a C<_fmos> suffix.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2008-2009 University of British Columbia and the
Particle Physics and Astronomy Research Council. All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Define the maximum number of pixels in a tile
use constant MAXPIX => 60e6;

if ($Frm->uhdr("DARKONLY")) {
  # OK this is a dark Frame so we don't want to mosaic it
  $Frm->isgood(0);
  $Grp->check_membership;
  $Frm->uhdr("NOCALIB",1);

} else {
# Pixel size for output image
my $pixsize = get_prim_arg( $_PRIM_ARGS_, "PIXSIZE", $Cal->pixelscale);

# Output coordinate system - default is TRACKING
my $system = get_prim_arg( $_PRIM_ARGS_, "SYSTEM", "TRACKING");

# Pixel-spreading scheme
my $spread = lc(get_prim_arg( $_PRIM_ARGS_, "SPREAD", "nearest"));

# Reset to "nearest" if an unsupported scheme is given
if ( ($spread ne "nearest") && ($spread ne "linear") ) {
  orac_warn "Unsupported pixel-spreading scheme, $spread: using NEAREST\n";
  $spread = "nearest";
}

# Method for reconstructing map
my $method = lc(get_prim_arg( $_PRIM_ARGS_, "METHOD", "rebin"));
my $iterate = 0;
# Minimum match on method
if ( $method =~ /^iter/ ) {
  $method = "iterate";
  $iterate = 1;
} elsif ( $method =~ /^reb/ ) {
  $method = "rebin";
} else {
  orac_warn "Unrecognized MAKEMAP METHOD, $method: assuming REBIN\n";
  $method = "rebin";
}

# How many files are we making a map with?
my $infiles = get_prim_arg($_PRIM_ARGS_, "INFILES", "FRAME");

my @infiles;
if ( $infiles eq "FRAME" ) {
  @infiles = $Frm->files;

} elsif ( $infiles eq "OBS" ) {
  # Create a sub-group for the current observation only
  my $subGrp = $Grp->subgrp(OBSNUM => $Frm->hdr("OBSNUM"));
  foreach my $frmobj ( $subGrp->members ) {
    push (@infiles, $frmobj->files);
  }
} elsif ( $infiles eq "ALL" ) {
  foreach my $frmobj ( $Grp->members ) {
    push (@infiles, $frmobj->files);
  }
}

# Write list of filenames to a temp file
my $inlist = write_file_list( @infiles );

# Set output filename
my ($in, $out) = $Frm->inout('_fmos');
$out = $Frm->rewrite_outfile_subarray( $out );

# Now retrieve bad bolometer masks if present and set BPM parameter
my @bbms;
foreach my $subarray ( $Frm->subarrays ) {
  $Frm->uhdr("SUBARRAY",$subarray);
  push(@bbms, $Cal->mask) if ( defined $Cal->mask );
}

my $bbm ="!";
my $bbmfiles;
if ( @bbms ) {
  # Note bbm must be different from bbmfiles - simply overwriting the
  # return value from write_file_list will run the desctructor and
  # unlink the temp file
  $bbmfiles = write_file_list( @bbms );
  $bbm = "^" . $bbmfiles;
}

# Maximum map-size - set to 2 GB as a default, increase later if the
# iterative map-maker is being used and processing is done in memory.
# Makemap uses maxmem to denote the maximum amount of memory available
# to process the data, not necessarily the size of the output
# map. This primitive uses it to limit the output file size. The
# difference between the two usages amounts to about a factor of 2.
my $maxmem = 4096;

my $tiledims = int(sqrt(MAXPIX));

# Makemap argument list
my $args = "in=^$inlist out=$out pixsize=$pixsize spread=$spread bpm=$bbm "
          ."system=$system method=$method maxmem=$maxmem tiledims=$tiledims";

# Add CROTA=0 and ALIGNSYS=true for AzEl maps
$args .= " crota=0 alignsys=true" if ( uc($system) eq "AZEL");

my $config;
if ( $iterate ) {
  # Obtain a suitable config file
  my $myconfig = get_prim_arg( $_PRIM_ARGS_, "MYCONFIG",  0 );
  # A new config file might not always be necessary, but should
  # internal consistency checks fail, a modified version will have to
  # be written even if MYCONFIG is 0. Therefore pass in a suitable
  # ORAC::TempFile object.
  $config = new ORAC::TempFile;

  _GET_MAKEMAP_CONFIG_ ARGS=$_PRIM_ARGS_ CONFIG=$config
  $args .= " config=^".$_GET_MAKEMAP_CONFIG_{CONFIG};
}

# Call makemap - really must have some sort of feedback to user
orac_print "Calling makemap using $method method\n";
# First time round, determine number of pixels in the output map by
# setting out=! Use method=rebin to avoid needing to specify any
# further unecessary parameters.
orac_print "Checking output map size... ";
my $mapszargs = "in=^$inlist out=! pixsize=$pixsize method=rebin maxmem=$maxmem";
$Mon{smurf_mon}->obeyw("makemap","$mapszargs");
my ($ORAC_STATUS, @lbound) = $Mon{smurf_mon}->get("makemap","lbound");
($ORAC_STATUS, my @ubound) = $Mon{smurf_mon}->get("makemap","ubound");

my $xsize = $ubound[0] - $lbound[0] + 1;
my $ysize = $ubound[1] - $lbound[1] + 1;
my $outpix = $xsize*$ysize;
if ( $outpix > MAXPIX ) {
  orac_print "Old image dimensions are $xsize x $ysize\n";
  my $scalefactor = sqrt( MAXPIX/$outpix );
  my $newxsize = int($xsize * $scalefactor);
  my $newysize = int($newxsize * $ysize / $xsize);
  my $dx = int($xsize * ( 1.0 - $scalefactor ) / 2.0);
  my $dy = int($ysize * ( 1.0 - $scalefactor ) / 2.0);
  # Reduce the bounds equally.
  $lbound[0] += $dx;
  $ubound[0] -= $dx;
  $lbound[1] += $dy;
  $ubound[1] -= $dy;
  $scalefactor = sprintf "%5.3f", $scalefactor;
  $scalefactor *= (100*$scalefactor);
  orac_print "\n";
  orac_warn "Size will exceed 2 GB, reducing to include central $scalefactor % of mapped area\n";
  orac_print "New image dimensions are $newxsize x $newysize\n";
  # Append the new bounds to the list of arguments
  $args .= " lbnd=[$lbound[0],$lbound[1]] ubnd=[$ubound[0],$ubound[1]]";
} else {
  orac_print "Size within limits, no need to tile.\n";
}
# Now create output map using the new bounds if necessary
orac_print "Making map: this... may... take... a... while...\n";
my $SMURF_STATUS = $Mon{smurf_mon}->obeyw("makemap","$args");

# Delete temporary config file generated by this primitive if present
undef $config if ($config);

# Check for SMF__NOMEM return status
if ( $SMURF_STATUS == 235176770 ) {
  # Since makemap failed mark this frame as BAD so it's not included
  # in further processing. Throw an error to skip the rest of the recipe.
  $Frm->isgood(0);
  orac_throw "Output image will exceed maximum size $maxmem MB - will not continue\n";
} elsif ( $SMURF_STATUS == ORAC__OK ) {

  # Now, is there any analysis of the model component files that could
  # be useful?

  # Register the new file name
  $Frm->files( $out );

  # Set Frame EXP_TIME and WEIGHTS flags
  $Frm->uhdr("EXP_TIME",1);
  $Frm->uhdr("WEIGHTS",1);
  # And of course sky subtraction and extinction correction have been
  # applied, though there really isn't much point to setting these
  # other than a desire for consistency.
  $Frm->uhdr("SKY_SUBTRACTION",1);
  $Frm->uhdr("EXTINCTION",1);

  orac_print "Thank you for waiting; image $out created\n";
} else {
  # If makemap failed for any other reason, mark this frame as
  # BAD. Throw an error to skip the rest of the recipe.
  $Frm->isgood(0);
  orac_term "Makemap failed: data from this Frame will be ignored\n";
}

}
