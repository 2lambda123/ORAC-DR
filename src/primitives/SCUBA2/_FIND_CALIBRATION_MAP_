# -*-cperl-*-

=head1 NAME

_FIND_CALIBRATION_MAP_ - determine the map flux conversion factor

=head1 SYNOPSIS

 _FIND_CALIBRATION_MAP_

=head1 DESCRIPTION

For calibrators, finds the total integrated intensity
using L<_FIND_INTEGRATED_INTENSITY_|_FIND_INTEGRATED_INTENSITY_>
and calculates a flux conversion factor from the known flux
of the calibrator:

  fcf = P_sum /  S_tot

This value is then stored in the index file C<index.gains>.

Additionally, the peak response is calculated by finding the peak flux
and the fitted peak signal (derived from a 2-D Gaussian fit).

  fcf = P_peak / S_peak

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<GROUP>

True if the Group image should be used. Otherwise the current Frame is
used.

=item B<STORE>

Flag to denote whether to store the results in the Calibration
system. Default us 1 (yes).

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA

NDFTRACE

=item ORAC-DR PRIMITIVES

_ADD_FCF_LOG_ENTRY_, _FIND_INTEGRATED_INTENSITY_, _FIND_MAP_PEAK_

=back

=head1 NOTES

This primitive is frame based (C<$Frm>), though with care it may also
be used on Groups.

=head1 OUTPUT DATA

The FCF is stored in the calibration system in the file C<index.gains>.

If the FCF calculations were successful, the primitive hash
C<%_FIND_CALIBRATION_MAP_> contains a single key called C<FCF> which
contains a hash reference with the following keys:

=over 4

=item * ARCSEC

FCF per square arcsec

=item * BEAM

FCF per nominal beam size

=back

=head1 OUTPUT FILES

Entry in C<log.fcf> log file if the frame is a calibrator.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>
Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1  COPYRIGHT

Copyright (C) 2009-2010 University of British Columbia.
Copyright (C) 2008 Science and Technology Facilities Council.
Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

my $group = get_prim_arg($_PRIM_ARGS_, "GROUP", 0);

# Flag to denote whether to store the result in the Calibration system
my $store = get_prim_arg($_PRIM_ARGS_, "STORE", 1);

my $Obj = ( $group ? $Grp : $Frm );

# Retrieve the obsend parameter - normally this primitive only
# proceeds at the end of an observation
my $obsend = $Frm->uhdr("OBSEND");

# Always estimate an FCF in the QL pipeline
$obsend = 1 if ( defined $Frm->uhdr("QUICKLOOK") );

# Do nothing if there is no data to analyze
$obsend = 0 if $Frm->uhdr("DARKONLY");

# Check the observation has ended so an FCF can be calculated
if ( $obsend ) {
  # Precalculate filter
  my $filter = $Obj->uhdr("ORAC_FILTER");

  # Retrieve source name
  my $src = $Obj->uhdr("ORAC_OBJECT");

  my $flux;
  # If the source is not a calibrator, look for an appropriate flux
  # specified in recipe parameters. The flux will be calculated later
  # for known calibrator sources.
  if (!$Cal->iscalsource($src)) {
    if ( $filter =~ /850/ ) {
      $flux = $Frm->uhdr("RECPAR_FLUX_850");
    } else {
      $flux = $Frm->uhdr("RECPAR_FLUX_450");
    }
    if ( !defined $flux ) {
      orac_warn "Unable to calculate an FCF for non-calibrator source, $src: no flux specified for filter $filter\n";
      return ORAC__OK;
    }
  }

  my $in = $Obj->file;

  # Get the current units so we quote the calibration factor
  $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
  my ($ORAC_STATUS, $dataunits) = $Mon{ndfpack_mon}->get("ndftrace","units");

  # Find the peak signal in the image
  _FIND_MAP_PEAK_ LOGFILE=0 VERBOSE=0 GROUP=$group

  # Retrieve the position - if successful, continue on to derive
  # an FCF
  my $posn = $_FIND_MAP_PEAK_{POSITION};
  if (@$posn) {
    # Find the integrated intensity within a 1-arcmin diameter
    # aperture - no need to write a logfile
    _FIND_INTEGRATED_INTENSITY_ VERBOSE=0 IMAGE=$in XYPOS=$posn RADIUS=30

    # Retrieve the results
    my %results = ( BEAM => $_FIND_MAP_PEAK_{PEAK},
		    ARCSEC => $_FIND_INTEGRATED_INTENSITY_{TOTALFLUX} );

    my %fcf;

    # Loop over the different type of results
    foreach my $type (keys %results) {

      # Type specific configurations
      my ($ismap, $units);
      if ($type eq 'ARCSEC') {
	$ismap = 1;  # Need full integrated flux
	$units = "Jy/arcsec**2/$dataunits";
      } else {
	$ismap = 0;
	$units = "Jy/beam/$dataunits";
      }

      orac_print "Determining calibration of type $type";

      next unless (defined $results{$type});
      # Trap zero when things have gone very badly wrong
      if ( $results{$type} <= 0) {
	# This is obviously a Bad Thing (TM)
	orac_print " - Failed!\n";
	my $garbage = ($results{$type} == 0) ? "zero"
	  : "a negative flux measurement";
	orac_err "Calibration returned $garbage!\n";
	if ( !$group ) {
	  $Obj->isgood(0);
	  $Grp->check_membership;
	}
	orac_term "Unable to determine a FCF for this observation\n";
      } else {
	orac_print "\n";
      }

      # Now get the flux for this filter
      unless ( defined $flux ) {
	$flux = $Cal->fluxcal($src, $filter, $ismap);
      }

      # If we have a flux, store the FCF in the calibration system
      if (defined $flux) {
	orac_print "Flux ($type) = $flux; Data = ". $results{$type}. "\n";

	# Calculate the new gain
	my $fcf = $flux / $results{$type};

	# Store the result in the calibration system
	if ( $store ) {
	  # Announce the new gain
	  orac_print("Storing new gain for $filter: $fcf $units\n",'yellow');

	  # Set the current gain - add to index file
	  # This means that we have to create a hash with the
	  # new keyword GAIN and the selected filter FILTER
	  $Obj->uhdr("GAIN",$fcf);
	  $Obj->uhdr("UNITS", $type);

	  # Need to append type to file name so that the keys are unique
	  $Cal->gainsindex->add($Obj->file() ."_$type",
				{ %{$Obj->hdr}, %{$Obj->uhdr}});
	} else {
	  orac_print ("Derived FCF for $filter: $fcf $units\n", "yellow");
	}
	$fcf{$type} = $fcf;

	# Additionally it seems that a user-friendly logfile is
	# a requirement
	_ADD_FCF_LOG_ENTRY_ FILTER=$filter FCF=$fcf UNITS=$type GROUP=$group

      } else {
	orac_warn "Unable to calculate a flux for source $src\n";
      }

    }
    # Store results in primitive hash
    $_FIND_CALIBRATION_MAP_{FCF} = \%fcf;
  } else {
    # If this is a Frame object and no FCF could be determined then
    # the data are undoubtedly bad and should be ignored. In this case
    # terminate the recipe - there is no need to do anything more.
    if ( !$group ) {
      $Obj->isgood(0);
      $Grp->check_membership;
      orac_term "Unable to determine a FCF for this observation\n";
    } else {
      # Just issue a warning otherwise
      orac_warn "Unable to determine a FCF for this observation\n";
    }
  }

}
