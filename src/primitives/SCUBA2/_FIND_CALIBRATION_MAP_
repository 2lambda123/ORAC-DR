# -*-perl-*-

=head1 NAME

_FIND_CALIBRATION_MAP_ - determine the map flux conversion factor

=head1 SYNOPSIS

 _FIND_CALIBRATION_MAP_

=head1 DESCRIPTION

For calibrators, finds the total integrated intensity
using L<_FIND_INTEGRATED_INTENSITY_|_FIND_INTEGRATED_INTENSITY_>
and calculates a flux conversion factor from the known flux
of the calibrator:

  fcf = P_sum /  S_tot

This value is then stored in the index file C<index.gains>.

Additionally, the peak response is calculated by finding the
peak flux and the fitted peak signal.

  fcf = P_peak / S_peak

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<GROUP>

True if the Group image should be used. Otherwise the current Frame is
used.

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA

NDFTRACE

=item ORAC-DR PRIMITIVES

_ADD_FCF_LOG_ENTRY_, _FIND_INTEGRATED_INTENSITY_, _FIND_MAP_PEAK_

=back

=head1 NOTES

This primitive is frame based (C<$Frm>), though with care it may also
be used on Groups.

=head1 OUTPUT DATA

The FCF is stored in the calibration system in the file C<index.gains>.

=head1 OUTPUT FILES

Entry in C<log.fcf> log file if the frame is a calibrator.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>
Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1  COPYRIGHT

Copyright (C) 2009 University of British Columbia.
Copyright (C) 2008 Science and Technology Facilities Council.
Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

my $group = get_prim_arg($_PRIM_ARGS_, "GROUP", 0);

my $Obj = ( $group ? $Grp : $Frm );

my $obsend = ( $Frm->uhdr("OBSEND") ) ? 1 : 0;

$obsend = 0 if $Frm->uhdr("DARKONLY");

# Check that we are a calibrator (regardless of filter)
if ($Cal->iscalsource($Obj->uhdr("ORAC_OBJECT")) && $obsend ) {

  my $in = $Obj->file;

  # Get the current units so we quote the calibration factor
  $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
  my ($ORAC_STATUS, $dataunits) = $Mon{ndfpack_mon}->get("ndftrace","units");

  # Find the peak signal in the image
  _FIND_MAP_PEAK_ LOGFILE=0 VERBOSE=0 GROUP=$_PRIM_ARGS_->{GROUP}

  # Retrieve the position - if successful, continue on to derive
  # an FCF
  my $posn = $_FIND_MAP_PEAK_{POSITION};
  if (@$posn) {
    # Find the integrated intensity - no need to write a logfile
    _FIND_INTEGRATED_INTENSITY_  LOGFILE=0 VERBOSE=0 IMAGE=$in XYPOS=$posn

    # Retrieve the results
    my %results = ( BEAM => $_FIND_MAP_PEAK_{PEAK},
		    ARCSEC => $_FIND_INTEGRATED_INTENSITY_{TOTALFLUX} );

    # Precalculate filter
    my $filter = $Obj->uhdr("ORAC_FILTER");

    # Loop over the different type of results
    foreach my $type (keys %results) {

      # Type specific configurations
      my ($ismap, $units);
      if ($type eq 'ARCSEC') {
	$ismap = 1;  # Need full integrated flux
	$units = "Jy/arcsec**2/$dataunits";
      } else {
	$ismap = 0;
	$units = "Jy/beam/$dataunits";
      }

      orac_print "Determining calibration of type $type\n";

      next unless (defined $results{$type});

      # Now get the flux for this filter
      my $flux = $Cal->fluxcal($Obj->uhdr("ORAC_OBJECT"), $filter, $ismap);

      # If we have a flux, store the FCF in the calibration system
      if (defined $flux) {
	orac_print "Flux: $type $flux, ". $results{$type}. "\n";

	# Calculate the new gain
	my $fcf = $flux / $results{$type};

	# Announce the new gain
	orac_print("Storing new gain for $filter: $fcf $units\n",'yellow');

	# Set the current gain - add to index file
	# This means that we have to create a hash with the
	# new keyword GAIN and the selected filter FILTER
	$Obj->uhdr("GAIN",$fcf);
	$Obj->uhdr("UNITS", $type);

	# Need to append type to file name so that the keys are unique
	$Cal->gainsindex->add($Obj->file() ."_$type",
			      { %{$Obj->hdr}, %{$Obj->uhdr}});

	# Additionally it seems that a user-friendly logfile is
	# a requirement
	_ADD_FCF_LOG_ENTRY_ FILTER=$filter FCF=$fcf UNITS=$type GROUP=$group

      }

    }
  } else {
    # If this is a Frame object and no FCF could be determined then
    # the data are undoubtedly bad and should be ignored. In this case
    # terminate the recipe - there is no need to do anything more.
    if ( !$group ) {
      $Obj->isgood(0);
      $Grp->check_membership;
      orac_term "Unable to determine a FCF for this observation\n";
    } else {
      # Just issue a warning otherwise
      orac_warn "Unable to determine a FCF for this observation\n";
    }
  }

}
