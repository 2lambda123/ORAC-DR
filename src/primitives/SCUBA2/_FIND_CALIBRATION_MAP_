# -*-perl-*-

=head1 NAME

_FIND_CALIBRATION_MAP_ - determine the map flux conversion factor

=head1 SYNOPSIS

 _FIND_CALIBRATION_MAP_

=head1 DESCRIPTION

For calibrators, finds the total integrated intensity
using L<_FIND_INTEGRATED_INTENSITY_|_FIND_INTEGRATED_INTENSITY_>
and calculates a flux conversion factor from the known flux
of the calibrator:

  fcf = P_sum /  S_tot

This value is then stored in the index file C<index.gains>.

Additionally, the peak response is calculated by finding the
peak flux and the fitted peak signal.

  fcf = P_peak / S_peak

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<GROUP>

True if the Group image should be used. Otherwise the current Frame is
used.

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item ORAC-DR PRIMITIVES

_ADD_FCF_LOG_ENTRY_, _FIND_INTEGRATED_INTENSITY_, _FIND_MAP_PEAK_

=back

=head1 NOTES

This primitive is frame based (C<$Frm>).

=head1 OUTPUT DATA

The FCF is stored in the calibration system in the file C<index.gains>.

=head1 OUTPUT FILES

Entry in C<log.fcf> log file if the frame is a calibrator.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

=head1  COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.
Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

my $Obj = ($_PRIM_ARGS_->{GROUP} ? $Grp : $Frm );

my $obsend = ( $Frm->uhdr("OBSEND") ) ? 1 : 0;

$obsend = 0 if $Frm->uhdr("DARKONLY");

# Check that we are a calibrator (regardless of filter)
if ($Cal->iscalsource($Obj->uhdr("ORAC_OBJECT")) && $obsend ) {

  my $in = $Obj->file;

  # Find the peak
  _FIND_MAP_PEAK_ LOGFILE=0 VERBOSE=0 GROUP=$_PRIM_ARGS_->{GROUP}

  # Find the integrated intensity
  # turn off logfile in production code
  my $posn = $_FIND_MAP_PEAK_{POSITION};
  if (@$posn) {
      _FIND_INTEGRATED_INTENSITY_  LOGFILE=0 VERBOSE=0 IMAGE=$in XYPOS=$posn
  }

  # Retrieve the results
  my %results = (
		 BEAM => $_FIND_MAP_PEAK_{PEAK},
		 ARCSEC => $_FIND_INTEGRATED_INTENSITY_{TOTALFLUX},
		);

  # precalculate filter
  my $filter = $Obj->uhdr("ORAC_FILTER");

  # Loop over the different type of results
  foreach my $type (keys %results) {

    # Type specific configurations
    my ($ismap, $units);
    if ($type eq 'ARCSEC') {
      $ismap = 1;  # Need full integrated flux
      $units = "Jy/arcsec**2/pW";
    } else {
      $ismap = 0;
      $units = "Jy/beam/pW";
    }

    orac_print "Determining calibration of type $type\n";

    next unless defined $results{$type};

    # Now get the flux for this filter
    my $flux = $Cal->fluxcal($Obj->uhdr("ORAC_OBJECT"),
			     $filter, $ismap);

    if (defined $flux) {

      orac_print "Flux: $type $flux, ". $results{$type}. "\n";

      # Calculate the new gain
      my $fcf = $flux / $results{$type};

      # Announce the new gain
      orac_print("Storing new gain for $filter:".
		 " $fcf $units\n",'yellow');

      # Set the current gain - add to index file
      # This means that we have to create a hash with the
      # new keyword GAIN and the selected filter FILTER
      $Obj->uhdr("GAIN",$fcf);
      $Obj->uhdr("UNITS", $type);

      # Need to append type to file name so that the keys are unique
      $Cal->gainsindex->add($Obj->file() ."_$type",
			    { %{$Obj->hdr}, %{$Obj->uhdr}});

      # Additionally it seems that a user-friendly logfile is
      # a requirement
      _ADD_FCF_LOG_ENTRY_ FILTER=$filter FCF=$fcf UNITS=$type GROUP=$_PRIM_ARGS_->{GROUP}

    }

  }

}
