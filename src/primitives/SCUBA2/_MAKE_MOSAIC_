#! -*-perl-*-

=head1 NAME

_MAKE_MOSAIC_ - Main primitive for mosaicking images

=head1 SYNOPSIS

 _MAKE_MOSAIC_ USEGRP=1 COADD_MODE=RUNNING

 _MAKE_MOSAIC_ USEGRP=0 MAKEMOS=1

=head1 DESCRIPTION

This is the work-horse mosaicking primitive for SCUBA-2 data. It will
create a Frame or Group mosaic depending on the specified processing
flag. It is designed to be called from a wrapper primitive
specifically for processing either Frame or Group objects. 

The user has the choice of specifying the mosaicking application:
either makemos (CCDPACK) or wcsmosaic (KAPPA). Generally for quick
mosaics of similar data, the latter is used, while the former has more
advanced image combination features.

A check is made to see if the number of files to mosaic is greater
than the maximum allowed (a value which depends on the version of
CCDPACK or KAPPA installed), and if so the process is divided into
several steps to generate intermediate mosaicked files which are then
mosaicked at the end.

For producing a Group mosaic, the user has the option of creating a
running average or stacking all of the images in the Group object.

Other arguments control the method used to combine the images.

For mosaicking images in a SKY frame, a reference image must be
created. If a Grp file exists, that will be taken as the reference. If
not, then the Cal object is queried to return a reference image. If
there is no reference by this stage, then the C<SKYREF> parameter is
used to determine whether or not a new sky-aligned reference image
should be created.

=head1 ARGUMENTS

=over 4

=item B<MAKEMOS_METHOD>

The method to be used by MAKEMOS to combine the images. May be any
value supported by MAKEMOS (see MAKEMOS documentation for further
details). MEAN is the default.

=item B<METHOD>

Image resampling method used by WCSALIGN or WCSMOSAIC. May be any
value supported by those tasks. Default is C<nearest>
(nearest-neighbour).

=item B<GENVAR>

Flag to determine whether or not to use genvar when
mosaicking. Default is 1 (yes),

=item B<SKYREF>

Flag to indicate whether to align images in a SKY coordinate
frame. Default is 1 (yes). Note that this flag is only used if there
is no prior reference image. If set to 0 (no) then the images will be
aligned to the first image in the Frame, which may or may not be
desireable.

=item B<VERBOSE>

Flag to denote whether to display extra information. Default is 0
(no).

=back

=head1 KNOWN ISSUES

The check for the maximum number of files that can be mosaicked
($maxmos) is done only once, which means this primitive will fail if
the number of intermediate mosaics also exceeds the maximum number of
files. Thus the effective limit to the number of files to mosaic is
$maxmos**2. For the most recent versions of MAKEMOS and WCSMOSAIC,
this amounts to 1 million files.

=head1 EXTERNAL ALGORITHMS

=over 4

=item Starlink applications

CCDPACK MAKEMOS, KAPPA WCSMOSAIC

=item Other primitives

_ALIGN_ARRAYS_, _CREATE_REFERENCE_IMAGE_

=back

=head1 FILE SUFFIX

Creates a single output image with a suffix of '_fmos' for Frame
mosaics, or `_mos' for Group mosaics which is registered with the
appropriate object.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>,
Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2004-2007 Particle Physics and Astronomy Research
Council and University of British Columbia.  All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307, USA

=cut

# Should I be verbose (default to no)
my $verbose = (exists $_MAKE_MOSAIC_{VERBOSE} &&
               defined $_MAKE_MOSAIC_{VERBOSE}) ?
               $_MAKE_MOSAIC_{VERBOSE} : 0;

# Are we processing Group data?
my $usegrp = (exists $_MAKE_MOSAIC_{USEGRP} &&
	      defined $_MAKE_MOSAIC_{USEGRP}) ?
              $_MAKE_MOSAIC_{USEGRP} : 0;

# Do we want to take advantage of what makemos can do?
my $makemos = (exists $_MAKE_MOSAIC_{MAKEMOS} &&
	       defined $_MAKE_MOSAIC_{MAKEMOS}) ?
               $_MAKE_MOSAIC_{MAKEMOS} : 0;

# Are we aligning images in a SKY frame?
my $skyalign = (exists $_MAKE_MOSAIC_{SKYREF} &&
	       defined $_MAKE_MOSAIC_{SKYREF}) ?
               $_MAKE_MOSAIC_{SKYREF} : 1;

# Flag to determine whether or not to generate variances when mosaicking
my $genvar = (exists $_MAKE_MOSAIC_{GENVAR} &&
	      defined $_MAKE_MOSAIC_{GENVAR}) ?
              $_MAKE_MOSAIC_{GENVAR} : 1;

# Check that the installed version of Kappa has WCSMOSAIC
unless ( $makemos ) {
  if (starversion_lt('kappa', 'V1.5')) {
    $makemos = 1;
    orac_warn "Installed Kappa version does not support WCSMOSAIC, using WCSALIGN + MAKEMOS\n";
  }
}

# Method for determining the output pixel values
my $method = (exists $_MAKE_MOSAIC_{METHOD} &&
	      defined $_MAKE_MOSAIC_{METHOD}) ? 
              lc($_MAKE_MOSAIC_{METHOD}) : "nearest"; 

# Method for combining images in makemos
my $makemos_method = (exists $_MAKE_MOSAIC_{MAKEMOS_METHOD} &&
		      defined $_MAKE_MOSAIC_{MAKEMOS_METHOD}) ? 
                      lc($_MAKE_MOSAIC_{MAKEMOS_METHOD}) : "mean"; 

# Input and output files...
my $in;
my $out;

# Define the reference image. Use default coordinate frame
_GET_REFERENCE_IMAGE_ SKYREF=$skyalign VERBOSE=$verbose
my $refimage = $_GET_REFERENCE_IMAGE_{REFIMAGE};

# Retrieve coordinate system for the reference image
$Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$refimage mode=get name=system");
my ($ORAC_STATUS, $outsys) = $Mon{ndfpack_mon}->get("wcsattrib","value");
# Set flag for moving sources
my $moving = 0;
if ( uc($outsys) eq "GAPPT" ) {
  $moving = 1;
}

# Write text file with list of files to align and mosaic.
my $filelist = new ORAC::TempFile;
my $listhandle = $filelist->handle;
my $tmpout;
my $grpfrm;
my $nfiles;

# Now we obtain the list of files to mosaic - let user know
orac_print "Collecting files to mosaic...\n";
if ( $usegrp ) {
  # #################
  # GROUP PROCESSING
  # #################
  $grpfrm = "Group";
  my $coadd_mode = uc($_MAKE_MOSAIC_{COADD_MODE} || 'RUNNING');
  # If the group file does not exist we can treat this as if
  # the coadd option is STACKALL
  $coadd_mode = 'STACKALL' unless $Grp->file_exists;

  if ($coadd_mode eq 'RUNNING') {
    if ($Grp->file_exists) {
      $nfiles = 1;
      print {$listhandle} $Grp->file ."\n";
      
      # Align the images in the current Frm before calling makemos
      if ( $makemos ) {
	_ALIGN_ARRAYS_ REFIMAGE=$refimage METHOD=$method REBIN=0
      }

      orac_print("Setting attributes for moving sources\n") 
	if ( !$makemos && $moving );
      for my $fname ($Frm->files) {
	# If we're using wcsmosaic for a moving source, SkyRefIs must be
	# set to origin and AlignOffset to 1
	if ( !$makemos && $moving ) {
	  my $alignargs = "ndf=$fname mode=set name=skyrefis newval=origin";
	  $Mon{ndfpack_mon}->obeyw("wcsattrib","$alignargs");
	  $alignargs = "ndf=$fname mode=set name=alignoffset newval=1";
	  $Mon{ndfpack_mon}->obeyw("wcsattrib","$alignargs");
	}
	print {$listhandle} "$fname\n";
	$nfiles++;
      }
    } else {
      orac_warn "Managed to get into RUNNING average without a group file";
    }
  } elsif ($coadd_mode eq 'STACKALL') {
    # Combine all the frames from all the groups
    $nfiles = 0;
    for my $f ($Grp->members) {
      if ( $makemos ) {
	_ALIGN_ARRAYS_ REFIMAGE=$refimage METHOD=$method REBIN=0 FRAME_OBJ=$f
      }
      orac_print("Setting attributes for moving sources\n") 
	if ( !$makemos && $moving );
      for my $fname ($f->files) {
	# If we're using wcsmosaic for a moving source, SkyRefIs must be
	# set to origin and AlignOffset to 1
	if ( !$makemos && $moving ) {
	  my $alignargs = "ndf=$fname mode=set name=skyrefis newval=origin";
	  $Mon{ndfpack_mon}->obeyw("wcsattrib","$alignargs");
	  $alignargs = "ndf=$fname mode=set name=alignoffset newval=1";
	  $Mon{ndfpack_mon}->obeyw("wcsattrib","$alignargs");
	}
	print {$listhandle} "$fname\n";
	$nfiles++;
      }
    }
  } else {
    orac_err("Unrecognized COADD_MODE, $coadd_mode");
    my $ORAC_STATUS = ORAC__ERROR;
  }

  orac_print "GROUP mosaic: coadd_mode = $coadd_mode\n" 
    if $verbose;
  # Define output file for Group images HACK
  if ( $usegrp ) {
    $tmpout = new ORAC::TempFile(0);
    $out = $tmpout->file;
  }
} else {
  # #################
  # FRAME PROCESSING
  # #################
  $grpfrm = "Frame";
  orac_print "FRAME mosaic\n" if $verbose;

  # Align images in the current Frm to a reference image
  if ( $makemos ) {
    _ALIGN_ARRAYS_ METHOD=$method REFIMAGE=$refimage
  }

  # Write names of all files to temp file
  orac_print("Setting attributes for moving sources\n") 
    if ( !$makemos && $moving );
  $nfiles = 0;
  for my $fname ($Frm->files) {
    # If we're using wcsmosaic for a moving source, SkyRefIs must be
    # set to origin and AlignOffset to 1
    if ( !$makemos && $moving ) {
      my $alignargs = "ndf=$fname mode=set name=skyrefis newval=origin";
      $Mon{ndfpack_mon}->obeyw("wcsattrib","$alignargs");
      $alignargs = "ndf=$fname mode=set name=alignoffset newval=1";
      $Mon{ndfpack_mon}->obeyw("wcsattrib","$alignargs");
    }
    print {$listhandle} "$fname\n";
    $nfiles++;
  }
  # Create output filename, derived from first input file
  # since this is a many to one operation
  ($in, $out) = $Frm->inout('_fmos', 0);
}
$listhandle->close;

# Done with image assembly, now mosaic the images
# First, some user feedback
my $mostask;
if ( $makemos ) {
  $mostask = "MAKEMOS";
} else {
  $mostask = "WCSMOSAIC";
}

orac_print "Mosaicking $grpfrm file with $mostask: combining $nfiles files\n";
my $args;
# Retrieve name of file containing list of images to mosaic
my $moslist = $filelist->file;
if ( $makemos ) {
  # MAKEMOS

  # Now, if we are using makemos, we need to deal with the finite
  # number of images that can be mosaicked simultaneously, currently
  # 1000 but it was only 100 in older versions of CCDPACK.
  my $maxmosfiles = (starversion_lt('ccdpack', 'V4.0-17')) ? 100 : 1000;

  my $maxmossq = $maxmosfiles*$maxmosfiles;
  if ( $nfiles > $maxmossq ) {
    orac_err "Unable to mosaic images: number of input files, $nfiles, exceeds capacity, $maxmossq\n";
  }

  # Declare variable names for list of intermediate mosaics, array of
  # intermediate mosaics ORAC::TempFile objects and list of filenames
  # in current intermediate mosaic. This must be done here because we
  # need these variables to remain in scope outside the block which
  # creates the intermediate mosaics.
  my ($intermoslist, @intermosaics, @mosaiclist);

  # Check number of files and generate intermediate mosaics if necessary
  if ( $nfiles > $maxmosfiles ) {
    use POSIX qw/ ceil /;
    my $nsteps = ceil($nfiles/$maxmosfiles);
    my $stepsize = ceil($nfiles/$nsteps);
    orac_print "Creating $nsteps intermediate mosaics, each of $stepsize images ...";

    # General arguments for makemos
    $args = ($genvar) ? " genvar usevar" : " nousevar";
    $args .= " method=$makemos_method";

    # Create the temporary files to hold the intermediate mosaic file
    # lists: there are $nsteps of them
    for my $j (1 .. $nsteps) {
      my $mosfile = new ORAC::TempFile(0);
      push (@intermosaics, $mosfile);
    }

    # Read filenames from master file list - note filenames will
    # include a line terminator, but this is OK since they will need
    # those be written out as well.
    open my $listhandle, "< $moslist" or die "Unable to open file, $moslist : $!\n";
    my @allfiles = <$listhandle>;

    # Loop over number of steps, define start and end index into array
    # of all files and write only those to the intermediate mosaic
    # list file. There will be $stepsize number of images in each of
    # these files. Run makemos with this shorter list of images.
    my $curmosfile;
    for my $i (1 .. $nsteps ) {
      # Retrieve name of current intermediate mosaic
      $curmosfile = $intermosaics[$i-1];

      # Define start and end indices of array of images to include
      my $start = ($i-1) * $nsteps;
      my $end = $start + $stepsize - 1;

      # Write out array slice to intermediate mosaic input file list
      my $tmplist = new ORAC::TempFile;
      print {$tmplist->handle} @allfiles[$start..$end];

      # Run makemos
      my $mosargs = "in=^".$tmplist->file." out=".$curmosfile->file."$args";
      $Mon{ccdpack_reg}->obeyw("makemos","$mosargs");
      push (@mosaiclist, $curmosfile->file);
    }

    # Reset the extra args to generate and use variances
    $args = " genvar usevar";

    # Create new list of input images to make the final mosaic
    $intermoslist = new ORAC::TempFile;
    print {$intermoslist->handle} join("\n",@mosaiclist[0..$#mosaiclist]);
    $moslist = $intermoslist->file;
  }

  my $mosargs = "in=^".$moslist." method=$makemos_method ref=$refimage "
            ."nozero noscale out=$out title=".$Frm->hdr('OBJECT')."$args";
  $Mon{ccdpack_reg}->obeyw("makemos","$mosargs");

} else {
  # WCSMOSAIC
  my $wlim = 0.2;
  # Note that to get wcsmosaic to calculate a variance based on
  # variances already present in the input files the genvar parameter
  # must be set to FALSE.
  my $weighting = ( $usegrp ) ? "genvar=false variance=true" : 
    "genvar=true variance=true";
  my $args = "ref=$refimage method=$method lbnd=! ubnd=! wlim=$wlim ".
    "out=$out in=^".$moslist." $weighting";
  $Mon{kappa_mon}->obeyw("wcsmosaic","$args");
}

# HACK for renaming group output
if ( $usegrp ) {
  my $outname = $Grp->file;
  $outname .= "_mos" unless $outname =~ /_mos$/; # horrible hack KLUGE

  rename $out .".sdf", $outname .".sdf" 
    or die "Error renaming temp file to output Group mosaic"; # horrible hack KLUGE

  # Register new output file with Grp
  $Grp->file( $outname );
} else {
  # Register new Frm file names
  $Frm->files( $out );
}
orac_print " done.\n";
