#! -*-perl-*-

=head1 NAME

_EXTINCTION_CORRECT_FRAME_

=head1 SYNOPSIS

  _EXTINCTION_CORRECT_FRAME_ EXTCOR=QUICK

=head1 DESCRIPTION

This primitive corrects each image in the current Frame for
atmospheric extinction. The method for deriving the correction can be
specified by the user depending on how accurate it should be and/or
how fast it should be applied. The default is to use the quickest
method possible, which is to calculate a mean optical depth and
airmass for all the files in the current Frame and multiply each file
by the same correction factor.

In FULL mode SMURF EXTINCTION is used to apply the extinction
correction on a per-pixel basis using information from the WVM stored
in the internal RTS state structure (if the input is timestream data)
or the WVM reading in the FITS header (if the input is 2-D image
data).

In QUICK mode, SMURF EXTINCTION is used to apply an extinction
correction to each frame using the mean optical depth stored in the
FITS header for that file.

In QUICKER mode the extinction correction is calculated as a single
value and is applied to all images in the Frame object using the KAPPA
CMULT routine.

=head1 ARGUMENTS

=over 4

=item B<EXTCOR>

Type of extinction correction to be applied. If set to FULL, then an
accurate pixel-level correction is applied taking into account the
airmass of individual pixels. If set to QUICKER then the image is
corrected assuming a single value for the airmass across the image for
all images in the current Frame. An intermediate level correction may
be applied by specifying QUICK whereby the airmass and optical depth
for each file is used to correct that file. Default value is
C<QUICKER>.

=back

=head1 EXTERNAL TASKS

=over 4

=item Starlink 

KAPPA: CMULT, SMURF: EXTINCTION

=back

=head1 KNOWN ISSUES

To be accurate the mean tau and airmass should be read from each
subframe rather than a mean for the entire observation. This also
requires that the extinction correction occurs before mosaicking
in the non-QuickLook recipe.

Note that this primitive relies on SMURF using its own internal tau
conversion methods. For consistency these should be identical to those
in JCMT::Tau.

=head1 OUTPUT FILES

Creates output files with suffix C<_ext>

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2004-2008 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA

=cut

unless ( $Frm->uhdr("EXTINCTION") ) {

  # Read the extinction correction argument if present
  my $extcor = uc(get_prim_arg($_PRIM_ARGS_, "EXTCOR", "QUICKER" ));

  # Check for valid value, use QUICKER if not recognized
  unless ( ( $extcor eq "QUICK" ) || ( $extcor eq "QUICKER" ) || ( $extcor eq "FULL" ) ) {
    orac_warn "Unrecognized extinction correction method, $extcor: assuming QUICKER\n";
    $extcor = "QUICKER";
  }

  # Tell user what we're doing
  orac_print "Correcting for extinction using $extcor method\n";

  # Define list of input and output files
  my ($inlist, $outlist, @out) = write_file_list_inout($Frm, "_ext");

  if ( $extcor eq 'FULL' ) {
    # Check input data for dimensionality as the `FULL' method means
    # different things depending on whether the data are in the form of
    # 2-D images or 3-D timestream.

    # Use the fact that all images in a Frm will have same
    # dimensionality. Use first file in Frm.
    $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=".$Frm->file);
    my ($ORAC_STATUS, $ndim) = $Mon{ndfpack_mon}->get("ndftrace","ndim");
 
    # Check for 2 or 3-D and set method accordingly
    my $extmethod;
    if ( $ndim == 2 ) {
      # For method CSOTAU we will let the extinction task select the
      # value from the header
      $extmethod = "CSOTAU";
    } elsif ( $ndim == 3 ) {
      # Else use the raw WVM data
      $extmethod = "WVMR";
    }
    # Process all files at once since they share arguments
    my $extargs = "in=^$inlist out=^$outlist method=$extmethod noquick hasskyrem accept";
    $Mon{smurf_mon}->obeyw("extinction",$extargs);
  } elsif ( $extcor eq 'QUICK' ) {

    # Use the QUICK method, let extinction obtain MEANWVM from FITS
    # header
    my $extargs = "in=^$inlist out=^$outlist method=CSOTAU csotau=! quick hasskyrem";
    $Mon{smurf_mon}->obeyw("extinction",$extargs);

  } else {
    # OK if the user has not specified FULL or QUICK then use the
    # quickest possible method, QUICKER

    # Use mean values from FITS header

    # CSO Tau - use average of first and last value. If tau changes
    # significantly over the duration of the Frame then this method is
    # not appropriate.
    my $tau;
    if (defined $Frm->hdrval('WVMTAUST', 0 ) && defined $Frm->hdrval('WVMTAUEN',-1)) {
      my $csotau = 0.5*($Frm->hdrval('WVMTAUST', 0) + $Frm->hdrval('WVMTAUEN',-1));

      # Get wavelength via name of filter. Assume that the string `850' or
      # `450' will form part of the filter name.
      my $filter = $Frm->uhdr('ORAC_FILTER');
      my $wavelen = ( $filter =~ /850/ ) ? "850" : "450";

      # Use JCMT::Tau module for tau conversions
      use JCMT::Tau;
      # Convert WVM TAU (which is 225 GHz) to filter TAU
      if (defined $csotau && $csotau > 0) {
        ($tau, my $status) = get_tau( $wavelen, 'CSO', $csotau );
      } else {
        orac_warn "Using a tau of 0.0. CSO tau information unavailable.\n";
        $tau = 0.0;
      }
    } else {
      orac_warn "Unable to determine a tau value. Using 0.\n";
      $tau = 0.0;
    }

    # Pseudo-average Airmass, should be close enough
    my $airmass;
    if (defined $Frm->hdrval('AMSTART',0)) {
      $airmass = 0.5 * ($Frm->uhdr('ORAC_AIRMASS_START') +
			$Frm->uhdr('ORAC_AIRMASS_END'));
    } else {
      orac_warn "Unable to determine airmass of observation. Using 1.0\n";
      $airmass = 1;
    }

    # Extinction correction factor
    my $extcor = exp($tau*$airmass);

    # Apply same multiplier to each frame
    $Mon{kappa_mon}->obeyw("cmult","in=^$inlist scalar=$extcor out=^$outlist");
  }

  # Register new file names
  $Frm->files( @out );

  # Print Done message and set uhdr flag
  orac_print "Extinction corrected (method = $extcor) \n";
  $Frm->uhdr("EXTINCTION",1);
} else {
  orac_warn "Extinction correction already applied to this Frame\n";
}
