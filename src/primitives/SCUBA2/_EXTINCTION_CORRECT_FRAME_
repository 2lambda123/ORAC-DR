#! -*-perl-*-

=head1 NAME

_EXTINCTION_CORRECT_FRAME_

=head1 SYNOPSIS

  _EXTINCTION_CORRECT_FRAME_ EXTCOR_MODE=QUICK

=head1 DESCRIPTION

This primitive corrects each image in the current Frame for
atmospheric extinction. The method for deriving the correction can be
specified by the user depending on how accurate it should be and/or
how fast it should be applied. The default is to use the quickest
method possible, which is to calculate a mean optical depth and
airmass for all the files in the current Frame and multiply each file
by the same correction factor.

In FULL mode SMURF EXTINCTION is used to apply the extinction
correction on a per-pixel basis using information from the WVM stored
in the internal RTS state structure (if the input is timestream data)
or the WVM reading in the FITS header (if the input is 2-D image
data).

In QUICK mode, SMURF EXTINCTION is used to apply an extinction
correction to each frame using the mean optical depth stored in the
FITS header for that file.

In QUICKER mode the extinction correction is calculated as a single
value and is applied to all images in the Frame object using the KAPPA
CMULT routine.

=head1 ARGUMENTS

=over 4

=item B<EXTCOR_MODE>

EXTCOR_MODE determines which extinction correction is applied. If set
to FULL, then an accurate pixel-level correction is applied taking
into account the airmass of individual pixels. If set to QUICKER then
the image is corrected assuming a single value for the airmass across
the array. An intermediate level correction may be applied by
specifying QUICK whereby the airmass and optical depth for each image
is used to correct that image.

=back

=head1 EXTERNAL TASKS

=over 4

=item Starlink 

KAPPA: CMULT, SMURF: EXTINCTION

=back

=head1 KNOWN ISSUES

To be accurate the mean tau and airmass should be read from each
subframe rather than a mean for the entire observation. This also
requires that the extinction correction occurs before mosaicking
in the non-QuickLook recipe.

Note that this primitive relies on SMURF using its own internal tau
conversion methods. For consistency these should be identical to those
in JCMT::Tau.

=head1 OUTPUT FILES

Creates output files with suffix C<_ext>

=head1 NOTES

Timing tests show that QUICKER is not any quicker than QUICK so it may
be deprecated.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2004-2007 University of British Columbia and the
Particle Physcis and Astronomy Research Council. All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA

=cut

unless ( $Frm->uhdr("EXTINCTION") ) {

# Read the extinction correction argument if present
my $extcor_mode = uc(get_prim_arg($_PRIM_ARGS_, "EXTCOR_MODE", "QUICKER" ));

my @out;

orac_print "Correcting for extinction in $extcor_mode mode\n";
if ( $extcor_mode eq 'FULL' ) {

  # Check input data for dimensionality as the `FULL' method means
  # different things depending on whether the data re in the form of
  # 2-D images or 3-D timestream.

  # Use the fact that all images in a Frm will have same
  # dimensionality. Use first file in Frm.
  $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=".$Frm->file);
  my ($ORAC_STATUS, $ndim) = $Mon{ndfpack_mon}->get("ndftrace","ndim");
 
  # Check for 2 or 3-D and set method accordingly
  my $extmethod;
  if ( $ndim == 2 ) {
    # For method CSOTAU we will let the extinction task select the
    # value from the header
    $extmethod = "CSOT";
  } elsif ( $ndim == 3 ) {
    # Else use the raw WVM data
    $extmethod = "WVMR";
  }

  # Process all files at once since they share arguments
  my ($inlist, $outlist, @outfiles) = write_file_list_inout($Frm, "_ext");
  my $extargs = "in=^$inlist out=^$outlist method=$extmethod noquick hasskyrem accept";
  $Mon{smurf_mon}->obeyw("extinction",$extargs);
  push(@out, @outfiles);

} elsif ( $extcor_mode eq 'QUICK' ) {

  # process files one at a time since the mean wvm value can change
  # during a single frame.
  for my $i (1..$Frm->nfiles) {
    # Tau at 225 GHz for this file
    my $csotau = sprintf "%5.3f", $Frm->hdrval('MEANWVM', ($i-1));

    my ($in, $out) = $Frm->inout('_ext',$i);
    push(@out, $out);

    my $extargs = "in=$in out=$out method=CSOTAU csotau=$csotau quick hasskyrem";
    $Mon{smurf_mon}->obeyw("extinction",$extargs);
  }

} elsif ( $extcor_mode eq 'QUICKER' ) {

  # Use mean values from FITS header
  my ($tau, $airmass);
  # CSO Tau - average of all values in current Frm
  my $csotau = sprintf "%5.3f", 0.5*($Frm->hdrval('WVMTAUST', 0) + 
				     $Frm->hdrval('WVMTAUEN',-1));

  # Get wavelength vie name of filter. Assume that the string `850' or
  # `450' will form part of the filter name.
  my $filter = $Frm->hdr('FILTER');
  my $wavelen = ( $filter =~ /850/ ) ? "850" : "450";

  # Use JCMT::Tau module for tau conversions
  use JCMT::Tau;
  # Convert WVM TAU (which is 225 GHz) to filter TAU
  ($tau, my $status) = get_tau( $wavelen, 'CSO', $csotau );

  # Airmass
  $airmass = 0.5 * ($Frm->hdrval('AMSTART',0) + $Frm->hdrval('AMEND',-1));

  # Extinction correction factor
  my $extcor = exp($tau*$airmass);

  # Apply same multiplier to each frame
  my ($inlist, $outlist, @outfiles) = write_file_list_inout($Frm, "_ext");
  $Mon{kappa_mon}->obeyw("cmult","in=^$inlist scalar=$extcor out=^$outlist");
  push(@out,@outfiles);

} else {
  orac_err("Unrecognized EXTCOR_MODE, $extcor_mode");
  my $ORAC_STATUS = ORAC__ERROR;
}

# Register new file names
$Frm->files( @out );

orac_print "Extinction corrected (mode = $extcor_mode) \n";

$Frm->uhdr("EXTINCTION",1);

} else {
  orac_warn "Extinction correction already applied to this Frame\n";
}
