# -*-perl-*-

=head1 NAME

_CENTROID_IMAGE_

=head1 DESCRIPTION

Find the centroid of the given image. Assumes that the centroid is
near the origin in axis coordinates, and that there is only one source
in the image.

Assumes that the peak value in the map is the value of the pixel at
the centroid position. This is not necessarily true though if the
centroid position contains a spike.

Returns C<undef> if the centroid could not be determined.

=head1 TASKS

Uses the KAPPA CENTROID task.

=head1 ARGUMENTS

=over 4

=item B<IMAGE>

Input image. If no image is given then the GROUP argument is used to
determine whether to use the current Group or Frame image.

=item B<BOX>

Size of search box in each dimension. Default is 9 pixels.

=item B<GROUP>

Flag to denote whether to use the current Group image or Frame
image. True (1) indicates use the Group image; else use the Frame
image. The presence of the IMAGE argument overrides this parameter.

=item B<SYSTEM>

Coordinate system in which to determine the centroid position. Default
is the current system.

=item B<OFFSET>

A flag to denote whether to return the centroid in offset
coordinates. A value of 1 (true) will set the SkyRefIs attribute to
C<Origin>, if it is not already set. The default value of 0 (false)
will leave this attribute unchanged (thus if the file is already in an
offset frame, the answer will still be returned in offset
coordinates).

=item B<VERBOSE>

Flag to indicate whether informational messages should be 
given to the user. Default is 1 (true).

=back

=head1 OUTPUT DATA

On completion the primitive hash C<%_CENTROID_IMAGE_> contains
the following keys:

=over 4

=item RESULTS

An array containing the X, Y position of the source in the current
coordinate frame. These are set to C<undef> if the centroid could not
be determined.

=back

=head1 NOTE

The frame object is not updated.

If an image is already in an offset frame, the B<OFFSET> parameter
should be set to 0.

This primitive is essentially a single-image version of
_CENTROID_FRAME_ and as such looks very similar.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2007 the University of British Columbia. All Rights
Reserved.

=cut

use NDF;

# Set input file - leave undefined if not specified
my $in = ( exists $_CENTROID_IMAGE_{IMAGE} ) && 
         ( defined $_CENTROID_IMAGE_{IMAGE}) ? 
         $_CENTROID_IMAGE_{IMAGE} : undef;

# Should I be verbose? (Default to yes)
my $verbose = (exists $_CENTROID_IMAGE_{VERBOSE} && 
	       defined $_CENTROID_IMAGE_{VERBOSE}) ?
               $_CENTROID_IMAGE_{VERBOSE} : 1;

# If not input file was defined use the current group or frame
unless ( defined $in ) {
  # Determine if the user wants to use the current stacked Grp or Frm
  # image
  my ($Obj, $Frmgrp);
  my $group = defined( $_CENTROID_IMAGE_{GROUP} ) ? 
    $_CENTROID_IMAGE_{GROUP} : 0;
  if( $group ) {
    $Obj = $Grp;
    $Frmgrp = "Grp";
  } else {
    $Obj = $Frm;
    $Frmgrp = "Frm";
  }
  if ( $Obj->nfiles == 1 ) {
    $in = $Obj->file;
  } else {
    orac_throw "Error: _CENTROID_IMAGE_ must be run on the $Frmgrp after images have been combined\n";
  }
}

my $box = ( $_CENTROID_IMAGE_{BOX} || 9 );

my $ORAC_STATUS;

# Check that we have sufficient number of good pixels to continue
$Mon{kappa_mon}->obeyw("stats","ndf=$in");
($ORAC_STATUS, my $numgood) = $Mon{kappa_mon}->get("stats","numgood");

# Define the minimum number of useful pixels as (2*$box)^2
if ( $numgood > 4.*$box*$box ) {

# Select the requested coordinate frame
my $cosys_out = (exists $_CENTROID_IMAGE_{SYSTEM} &&
		 defined $_CENTROID_IMAGE_{SYSTEM}) ? 
                 lc($_CENTROID_IMAGE_{SYSTEM}) : ""; 

my $cosys_in;
unless ( $cosys_out eq "" ) {
  $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=get name=system");
  ($ORAC_STATUS, $cosys_in) = $Mon{ndfpack_mon}->get("wcsattrib","value");
  $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=set name=system newval=$cosys_out");
}

# Are we insisting that the the centroid be returned in Offset
# coordinates? Default is no: use the current system.
my $offset = ($_CENTROID_IMAGE_{OFFSET} || 0);
# Set the default initial position - this only changes if we are not
# working in an offset coordinate system
my $initpos = "0,0";
# Check if we need to set it first
$Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=get name=skyrefis");
($ORAC_STATUS, my $skyrefis) = $Mon{ndfpack_mon}->get("wcsattrib","value");
# If we are not in an offset coord system...
if ( lc($skyrefis) eq "ignored" ) {
  # Do we want to change to an offset coord system?
  if ( $offset ) {
    $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=set name=skyrefis newval=origin");
    orac_print "Centroid will be determined in offset coordinates\n" if ($verbose);
  } else {
    # If we don't want offset, retrieve the formatted WCS position of
    # the peak. NOTE: this will be fooled by the presence of a spike
    # FUTURE: dealing with spikes, may need an iterative procedure
    # (clip= option in stats).
    $Mon{kappa_mon}->obeyw("stats","ndf=$in");
    ($ORAC_STATUS, $initpos) = $Mon{kappa_mon}->get("stats","maxwcs");
  }
}

# Initialize the results array
$_CENTROID_IMAGE_{RESULTS} = [];

# Need to check for kappa 0.14 or higher -- use the KAPVERSION_MINOR
# global variable
my $args;
if (starversion_lt('kappa','V0.14-0')) {
  $args = " cosys=d init=[$initpos]";
} else {
  # If we have KAPPA14 we have to first make sure the wcsframe is AXIS
  # so that we can start searching from the coordinate centre
#  $Mon{ndfpack_mon}->obeyw("wcsframe","ndf=$in frame=axis");
  $args = " init='".$initpos."' ";
}

$args .= " mode=i cerror=true search=$box";

$ORAC_STATUS = $Mon{kappa_mon}->obeyw("centroid","ndf=$in $args");
if ( $ORAC_STATUS == ORAC__OK ) {
  # Read the result
  my @centre;

  # KAPPA 14 returns the centre pos as a string, earlier versions
  # return an array -- just use XCEN and YCEN with two ADAM calls
  ($ORAC_STATUS, $centre[0]) = $Mon{kappa_mon}->get("centroid","xcen");
  ($ORAC_STATUS, $centre[1]) = $Mon{kappa_mon}->get("centroid","ycen");

  # Store the results
  $_CENTROID_IMAGE_{RESULTS} = [@centre];

  # Reset the coordinate system if necessary
  unless ( $cosys_out eq "" ) {
    $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=set name=system newval=$cosys_in");
  }
} else {
  orac_warn "Unable to determine position of centroid\n";
  # Store the results
  $_CENTROID_IMAGE_{RESULTS} = [undef,undef];
  $ORAC_STATUS = ORAC__OK;
}
# Reset the SkyRefIs parameter if necessary
if ( $offset ) {
  if ( lc($skyrefis) eq "ignored" ) {
    $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=set name=skyrefis newval=$skyrefis");
  }
}

} else {
  orac_warn "Unable to determine centroid: insufficient number of good pixels\n";
  $_CENTROID_IMAGE_{RESULTS} = [undef,undef];
}
