#! -*-perl-*-

=head1 NAME

_ANALYZE_FLATFIELD_ - Analyze the current flatfield solution

=head1 SYNOPSIS

_ANALYZE_FLATFIELD_ 

=head1 DESCRIPTION

Analyze the current flatfield solution and compare with previous
flatfields

This is a Frame operation and should be used before group operations.

=head1 ARGUMENTS

This primitive supports the following arguments

=over 4

=item B<VERBOSE>

How much verbiage do you want? Default is 1 (yes, lots please).

=back

=head1 External Tasks

The following external tasks are used:

=over 4

=item KAPPA

Insert kappa tasks here....

=back

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2008 the University of British Columbia.  All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA

=cut

# compare the new values with the previous flatfield and flag any
# large differences

# create a flag file containing the names of each subarray that was processed
# (similar naming convention to pointing/focus)

# @outfiles contains the list of output flatfield solutions - store in
# the calibration object - must set the appropriate subarray first


# Flatfield can only be calculated after the observation has ended
if ( $Frm->uhdr("OBSEND") ) {

  # Loop over subarrays... Use subgrps method to return list of Groups
  # sorted by subarray
  my @Grps = $Grp->subgrps( "SUBARRAY" );
  
  foreach my $Subgrp ( @Grps ) {
    my @frames = $Subgrp->allmembers;
    # Hmm what if @frames contains >1 ?
    foreach my $Frmobj ( @frames ) {
      # Retrieve flatfield solution
      my $flatfile = $Frmobj->file(1);
      # Get responsivity file - this will be the same as the flatfile
      # if there is responsivity file in the current Frame object
      my $respfile = $Frmobj->file(2);

      # Check if we really have a responsivity file
      my $subarray = $Frmobj->hdr('SUBARRAY');
      if ($respfile eq $flatfile ) {
	orac_warn "No responsivity file for subarray $subarray\n";
      } else {
	# Analyze resp file - use HISTAT
	_FIND_IMAGE_STATISTICS_ IMAGE=$respfile COMP=err
	my %results = %{ $_FIND_IMAGE_STATISTICS_{RESULTS} };
	# Now get the std deviation using plain STATS
	_FIND_IMAGE_STATISTICS_ IMAGE=$respfile COMP=err HISTAT=0 VERBOSE=0
	$results{SIGMA} = $_FIND_IMAGE_STATISTICS_{RESULTS}->{SIGMA};

	# Print out results from current solution
	orac_print ("---- Uncertainties in responsivity fits for subarray $subarray ---- \n", "green");
	foreach my $stat ( qw/ MEAN MEDIAN SIGMA MAX MIN / ) {
	  my $value = sprintf "%11.4f", $results{$stat};
	  # Align the output for easy reading
	  my $outstat = sprintf "%-8s", $stat;
	  orac_print ( " $outstat = $value A/W\n", "green");
	}
	orac_print (" NGOOD    = $results{NUMGOOD} solutions\n", "green");

	# Compare these values with the previous ones if they exist
	my %previous;
	if ( defined $Cal->respstats ) {
	  %previous = %{ $Cal->respstats($subarray) };
	  orac_print "\nComparing with previous solution\n";
	} else {
	  # If nothing stored in the in-memory Cal system, attempt to
	  # get a suitable entry from the index file
	  my $previous = $Cal->resp;
	  if ( defined $previous ) {
	    orac_print "\nComparing with previous solution in file $previous\n";
	    _FIND_IMAGE_STATISTICS_ IMAGE=$previous COMP=err VERBOSE=0
	    %previous = %{ $_FIND_IMAGE_STATISTICS_{RESULTS} };
	    # Now get the std deviation using plain STATS
	    _FIND_IMAGE_STATISTICS_ IMAGE=$respfile COMP=err HISTAT=0 VERBOSE=0
            $previous{SIGMA} = $_FIND_IMAGE_STATISTICS_{RESULTS}->{SIGMA};
	  }
	}
	# Bulk comparisons go here if we have the data to compare
	if ( %previous ) {
	  # Inform the user of the changes between the current and
	  # previous solutions
	  orac_print ("---- Changes from previous flatfield for $subarray ----\n", 
	             "green");
	  foreach my $stat ( qw/ MEAN MEDIAN SIGMA MAX MIN / ) {
	    my $diff = sprintf "%11.4f", ($results{$stat} - $previous{$stat});
	    my $incdec = ( $diff == 0) ? "change" : 
	                 (( $diff > 0 ) ? "increase" : "decrease");
	    my $deltapc = 100*abs($diff / $results{$stat});
	    # Align the output for easy reading
	    my $outstat = sprintf "%-8s", $stat;
	    orac_print ( " $outstat = $diff A/W ( $deltapc % $incdec)\n", "green");
	  }

	  # Now print out the change in the number of good solutions
	  my $numstring = " no change in the number of";
	  my $numdiff = $results{NUMGOOD} - $previous{NUMGOOD};
	  if ( $numdiff > 0 ) {
	    $numstring = "$numdiff more";
	  } elsif ( $numdiff < 0 ){
	    $numstring = -$numdiff ." fewer";
	  }
	  orac_print (" NGOOD    = $numstring good solutions\n", "green");

	} else {
	  # Nothing to compare - tell user
	  orac_warn "Unable to retrieve previous responsivity data\n";
	}

	# Store current results
	$Cal->respstats( $subarray, \%results );
      }

      # Now create an ok file to indicate processing is complete
      _WRITE_FLAG_FILE_ FRAME=$Frmobj FILE=$flatfile

      # Finally register the flatfield with the Calibration system
      $Cal->flatindex->add( $flatfile, {%{$Frmobj->hdr}, %{$Frmobj->uhdr}} );
      $Cal->respindex->add( $respfile, {%{$Frmobj->hdr}, %{$Frmobj->uhdr}} );

    }
  }
}

