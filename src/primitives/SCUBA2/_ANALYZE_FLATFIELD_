#! -*-perl-*-

=head1 NAME

_ANALYZE_FLATFIELD_ - Analyze the current flatfield solution

=head1 SYNOPSIS

_ANALYZE_FLATFIELD_ ERR=1

=head1 DESCRIPTION

Analyze the current flatfield solution and compare with previous
flatfields

This is a Frame operation and should be used before group operations.

=head1 ARGUMENTS

This primitive supports the following arguments

=over 4

=item B<ERR>

Flag to denote whether to analyze the error in the responsivities
rather than the responsivities themselves. Default is 0 (false), use
the responsivity data.

=item B<CLIP>

Level at which to clip the data before calculating statistics, given
in number of standard deviations. Default is 0, no clipping.

=back

=head1 External Tasks

The following external tasks are used:

=over 4

=item KAPPA

Insert kappa tasks here....

=back

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2008-2009 the University of British Columbia.  All
Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA

=cut

# compare the new values with the previous flatfield and flag any
# large differences

# Flatfield can only be calculated after the observation has ended
if ( $Frm->uhdr("OBSEND") ) {

  # Get ERR argument
  my $err = get_prim_arg( $_PRIM_ARGS_, "ERR", 0 );

  # Which component to analyze?
  my $comp = ( $err ) ? "err" : "data";

  # Level to clip the data before calculating statistics?
  my $clip = get_prim_arg( $_PRIM_ARGS_, "CLIP", "" );

  my $preftext = ( $err ) ? "Uncertainties in" : "Values of";

  # Loop over subarrays... Use subgrps method to return list of Groups
  # sorted by subarray
  my @Grps = $Grp->subgrps( "SUBARRAY" );
  
  foreach my $Subgrp ( @Grps ) {
    my @frames = $Subgrp->allmembers;
    # Hmm what if @frames contains >1 ?
    foreach my $Frmobj ( @frames ) {
      # Retrieve flatfield solution
      my $flatfile = $Frmobj->file(1);
      # Get responsivity file - this will be the same as the flatfile
      # if there is responsivity file in the current Frame object
      my $respfile = $Frmobj->file(2);

      # Check if we really have a responsivity file
      my $subarray = $Frmobj->hdr('SUBARRAY');
      if ($respfile eq $flatfile ) {
	orac_warn "No responsivity file for subarray $subarray\n";
      } else {
	# Analyze current resp file - use STATS for sigma-clipping
	_FIND_IMAGE_STATISTICS_ IMAGE=$respfile COMP=$comp VERBOSE=0 CLIP=$clip HISTAT=0 
	my %results = %{ $_FIND_IMAGE_STATISTICS_{RESULTS} };
	# Now get the median and mode using HISTAT
	_FIND_IMAGE_STATISTICS_ IMAGE=$respfile COMP=$comp VERBOSE=0 CLIP=$clip
	$results{MEDIAN} = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MEDIAN};
	$results{MODE} = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MODE};

	# Calculate how many values have been dropped due to
	# sigma-clipping and what proportion that represents
	my $totalgood = $_FIND_IMAGE_STATISTICS_{RESULTS}->{NUMGOOD};
	my $dn = $totalgood - $results{NUMGOOD};
	my $dnpc = sprintf "%5.1f", 100.0 * $dn/$totalgood;

	# Obtain statistics for the previous solution
	my %previous;
	# Retrieve the previous entry from the index file
	my $previous = $Cal->resp;
	if ( defined $previous ) {
	  # Find stats with STATS to get sigma-clipped statistics
	  _FIND_IMAGE_STATISTICS_ IMAGE=$previous COMP=$comp VERBOSE=0 CLIP=$clip HISTAT=0 
	  %previous = %{ $_FIND_IMAGE_STATISTICS_{RESULTS} };
	  # Now get the median and mode using HISTAT
	  _FIND_IMAGE_STATISTICS_ IMAGE=$previous COMP=$comp VERBOSE=0 CLIP=$clip
          $previous{MEDIAN} = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MEDIAN};

	  # Add this file to the Frame object for display purposes
	  $Frmobj->uhdr( "PREVIOUS", $previous );
	}

	# Print out results from current solution and calculate
	# percentage changes from previous solution
	orac_print ("---- $preftext responsivity fits for subarray $subarray ---- \n", "green");
	orac_print ("---- Clipped at $clip sigma ($dn solutions omitted = $dnpc %) ----\n", "green") 
	  if ($clip ne "");
	foreach my $stat ( qw/ MEDIAN MEAN SIGMA MAX MIN / ) {
	  my $value = sprintf "%11.4f", $results{$stat};
	  my $diff = sprintf "%11.4f", ($results{$stat} - $previous{$stat});
	  my $incdec = ( $diff == 0) ? "change" : 
	               (( $diff > 0 ) ? "increase" : "decrease");
	  my $deltapc = sprintf "%4.1f", 100*abs($diff / $previous{$stat});
	  # Align the output for easy reading
	  my $outstat = sprintf "%-8s", $stat;
	  orac_print ( " $outstat = $value A/W ( $deltapc % $incdec )\n", "green");
	}
	# Now print out the change in the number of good solutions
	my $numstring = "no change";
	my $numdiff = $results{NUMGOOD} - $previous{NUMGOOD};
	my $deltapc = sprintf "%4.1f", 100*abs($numdiff / $previous{NUMGOOD});
	if ( $numdiff > 0 ) {
	  $numstring = "$numdiff / $deltapc % more";
	} elsif ( $numdiff < 0 ){
	  $numstring = -$numdiff ." / $deltapc % fewer";
	}
	orac_print (" NGOOD    = $results{NUMGOOD} solutions ( $numstring )\n", "green");
	# Now display the results
	_DISPLAY_RESPONSIVITIES_ FRAME=$Frmobj CLIP=$clip
      }

      # Now create an ok file to indicate processing is complete
      _WRITE_FLAG_FILE_ FRAME=$Frmobj FILE=$flatfile

      # Finally register the flatfield with the Calibration system
      $Cal->flatindex->add( $flatfile, {%{$Frmobj->hdr}, %{$Frmobj->uhdr}} );
      $Cal->respindex->add( $respfile, {%{$Frmobj->hdr}, %{$Frmobj->uhdr}} );

    }
  }
}

