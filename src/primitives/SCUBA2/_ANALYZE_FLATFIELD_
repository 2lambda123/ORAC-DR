# -*-cperl-*-

=head1 NAME

_ANALYZE_FLATFIELD_ - Analyze the current flatfield solution

=head1 SYNOPSIS

_ANALYZE_FLATFIELD_ ERR=1

=head1 DESCRIPTION

Analyze the current flatfield solution and compare with previous
flatfields. The analysis is performed on the current and previous
responsivity images and is only carried out if the OBSEND FITS header
flag is true. The results are displayed numerically (including
percentage changes) and visually (see the documentation for
_DISPLAY_RESPONSIVITIES_ for further information).

On completion, a flag file is written to indicate that flatfield
processing is complete and the flatfield solution is stored in the
calibration system.

This is a Frame operation.

=head1 ARGUMENTS

This primitive supports the following arguments:

=over 4

=item B<CLIP>

Level at which to clip the data before calculating statistics, given
in number of standard deviations. Default is 0, no clipping.

=item B<ERR>

Flag to denote whether to analyze the error in the responsivities
rather than the responsivities themselves. Default is 0 (false), use
the responsivity data.

=item B<LOGFILE>

Flag to denote whether or not to write a log file. Default is 1
(yes). Log file is called C<log.flatfield>.

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA:

NDFTRACE

=item ORAC-DR PRIMITIVES:

_ADD_FLATFIELD_LOG_ENTRY_, _DISPLAY_RESPONSIVITIES_,
_FIND_IMAGE_STATISTICS_, _WRITE_FLAG_FILE_

=back

=head1 NOTES

It might be more logical to write the flag file and store the
flatfield in the calibration system in _CALCULATE_FLATFIELD_ rather
than here.

=head1 OUTPUT DATA

The name of each flatfield solution is stored in the calibration
system in C<index.flat>.

The ratio of the current and previous responsivity images (if they
exist) is stored as an NDF extension within the flatfield solution.

=head1 OUTPUT FILES

A (hidden) flag file is written with the extension C<.ok> which
contains the names of all of the new flatfield solutions. it is
written after the pipeline has performed its own analysis.

If B<LOGFILE> is true, then the file C<log.flatfield> is written with
the current subarray, median, mean, sigma, max, min and number of good
solutions along with assoaicted changes compared with previous
solutions. See the documentation for
L<_ADD_FLATFIELD_LOG_ENTRY_|_ADD_FLATFIELD_LOG_ENTRY_> for more
details.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2008-2009 the University of British Columbia.  All
Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Flatfield can only be calculated after the observation has ended
if ( $Frm->uhdr("OBSEND") ) {

  # Flag to denote whether to write a log file
  my $uselog = get_prim_arg( $_PRIM_ARGS_, "LOGFILE", 1 );

  # Get ERR argument
  my $err = get_prim_arg( $_PRIM_ARGS_, "ERR", 0 );

  # Which component to analyze?
  my $comp = ( $err ) ? "err" : "data";

  # Level to clip the data before calculating statistics?
  my $clip = get_prim_arg( $_PRIM_ARGS_, "CLIP", "" );

  my $preftext = ( $err ) ? "Uncertainties in" : "Values of";

  # List of flatfield file names for writing to flag (.ok) file
  my @flatfiles;

  # List of alternative `previous' fastflat solutions for comparison
  my %fastflats = %{$Grp->uhdr("FASTFLATSOL")}
    if (defined $Grp->uhdr("FASTFLATSOL"));

  # Loop over subarrays... Use subgrps method to return list of Groups
  # sorted by subarray
  my @Grps = $Grp->subgrps( "SUBARRAY" );

  foreach my $Subgrp ( @Grps ) {
    my @frames = $Subgrp->members;
    # Retrieve the representative Frame object
    my $Frmobj = $frames[0];
    # Retrieve flatfield solution
    my $flatfile = $Frmobj->file;
    # Store the current flatfield file in the list to be written.
    # Note that the flag file is written regardless of whether the
    # solution is any good.
    push( @flatfiles, $flatfile );

    # If this is a FASTFLAT then look for the earlier solution
    if (defined $fastflats{$Frmobj->hdr("SUBARRAY")}) {
      my $newprevious = $fastflats{$Frmobj->hdr("SUBARRAY")} .".more.smurf.resp_new";
      my $cpargs = "in=$newprevious out=".($Frmobj->uhdr("RESP_OLD"));
      $Mon{ndfpack_mon}->obeyw("ndfcopy","$cpargs");
    }

    # Get responsivity file names
    my $respfile = $Frmobj->uhdr("RESP_NEW");
    my $previous = $Frmobj->uhdr("RESP_OLD");

    # Get the responsivity units if info is being displayed to the screen
    my $units;
    unless ( $uselog ) {
      $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$respfile");
      (my $ORAC_STATUS, $units) = $Mon{ndfpack_mon}->get("ndftrace","units");
    }

    my $subarray = $Frmobj->hdr('SUBARRAY');

    # Check there are enough solutions to analyze - unset the CLIP parameter
    if ( $Frmobj->uhdr("NUMGOOD") < 10 ) {
      my $numgood = $Frmobj->uhdr("NUMGOOD");
      orac_warn "Very few good solutions for subarray $subarray ($numgood)\n";
      $clip = "";
    }

    # Check if we really have a responsivity file
    if ( $respfile && $previous ) {
      # Analyze current resp file - use STATS for sigma-clipping
      _FIND_IMAGE_STATISTICS_ IMAGE=$respfile COMP=$comp VERBOSE=0 CLIP=$clip HISTAT=0
      my %results = %{ $_FIND_IMAGE_STATISTICS_{RESULTS} };
      # Now get the median using HISTAT
      if ( $results{NUMGOOD} > 0 ) {
        _FIND_IMAGE_STATISTICS_ IMAGE=$respfile COMP=$comp VERBOSE=0 CLIP=$clip
        $results{MEDIAN} = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MEDIAN};
      }

      # Calculate how many values have been dropped due to
      # sigma-clipping and what proportion that represents
      my $totalgood = $_FIND_IMAGE_STATISTICS_{RESULTS}->{NUMGOOD};
      my $dn = $totalgood - $results{NUMGOOD};
      # Trap division by zero - set a dummy 100% as a default
      my $dnpc = ($totalgood > 0) ? sprintf "%5.1f", 100.0 * $dn/$totalgood
	: 100;

      # Obtain statistics for the previous responsivity solution.
      # Analyze previous resp solution - use STATS to get sigma-clipped statistics
      _FIND_IMAGE_STATISTICS_ IMAGE=$previous COMP=$comp VERBOSE=0 CLIP=$clip HISTAT=0
      my %previous = %{ $_FIND_IMAGE_STATISTICS_{RESULTS} };
      # Now get the median using HISTAT
      if ( $previous{NUMGOOD} > 0 ) {
        _FIND_IMAGE_STATISTICS_ IMAGE=$previous COMP=$comp VERBOSE=0 CLIP=$clip
        $previous{MEDIAN} = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MEDIAN};
      }

      # Print out results from current solution and calculate
      # percentage changes from previous solution
      orac_print ("---- $preftext responsivity fits for subarray $subarray ---- \n", "green");
      orac_print ("---- Clipped at $clip sigma ($dn solutions omitted = $dnpc %) ----\n", "green")
	if ($clip ne "");
      my @logparms = ($subarray);
      foreach my $stat ( qw/ MEDIAN MEAN SIGMA MAX MIN / ) {
	my $value = sprintf "%11.4f", $results{$stat};
	my $diff = sprintf "%11.4f", ($results{$stat} - $previous{$stat});
	my $incdec = ( $diff == 0) ? "change" :
	  (( $diff > 0 ) ? "increase" : "decrease");
	my $deltapc = sprintf "%4.1f", 100*abs($diff / $previous{$stat});
	# Align the output for easy reading
	my $outstat = sprintf "%-8s", $stat;
	if ($uselog) {
	  push (@logparms, $value, $diff);
	} else {
	  orac_print ( " $outstat = $value $units ( $deltapc % $incdec )\n",
		       "green");
	}
	# Store in uhdr
	$Frmobj->uhdr( $stat, $value );
	$Frmobj->uhdr( "D".$stat, $diff );
      }
      # Now print out the change in the number of good solutions
      my $numstring = "no change";
      my $numdiff = $results{NUMGOOD} - $previous{NUMGOOD};
      # Make sure we don't divide by zero - set a dummy 100% as a default
      my $deltapc = ($previous{NUMGOOD} > 0)
	? sprintf "%4.1f", 100*abs($numdiff / $previous{NUMGOOD})
	: 100;
      $numstring = abs($numdiff) . " changed : $deltapc % ".
	($numdiff > 0 ? "increase" : "decrease");
      if ($uselog) {
	push (@logparms, $results{NUMGOOD}, $numdiff);
	my $logtype = "flatfield";
	my @names = ("Subarray", "Median", "Delta", "Mean", "Delta", "Sigma", "Delta", "Max", "Delta", "Min", "Delta", "Ngood", "Delta");
	_ADD_LOG_ENTRY_ LOGFILE=$logtype ENTRIES=\@logparms PARAMS=\@names PARLIST=BRIEF
      }
      orac_print (" NGOOD    = $results{NUMGOOD} solutions ( $numstring )\n",
		  "green");

      # Store in uhdr
      $Frmobj->uhdr( "NGOOD", $results{NUMGOOD} );
      $Frmobj->uhdr( "DNGOOD", $numdiff );

      # Next create the `percentage change' image
      my $deltafile = $Frmobj->inout("_pcrsp");
      my $exp = "PA*(IA-IB)/IB";
      my $args = "exp=$exp IA=$respfile IB=$previous PA=100.0 out=$deltafile";
      $Mon{kappa_mon}->obeyw("maths","$args");
      # Set the title to something meaningful
      my $sign = ( $numdiff > 0 ) ? "+" : "-";
      my $title = "Change (%) / N = ".$Frmobj->uhdr( "NGOOD")." ($sign".abs($numdiff).")";
      $args = "ndf=$deltafile title='".$title."'";
      $Mon{ndfpack_mon}->obeyw("settitle","$args");

      # Store this as another extension in flatfield file
      my $pcresp = $flatfile.".MORE.SMURF.RESP_DELTA";
      $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$deltafile out=$pcresp");
      # However, for display purposes, store the original percentage
      # change image
      $Frmobj->uhdr("RESP_DELTA", $deltafile);

      # Now display the results
      _DISPLAY_RESPONSIVITIES_ FRAME=$Frmobj CLIP=$clip
    } else {
      orac_warn "No responsivity file for subarray $subarray\n";
    }

    # Finally register the flatfield with the Calibration system -
    # note this has to be done after the analysis in order to store
    # the results in the index file
    $Cal->flatindex->add( $flatfile, {%{$Frmobj->hdr}, %{$Frmobj->uhdr}} );

    # HACK - remove the .more.smurf.resp* files from the intermediates
    # array so they are not deleted.
    my @newintermediates;
    foreach my $interfile ( $Frmobj->intermediates ) {
      push (@newintermediates, $interfile)
	unless ( $interfile =~ /.more.smurf.resp/i);
    }
    $Frmobj->intermediates(@newintermediates);

  }
  # Now create an ok file to indicate processing is complete.
  if ( @flatfiles ) {
    _WRITE_FLAG_FILE_ FILES=\@flatfiles PREFIX=s
    $Frm->uhdr("FLATFIELD",1);
  } else {
    $Frm->uhdr("FLATFIELD",0);
  }

}
