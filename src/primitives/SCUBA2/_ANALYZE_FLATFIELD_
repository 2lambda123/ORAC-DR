# -*-perl-*-

=head1 NAME

_ANALYZE_FLATFIELD_ - Analyze the current flatfield solution

=head1 SYNOPSIS

_ANALYZE_FLATFIELD_ ERR=1

=head1 DESCRIPTION

Analyze the current flatfield solution and compare with previous
flatfields. The analysis is performed on the current and previous
responsivity images and is only carried out if the OBSEND FITS header
flag is true. The results are displayed numerically (including
percentage changes) and visually (see the documentation for
_DISPLAY_RESPONSIVITIES_ for further information).

On completion, a flag file is written to indicate that flatfield
processing is complete and the flatfield solution is stored in the
calibration system.

This is a Frame operation.

=head1 ARGUMENTS

This primitive supports the following arguments:

=over 4

=item B<CLIP>

Level at which to clip the data before calculating statistics, given
in number of standard deviations. Default is 0, no clipping.

=item B<ERR>

Flag to denote whether to analyze the error in the responsivities
rather than the responsivities themselves. Default is 0 (false), use
the responsivity data.

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item ORAC-DR PRIMITIVES:

_DISPLAY_RESPONSIVITIES_, _FIND_IMAGE_STATISTICS_, _WRITE_FLAG_FILE_

=back

=head1 OUTPUT DATA

The name of each flatfield solution is stored in the calibration
system in C<index.flat>.

=head1 OUTPUT FILES

A (hidden) flag file is written for each subarray, with the extension
C<.ok>.

=head1 NOTES

It might be more logical to write the flag file and store the
flatfield in the calibration system in _CALCULATE_FLATFIELD_ rather
than here.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2008-2009 the University of British Columbia.  All
Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Compare the new values with the previous flatfield and flag any
# large differences

# Flatfield can only be calculated after the observation has ended
if ( $Frm->uhdr("OBSEND") ) {

  # Get ERR argument
  my $err = get_prim_arg( $_PRIM_ARGS_, "ERR", 0 );

  # Which component to analyze?
  my $comp = ( $err ) ? "err" : "data";

  # Level to clip the data before calculating statistics?
  my $clip = get_prim_arg( $_PRIM_ARGS_, "CLIP", "" );

  my $preftext = ( $err ) ? "Uncertainties in" : "Values of";

  # Loop over subarrays... Use subgrps method to return list of Groups
  # sorted by subarray
  my @Grps = $Grp->subgrps( "SUBARRAY" );
  
  foreach my $Subgrp ( @Grps ) {
    my @frames = $Subgrp->allmembers;
    # Hmm what if @frames contains >1 ?
    foreach my $Frmobj ( @frames ) {
      # Retrieve flatfield solution
      my $flatfile = $Frmobj->file(1);
      # Get responsivity file - this will be the same as the flatfile
      # if there is responsivity file in the current Frame object
      my $respfile = $Frmobj->file(2);

      # Check if we really have a responsivity file
      my $subarray = $Frmobj->hdr('SUBARRAY');
      if ($respfile eq $flatfile ) {
	orac_warn "No responsivity file for subarray $subarray\n";
      } else {
	# Analyze current resp file - use STATS for sigma-clipping
	_FIND_IMAGE_STATISTICS_ IMAGE=$respfile COMP=$comp VERBOSE=0 CLIP=$clip HISTAT=0 
	my %results = %{ $_FIND_IMAGE_STATISTICS_{RESULTS} };
	# Now get the median using HISTAT
	_FIND_IMAGE_STATISTICS_ IMAGE=$respfile COMP=$comp VERBOSE=0 CLIP=$clip
	$results{MEDIAN} = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MEDIAN};

	# Calculate how many values have been dropped due to
	# sigma-clipping and what proportion that represents
	my $totalgood = $_FIND_IMAGE_STATISTICS_{RESULTS}->{NUMGOOD};
	my $dn = $totalgood - $results{NUMGOOD};
	my $dnpc = sprintf "%5.1f", 100.0 * $dn/$totalgood;

	# Obtain statistics for the previous responsivity solution.
	my $previous = $Frmobj->file(3);

	# Analyze previous resp solution - use STATS to get sigma-clipped statistics
	_FIND_IMAGE_STATISTICS_ IMAGE=$previous COMP=$comp VERBOSE=0 CLIP=$clip HISTAT=0 
	my %previous = %{ $_FIND_IMAGE_STATISTICS_{RESULTS} };
	# Now get the median using HISTAT
	_FIND_IMAGE_STATISTICS_ IMAGE=$previous COMP=$comp VERBOSE=0 CLIP=$clip
        $previous{MEDIAN} = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MEDIAN};

	# Add this file to the Frame object for display purposes
	$Frmobj->uhdr( "PREVIOUS", $previous );

	# Print out results from current solution and calculate
	# percentage changes from previous solution
	orac_print ("---- $preftext responsivity fits for subarray $subarray ---- \n", "green");
	orac_print ("---- Clipped at $clip sigma ($dn solutions omitted = $dnpc %) ----\n", "green") 
	  if ($clip ne "");
	foreach my $stat ( qw/ MEDIAN MEAN SIGMA MAX MIN / ) {
	  my $value = sprintf "%11.4f", $results{$stat};
	  my $diff = sprintf "%11.4f", ($results{$stat} - $previous{$stat});
	  my $incdec = ( $diff == 0) ? "change" : 
	               (( $diff > 0 ) ? "increase" : "decrease");
	  my $deltapc = sprintf "%4.1f", 100*abs($diff / $previous{$stat});
	  # Align the output for easy reading
	  my $outstat = sprintf "%-8s", $stat;
	  orac_print ( " $outstat = $value A/W ( $deltapc % $incdec )\n", "green");
	}
	# Now print out the change in the number of good solutions
	my $numstring = "no change";
	my $numdiff = $results{NUMGOOD} - $previous{NUMGOOD};
	my $deltapc = sprintf "%4.1f", 100*abs($numdiff / $previous{NUMGOOD});
	if ( $numdiff > 0 ) {
	  $numstring = "$numdiff / $deltapc % more";
	} elsif ( $numdiff < 0 ){
	  $numstring = -$numdiff ." / $deltapc % fewer";
	}
	orac_print (" NGOOD    = $results{NUMGOOD} solutions ( $numstring )\n", "green");
	# Now display the results
	_DISPLAY_RESPONSIVITIES_ FRAME=$Frmobj CLIP=$clip
      }

      # Now create an ok file to indicate processing is complete.
      _WRITE_FLAG_FILE_ FRAME=$Frmobj FILE=$flatfile

      # Finally register the flatfield with the Calibration system
      $Cal->flatindex->add( $flatfile, {%{$Frmobj->hdr}, %{$Frmobj->uhdr}} );

    }
  }
}

