# -*-cperl-*-

=head1 NAME

_ANALYZE_FLATFIELD_ - Analyze the current flatfield solution

=head1 SYNOPSIS

_ANALYZE_FLATFIELD_ ERR=1

=head1 DESCRIPTION

Analyze the current flatfield solution and compare with previous
flatfields. The analysis is performed on the current and previous
responsivity images and is only carried out if the OBSEND FITS header
flag is true. The results (including percentage changes) are displayed
numerically in the terminal window.

On completion, a flag file is written to indicate that flatfield
processing is complete and the flatfield solution is stored in the
calibration system.

This is a Frame operation.

=head1 ARGUMENTS

This primitive supports the following arguments:

=over 4

=item B<CLIP>

Level at which to clip the data before calculating statistics, given
in number of standard deviations. Default is 0, no clipping.

=item B<ERR>

Flag to denote whether to analyze the error in the responsivities
rather than the responsivities themselves. Default is 0 (false), use
the responsivity data.

=item B<LOGFILE>

Flag to denote whether or not to write a log file. Default is 1
(yes). Log file is called C<log.flatfield>.

=item B<LOGPAR>

Specifies the type of log file to write. May be C<ABS> or C<DIFF>
depending on whether absolute values from both solutions are required,
or just those from the new solution and the differences from the
previous. Default is C<DIFF>.

=item B<OBSEND>

Flag to denote whether the primitive should wait until the observation
has ended before proceeding. Default is 1 (yes).

=item B<PERCENTILES>

Comma-separated list of percentiles to calculate. Default is the null
parameter, C<!>, which indicates no percentiles.

=item B<RESPRATIO>

A flag to indicate whether an output image is created of the ratio of
the current and previous responsivities. Default is 0 (do not
calculate the ratio image).

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA:

NDFTRACE

=item ORAC-DR PRIMITIVES:

_ADD_LOG_ENTRY_, _FIND_IMAGE_STATISTICS_, _WRITE_FLAG_FILE_

=back

=head1 NOTES

It might be more logical to write the flag file and store the
flatfield in the calibration system in _CALCULATE_FLATFIELD_ rather
than here.

=head1 OUTPUT DATA

The name of each flatfield solution is stored in the calibration
system in C<index.flat>.

The percentage change image is stored as an NDF extension in the
flatfield file called C<RESP_DELTA> (under .MORE.SMURF).

If the B<RESPRATIO> parameter is true, then the responsivity ratio
image is also stored as an NDF extension called C<RESP_RATIO>.

=head1 OUTPUT FILES

A (hidden) flag file is written with the extension C<.ok> which
contains the names of all of the new flatfield solutions. it is
written after the pipeline has performed its own analysis.

If B<LOGFILE> is true, then the file C<log.flatfield> is written with
the current subarray, median, mean, sigma, max, min and number of good
solutions along with associated changes compared with previous
solutions. See the documentation for
L<_ADD_LOG_ENTRY_|_ADD_LOG_ENTRY_> for more details.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2008-2011 the University of British Columbia.  All
Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

my $wait = get_prim_arg($_PRIM_ARGS_, "OBSEND", 1);
my $obsend = $Frm->uhdr("OBSEND");
my $proceed = ($wait) ? ($obsend ? 1 : 0) : 1;

# Flatfield can only be calculated after the observation has ended
if ( $proceed ) {

  # Flag to denote whether to write a log file
  my $uselog = get_prim_arg( $_PRIM_ARGS_, "LOGFILE", 1 );
  my $logtype = "flatfield";

  # Get ERR argument
  my $err = get_prim_arg( $_PRIM_ARGS_, "ERR", 0 );

  # Which component to analyze?
  my $comp = ( $err ) ? "err" : "data";
  my $preftext = ( $err ) ? "Uncertainties in responsivities" : "Responsivities";

  # Level to clip the data before calculating statistics?
  my $clip = get_prim_arg( $_PRIM_ARGS_, "CLIP", "" );

  # Percentiles
  my $percentiles = get_prim_arg( $_PRIM_ARGS_, "PERCENTILES", "!" );

  # What type of log file should be written? Absolute values or
  # differences?
  my $logpar = lc(get_prim_arg( $_PRIM_ARGS_, "LOGPAR", "diff" ));
  my $abslog = ($logpar eq "abs") ? 1 : 0;

  # Is the responsivity analysis calculating a ratio or a percentage
  # change image? Default to percentage change.
  my $respratio = get_prim_arg( $_PRIM_ARGS_, "RESPRATIO", 0 );

  # List of alternative `previous' fastflat solutions for comparison
  my %fastflats = %{$Grp->uhdr("FASTFLATSOL")}
    if (defined $Grp->uhdr("FASTFLATSOL"));

  # Loop over subarrays... Use subgrps method to return list of Groups
  # sorted by subarray
  my @Grps = $Grp->subgrps( "SUBARRAY" );

  my $logmsg = ($uselog) ? " (full results written to log.$logtype)" : "";
  orac_print "\nAnalyzing responsivity solutions$logmsg:\n";

  foreach my $Subgrp ( @Grps ) {
    my @frames = $Subgrp->members;
    # Retrieve the representative Frame object
    my $Frmobj = $frames[0];
    # Retrieve flatfield solution
    my $flatfile = $Frmobj->file;

    # If this is a FASTFLAT then look for the earlier solution
    if (defined $fastflats{$Frmobj->hdr("SUBARRAY")}) {
      my $newprevious = $fastflats{$Frmobj->hdr("SUBARRAY")} .".more.smurf.resp_new";
      my $cpargs = "in=$newprevious out=".($Frmobj->uhdr("RESP_OLD"));
      $Mon{ndfpack_mon}->obeyw("ndfcopy","$cpargs");
    }

    # Get responsivity file names
    my $respfile = $Frmobj->uhdr("RESP_NEW");
    my $previous = $Frmobj->uhdr("RESP_OLD");

    # Get the responsivity units if info is being displayed to the screen
    my $units;
    unless ( $uselog ) {
      $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$respfile");
      (my $ORAC_STATUS, $units) = $Mon{ndfpack_mon}->get("ndftrace","units");
    }

    my $subarray = $Frmobj->hdr('SUBARRAY');

    # Check there are enough solutions to analyze - unset the CLIP parameter
    if ( $Frmobj->uhdr("NUMGOOD") < 10 ) {
      my $numgood = $Frmobj->uhdr("NUMGOOD");
      orac_warn "Very few good solutions for subarray $subarray ($numgood)\n";
      $clip = "";
    }

    # Check if we really have a responsivity file
    if ( $respfile && $previous ) {
      ### Calculate responsivity statistics ###
      # Analyze current resp file - use STATS for sigma-clipping
      _FIND_IMAGE_STATISTICS_ IMAGE=$respfile COMP=$comp VERBOSE=0 CLIP=$clip HISTAT=0 PERCENTILES=$percentiles
      my %results = %{ $_FIND_IMAGE_STATISTICS_{RESULTS} };
      # Now get the mode using HISTAT
      if ( $results{NUMGOOD} > 0 ) {
        _FIND_IMAGE_STATISTICS_ IMAGE=$respfile COMP=$comp VERBOSE=0
        $results{MODE} = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MODE};
      } else {
	# If this happens then something went badly wrong!
	$results{MODE} = 0.0;
      }
      $results{LABEL} = "END  ";

      # Calculate how many values have been dropped due to
      # sigma-clipping and what proportion that represents
      my $totalgood = $_FIND_IMAGE_STATISTICS_{RESULTS}->{NUMGOOD};
      my $dn = $totalgood - $results{NUMGOOD};
      # Trap division by zero - set a dummy 100% as a default
      my $dnpc = ($totalgood > 0) ? sprintf "%5.1f", 100.0 * $dn/$totalgood
	: 100;

      # Analyze previous resp solution - use STATS to get
      # sigma-clipped statistics
      _FIND_IMAGE_STATISTICS_ IMAGE=$previous COMP=$comp VERBOSE=0 CLIP=$clip HISTAT=0 PERCENTILES=$percentiles
      my %previous = %{ $_FIND_IMAGE_STATISTICS_{RESULTS} };
      # Now get the mode using HISTAT
      if ( $previous{NUMGOOD} > 0 ) {
        _FIND_IMAGE_STATISTICS_ IMAGE=$previous COMP=$comp VERBOSE=0
        $previous{MODE} = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MODE};
      } else {
	# We can get here if there is no previous solution to analyze
	$previous{MODE} = 0.0;
      }
      $previous{LABEL} = "START";

      ### Obtain and store the desired statistics for printing/logging ###

      # Print out results from current solution and calculate
      # percentage changes from previous solution
      orac_print " $preftext clipped at $clip sigma ($dn solutions omitted = $dnpc %)\n"
	if ($clip ne "");

      # Define two arrays to hold the results for the current and
      # previous solutions respectively. The `current' array is always
      # populated, and has diff values included under normal
      # circumstances. When writing an absolute-value log file (such
      # as when comparing fast-ramp flatfields), the `previous' array
      # is populated. Each set of results is written as an entry to
      # the log file if appropriate.
      my @curlogpar = ($subarray);
      my (@prelogpar, @perval, @pervalstrings);
      # Add extra parameters if an `absolute' logfile is being written
      if ($abslog) {
	push(@curlogpar, $results{LABEL});
	push(@prelogpar, $subarray, $previous{LABEL});
      }

      # Store the number of good results and the change in uhdr
      my $numdiff = $results{NUMGOOD} - $previous{NUMGOOD};
      $Frmobj->uhdr( "NGOOD", $results{NUMGOOD} );
      $Frmobj->uhdr( "DNGOOD", $numdiff );

      ### Now print out the change in the number of good solutions ###
      my $numstring = "no change";
      # Make sure we don't divide by zero - set a dummy 100% as a default
      my $deltapc = ($previous{NUMGOOD} > 0)
	? sprintf "%5.1f", 100*abs($numdiff / $previous{NUMGOOD})
	  : "100.0";
      $numstring = (sprintf "%4d", abs($numdiff)) . " changed : $deltapc % ".
	($numdiff > 0 ? "increase" : "decrease");
      # Print a simple message if the results are being written to a
      # log file, otherwise use the same format as for the other
      # statistics below
      my $msg = ($uselog) ? " $subarray: " : " NGOOD   = ";
      orac_print ("$msg".(sprintf "%4d", $results{NUMGOOD}).
		  " good solutions ( $numstring )\n", "green");

      # Loop over the statistics calculated above and reformat to
      # store in the array(s) as necessary
      foreach my $stat ( qw/ MEDIAN MEAN MODE SIGMA MAX MIN / ) {
        my $curval = $results{$stat};
        if ($curval == &NDF::VAL__BADD()) {
          $curval = "NaN" + 0;
        } else {
          $curval = sprintf "%11.4f", $results{$stat};
        }
        my $diff;
        if ($previous{$stat} eq &NDF::VAL__BADD()) {
          $diff = "NaN" + 0;
        } else {
          $diff = sprintf "%11.4f", ($results{$stat} - $previous{$stat});
        }
	if ($uselog) {
	  push (@curlogpar, $curval);
	  if ($abslog) {
	    my $preval = sprintf "%11.4f", $previous{$stat};
	    push (@prelogpar, $preval);
	  } else {
	    push (@curlogpar, $diff);
	  }
	} else {
	  my $deltapc = sprintf "%4.1f", 100*abs($diff / $previous{$stat});
	  my $incdec = ( $diff == 0) ? "change" :
	    (( $diff > 0 ) ? "increase" : "decrease");
	  # Align the output for easy reading
	  my $outstat = sprintf "%-8s", $stat;
	  orac_print ( " $outstat = $curval $units ( $deltapc % $incdec )\n",
		       "green");
	}

	# Store in uhdr
	$Frmobj->uhdr( $stat, $curval );
	$Frmobj->uhdr( "D".$stat, $diff );
      }

      ### Write results to log file if appropriate ###
      if ($uselog) {
	push (@curlogpar, $results{NUMGOOD});

	my @names;
	my $parlist = "BRIEF";
	# For absolute log files, the previous details must be written
	# first
	if ($abslog) {
	  $parlist = "FULL";
	  push (@prelogpar, $previous{NUMGOOD});

	  # Define an anon sub to get the percentiles info
	  my $get_percentiles = sub {
	    my ($flatsol, $percentiles) = @_;
	    my $pervals = $flatsol->{PERCENTILES};
	    # List of requested percentiles and calculated values
	    my @pc = split(/\,/, $percentiles);
	    my @pervals = (ref($pervals) eq "ARRAY") ? @{$pervals} : ($pervals);
	    # Arrays to store returned values
	    my (@pervalpar, @pervalstrings);
	    # Loop over the elements in the arrays
	    for my $i (0 .. $#pc) {
	      push(@pervalstrings, "PC_".$pc[$i]);
	      my $value = sprintf "%11.4f", $pervals[$i];
	      push(@pervalpar, $value);
	      push(@pervalstrings, "DELTA_".$pc[$i]);
	      # Define the DELTA value as the difference between the
	      # value at the current percentile and the mode, divided
	      # by sigma
	      $value = sprintf "%11.4f", ($pervals[$i] - $flatsol->{MODE}) / $flatsol->{SIGMA};
	      push(@pervalpar, $value);
	    }
	    return [ \@pervalpar, \@pervalstrings];
	  };

	  # Get the percentiles info provided the percentiles
	  # parameter is not null
	  if ( $percentiles ne "!" ) {
	    my $pcresults = $get_percentiles->(\%results, $percentiles);
	    push(@curlogpar, @{$pcresults->[0]});
	    push(@pervalstrings, @{$pcresults->[1]});

	    $pcresults = $get_percentiles->(\%previous, $percentiles);
	    push(@prelogpar, @{$pcresults->[0]});
	  }

	  @names = ("Subarray", "Fastflat", "Median", "Mean", "Mode", "Sigma", "Max", "Min", "Ngood", @pervalstrings);
	  _ADD_LOG_ENTRY_ LOGFILE=$logtype ENTRIES=\@prelogpar PARAMS=\@names PARLIST=$parlist
	} else {
	  @names = ("Subarray", "Median", "Delta", "Mean", "Delta", "Sigma", "Delta", "Max", "Delta", "Min", "Delta", "Ngood", "Delta");
	  push(@curlogpar, $numdiff);
	}
	_ADD_LOG_ENTRY_ LOGFILE=$logtype ENTRIES=\@curlogpar PARAMS=\@names PARLIST=$parlist
      }

      ### Create the `percentage change' image ###
      my $deltafile = $flatfile.".MORE.SMURF.RESP_DELTA";
      my $exp = "PA*(IA-IB)/IB";
      my $args = "exp=$exp IA=$respfile IB=$previous PA=100.0 out=$deltafile";
      $Mon{kappa_mon}->obeyw("maths","$args");
      # Set the title to something meaningful
      my $sign = ( $Frmobj->uhdr("DNGOOD") > 0 ) ? "+" : "-";
      my $title = "Change (%) / N = ".$Frmobj->uhdr("NGOOD")." ($sign".abs($Frmobj->uhdr("DNGOOD")).")";
      $args = "ndf=$deltafile title='".$title."'";
      $Mon{ndfpack_mon}->obeyw("settitle","$args");

      # Now create the responsivity ratio image if requested - note
      # there is no display associated with this image
      if ($respratio) {
	my $ratiofile = new ORAC::TempFile;
	my $title = "Ratio of fastramp flatfields from beginning and end of obs";
	my $args = "in1=$previous in2=$respfile out=$ratiofile title='".$title."'";
	$Mon{kappa_mon}->obeyw("div","$args");
	# Store this as another extension in flatfield file
	my $respratio = $flatfile.".MORE.SMURF.RESP_RATIO";
	$Mon{ndfpack_mon}->obeyw("ndfcopy","in=$ratiofile out=$respratio");
      }
    } else {
      orac_warn "No responsivity file for subarray $subarray\n";
    }

    # Finally register the flatfield with the Calibration system -
    # note this has to be done after the analysis in order to store
    # the results in the index file
    $Cal->flatindex->add( $flatfile, {%{$Frmobj->hdr}, %{$Frmobj->uhdr}} );

    # HACK - remove the .more.smurf.resp* files from the intermediates
    # array so they are not deleted.
    my @newintermediates;
    foreach my $interfile ( $Frmobj->intermediates ) {
      push (@newintermediates, $interfile)
	unless ( $interfile =~ /.more.smurf.resp/i);
    }
    $Frmobj->intermediates(@newintermediates);
  }

  my @flatfiles = map { $_->file } $Grp->members;
  if ( @flatfiles ) {
    if ($Frm->hdr("OBS_TYPE") ne "pointing" &&
	$Frm->hdr("OBS_TYPE") ne "focus" ) {
      _WRITE_FLAG_FILE_ FILES=\@flatfiles PREFIX=s
    }
  }
}
