# -*-cperl-*-

=head1 NAME

_CALCULATE_FLATFIELD_ - Calculate flatfield solution

=head1 SYNOPSIS

_CALCULATE_FLATFIELD_ RESIST=$resistorlistfile

=head1 DESCRIPTION

Calculate a flatfield solution from a dedicated flatfield
observation. On completion of the observation (the OBSEND FITS header
flag must be true) the new flatfield solution is determined for each
subarray. A responsivity image may be generated from this solution and
will be used for subsequent analysis of the flatfield. A similar image
is derived for the existing flatfield solution (which will be included
in the raw data) and stored for comparison with the current
responsivity data.

=head1 ARGUMENTS

This primitive supports the following arguments:

=over 4

=item B<REFRES>

Value of reference resistance in ohms. Default is 2.0 ohms.

=item B<RESIST>

Text file listing the resistor settings for each bolometer. Filename
must include full path. Default is C<resist.cfg> located in
$ORAC_DATA_CAL.

=item B<RESP>

Flag to denote whether to generate a responsivity image. Use the null
parameter C<!> for no responsivity image (false). Any other value
(including 0) will generate an image.

=item B<RESPMASK>

Flag to denote whether the responsivity should be used to mask
bolometers in the flatfield. Default is 1 (true).

=item B<SNRMIN>

Minimum signal-to-noise ratio to accept solutions. Default is 10.

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item SMURF:

CALCFLAT, CALCRESP

=back

=head1 NOTES

Analysis of the flatfield solution can only take place if responsivity
images exist. Thus avoid setting B<RESP=!>.

The name of the responsivity image(s) is determined automatically
using the Frame inout method.

=head1 OUTPUT DATA

If desired, the current and previous responsivity images are stored as
NDF extensions within the flatfield file.

=head1 OUTPUT FILES

On exit there will be one file (the flatfield solution) stored in the
first Frame object associated with each of the subgroups defined by
the different subarrays.

The flatfield solutions are stored in files with suffix C<_flat>, one
for each subarray.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2008-2009 University of British Columbia.  All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut


# Flatfield can only be calculated after the observation has ended
if ( $Frm->uhdr("OBSEND") ) {

  # Issues:
  # - Resist must be given for each subarray
  # - Resp must be given for each subarray, unless generated automatically
  #   (then resp is a flag)

  # Input arguments

  # Reference resistor value
  my $refres = get_prim_arg( $_PRIM_ARGS_, "REFRES", 2.0 );

  # List of resistor settings - currently the same config file is used
  # for all subarrays which is probably not appropriate
  my $resist = get_prim_arg( $_PRIM_ARGS_, "RESIST", undef );
  $resist = File::Spec->catfile($ENV{ORAC_DATA_CAL}, "resist.cfg")
    unless (defined $resist);

  # Mask bolometers based on responsivity?
  my $respmask = get_prim_arg( $_PRIM_ARGS_, "RESPMASK", 1 );
  $respmask = ( $respmask ) ? "respmask" : "norespmask";

  # Minimum S/N ratio to accept responsivity solutions
  my $snrmin = get_prim_arg( $_PRIM_ARGS_, "SNRMIN", 10 );

  # The only acceptable input value for resp is the null parameter,
  # !. Anything else will ensure the pipeline determines an output
  # file name. Also this primitive has to deal with multiple
  # subarrays, which will have different output results.
  my $resp = get_prim_arg( $_PRIM_ARGS_, "RESP", "");
  if ( $resp eq "!" ) {
    orac_warn "No responsivity image will be written: flatfield solution can not be analyzed\n";
  }

  # Loop over subarrays. Use subgrps method to return a list of Groups
  # sorted by subarray.
  my @Grps = $Grp->subgrps( "SUBARRAY" );
  foreach my $Subgrp ( @Grps ) {
    # Retrieve all the Frames
    my @frames = $Subgrp->allmembers;

    # Store the first as a template Frame object for retrieving header
    # info and storing files
    my $Frmobj = $frames[0];

    # Determine name of output file
    my $out = $Frmobj->inout( "_flat" );
    $out = $Frmobj->strip_subscan( $out );

    # Set name of output responsivity file if desired
    unless ( $resp eq "!" ) {
      $resp = $Frmobj->inout("_resp");
      $resp = $Frmobj->strip_subscan( $resp );
    }

    # Get list of files to process
    my @inputfiles;
    foreach my $frameobj ( @frames ) {
      push(@inputfiles, $frameobj->files);
    }
    my $in = write_file_list( @inputfiles );

    # Retrieve the subarray for this subgroup
    my $subarray = $Frmobj->hdr("SUBARRAY");

    orac_say "Deriving flatfield solution for subarray $subarray";

    # Call calcflat and retrieve the number of good solutions
    my $args = "in=^$in out=$out resist=^$resist $respmask resp=$resp refres=$refres snrmin=$snrmin";
    $Mon{smurf_mon}->obeyw("calcflat","$args");
    my ( $ORAC_STATUS, $numresp ) = $Mon{smurf_mon}->get("calcflat","ngood");
    orac_print ("Subarray $subarray has $numresp good responsivities\n", "green");

    $Frmobj->uhdr("NUMGOOD", $numresp);
    # Store the responsivity file if created, and calculate the
    # previous solution
    unless ( $resp eq "!" ) {
      # Calculate previous responsivity solution and store it as an
      # extension in the flatfield file. Since all the files in the
      # Frame object have the same flatfield info, we can use any to
      # calculate the previous responsivity - so use the first one.
      my $previous = $out.".MORE.SMURF.RESP_OLD";
      $args = "in=".$Frmobj->file." out=$previous";
      $Mon{smurf_mon}->obeyw("calcresp","$args");
      # Add this file to the Frame object uhdr, to be used later for
      # display purposes
      $Frmobj->uhdr( "RESP_OLD", $previous );

      # Store current responsivity solution as an extension in the
      # flatfield file
      my $current = $out.".MORE.SMURF.RESP_NEW";
      $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$resp out=$current");
      # For simplicity just store name in uhdr
      $Frmobj->uhdr( "RESP_NEW", $current );

      # Store responsivity file in Frame object so it can be deleted
      # when it's no longer needed
      $Frmobj->files($resp);
    }

    # Store the flatfield file in the template Frame object
    $Frmobj->files($out);
  }
} else {
  # If we're not processing this time round, make a copy so the data
  # are available when the time comes.
  _COPY_RAW_DATA_
}
