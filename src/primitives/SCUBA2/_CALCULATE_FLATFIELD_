# -*-cperl-*-

=head1 NAME

_CALCULATE_FLATFIELD_ - Calculate flatfield solution

=head1 SYNOPSIS

_CALCULATE_FLATFIELD_

=head1 DESCRIPTION

Calculate a flatfield solution from a dedicated flatfield
observation. On completion of the observation (the OBSEND FITS header
flag must be true) the new flatfield solution is determined for each
subarray. A responsivity image may be generated from this solution and
will be used for subsequent analysis of the flatfield. A similar image
is derived for the existing flatfield solution (which will be included
in the raw data) and stored for comparison with the current
responsivity data.

=head1 ARGUMENTS

This primitive supports the following arguments:

=over 4

=item B<METHOD>

Method to use to calculate flatfield. Can be TABLE or POLYNOMIAL.
Default is polynomial.

=item B<RESP>

Flag to denote whether to generate a responsivity image. Use the null
parameter C<!> for no responsivity image (false). Any other value
(including 0) will generate an image.

=item B<RESPMASK>

Flag to denote whether the responsivity should be used to mask
bolometers in the flatfield. Default is 1 (true).

=item B<SNRMIN>

Minimum signal-to-noise ratio to accept solutions. Default is 10
for a ramp and 3 for a discrete flatfield.

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item SMURF:

CALCFLAT, CALCRESP

=back

=head1 NOTES

Analysis of the flatfield solution can only take place if responsivity
images exist. Thus avoid setting B<RESP=!>.

The name of the responsivity image(s) is determined automatically
using the Frame inout method.

=head1 OUTPUT DATA

If desired, the current and previous responsivity images are stored as
NDF extensions within the flatfield file.

=head1 OUTPUT FILES

On exit there will be one file (the flatfield solution) stored in the
first Frame object associated with each of the subgroups defined by
the different subarrays.

The flatfield solutions are stored in files with suffix C<_flat>, one
for each subarray.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>
Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2010 Science & Technology Facilities Council.
Copyright (C) 2008-2009 University of British Columbia.  All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Flatfield can only be calculated after the observation has ended
if ( $Frm->uhdr("OBSEND") ) {

  # Issues:
  # - Resp must be given for each subarray, unless generated automatically
  #   (then resp is a flag)

  # Input arguments

  # Method
  my $method = get_prim_arg( $_PRIM_ARGS_, "METHOD", "POLYNOMIAL");

  # Mask bolometers based on responsivity?
  my $respmask = get_prim_arg( $_PRIM_ARGS_, "RESPMASK", 1 );
  $respmask = ( $respmask ) ? "respmask" : "norespmask";

  # Minimum S/N ratio to accept responsivity solutions. Default depends on whether
  # this is a fast flat or an explicit flatfield observation.
  my $defsnr = ( $Frm->hdr("OBS_TYPE") =~ /flatfield/i ? 3 : 10 );
  my $snrmin = get_prim_arg( $_PRIM_ARGS_, "SNRMIN", $defsnr );

  # The only acceptable input value for resp is the null parameter,
  # !. Anything else will ensure the pipeline determines an output
  # file name. Also this primitive has to deal with multiple
  # subarrays, which will have different output results.
  my $resp = get_prim_arg( $_PRIM_ARGS_, "RESP", "" );
  if ( $resp eq "!" ) {
    orac_warn "No responsivity image will be written: flatfield solution can not be analyzed\n";
  }

  # Create a new group where the frame objects only contain files from
  # a single subarray
  my $subarrayGrp = $Grp->sort_by_subarray;

  # Loop over subarrays.
  foreach my $Frmobj ( $subarrayGrp->members ) {

    # Determine name of output file
    my $out = $Frmobj->inout( "_flat" );
    $out = $Frmobj->strip_subscan( $out );

    # Set name of output responsivity file if desired
    unless ( $resp eq "!" ) {
      $resp = $Frmobj->inout("_resp");
      $resp = $Frmobj->strip_subscan( $resp );
    }

    # Get list of files to process
    my @inputfiles = $Frmobj->files;
    my $in = write_file_list( @inputfiles );

    # Retrieve the subarray for this subgroup
    my $subarray = $Frmobj->hdr("SUBARRAY");

    orac_say "Deriving flatfield solution for subarray $subarray";

    # Call calcflat and retrieve the number of good solutions
    my $args = "in=^$in out=$out $respmask resp=$resp snrmin=$snrmin method=$method";
    $Mon{smurf_mon}->obeyw("calcflat","$args");
    my ( $ORAC_STATUS, $numresp ) = $Mon{smurf_mon}->get("calcflat","ngood");
    orac_print ("Subarray $subarray has $numresp good responsivities\n", "green");

    $Frmobj->uhdr("NUMGOOD", $numresp);
    # Store the responsivity file if created, and calculate the
    # previous solution
    unless ( $resp eq "!" ) {
      # Calculate previous responsivity solution and store it as an
      # extension in the flatfield file. Since all the files in the
      # Frame object have the same flatfield info, we can use any to
      # calculate the previous responsivity - so use the first one.
      my $previous = $out.".MORE.SMURF.RESP_OLD";
      $args = "in=".$Frmobj->file." out=$previous";
      $Mon{smurf_mon}->obeyw("calcresp","$args");
      # Add this file to the Frame object uhdr, to be used later for
      # display purposes
      $Frmobj->uhdr( "RESP_OLD", $previous);

      # Store current responsivity solution as an extension in the
      # flatfield file
      my $current = $out.".MORE.SMURF.RESP_NEW";
      $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$resp out=$current");
      # For simplicity just store name in uhdr
      $Frmobj->uhdr( "RESP_NEW", $current );

      # Store responsivity file in Frame object so it can be deleted
      # when it's no longer needed
      $Frmobj->files($resp);
    }

    # Store the flatfield file in the template Frame object
    $Frmobj->files($out);

    # Later primitives are going to assume we have processed
    # frames in $Grp so we clear out the group and copy the
    # frames in from $subarrayGrp
    $Grp->allmembers( $subarrayGrp->members );
  }

  # Now create an ok file to indicate the processing is complete.
  # List of flatfield file names for writing to flag (.ok) file
  my @flatfiles = map { $_->file } $Grp->members;
  if ( @flatfiles ) {
    _WRITE_FLAG_FILE_ FILES=\@flatfiles PREFIX=s
    $Frm->uhdr("FLATFIELD",1);
  } else {
    $Frm->uhdr("FLATFIELD",0);
  }
} else {
  # If we're not processing this time round, make a copy so the data
  # are available when the time comes.
  _COPY_RAW_DATA_
}
