# -*-perl-*-

=head1 NAME

_CALCULATE_FLATFIELD_ - Calculate flatfield solution

=head1 SYNOPSIS

_CALCULATE_FLATFIELD_ RESIST=$resistorlistfile

=head1 DESCRIPTION

Calculate a flatfield solution from a dedicated flatfield
observation. On completion of the observation (the OBSEND FITS header
flag must be true) the new flatfield solution is determined for each
subarray. A responsivity image may be generated from this solution and
will be used for subsequent analysis of the flatfield. A similar image
is derived for the existing flatfield solution (which will be included
in the raw data) and stored for comparison with the current
responsivity data.

=head1 ARGUMENTS

This primitive supports the following arguments:

=over 4

=item B<REFRES>

Value of reference resistance in ohms. Default is 2.0 ohms.

=item B<RESIST>

Text file listing the resistor settings for each bolometer. Filename
must include full path. Default is C<resist.cfg> located in
$ORAC_DATA_CAL.

=item B<RESP>

Flag to denote whether to generate a responsivity image. Use the null
parameter C<!> for no responsivity image (false). Any other value
(including 0) will generate an image.

=item B<RESPMASK>

Flag to denote whether the responsivity should be used to mask
bolometers in the flatfield. Default is 1 (true).

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item SMURF:

CALCFLAT, CALCRESP

=back

=head1 NOTES

Analysis of the flatfield solution can only take place if responsivity
images exist. Thus avoid setting B<RESP=!>.

The name of the responsivity image(s) is determined automatically
using the Frame inout method.

=head1 OUTPUT DATA

None.

=head1 OUTPUT FILES

On exit there will be one or three files stored in the Frame object
associated with each of the subgroups defined by the different
subarrays.

The flatfield soluions are stored in files with suffix C<_flat>, one
for each subarray.

Responsivity files for the current and previous flatfield solutions
are generated with the suffix C<_resp> and C<_prsp>
respectively. There will be one of each for each subarray. These are
considered temporary files and will be deleted on completion of the
recipe.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 University of British Columbia.  All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut


# Flatfield can only be calculated after the observation has ended
if ( $Frm->uhdr("OBSEND") ) {

  # Issues:
  # - Resist must be given for each subarray
  # - Resp must be given for each subarray, unless generated automatically
  #   (then resp is a flag)
  # - Need to get all DARKs and include them in the input file list

  # Input arguments

  # Reference resistor value
  my $refres = get_prim_arg( $_PRIM_ARGS_, "REFRES", 2.0 );

  # List of resistor settings - currently the same config file is used
  # for all subarrays
  my $resist = get_prim_arg( $_PRIM_ARGS_, "RESIST", undef );
  unless (defined $resist) {
    $resist = $ENV{ORAC_DATA_CAL} . "/resist.cfg";
  }

  # Mask bolometers based on responsivity?
  my $respmask = get_prim_arg( $_PRIM_ARGS_, "RESPMASK", 1 );
  $respmask = ( $respmask ) ? "respmask" : "norespmask";

  # The only acceptable input value for resp is the null parameter,
  # !. Anything else will ensure the pipeline determines an output
  # file name. Also this primitive has to deal with multiple
  # subarrays, which will have different output results.
  my $resp = get_prim_arg( $_PRIM_ARGS_, "RESP", "");
  if ( $resp eq "!" ) {
    orac_warn "No responsivity image will be written: flatfield solution can not be analyzed\n";
  }

  # Loop over subarrays. Use subgrps method to return a list of Groups
  # sorted by subarray.
  my @Grps = $Grp->subgrps( "SUBARRAY" );
  foreach my $Subgrp ( @Grps ) {
    # Retrieve all the Frames - probably just a single one
    my @frames = $Subgrp->allmembers;
    foreach my $Frmobj ( @frames ) {
      my $subarray = $Frmobj->hdr("SUBARRAY");
      # Determine input and output files
      my $in = write_file_list( $Frmobj->files );
      my $out = $Frmobj->inout( "_flat" );
      # Set name of output responsivity file if desired
      $resp = $Frmobj->inout( "_resp" ) unless ($resp eq "!");

      my $args = "in=^$in out=$out refres=$refres resist=^$resist $respmask resp=$resp";
      $Mon{smurf_mon}->obeyw("calcflat","$args");
      my ( $ORAC_STATUS, $numresp ) = $Mon{smurf_mon}->get("calcflat","ngood");
      orac_print ("Subarray $subarray has $numresp good responsivities\n", "green");
      # Store output files
      push (my @out, $out);
      # Store the responsivity file if created, and calculate the
      # previous solution
      unless ( $resp eq "!" ) {
	# Store current responsivity solution
	push (@out, $resp);
	# Calculate previous responsivity solution and store it
	my $previous = $Frmobj->inout("_prsp");
	$args = "in=".$Frmobj->file." out=$previous";
	$Mon{smurf_mon}->obeyw("calcresp","$args");
	push (@out, $previous);
      }
      # The current Frame object for this subgroup now has either 1 or
      # 3 files stored in it:
      # $Frmobj->file(1) = Flatfield solution
      # $Frmobj->file(2) = Current responsivity image
      # $Frmobj->file(3) = Previous responsivity image
      # The analysis carried out in _ANALYZE_FLATFIELD_ relies on this order.
      $Frmobj->files(@out);
    }
  }

}

