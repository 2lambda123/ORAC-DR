# -*-cperl-*-

=head1 NAME

_FIT_PSF_ - Determine the PSF from one or more point sources

=head1 SYNOPSIS

  _FIT_PSF_ IMAGE=$image COFILE=$cofile

  _FIT_PSF_ IMAGE=$image COFILE=$cofile GAUSSIAN=1

=head1 DESCRIPTION

Determines the point-spread function (PSF) from a point source in the
given image. The KAPPA routine PSF is used, and must be supplied with
the name of a file containing an estimate of the source position.

A check is made that the number of good pixels in the image is at
least as large as the number of pixels in the fitting region. Since
the fitting region will (should) be smaller than the image, this
allows for the presence of bad pixels within the fitting
region.

The user may specify the size of the region used in the fit. If so, a
check is made that the choice does not exceed the image size. In this
case, the fitting region is set to the image size. Note that in
general using the entire image to fit a single source may not result
in a good fit as too much weight will be given to outlying points.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<BOX>

Size of square area in pixels in which to carry out the fit. Must be
odd and lie between 3 and 101. Default is 15.

=item B<COFILE>

Name of file containing estimate of position of (point) sources. No
default. The positions in this file must be in the same coordinate
frame as that of the image.

=item B<GAUSSIAN>

If true (non-zero), then the PSF fit is forced to be a
gaussian. Default is 1 (true).

=item B<IMAGE>

Name of image to fit PSF. No default.

=item B<VERBOSE>

Flag to indicate whether informational messages should be given to the
user. Default is 1 (true).

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA:

PSF, STATS

=back

=head1 OUTPUT DATA

On completion, the primitive hash C<%_FIT_PSF_> contains the following
keys:

=over 4

=item AMPLITUDE

Amplitude of first fitted source

=item AXISR

Axial ratio of PSF

=item FIT

Contains 1 on success, 0 on failure. Will be the only entry defined on
failure.

=item FWHM

The FWHM of minor axis, or C<seeing disc>

=item GAMMA

Radial fall off parameter, gamma. Will be 2 if B<GAUSSIAN> was true.

=item ORIENT

Orientation of PSF, degrees east of north in current coordinate frame

=item POSITION

The position of the fitted peak, reference to an array of
x, y coordinates.

=item TOTALFLUX

Total area under fit, in units of AMP*FWHM^2

=back

If the fit failed for some reason, each of these is set to C<undef>.

=head1 KNOWN ISSUES

If the fit is in a celestial coordinate frame the beam PA will rotate
during the course of a night. It is recommended that the system be set
to AZEL before entry to this primitive.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>,
Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.
Copyright (C) 2005-2007 the University of British Columbia. All
Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Determine that we have an image as an argument...
my $in = get_prim_arg($_PRIM_ARGS_, "IMAGE", undef);
orac_throw "Error: _FIT_PSF_ requires an image file as input\n"
    unless defined $in;

# Check for COFILE
my $cofile = get_prim_arg($_PRIM_ARGS_, "COFILE", undef);
orac_throw "Error: _FIT_PSF_ requires a file containing an estimate of the source position(s) \n"
    unless defined $cofile;

# Are we forcing a gaussian fit?
my $gaussian = get_prim_arg($_PRIM_ARGS_, "GAUSSIAN", 1);

# Convert flag to logical
$gaussian = ( $gaussian ) ? "true" : "false";

# How large a box are we fitting in?
my $box = get_prim_arg( $_PRIM_ARGS_, "BOX", 15);

# Should we be verbose? (Default to yes)
my $verbose = get_prim_arg($_PRIM_ARGS_, "VERBOSE", 1);

# Check that $box is an odd number
if ( $box % 2 == 0) {
  orac_warn "Given value for BOX ($box) is even: adding 1 to make it odd\n"
    if $verbose;
  $box++;
}

# Initialize entries in primitive hash
foreach my $item (qw/ AMPLITUDE FWHM AXISR GAMMA ORIENT TOTALFLUX /) {
  $_PRIM_ARGS_->{$item} = undef;
}
$_PRIM_ARGS_->{POSITION} = [];

# Check that we have enough good values in the image before attempting
# to fit the psf
$Mon{kappa_mon}->obeyw("stats","ndf=$in");
(my $ORAC_STATUS, my $numgood) = $Mon{kappa_mon}->get("stats","numgood");

# Define the minimum number of useful pixels as (2*$box+1)^2
my $minpix = 4.*($box+1)*($box+1);
# Make sure it lies within the bounds of the image though!
($ORAC_STATUS, my $numpix) = $Mon{kappa_mon}->get("stats","numpix");
$minpix = $numpix if ( $minpix > $numpix );

# We now run PSF if possible
if ( $numgood >= $minpix ) {

  my $args = "incat=! device=! gauss=$gaussian isize=$box cofile=$cofile";

  # Everything looks OK, so call PSF
  my $PSF_STATUS = $Mon{kappa_mon}->obeyw("psf","norm=no range=4 isize=15 in=$in $args");

  # Integer error code for KAP__PSFSN: PSF fit failed because Gaussian
  # fit normal-equation matrix is singular
  if ( $PSF_STATUS == 257327122 ) {
    orac_warn "Unable to fit a PSF profile in the current image\n"
      if $verbose;
    $_PRIM_ARGS_->{FIT} = 0;
  } elsif ($PSF_STATUS == 257327130 ) {
    # Integer error code for KAP__PSFNO: PSF fit failed because no
    # star(s) were found at the supplied position(s)
    orac_warn "No source found at supplied position in the current image\n"
      if $verbose;
    $_PRIM_ARGS_->{FIT} = 0;
  } elsif ( $PSF_STATUS == ORAC__OK ) {
    # Retrieve the answers
    ( my $ORAC_STATUS, my $amp ) = $Mon{kappa_mon}->get("psf","amp1");
    ( $ORAC_STATUS, my $axisr )  = $Mon{kappa_mon}->get("psf","axisr");
    ( $ORAC_STATUS, my $fwhm )   = $Mon{kappa_mon}->get("psf","fwhm");
    ( $ORAC_STATUS, my $gamma )  = $Mon{kappa_mon}->get("psf","gamma");
    ( $ORAC_STATUS, my $orient ) = $Mon{kappa_mon}->get("psf","orient");
    ( $ORAC_STATUS, my $total )  = $Mon{kappa_mon}->get("psf","total");
    ( $ORAC_STATUS, my $xcen )   = $Mon{kappa_mon}->get("psf","xcen");
    ( $ORAC_STATUS, my $ycen )   = $Mon{kappa_mon}->get("psf","ycen");

    $_PRIM_ARGS_->{FIT} = 1;
    $_PRIM_ARGS_->{AMPLITUDE} = $amp;
    $_PRIM_ARGS_->{FWHM} = $fwhm;
    $_PRIM_ARGS_->{AXISR} = $axisr;
    $_PRIM_ARGS_->{GAMMA} = $gamma;
    $_PRIM_ARGS_->{ORIENT} = $orient;
    $_PRIM_ARGS_->{TOTALFLUX} = $total;
    $_PRIM_ARGS_->{POSITION} = [ $xcen, $ycen ];

    # Tell user of results if requested
    if ($verbose) {
      $fwhm = sprintf "%5.2f", $fwhm;
      $orient = sprintf "%5.2f", $orient;
      $axisr = sprintf "%5.2f", $axisr;
      $gamma = sprintf "%5.2f", $gamma;
      orac_print "Successful PSF fit: FWHM = $fwhm arcsec, AXISR = $axisr, ORIENT = $orient deg, GAMMA = $gamma\n";
    }
  } else {
    $_PRIM_ARGS_->{FIT} = 0;
    orac_err "Error fitting PSF\n";
    $ORAC_STATUS = $PSF_STATUS;
  }
} else {
  orac_warn "Insufficient number of good values to fit a PSF profile in the current image\n" if $verbose;
  $_PRIM_ARGS_->{FIT} = 0;
}
