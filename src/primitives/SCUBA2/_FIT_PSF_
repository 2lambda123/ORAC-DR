# -*-perl-*-

=head1 NAME

_FIT_PSF_ - Determine the PSF from one or more point sources

=head1 DESCRIPTION

Determines the point-spread function (PSF) from a given image. The
Starlink Kappa routine PSF is used, and must be supplied with the name
of a file containing an estimate of the source positions.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item IMAGE

Name of image to fit PSF. No default.

=item COFILE

Name of file containing estimate of position of (point) sources. No
default. The positions in this file must be in the same coordinate
frame as that of the image.

=item GAUSSIAN

If true (non-zero), then the PSF fit is forced to be a
gaussian. Default is zero (false).

=item VERBOSE

Flag to indicate whether informational messages should be given to the
user. Default is verbose (true).

=back

=head1 STARLINK TASKS

=over 4

=item KAPPA

PSF

=back

=head1 OUTPUT DATA

On completion, the primitive hash C<%_FIT_PSF_> contains the following
key:

=over 4

=item RESULTS

A reference to an array containing five fit parameters from PSF:
Amplitude, FWHM, axis-ratio, gamma, and orientation in the current
coordinate frame. See the Starlink PSF documentation for further
details of these parameters. Returns C<undef> for each value if the
fit failed.

=back

=head1 KNOWN ISSUES

Fits only a single-component PSF and thus does not take the error beam
into account.

If the fit is in a celestial coordinate frame the beam PA will rotate
during the course of a single night.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2005-2007 the University of British Columbia. All
Rights Reserved.

=head1 TODO

=over 4

=item - If COFILE is false then another keyword could be used to
specify the source position (RADEC=...)

=item - Add further PSF parameters

=cut

# Determine that we have an image as an argument...
unless (exists $_FIT_PSF_{IMAGE} && defined $_FIT_PSF_{IMAGE}) {
  orac_throw "Error: _FIT_PSF_ requires an image file as input \n";
}
my $in = $_FIT_PSF_{IMAGE};

# Check for COFILE
unless (exists $_FIT_PSF_{COFILE} && defined $_FIT_PSF_{COFILE}) {
  orac_throw "Error: _FIT_PSF_ requires a file containing an estimate of the source position(s) \n";
}

# Are we forcing a gaussian?
my $gaussian = (exists $_FIT_PSF_{GAUSSIAN} &&
		defined $_FIT_PSF_{GAUSSIAN}) ?
  $_FIT_PSF_{GAUSSIAN} : 0;

# Convert flag to logical
if ( $gaussian ) {
  $gaussian = "true";
} else {
  $gaussian = "false";
}

# Should I be verbose? (Default to yes)
my $verbose = (exists $_FIT_PSF_{VERBOSE} && 
	       defined $_FIT_PSF_{VERBOSE}) ?
  $_FIT_PSF_{VERBOSE} : 1;

# Initialize the results array
$_FIT_PSF_{RESULTS} = [];

# We now run PSF if possible else simply use the peak position from
# centroiding
my ($amp, $axisr, $fwhm, $gamma, $orient);
my $ORAC_STATUS;
if (starversion_lt('kappa', 'V0.15-0')) {
  # Return if Kappa is too old
  orac_throw "Your Kappa version is too old to use PSF properly. Unable to fit PSF\n";
} else {
  my $args = "incat=! device=! gauss=$gaussian cofile=$_FIT_PSF_{COFILE}";

  # Run PSF
  $Mon{kappa_mon}->obeyw("psf","norm=no range=4 isize=15 in=$in $args");

  # Retrieve the answer
  ( $ORAC_STATUS, $amp)    = $Mon{kappa_mon}->get("psf","amp1");
  ( $ORAC_STATUS, $axisr)  = $Mon{kappa_mon}->get("psf","axisr");
  ( $ORAC_STATUS, $fwhm)   = $Mon{kappa_mon}->get("psf","fwhm");
  ( $ORAC_STATUS, $gamma)  = $Mon{kappa_mon}->get("psf","gamma");
  ( $ORAC_STATUS, $orient) = $Mon{kappa_mon}->get("psf","orient");

#  orac_print "Successful PSF fit: AMP=".$amp.", FWHM=".$fwhm.", AXISR=".$axisr.
#             ", GAMMA=". $gamma ." , ORIENT=".$orient."\n" if ($verbose);
  orac_print "Successful PSF fit: FWHM = ".$fwhm.", AXISR = ".$axisr.
             ", GAMMA = ". $gamma .", ORIENT = ".$orient."\n" if ($verbose);
}

# Store the result in the hash if successful
if ( $ORAC_STATUS == ORAC__OK ) {
  $_FIT_PSF_{RESULTS} = [ $amp, $fwhm, $axisr, $gamma, $orient ];
} else {
  $_FIT_PSF_{RESULTS} = [ undef, undef, undef, undef, undef ];
}
 
#orac_print "Calculated PSF fit parameters \n" if $verbose;

