# -*-perl-*-

=head1 NAME

_FIT_PSF_ - Determine the PSF from one or more point sources

=head1 DESCRIPTION

Determines the point-spread function (PSF) from a given image. The
Starlink Kappa routine PSF is used, and must be supplied with the name
of a file containing an estimate of the source positions.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item IMAGE

Name of image to fit PSF. No default.

=item COFILE

Name of file containing estimate of position of (point) sources. No
default. The positions in this file must be in the same coordinate
frame as that of the image.

=item GAUSSIAN

If true (non-zero), then the PSF fit is forced to be a
gaussian. Default is 1 (true).

=item BOX

Size of square area in pixels in which to carry out the fit. Must be
odd and lie between 3 and 101. Default is 15.

=item VERBOSE

Flag to indicate whether informational messages should be given to the
user. Default is verbose (true).

=back

=head1 STARLINK TASKS

=over 4

=item KAPPA

PSF

=back

=head1 OUTPUT DATA

On completion, the primitive hash C<%_FIT_PSF_> contains the following
key:

=over 4

=item AMPLITUDE

Amplitude of first star in fit

=item AXISR

Axial ratio of PSF

=item GAMMA

Radial fall off parameter, gamma

=item FWHM

The FWHM of minor axis, or C<seeing disc>

=item ORIENT

Orientation of PSF, degrees east of north in current coordinate frame

=item TOTALFLUX

Total area under fit, in units of AMP*FWHM^2

=back

If the fit failed for some reason, each of these is set to C<undef>.

=head1 KNOWN ISSUES

If the fit is in a celestial coordinate frame the beam PA will rotate
during the course of a single night.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2005-2007 the University of British Columbia. All
Rights Reserved.

=head1 TODO

=over 4

=item - If COFILE is false then another keyword could be used to
specify the source position (RADEC=...)

=item - Add further PSF parameters

=cut

# Determine that we have an image as an argument...
unless (exists $_FIT_PSF_{IMAGE} && defined $_FIT_PSF_{IMAGE}) {
  orac_throw "Error: _FIT_PSF_ requires an image file as input \n";
}
my $in = $_FIT_PSF_{IMAGE};

# Check for COFILE
unless (exists $_FIT_PSF_{COFILE} && defined $_FIT_PSF_{COFILE}) {
  orac_throw "Error: _FIT_PSF_ requires a file containing an estimate of the source position(s) \n";
}

# Are we forcing a gaussian?
my $gaussian = (exists $_FIT_PSF_{GAUSSIAN} &&
		defined $_FIT_PSF_{GAUSSIAN}) ?
  $_FIT_PSF_{GAUSSIAN} : 1;

# Convert flag to logical
$gaussian = ( $gaussian ) ? "true" : "false";

# How large a box are we fitting in?
my $box = (exists $_FIT_PSF_{BOX} &&
	   defined $_FIT_PSF_{BOX}) ?
           $_FIT_PSF_{BOX} : 15;

# Should we be verbose? (Default to yes)
my $verbose = (exists $_FIT_PSF_{VERBOSE} && 
	       defined $_FIT_PSF_{VERBOSE}) ?
               $_FIT_PSF_{VERBOSE} : 1;

# Check that $box is an odd number
if ( $box % 2 == 0) {
  orac_warn "Given value for BOX ($box) is even: adding 1 to make it odd\n" 
    if $verbose;
  $box++;
}

# Initialize entries in primitive hash
foreach my $item (qw/ AMPLITUDE FWHM AXISR GAMMA ORIENT TOTALFLUX /) {
  $_FIT_PSF_{$item} = undef;
}

# Check that we have enough good values in the image before attempting
# to fit the psf.
$Mon{kappa_mon}->obeyw("stats","ndf=$in");
(my $ORAC_STATUS, my $numgood) = $Mon{kappa_mon}->get("stats","numgood");

# Define the minimum number of useful pixels as (2*$box+1)^2
my $minpix = 4.*($box+1)*($box+1);
# Make sure it lies within the bounds of the image though!
($ORAC_STATUS, my $numpix) = $Mon{kappa_mon}->get("stats","numpix");
$minpix = $numpix if ( $minpix > $numpix );

# We now run PSF if possible
if ( $numgood >= $minpix ) {
  my ($amp, $axisr, $fwhm, $gamma, $orient, $total);
  my $ORAC_STATUS;
  if (starversion_lt('kappa', 'V0.15-0')) {
    # Return if Kappa is too old
    orac_warn "Your Kappa version is too old to use PSF properly. Unable to fit PSF\n";
  } else {
    my $args = "incat=! device=! gauss=$gaussian isize=$box cofile=$_FIT_PSF_{COFILE}";

    # Everything looks OK, so call PSF
    my $PSF_STATUS = $Mon{kappa_mon}->obeyw("psf","norm=no range=4 isize=15 in=$in $args");

    # Integer error code for KAP__PSFSN
    if ( $PSF_STATUS == 257327122 ) {
      orac_warn "Unable to fit a PSF profile in the current image\n" 
	if $verbose;
    } elsif ( $PSF_STATUS == ORAC__OK ) {
      # Retrieve the answers
      ( $ORAC_STATUS, $amp )    = $Mon{kappa_mon}->get("psf","amp1");
      ( $ORAC_STATUS, $axisr )  = $Mon{kappa_mon}->get("psf","axisr");
      ( $ORAC_STATUS, $fwhm )   = $Mon{kappa_mon}->get("psf","fwhm");
      ( $ORAC_STATUS, $gamma )  = $Mon{kappa_mon}->get("psf","gamma");
      ( $ORAC_STATUS, $orient ) = $Mon{kappa_mon}->get("psf","orient");
      ( $ORAC_STATUS, $total )  = $Mon{kappa_mon}->get("psf","total");
      $_FIT_PSF_{AMPLITUDE} = $amp;
      $_FIT_PSF_{FWHM} = $fwhm;
      $_FIT_PSF_{AXISR} = $axisr;
      $_FIT_PSF_{GAMMA} = $gamma;
      $_FIT_PSF_{ORIENT} = $orient;
      $_FIT_PSF_{TOTALFLUX} = $total;
      orac_print "Successful PSF fit: FWHM = ".$fwhm.", AXISR = ".$axisr.
	", GAMMA = ". $gamma .", ORIENT = ".$orient."\n" if ($verbose);
    } else {
      orac_throw "Error fitting PSF\n";
    }
  }
} else {
  orac_warn "Insufficient number of good values to fit a PSF profile in the current image\n" if $verbose;
}
