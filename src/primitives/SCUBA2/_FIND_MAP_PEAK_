# -*-cperl-*-

=head1 NAME

_FIND_MAP_PEAK_ - Determine the peak signal of the brightest source

=head1 SYNOPSIS

 _FIND_MAP_PEAK_ IMAGE=$image

 _FIND_MAP_PEAK_ GROUP=1 INITPOS=\@radec

=head1 DESCRIPTION

Finds the location and value of the brightest source in the given
image. The user can optionally provide an initial position which is
used to narrow down the search to a 2x2 arcmin^2 region centred on
that position. If desired, the best-fit source position can be derived
by fitting a 2-d profile. The peak value is then the maximum from this
fit.

The primitive works by first creating a signal-to-noise image. If the
peak S/N exceeds 5, the primitive goes on to apply a matched filter
and the peak value and position are derived from the filtered image.

The primitive returns C<undef> values if no 5-sigma or greater peak
could be located.

=head1 ARGUMENTS

The following arguments are supported:

=over 2

=item B<FITBOX>

Size of area in pixels within which to constrain the fit. Default is
25.

=item B<FITPEAK>

A flag to denote whether the peak position should be refined by fitting
a 2-d function. Default is 1 (yes).

=item B<GAUSSIAN>

A flag to indicate whether the fit is forced to be gaussian. The
default is 0 (no).

=item B<GROUP>

If true, the Group file is used rather than the Frame file. Default is
false (0).

=item B<IMAGE>

Name of input image. Default is to use the file obtained from Grp or
Frm depending on the value of B<GROUP>. If given, must be a file name,
not an NDF section.

=item B<INITPOS>

Optional reference to an array containing the X, Y coordinate to be
used as the initial estimate of the peak position. If not given, the
entire image will be searched for the brightest peak.

=item B<PLOTFIT>

A flag to denote whether the fit should be plotted against the input
data. Default is 0 (do not plot).

=item B<USESNR>

A flag to indicate that a signal-to-noise ratio map should be made to
determine if a peak exists. Default is 1 (yes).

=item B<VERBOSE>

Flag to indicate whether informational messages should be given to the
user. Default is 1 (be verbose).

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA:

NDFCOPY, NDFTRACE, STATS, THRESH

=item ORAC-DR PRIMITIVES:

_APPLY_MATCHED_FILTER_, _ASSESS_BEAM_FIT_, _FIT_SOURCE_, _PLOT_FIT_PROFILE_

=back

=head1 NOTES

The fit undergoes an assessment for C<point-like> properties and
returns an error if the fit looks poor.

=head1 OUTPUT DATA

On completion, the primitive hash C<%_FIND_MAP_PEAK_>
contains the following keys:

=over 2

=item PEAK

The peak signal. Corresponds to the peak signal at the peak
signal-to-noise position if the fit failed or no fit was
specified. Will be undef if no significant maximum was found.

=item PEAKERR

Uncertainty in the peak signal. If the fit failed or no fit was
specified then this is the value of the error component of the NDF at
the position of the peak signal. Will be undef if no significant
maximum was found.

=item POSITION

The position of the peak. Reference to an array of x, y coordinates in
the current coordinate frame (which will be empty if the calculation
failed). Undef if no significant maximum was found.

=item SNR

Signal-to-noise ratio at the peak position. Undef if no significant
maximum was found, 0 if the uncertainty at the peak position is bad.

=back

The Frame object is not updated.

=head1 OUTPUT FILES

None.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>
Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2009-2013 University of British Columbia.
Copyright (C) 2008 Science and Technology Facilities Council.
Copyright (C) 2000 Particle Physics and Astronomy Research Council.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Should I be verbose (default to yes)
my $verbose = get_prim_arg($_PRIM_ARGS_, "VERBOSE", 1);

# Which object?
my $group = get_prim_arg($_PRIM_ARGS_, "GROUP", 0);
my $Obj = ($group) ? $Grp : $Frm;

$Obj->tagset("find_map_peak_input");
my $inproduct = $Obj->product;

# Input file
my $in = get_prim_arg($_PRIM_ARGS_, "IMAGE", $Obj->file);
# Image to use for finding the peak value and position
my $image = $in;

# Fit the peak position - if false then the peak position and signal
# from KAPPA stats will be used
my $fitpeak = get_prim_arg($_PRIM_ARGS_, "FITPEAK", 1);

# Is the peak s/n to be calculated?
my $usesnr = get_prim_arg($_PRIM_ARGS_, "USESNR", 1);
# Override with a recipe parameter
$usesnr = $Frm->uhdr("RECPAR_USESNR") if (defined $Frm->uhdr("RECPAR_USESNR"));
# Set a dummy value for the peak S/N if the user is confident that a
# bright source exists
my $peaksn = 10;

# Initial position
my $initpos = get_prim_arg($_PRIM_ARGS_, "INITPOS", undef);

# Plot fit + data?
my $plotfit = get_prim_arg($_PRIM_ARGS_, "PLOTFIT", 0);
$plotfit = $Frm->uhdr("RECPAR_PLOT_SOURCEFIT")
  if (defined $Frm->uhdr("RECPAR_PLOT_SOURCEFIT"));

# Unset all the flags so that nothing happens if the map has bad
# values at the peak position
if ($Frm->tagexists("badpeak")) {
  $usesnr = 0;
  $fitpeak = 0;
  undef $initpos;
  $plotfit = 0;
  $peaksn = 0;
}

# Retrieve the pixel scale
$Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
my ($ORAC_STATUS, @dims) = $Mon{ndfpack_mon}->get("ndftrace","dims");
($ORAC_STATUS, my @pixscale) = $Mon{ndfpack_mon}->get("ndftrace","fpixscale");
my $pixscale = 0.5*($pixscale[0] + $pixscale[1]);

# If an initial position is given, copy out a 2x2 arcmin^2 box centred
# on that position
if ($initpos) {
  # Use a 2-arcmin image for speed
  my $minmapsize = 120.0;
  my $region = int($minmapsize / $pixscale);
  # Copy out a box centred on the source if the map is larger than the
  # minimum
  if ($region < $dims[0] && $region < $dims[1]) {
    my ($x, $y) = ($initpos->[0], $initpos->[1]);
    my $infile = $in. "($x~$region,$y~$region,)";
    $image = $Obj->inout("_region");
    $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$infile out=$image");
    $Obj->push_intermediates($image);
  }
}

if ($usesnr) {
  # Now find the position of the brightest peak in the map
  my $image_snr = new ORAC::TempFile;
  # Make snr image
  $Mon{kappa_mon}->obeyw("makesnr","minvar=0 in=$image out=$image_snr");
  # Check that SNR image has >5 sigma peaks
  $Mon{kappa_mon}->obeyw("stats","ndf=$image_snr");
  (my $ORAC_STATUS, $peaksn) = $Mon{kappa_mon}->get("stats","maximum");
}

my ($peakval, $peakerr, $peaksnr, @xy, $peak, $dpeak, $snr, $posn);
# Choose a S/N cutoff of 3, which will correspond to a peak S/N of ~6
# in the matched-filtered map
if ( $peaksn > 3 ) {
  orac_warn "Peak S/N is only ".(sprintf "%.1f", $peaksn).": source may not be located accurately\n"
    if ($peaksn < 6);
  # User can supply a matched-filtered image to save some time
  my $image_mf;
  # Only use an existing matched-filtered image if the current object
  # contains a single file otherwise there is no guarantee the
  # matched-filtered image corresponds to the current image
  unless ($Obj->nfiles == 1 && $Obj->tagretrieve("matchfilt")) {
    _APPLY_MATCHED_FILTER_ VERBOSE=0 IN=$image
  }
  $image_mf = $Obj->file;

  my $point_focus = ($Obj->hdr("OBS_TYPE") =~ /focus|pointing/i) ? 1 : 0;
  # Find position of max value - restrict search to a 60-arcsec box for
  # calibrators. Might be worth using the map size as defined in
  # header to avoid picking up edge pixels for other targets.
  my $npix = int(60.0 / $pixscale) + 1;
  my $ndf = ($Cal->iscalsource($Obj->hdr("OBJECT")) || $point_focus)
    ? $image_mf."(0~$npix,0~$npix,)" : $image_mf;
  $Mon{kappa_mon}->obeyw("stats","ndf=$ndf");
  my ($ORAC_STATUS, $pkpos) = $Mon{kappa_mon}->get("stats", "maxwcs");
  # Split into coordinates
  @xy = split(/\,\s+/, $pkpos);

  # Now find the value in the original image at the maximum
  $in = $image."($xy[0]~1,$xy[1]~1,)";
  $Mon{kappa_mon}->obeyw("stats","ndf=$in");
  ($ORAC_STATUS, $peakval) = $Mon{kappa_mon}->get("stats", "maximum");
  $Mon{kappa_mon}->obeyw("stats","ndf=$in comp=err");
  ($ORAC_STATUS, $peakerr) = $Mon{kappa_mon}->get("stats", "maximum");

  # For pointing and focus observations, check to see if the peak lies
  # within 30" of the centre
  if ($point_focus) {
    # x, y offsets will be in degrees so this is safe
    my $dr = sprintf "%.1f", (3600 * sqrt($xy[0]*$xy[0] + $xy[1]*$xy[1]));
    if ($dr > 30) {
      orac_warn "S/N peak is far from centre ($dr arcsec) - source is probably not detected\n";
      @xy = ();
      $fitpeak = 0;
    }
  }
} else {
  orac_warn "Image $in has no significant maximum\n";
  @xy = ();
  $fitpeak = 0;
}

# Fit the peak position if desired
if ($fitpeak) {
  # Are we forcing a gaussian fit?
  my $gaussian = get_prim_arg($_PRIM_ARGS_, "GAUSSIAN", 0);
  # Override with recipe parameter
  $gaussian = $Frm->uhdr("RECPAR_FIT_GAUSSIAN")
    if (defined $Frm->uhdr("RECPAR_FIT_GAUSSIAN"));

  # Size of region to fit - use a smaller default for pointing
  # observations as the image will have been trimmed
  my $box_default = (lc($Obj->hdr("OBS_TYPE")) eq "pointing") ? 15 : 25;
  # Double the default box size for "large" planets at 450 um
  my $bigplanet = (uc($Obj->hdr("OBJECT")) eq "JUPITER") ? 1
    : (uc($Obj->hdr("OBJECT")) eq "SATURN" ? 1 : 0);
  $box_default *= 2 if ($bigplanet && $Obj->hdr("FILTER") =~ /450/);
  # However, if FITBOX is given, assume that the caller has done their
  # bit in choosing a suitable size
  my $fitbox = get_prim_arg($_PRIM_ARGS_, "FITBOX", $box_default);

  # Fit a 2-d gaussian to the source to determine the peak signal
  _FIT_SOURCE_ IMAGE=$image XYPOS=\@xy BOX=$fitbox VERBOSE=0 GAUSSIAN=$gaussian MODEL=$plotfit

  # Proceed if the fit was successful
  my $beamfit = 0;
  if ( $_FIT_SOURCE_{FIT} ) {
    # Although it's for assessing beam fits, we can use it here to
    # ensure that the fit is reasonable
    my $amp = $_FIT_SOURCE_{AMPLITUDE};
    my $major = $_FIT_SOURCE_{MAJFWHM};
    my $minor = $_FIT_SOURCE_{MINFWHM};
    my $axisr = $_FIT_SOURCE_{AXISR};
    _ASSESS_BEAM_FIT_ AMP=$amp MAJOR=$major MINOR=$minor AXISR=$axisr
    $beamfit = $_ASSESS_BEAM_FIT_{BEAM};
  }
  # If the fit looks good, retrieve fit parameters, otherwise use the
  # maximum derived above
  if ($beamfit) {
    my $amp = $_FIT_SOURCE_{AMPLITUDE};
    $peak = $amp->[0];
    # Use the uncertainty in the fit - could use the RMS to get a
    # better sense of the overall uncertainty but in practice it's
    # only a little bit higher than this
    $dpeak = $amp->[1];
    $posn = $_FIT_SOURCE_{POSITION};
    $snr = $_FIT_SOURCE_{SNR};
    orac_print " Fitted peak at $posn->[0], $posn->[1]\n" if ($verbose);
    my %fitpars = %_FIT_SOURCE_;
    $_PRIM_ARGS_->{BEAM} = \%fitpars;

    # Plot fit + data?
    if ($plotfit) {
      # Store and tag the image and fit - restoring the contents of
      # the object can safely be left to the end of the primitive
      # because the object is not used again
      $Obj->files($image, $_FIT_SOURCE_{MODELFIT});
      $Obj->tagset("profile_fit");
      _PLOT_FIT_PROFILE_ GROUP=$group
    }
  } else {
    orac_warn "Fit to source failed - using peak position instead\n";
    $peak = $peakval;
    $dpeak = $peakerr;
    $posn = \@xy;
    # Return a SNR of 0 if the uncertainty is not defined
    $snr = ($dpeak && $dpeak > 0) ? $peak / $dpeak : 0;
    orac_print " Found peak at $posn->[0], $posn->[1]\n" if ($verbose);
  }
  # Having gone to the trouble of finding the peak, store it so it can
  # be used again later
  $Obj->uhdr("MAP_PEAK_POSITION", $posn) if ($posn && @$posn);
} else {
  # These will be undef, but return them anyway
  $peak = $peakval;
  $dpeak = $peakerr;
  $posn = \@xy;
  $snr = $peaksnr;
}

# Store the result in the hash
$_PRIM_ARGS_->{PEAK} = $peak;
$_PRIM_ARGS_->{PEAKERR} = $dpeak;
$_PRIM_ARGS_->{POSITION} = $posn;
$_PRIM_ARGS_->{SNR} = $snr;

# Restore object to original state
$Obj->tagretrieve("find_map_peak_input");
$Obj->product( $inproduct );
