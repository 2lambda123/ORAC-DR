#! -*-perl-*-

=head1 NAME

_FIND_INTEGRATED_INTENSITY_ - aperture photometry of maps using statistics

=head1 SYNOPSIS

 _FIND_INTEGRATED_INTENSITY_

 _FIND_INTEGRATED_INTENSITY_  LOGFILE=0

=head1 DESCRIPTION

This primitive calculates the integrated intensity, in whatever units
the map is currently using, around a single (point) source that is
assumed to be the only source on the map (so that the sky contribution
can be calculated). The value is corrected for pixel area. The SKY
domain is used throughout.

The integrated intensity is calculated using the following technique:

=over 4

=item 1

Define radius of aperture. This is assumed to be 20 arcsec.

=item 2

Find centroid and mask all data centred on this outside the calculated
radius.

=item 3

Calculate the sum of all valid pixels.

=item 4

For a number of `sky' positions, generate a mask and find the
mean and standard deviation of the sky.

=item 5

Choose the sky region with the lowest noise (deemed to be the region
of the map least affected by noisy pixels). The mean is not subtracted
from the image since it is assumed that sky removal and surface
fitting have already done that.

=item 6

Correct for pixel size to convert the sum to an area integral.
Calculate signal-to-noise ratio.

=back

This primitive is Frame based (C<$Frm>) and either acts on each image
in the frame or only on the one selected by the FRAME
argument. UPDATE!!

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item IMAGE

The usual input file... will use current Frm

=item CATALOGUE

...

=item LOGFILE

A flag to indicate whether a log file should be written containing the
results of the integrated intensity calculation. Default is true.

=item VERBOSE

Flag to indicate whether informational messages should be given to the
user. Default is true.

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA

C<ardmask>, C<stats>, C<histat>

=back

=head1 OUTPUT DATA

On completion, the primitive hash C<%_FIND_INTEGRATED_INTENSITY_>
contains the following keys:

=over 4

=item TOTALFLUX

A reference to an array containing the integrated intensity for each
source in the catalogue

=item PEAKFLUX

A reference to an array containing the peak intensity for each source
in the catalogue

=back

The frame object is not updated.

=head1 NOTES

It may be desireable to allow different domains to be used.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>,
Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2005-2007 Particle Physics and Astronomy Research
Council and University of British Columbia.  All Rights Reserved.

=cut

$ORAC::Tempfile::DEBUG = 1;

# Set the input file name
my $in = (exists $_FIND_INTEGRATED_INTENSITY_{IMAGE} &&
	  defined $_FIND_INTEGRATED_INTENSITY_{IMAGE}) 
          ? $_FIND_INTEGRATED_INTENSITY_{IMAGE} : undef;

# Obtain the catalogue 
#my $catalogue = (exists $_FIND_INTEGRATED_INTENSITY_{CATALOGUE} &&
#		 defined $_FIND_INTEGRATED_INTENSITY_{CATALOGUE}) 
#                 ? $_FIND_INTEGRATED_INTENSITY_{CATALOGUE} : undef;

#unless ( defined ($catalogue) && defined ($in) ) {
#  orac_throw "Error: _FIND_INTEGRATED_INTENSITY_ must be supplied with an image and corresponding catalogue\n";
#}

# Write logfile (default to true)
my $uselog = ( exists $_FIND_INTEGRATED_INTENSITY_{LOGFILE} && 
	       defined $_FIND_INTEGRATED_INTENSITY_{LOGFILE} ) ?
               $_FIND_INTEGRATED_INTENSITY_{LOGFILE} : 1;

# Should I be verbose (default to yes)
my $verbose = ( exists $_FIND_INTEGRATED_INTENSITY_{VERBOSE} && 
		defined $_FIND_INTEGRATED_INTENSITY_{VERBOSE} ) ?
                $_FIND_INTEGRATED_INTENSITY_{VERBOSE} : 1;

# Set the WCS domain to SKY

# Define X and Y positions
my ($x, $y);
if ( exists $_FIND_INTEGRATED_INTENSITY_{XYPOS} && 
     defined $_FIND_INTEGRATED_INTENSITY_{XYPOS} && 
     ref($_FIND_INTEGRATED_INTENSITY_{XYPOS}) eq "ARRAY" ) {
  ($x, $y) = @{ $_FIND_INTEGRATED_INTENSITY_{XYPOS} };
} else {
  orac_throw "Error: must provide an array reference with X, Y position of source\n";
}

# Set radius of mask - default is 20 arcsec
my $radius = $_FIND_INTEGRATED_INTENSITY_{RADIUS} || 20.0;

# Create the temporary file for the ard description
my $ard = new ORAC::TempFile;

# Write the ard description
# In kappa 18 we need to add a COFRAME - we are using arcseconds
if (starversion_gt('kappa','V0.18-0')) {
  print {$ard->handle} "COFRAME(SKY,System=FK5)\n";
}

# Mask out everything EXCEPT a circle centred on x, y. Note the
# conversion of radius from arcsec to sky (FK5) coords.
print {$ard->handle} ".NOT.CIRCLE($x, $y, 00:00:$radius)\n";

# Close the file
$ard->handle->close;

# Get temporary output file
my $outobj = new ORAC::TempFile;
my $out = $outobj->file;
my $ardin = $ard->file;

# Arguments for ardmask depend on kappa version
my $ardargs;
if (starversion_lt('kappa','V0.18-0')) {
  $ardargs = " cosys=data ";
} else {
  $ardargs = " "; # in the ard file
}

# Run ardmask
$Mon{kappa_mon}->obeyw("ardmask", "in=$in out=$out ardfile=$ardin $ardargs");

# Now calculate stats of the masked file to get the flux in the
# aperture
$Mon{kappa_mon}->obeyw("stats","ndf=$out");

# Get sum and number of valid pixels
my $ORAC_STATUS;
($ORAC_STATUS, my $sum) = $Mon{kappa_mon}->get("stats","total");
($ORAC_STATUS, my $maxflux) = $Mon{kappa_mon}->get("stats","maximum");
($ORAC_STATUS, my $ngood) = $Mon{kappa_mon}->get("stats","numgood");
($ORAC_STATUS, my $sigma) = $Mon{kappa_mon}->get("stats","sigma");

if ($verbose) {
  my $outsum = sprintf "%6.2f", $sum;
  orac_print "Sum calculated to be $outsum\n";
}

# Calculate error on the sum (done the simple way)
#my $err = sqrt($ngood) * $noise;
#orac_warn "All pixels in aperture are bad!\n"
#  if $ngood == 0;

# Signal-to-noise
#my $s2n;
#if (abs($err) <= 1.0e-30) {
#  # protect division by zero and assume that very small
#  # error really means an error in the calculation
#  $s2n = 0.0;
#} else {
#  # signal-to-noise is positive
#  $s2n = abs($sum / $err);
#}

# Store sum in the hash
$_FIND_INTEGRATED_INTENSITY_{TOTALFLUX} = $sum;
$_FIND_INTEGRATED_INTENSITY_{PEAKFLUX} = $maxflux;
$_FIND_INTEGRATED_INTENSITY_{SIGMA} = $sigma;

# Tidy up by deleting masked file
#undef $outobj;

# User feedback
orac_print "Calculated integrated intensity\n" if $verbose;
