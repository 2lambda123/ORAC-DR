# -*-perl-*-

=head1 NAME

_FIT_BEAM_ - Calculate the beam size from a calibrator

=head1 SYNOPSIS

 _FIT_BEAM_ IMAGE=$Frm->file

 _FIT_BEAM_ IMAGE=$image XYPOS=\@xypos

=head1 DESCRIPTION

This primitive carries out a 2-D Gaussian fit to a calibrator to
determine the beam size and position angle using one of two available
methods. The reported values are the full-width-at-half-maximum (FWHM)
along the major and minor axes, and the beam position angle on the sky
at the time of obseration. The fit is performed in the SKY domain so
the FWHM is returned in arcsec.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<BOX>

Size of square area in pixels in which to carry out the fit. Must be
at least 10. Default is 25.

=item B<IMAGE>

Name of image to fit beam. No default.

=item B<VERBOSE>

Flag to indicate whether informational messages should be given to the
user. Default is 1 (print messages).

=item B<XYPOS>

An array reference containing the formatted X, Y coordinates in the
chosen frame. Default is (0,0).

=back

=head1 EXTERNAL TASKS

=over 4

=item KAPPA:

BEAMFIT, STATS

=item ORAC-DR PRIMITIVES:

_CENTROID_IMAGE_, _FIT_PSF_, _FIND_INTEGRATED_INTENSITY_,
_GET_LOG_PARAMETERS_

=back

=head1 NOTES

This method only fits a single component to the beam. This is not
enough at 450 microns, but currently the beam is not sufficiently
well-known to do much more.

Using coordinate frames other than AzEl will cause the beam to appear
to rotate during the course of an observation.

=head1 OUTPUT DATA

The following keys are returned in the primitive hash:

=over 4

=item AMPLITUDE

The peak signal in the current units.

=item POSITION

The position at which the beam is centred.

=back

=head1 OUTPUT FILES


=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>,

=head1 COPYRIGHT

Copyright (C) 2009 the University of British Columbia.  All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

use constant RAD2ASEC => 206265.0;

# Should we be verbose? (Default to yes)
my $verbose = get_prim_arg($_PRIM_ARGS_, "VERBOSE", 1);

# Mandatory input image
my $in = get_prim_arg($_PRIM_ARGS_, "IMAGE", undef);
# Go no further if no input image was given
unless (defined $in) {
  orac_err "Error: _FIT_BEAM_ requires an image file as input\n";
  return ORAC__OK;
}

# Fitarea (corresponds to BOX parameter of _FIT_PSF_). Must be greater
# than 9, so check and set it to the minimum. Note that fitarea may be
# null, "!", so check that before attempting to do a numerical comparison.
my $fitarea = get_prim_arg($_PRIM_ARGS_, "BOX", 25);
if ( $fitarea ne "!") {
  $fitarea = 10 if ( $fitarea < 10 );
}

# Check that we have enough good values in the image before attempting
# to fit the beam
$Mon{kappa_mon}->obeyw("stats","ndf=$in");
(my $ORAC_STATUS, my $numgood) = $Mon{kappa_mon}->get("stats","numgood");

# Define the minimum number of useful pixels as ($fitarea+1)^2
my $minpix = ($fitarea+1)*($fitarea+1);

# Make sure it lies within the bounds of the image though!
($ORAC_STATUS, my $numpix) = $Mon{kappa_mon}->get("stats","numpix");
$minpix = $numpix if ( $minpix > $numpix );

# We now run PSF if possible
if ( $numgood >= $minpix ) {

  # Estimated source position - default to 0,0
  my $xypos = get_prim_arg($_PRIM_ARGS_, "XYPOS", [0,0]);
  my $pos = '"'.$xypos->[0].", ".$xypos->[1].'"';

  # Use BEAMFIT - define args
  my $var = "false";
  my $args = "mode=interface pos=$pos variance=$var fitarea=$fitarea";

  # Call beamfit
  $Mon{kappa_mon}->obeyw("beamfit","ndf=$in $args");

  # Retrieve fit parameters
  my @params = (qw/ majfwhm minfwhm orient amp centre /);
  ($ORAC_STATUS, my %bfitres) = $Mon{kappa_mon}->mget("beamfit",@params);

  # Read the FWHM and convert to arcsec
  my @majfwhm = map {$_ * RAD2ASEC} @{$bfitres{majfwhm}};
  my @minfwhm = map {$_ * RAD2ASEC} @{$bfitres{minfwhm}};
  my $axisr = $majfwhm[0] / $minfwhm[0];

  # Amplitude and orientation with error
  my @orient = @{$bfitres{orient}};
  my @amp = @{$bfitres{amp}};

  # Calculate total flux under the gaussian
  my $totalflux = 1.133 * $amp[0] * $majfwhm[0] * $minfwhm[0];

  # Fitted peak position
  my @posn = split(/\s+/, $bfitres{centre}->[0], 2);

  # Store results in primitive hash
  $_FIT_BEAM_{AMPLITUDE} = \@amp;
  $_FIT_BEAM_{AXISR}     = $axisr;
  $_FIT_BEAM_{MAJFWHM}   = \@majfwhm;
  $_FIT_BEAM_{MINFWHM}   = \@minfwhm;
  $_FIT_BEAM_{ORIENT}    = \@orient;
  $_FIT_BEAM_{POSITION}  = \@posn;
  $_FIT_BEAM_{TOTALFUX}  = $totalflux;

  # Tell user of success if requested
  if ($verbose) {
    my $fwhm1 = sprintf "%5.2f", $minfwhm[0];
    my $orient = sprintf "%5.2f", $orient[0];
    my $fwhm2 = sprintf "%5.2f", $axisr*$fwhm1;
    orac_print "Successful 2-D Gaussian fit: FWHM = $fwhm1 x $fwhm2 arcsec^2, ORIENT = $orient deg\n";
  }

} else {
  orac_warn "Insufficient number of good values to fit a 2-D Gaussian profile in the current image\n"
    if $verbose;

  # Return some dummy values to prevent dereferencing errors
  $_FIT_BEAM_{AMPLITUDE} = [0, undef];
  $_FIT_BEAM_{MAJFWHM}   = [0, undef];
  $_FIT_BEAM_{MINFWHM}   = [-1, undef];
  $_FIT_BEAM_{ORIENT}    = [0, 0];
  $_FIT_BEAM_{POSITION}  = [0, 0];

}
