# -*-cperl-*-

=head1 NAME

_FIT_BEAM_ - Calculate the beam size from a calibrator

=head1 SYNOPSIS

 _FIT_BEAM_ IMAGE=$Frm->file

 _FIT_BEAM_ IMAGE=$image XYPOS=\@xypos

=head1 DESCRIPTION

This primitive carries out a 2-D Gaussian fit to a calibrator to
determine the beam size and position angle using one of two available
methods. The reported values are the full-width-at-half-maximum (FWHM)
along the major and minor axes, and the beam position angle on the sky
at the time of obseration. The fit is performed in the SKY domain so
the FWHM is returned in arcsec.

See also L<_FIT_PSF_|_FIT_PSF_>

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<BOX>

Size of square area in pixels in which to carry out the fit. Must be
at least 10. Default is C<!>, which uses the whole image.

=item B<IMAGE>

Name of image to fit beam. No default.

=item B<VERBOSE>

Flag to indicate whether informational messages should be given to the
user. Default is 1 (print messages).

=item B<XYPOS>

An array reference containing the formatted X, Y coordinates in the
chosen frame. Default is (0,0).

=back

=head1 EXTERNAL TASKS

The following external tasks are used.

=over 4

=item KAPPA:

BEAMFIT, STATS

=back

=head1 NOTES

This method only fits a single component to the beam. This is not
enough at 450 microns, but currently the beam is not sufficiently
well-known to do much more.

Using coordinate frames other than AzEl will cause the beam to appear
to rotate during the course of an observation.

=head1 OUTPUT DATA

The following keys are returned in the primitive hash if the fit was
successful.

=over 4

=item AMPLITUDE

Array reference with the peak signal and its uncertainty in the
current units.

=item AXISR

Axial ratio of the beam.

=item FIT

Contains 1 on success, 0 on failure. Will be the only entry defined on
failure.

=item MAJFWHM

Array reference with the FWHM of the major axis and its uncertainty.

=item MINFWHM

Array reference with the FWHM of the minor axis and its uncertainty.

=item ORIENT

Array reference with the beam orientation and its uncertainty, in
degrees east of north in current coordinate frame

=item POSITION

The position at which the beam is centred.

=item RMS

The RMS of the fit, in the current units.

=item TOTALFLUX

Array reference with the total area under fit and its uncertainty, in
units of AMP*FWHM^2.

=back

=head1 OUTPUT FILES

None

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>,

=head1 COPYRIGHT

Copyright (C) 2009 the University of British Columbia.  All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

use constant RAD2ASEC => 206265.0;

# Should we be verbose? (Default to yes)
my $verbose = get_prim_arg($_PRIM_ARGS_, "VERBOSE", 1);

# Mandatory input image
my $in = get_prim_arg($_PRIM_ARGS_, "IMAGE", undef);
# Go no further if no input image was given
unless (defined $in) {
  orac_err "Error: _FIT_BEAM_ requires an image file as input\n";
  return ORAC__TERM;
}

# Fitarea (corresponds to BOX parameter of _FIT_PSF_). Must be greater
# than 9, so check and set it to the minimum. Note that fitarea may be
# null, "!", so check that before attempting to do a numerical comparison.
my $fitarea = get_prim_arg($_PRIM_ARGS_, "BOX", 25);
my $minpix;

# Check that we have enough good values in the image before attempting
# to fit the beam
$Mon{kappa_mon}->obeyw("stats","ndf=$in");
(my $ORAC_STATUS, my $numgood) = $Mon{kappa_mon}->get("stats","numgood");
($ORAC_STATUS, my $numpix) = $Mon{kappa_mon}->get("stats","numpix");
if ( $fitarea ne "!") {
  $fitarea = 10 if ( $fitarea < 10 );

  # Define the minimum number of useful pixels as ($fitarea+1)^2
  $minpix = ($fitarea+1)*($fitarea+1);
  # Make sure it lies within the bounds of the image though!
  $minpix = $numpix if ( $minpix > $numpix );
} else {
  $minpix = $numgood;
}


# We now run PSF if possible
if ( $numgood >= $minpix ) {

  orac_print "Fitting 2-D Gaussian to source... " if $verbose;

  # Estimated source position - default to 0,0
  my $xypos = get_prim_arg($_PRIM_ARGS_, "XYPOS", [0,0]);
  my $pos = '"'.$xypos->[0].", ".$xypos->[1].'"';

  # Use BEAMFIT - define args
  my $var = "false";
  my $args = "mode=interface pos=$pos variance=$var fitarea=$fitarea";

  # Call beamfit
  my $BEAM_STATUS = $Mon{kappa_mon}->obeyw("beamfit","ndf=$in $args");

  if ( $BEAM_STATUS == ORAC__OK ) {
    # Retrieve fit parameters
    my @params = (qw/ majfwhm minfwhm orient amp centre back rms /);
    ($ORAC_STATUS, my %bfitres) = $Mon{kappa_mon}->mget("beamfit",@params);

    # Read the FWHM and convert to arcsec
    my @majfwhm = map {$_ * RAD2ASEC} @{$bfitres{majfwhm}};
    my @minfwhm = map {$_ * RAD2ASEC} @{$bfitres{minfwhm}};
    orac_err "Beamfit appeared to be successful but no FWHM was derived"
      if (!defined $minfwhm[0] || !defined $majfwhm[0]);
    # Set axisr to a non-physical value if no fwhm could be obtained
    my $axisr = ( $minfwhm[0] > 0 ) ? $majfwhm[0] / $minfwhm[0] : -1;

    # Amplitude, RMS and orientation with error
    my @amp = @{$bfitres{amp}};
    my @orient = @{$bfitres{orient}};
    my $rms = $bfitres{rms};

    # Background level
    my @backgr = @{$bfitres{back}};

    # Calculate total flux under the gaussian
    my $totalflux = 1.133 * $amp[0] * $majfwhm[0] * $minfwhm[0];
    # Estimate error assuming uncertainties add in quadrature
    my $fluxerr = $totalflux * ( $amp[1]*$amp[1]/($amp[0]*$amp[0]) +
			         $minfwhm[1]*$minfwhm[1]/($minfwhm[0]*$minfwhm[0]) +
			         $majfwhm[1]*$majfwhm[1]/($majfwhm[0]*$majfwhm[0])
			       );

    # Fitted peak position
    my @posn = split(/\s+/, $bfitres{centre}->[0], 2);

    # Store results in primitive hash
    $_FIT_BEAM_{FIT}       = 1;
    $_FIT_BEAM_{AMPLITUDE} = \@amp;
    $_FIT_BEAM_{AXISR}     = $axisr;
    $_FIT_BEAM_{MAJFWHM}   = \@majfwhm;
    $_FIT_BEAM_{MINFWHM}   = \@minfwhm;
    $_FIT_BEAM_{ORIENT}    = \@orient;
    $_FIT_BEAM_{POSITION}  = \@posn;
    $_FIT_BEAM_{TOTALFLUX} = [$totalflux, $fluxerr];
    $_FIT_BEAM_{RMS}       = $rms;

    # Tell user of success if requested
    if ($verbose) {
      $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
      ($ORAC_STATUS, my $units) = $Mon{ndfpack_mon}->get("ndftrace","units");
      $units = "unknown" if (!defined $units);
      my $fwhm1 = sprintf "%5.2f", $minfwhm[0];
      my $orient = sprintf "%5.2f", $orient[0];
      my $fwhm2 = sprintf "%5.2f", $axisr*$fwhm1;
      my $amp1 = sprintf "%5.2e", $amp[0];
      my $flux1 = sprintf "%5.2e", $totalflux;

      # Report correct units for total fluxes if data are calibrated
      # in (say) mJy/beam, and correct the reported total flux for the
      # beam area in square arcsec.
      my $totalunits;
      if ($units =~ /beam/i) {
	$totalunits = $units;
	$totalunits =~ s/\/beam//;
	# Beam FWHM
	my $fwhm = $Cal->fwhm;
	use Astro::SLA qw/ :constants/;
	# Beam area in square arcsec
	my $beamarea = DPI * $fwhm * $fwhm / 4.0;
	$flux1 = sprintf "%5.2e", ($totalflux / $beamarea);
      } else {
	$totalunits = $units . " arcsec**2";
      }
      orac_print "Successful fit:\n"
	."  FWHM = $fwhm1 x $fwhm2 arcsec**2, ORIENT = $orient deg\n"
	."  AMP  = $amp1 $units, TOTAL FLUX = $flux1 ($totalunits)\n";
    }
  } elsif ( $BEAM_STATUS == 234127368 ) {
    # PDA error status: PDA__FICMX: Failed to invert the curvature
    # matrix to derive fit errors
    orac_warn "Beamfit failed: unable to determine fit errors\n";
    $_FIT_BEAM_{FIT} = 0;

  } elsif ( $BEAM_STATUS == 233209874 ) {
    # PSX error status: PSX__NOALL: Null pointer returned on memory
    # allocation
    orac_warn "Beamfit failed: unable to allocate memory\n";
    $_FIT_BEAM_{FIT} = 0;

  } else {
    orac_err "Beamfit failed in an unexpected manner\n";
    $_FIT_BEAM_{FIT} = 0;
    $ORAC_STATUS = $BEAM_STATUS;
  }

} else {
  orac_warn "Insufficient number of good values to fit a 2-D Gaussian profile in the current image\n"
    if $verbose;

  $_FIT_BEAM_{FIT} = 0;
}
