# -*-perl-*-

=head1 NAME

_GET_PIXEL_SCALE_ - Determine the pixel scale for a given image

=head1 DESCRIPTION

_GET_PIXEL_SCALE_ determines the pixel scale for a given image by
examining the information in the WCS extension. The calculation is
carried out by defining triplets of PIXEL positions in the image,
converting these into positions in the desired output frame (e.g. SKY)
and then using astDistance to compute the distance in radians between
the positions in the x- and y-directions respectively. Since field
distortion will change the scale across the image, the average of the
four corners plus the mid-point is returned.

Returns an error if desired frame is not in the frameset; currently
this means that if there is no SKY frame the primitive aborts.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item IMAGE

Name of image. No default.

=item DOMAIN

Desired domain for output values. Default is SKY. (Currently SKY is
the B<only> supported domain.)

=item UNITS

Units for returned pixel scale. Valid units are radians, arcsec,
arcmin or degrees. Default is arcsec.

=item DERIVE

Flag to denote whether to derive the pixel scale from the image
manually or use the value reported by ndftrace. Default is 0 (false)

=item VERBOSE

Flag to indicate whether informational messages should be 
given to the user. Default is 1 (true).

=back

=head1 EXTERNAL TASKS

=over 4

=item AST and NDF

=back

=head1 OUTPUT DATA

On completion, the primitive hash C<%_GET_PIXEL_SCALE_>
contains the following keys:

=over 4

=item RESULTS

Array reference with pixel scales in the X and Y directions in the
requested units.

=item AREA

Pixel area in units**2

=back

=head1 KNOWN ISSUES

The checking for the presence of the SKY frame is not very
sophisticated, and only relies on seeing if a variable is left unset.

Output frames other than SKY are not yet supported.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2005-2007 the University of British Columbia.  All
Rights Reserved.

=cut

# Load AST & NDF modules
use Starlink::AST;
use NDF;

# Determine that we have an image as an argument...
unless (exists $_GET_PIXEL_SCALE_{IMAGE} && defined $_GET_PIXEL_SCALE_{IMAGE}) {
  orac_throw "Error: _GET_PIXEL_SCALE_ requires a file as input \n";
}

# Set the input file
my $in = $_GET_PIXEL_SCALE_{IMAGE};

# Should I be verbose? (default to yes)
my $verbose = get_prim_arg($_PRIM_ARGS_, "VERBOSE", 1);

# Values will be returned in these units:
my $units = lc(get_prim_arg($_PRIM_ARGS_, "UNITS", "arcsec"));

# Do we want to return the mapping?
my $wantmap = get_prim_arg($_PRIM_ARGS_, "WANTMAP", 0);

# Are we being asked to derive it ourselves? Default is no.
my $derive = get_prim_arg($_PRIM_ARGS_, "DERIVE". 0);

if ( $derive == 0 ) {
  # Note the WANTMAP option is incompatible with DERIVE=0
  if ( $wantmap && $verbose ) {
    orac_warn "Unable to return mapping with DERIVE=0";
    $wantmap = 0;
  }
  if ($units ne "arcsec" && $verbose ) {
    orac_warn "Ndftrace call requested: pixel scales will be returned in arcsec";
  }
}

my $unitconv;
if ( $units =~ /arcsec/ ) {
  $unitconv = 206264.806;
} elsif ( $units =~ /arcmin/ ) {
  $unitconv = 3437.74677;
} elsif ( $units =~ /deg/ ) {
  $unitconv = 57.2957795;
} elsif ( $units =~ /rad/ ) {
  $unitconv = 1.0;
} else {
  orac_warn "_GET_PIXEL_SCALE_: Unknown output units, $units - assuming arcsec\n";
  $unitconv = 206264.806;
}

# initialise the results array
$_GET_PIXEL_SCALE_{RESULTS} = [];

my $ORAC_STATUS;
my ($avxscale, $avyscale) = (0.0, 0.0);
my $mapping = undef;

if ( $derive ) {
  my $indomain = "PIXEL";
  # Check the desired output frame - default is SKY
  my $outdomain = uc(get_prim_arg($_PRIM_ARGS_, "DOMAIN", "SKY"));

  # For now only sky domains are supported. Shouldn't be too much of a
  # problem as I can't see anyone wanting any of the intermediate
  # domains.
  unless ($outdomain =~ /SKY/) {
    orac_throw "Sorry requested domain $outdomain is not yet supported \n";
  }

  # Create FrameSet from the WCS info in the input file
  my $STATUS = 0;
  ndf_begin();
  ndf_find( &NDF::DAT__ROOT(), $in, my $indf, $STATUS );

  my $frameset = ndfGtwcs( $indf, $STATUS );
  ndf_annul( $indf, $STATUS );
  ndf_end( $STATUS );

  # Frame numbers corresponding to the given in/out domain names
  my $indom;
  my $outdom = -1;
  # Number of Frames in the FrameSet
  my $nframes = $frameset->Get( 'Nframe' );

  # Loop over the number of domains in the FrameSet to set the Frame
  # number for the specified domain
  for my $i (1 .. $nframes) {
    my $tmp_frame = $frameset->GetFrame( $i );
    my $domain = $tmp_frame->Get( 'Domain' );
    $indom = $i if ($domain eq $indomain);
    $outdom = $i if ($domain eq $outdomain);
  }

  # Check that the SKY domain exists - not fancy as it only
  # checks whether $outdom is unset
  orac_throw "Error: Image has no SKY domain \n" if ($outdom == -1);

  # Retrieve the output SkyFrame
  my $outframe = $frameset->GetFrame( $outdom );

  # Retrieve mapping between PIXEL and SKY domains
  $mapping = $frameset->GetMapping( $indom, $outdom );

  # Get PIXEL bounds for image
  $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
  ($ORAC_STATUS, my $xmin, my $ymin) = $Mon{ndfpack_mon}->get("ndftrace","lbound");
  ($ORAC_STATUS, my $xmax, my $ymax) = $Mon{ndfpack_mon}->get("ndftrace","ubound");

  # Loop over 5 positions to calculate X and Y scale and calculate average
  my (@xpixels, @ypixels);
  for my $posindex (1..5) {
    # Set up arrays of positions to use in pixel coords: four corners
    # plus centre.
    if ( $posindex == 1 ) {
      @xpixels = ($xmin, $xmin, $xmin+1);
      @ypixels = ($ymin, $ymin+1, $ymin);
    } elsif ( $posindex == 2 ) {
      @xpixels = ($xmin, $xmin, $xmin+1);
      @ypixels = ($ymax, $ymax-1, $ymax);
    } elsif ( $posindex == 3 ) {
      @xpixels = ($xmax, $xmax, $xmax-1);
      @ypixels = ($ymax, $ymax-1, $ymax);
    } elsif ( $posindex == 4 ) {
      @xpixels = ($xmax, $xmax, $xmax-1);
      @ypixels = ($ymin, $ymin+1, $ymin);
    } elsif ( $posindex == 5 ) {
      my $xmid = int( $xmax - $xmin );
      my $ymid = int( $ymax - $ymin );
      @xpixels = ($xmid, $xmid+1, $xmid);
      @ypixels = ($ymid, $ymid, $ymid+1);
    }

    # Convert pixel positions into sky positions using the mapping we
    # derived earlier
    (my $xskyref, my $yskyref) = $mapping->Tran2( \@xpixels, \@ypixels, 1);

    # Output positions on the sky
    my @xsky = ($xskyref->[0], $xskyref->[1], $xskyref->[2] );
    my @ysky = ($yskyref->[0], $yskyref->[1], $yskyref->[2] );

    # Use astDistance to calculate the distance on the sky between the positions
    my $pt1 = [ $xsky[0], $ysky[0] ] ;
    my $pt2 = [ $xsky[2], $ysky[2] ] ;
    my $xscale = $outframe->Distance($pt1, $pt2);

    $pt2 = [ $xsky[1], $ysky[1] ] ;
    my $yscale = $outframe->Distance($pt1, $pt2);

    # Now, xscale and yscale are in radians, and so must be converted to
    # the output units.
    unless ( $unitconv == 1.0 ) {
      $xscale *= $unitconv;
      $yscale *= $unitconv;
    }
    # Add to sum
    $avxscale += $xscale;
    $avyscale += $yscale;
  }
  # Calculate average value to use
  $avxscale /= 5;
  $avyscale /= 5;

} else {
  # Alternatively, use ndftrace to get the pixel scale. This may or
  # may not be a better estimate. Note this always returns arcsec.
  $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
  ($ORAC_STATUS, $avxscale, $avyscale) = $Mon{ndfpack_mon}->get("ndftrace","fpixscale");
}

# Store the results in the hash
$_GET_PIXEL_SCALE_{RESULTS} = [$avxscale, $avyscale];
$_GET_PIXEL_SCALE_{AREA} = $avxscale*$avyscale;

# If the caller would like access to the mapping then store that too
if ( $wantmap ) {
  $_GET_PIXEL_SCALE_{MAPPING} = $mapping
}

# Format for pretty printing
if ($verbose) {
  $avxscale = sprintf "%6.2f", $avxscale;
  $avyscale = sprintf "%6.2f", $avyscale;
  orac_print " (X, Y) pixel scale is ($avxscale, $avyscale) $units \n";
  orac_print "Successfully calculated pixel scale for image\n";
}

