=head1 NAME

_FIT_INTERFEROGRAM_PEAK_ - fits a peak in an interferogram

=head1 SYNOPSIS

 _SET_INTERFEROGRAM_PEAK_

=head1 DESCRIPTION

This primitive fits a peak in an interferogram.

=head1 ARGUMENTS

ESTIMATE can either be 'fixed' to search only near the
specified ZPD position estimate, or 'smooth' to smooth
the interferogram to determine an initial estimate of
the position.

=head1 EXTERNAL TASKS

KAPPA, SMURF, NDFPACK.

=head1 OUTPUT DATA

None

=head1 OUTPUT FILES

None.

=head1 NOTES

None.

=head1 AUTHOR

Graham Bell E<lt>g.bell@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2012 Science and Technology Facilities Council.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

use JSA::Headers qw/read_jcmtstate/;

my @output = ();

my $estimate = lc(get_prim_arg($_PRIM_ARGS_, 'ESTIMATE', 'fixed'));
my $zpd = $Frm->uhdr('FTS_ZPD_ESTIMATE');
orac_termerr('FTS_ZPD_ESTIMATE is missing') unless defined $zpd;
my $height = $Frm->uhdr('FTS_ZPD_PEAK_HEIGHT');
orac_termerr('FTS_ZPD_PEAK_HEIGHT is missing') unless defined $height;
my $width = $Frm->uhdr('FTS_ZPD_PEAK_WIDTH');
orac_termerr('FTS_ZPD_PEAK_WIDTH is missing') unless defined $width;
my $off = $Frm->uhdr('FTS_ZPD_BASE_OFFSET');
orac_termerr('FTS_ZPD_BASE_OFFSET is missing') unless defined $off;
my $wid = $Frm->uhdr('FTS_ZPD_BASE_WIDTH');
orac_termerr('FTS_ZPD_BASE_WIDTH is missing') unless defined $wid;
my $boxwidth = $Frm->hdr('FILTER') =~ /850/ ? 200 : 100;

my $range = sprintf('%.03f:%.03f', $zpd - ($off + $wid), $zpd - $off);


# Write FIT1D config file.

my $cfg = new ORAC::TempFile(OPEN => 1, SUFFIX => '.def');
{
  local $\ = "\n"; local $, = "\n";
  my $fh= $cfg->handle();
  print $fh '^'.$ENV{'SMURF_DIR'}.'/smurf_fit1d.def',
            'function=gaussian',
            'ncomp=1',
            'minwidth=1',
            'axis=3';
  $fh->close();
}


for (my $i = 1; $i <= $Frm->nfiles(); $i ++) {
  my ($in, $neg) = $Frm->inout('_neg', $i);
  my $subarray = lc($Frm->subarray($in));

  # Invert interferogram if we expect negative fringes.

  if (grep {$_ eq $subarray} qw/s4b s8d/) {
    $Mon{'kappa_mon'}->obeyw('cmult', "$in -1.0 $neg");
    $in = $neg;
  }

  # Threshold interferogram (to remove negative fringes).

  my (undef, $thr) = $Frm->inout('_thr', $i);
  #$Frm->push_intermediates($thr);
  $Mon{'kappa_mon'}->obeyw('thresh', "$in $thr thrlo=0 newlo=0 thrhi=1000 newhi=bad");

  # Estimate interferogram RMS.
  # Currently do this by taking the 75% percentile of the baselined
  # interferogram in one of the baseline regions.  (Calculating
  # sigma directly gives a very high value, presumably due to
  # bad pixels.)

  $Mon{'kappa_mon'}->obeyw('stats', "$in(,,$range) data order=true percentiles=[75]");
  my ($ORAC_STATUS, @values) = $Mon{'kappa_mon'}->get('stats', qw/PERVAL/);
  my $rms = $values[0];

  # Determine initial ZPD estimate.

  my @fitparams = (
                    'comp1.c=' . $width,
                    'fix1.c=1',
                  );
  my $parndf = '!';

  if ($estimate eq 'fixed') {
    push @fitparams, 'comp1.b=' . $zpd,
                     'comp1.a=' . $height,
  }
  elsif ($estimate eq 'smooth') {
    # In this mode, we smooth the absolute value of the interferogram
    # to fit the ZPD feature.  This gives us an NDF we can feed back
    # into FIT1D to fit the central fringe.

    my (undef, $abs) = $Frm->inout('_abs', $i);
    $Mon{'kappa_mon'}->obeyw('maths', "abs(ia) $abs ia=$in");
    my (undef, $smo) = $Frm->inout('_smo', $i);
    $Mon{'kappa_mon'}->obeyw('block', "$abs $smo box=[1,1,$boxwidth]");
    (undef, $parndf) = $Frm->inout('_sft', $i);
    $Mon{'smurf_mon'}->obeyw('fit1d', "in=$smo out=$parndf parndf=! rms=$rms config=^$cfg userval=\"comp1.c=$wid\"");
  }
  else {
    orac_termerr('Unknown ZPD estimation method ' . $estimate);
  }

  # Write FIT1D values file.

  my $val = new ORAC::TempFile(OPEN => 1, SUFFIX => '.def');
  {
    local $\ = "\n"; local $, = "\n";
    my $fh= $val->handle();
    print $fh @fitparams;
    $fh->close();
  }

  # Perform fit.

  my (undef, $fit) = $Frm->inout('_fit', $i);
  #$Frm->push_intermediates($fit);
  $Mon{'smurf_mon'}->obeyw('fit1d', "in=$thr out=$fit parndf=$parndf rms=$rms config=^$cfg userval=^$val");

  my (undef, $pos) = $Frm->inout('_pos', $i);
  $Mon{'ndfpack_mon'}->obeyw('ndfcopy', "$fit.MORE.SMURF_FIT1D.COMP_1\(,,2\) $pos trim=true");

  # Copy across FITS headers to stop ORAC-DR complaining.

  my $tmp = new ORAC::TempFile(OPEN => 0, SUFFIX => '.lis');
  $Mon{'ndfpack_mon'}->obeyw('fitslist', "$thr $tmp");
  $Mon{'ndfpack_mon'}->obeyw('fitstext', "$pos $tmp");

  push @output, $pos;
}

$Frm->files(@output);

