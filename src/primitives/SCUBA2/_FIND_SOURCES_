#! -*-perl-*-

=head1 NAME

_FIND_SOURCES_ - Find sources in given image

=head1 DESCRIPTION

Find the position of sources in the given image using
SExtractor. Returns an C<Astro::Catalog> object and optionally the
name of a catalogue written to disk.

This primitive is designed to work on a single image and will fail if
the current Frame object contains more than one file.

=head1 ARGUMENTS

=over 4

=item IMAGE

Name of image file to extract point sources from. Default is current
Frame object but only if it contains a single (stacked) image.

=item POINT

Flag to denote whether to return point sources in the
catalogue. Default is 0 (return all sources found).

=item WRITE_CATALOGUE

Flag denote whether to write the catalogue to a disk file. Default is
0 (do not write catalogue).

=item MINPIX

Minimum number of connected pixels defining a source. Default is 9.

=item DETECT_SIGMA

Optional detection threshold in units of standard deviation. Default
is 5.

=item GROUP

Only used if IMAGE is not defined. If true, use the current Group file,
otherwise use the current Frame. Default is 0 (false).

=back

The frame object is not updated.

=head1 OUTPUT DATA

On completion the primitive hash C<%_FIND_SOURCES_> contains
the following keys:

=over 4

=item CATALOGUE

A catalogue in the form of an Astro::Coords object containing
sources

=item CATALOGUE_NAME

Name of disk file containing catalogue. Will be undef if no file was
written.

=back

=head1 STARLINK TASKS

Extractor

=head1 REQUIRED PERL MODULES

Starlink::Extractor, Astro::Catalog, Astro::WaveBand

=head1 AUTHOR

Andy Gibb <agg@astro.ubc.ca>

=head1 COPYRIGHT

Copyright (C) 2007 University of British Columbia. All Rights
Reserved.

=head1 TODO

=over 4

=item - Set up SCUBA2 SExtractor config files in oracdr_cal

=back

=cut

# Set input file - leave undefined if not specified
my $in = ( exists $_FIND_SOURCES_{IMAGE} ) && 
         ( defined $_FIND_SOURCES_{IMAGE}) ? 
         $_FIND_SOURCES_{IMAGE} : undef;

# If not input file was defined use the current group or frame
unless ( defined $in ) {
  # Determine if the user wants to use the current stacked Grp or Frm
  # image
  my $Obj;
  my $group = defined( $_FIND_SOURCES_{GROUP} ) ? 
    $_FIND_SOURCES_{GROUP} : 0;
  if( $group ) {
    $Obj = $Grp;
  } else {
    $Obj = $Frm;
  }
  if ( $Obj->nfiles == 1 ) {
    $in = $Obj->file;
  } else {
    orac_throw "Error: _FIND_SOURCES_ must be run after images have been combined\n";
  }
}

# Should the catalogue contain only point sources? Default is no.
my $point = ( exists $_FIND_SOURCES_{POINT} ) && 
            ( defined $_FIND_SOURCES_{POINT}) ? 
            $_FIND_SOURCES_{POINT} : 0;

# Should the catalogue be written to disk? Default is no.
my $writecatalogue = ( exists $_FIND_SOURCES_{WRITE_CATALOGUE} ) && 
                     ( defined $_FIND_SOURCES_{WRITE_CATALOGUE}) ? 
                     $_FIND_SOURCES_{WRITE_CATALOGUE} : 0;

# Minimum size of box defining a source
my $minpix = ( $_FIND_SOURCES_{MINPIX} || 9 );
# Obtain the detection sigma level.
my $detect = ( $_FIND_SOURCES_{DETECT_SIGMA} || 5 );

# Initialise the results array
$_FIND_SOURCES_{RESULTS} = [];

# Set ellipticity criteria for adding to source catalogue
my $maxel;
if ($point) {
  $maxel = 0.25; # Point-source definition
} else {
  $maxel = 5.0; # Weed out obviously dodgy sources
}

# Run SExtractor
use Starlink::Extractor;
use Astro::WaveBand;
use Astro::Catalog;
my $conf_file = $Cal->find_file("extractor_catalogue.sex");
my $extractor = new Starlink::Extractor( config => $conf_file );
# Set the detection threshold
$extractor->detect_thresh( $detect );
# And the analysis threshold
$extractor->analysis_thresh( 3.0 );
$extractor->verbose_type('NORMAL');

# Note that filter is a mandatory argument so create a dummy one
my $extracted_catalogue = $extractor->extract( frame => $in,
					     filter => new Astro::WaveBand( Filter => $Frm->uhdr("ORAC_FILTER") ) );

# Filter output catalogue to identify point sources
my $filtered_catalogue = new Astro::Catalog( origin => 'ORAC-DR primitive _FIND_POINT_SOURCES_');
my $source;
while ( $extracted_catalogue->sizeof > 0 ) {
  # Pop current source (returns an Astro::Catalog::Star object)
  $source = $extracted_catalogue->popstar;

  # Add suitable sources to output catalogue
  if ( ( $source->morphology->area > $minpix-1 ) && 
       ( $source->morphology->ellipticity < $maxel ) ) {
    $filtered_catalogue->pushstar( $source ) ;
  }
}

if ( $filtered_catalogue->sizeof == 0 ) {
  orac_warn "No sources found in current image\n";
  if ( $writecatalogue ) {
    orac_warn "Will not write catalogue to disk\n";
    $writecatalogue = 0;
  }
}

# Store the resultant catalogue, even if it's empty
$_FIND_SOURCES_{CATALOGUE} = $filtered_catalogue;

# Write to disk if desired.
if ( $writecatalogue ) {
  _GET_CATALOGUE_NAME_
  my $catalogue_name = $_GET_CATALOGUE_NAME_{NAME};
  my $cat_file = File::Spec->catfile($ENV{'ORAC_DATA_OUT'}, $catalogue_name);
  my $status = $filtered_catalogue->write_catalog( file => $cat_file, format => 'Cluster');
  $_FIND_SOURCES_{CATALOGUE_NAME} = $catalogue_name;
  orac_print "Wrote catalogue to $cat_file.\n";
} else {
  $_FIND_SOURCES_{CATALOGUE_NAME} = undef;
}
