# -*-perl-*-

=head1 NAME

_FIND_SOURCES_ - find sources in given image using SExtractor

=head1 SYNOPSIS

 _FIND_SOURCES_

 _FIND_SOURCES_ WRITE_CATALOGUE=1

=head1 DESCRIPTION

Find the position of sources in the given image using
SExtractor. Returns an C<Astro::Catalog> object and optionally the
name of a catalogue written to disk.

This primitive is designed to work on a single image and will fail if
the current Frame object contains more than one file.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<DETECT_SIGMA>

Optional detection threshold in units of standard deviation. Default
is 5.

=item B<GROUP>

Only used if B<IMAGE> is not defined. If true, use the current
Group file. Otherwise, use the current Frame. Default is 0 (false).

=item B<IMAGE>

Name of image file to extract point sources from. No default, but if
left unset image will be determined by the B<GROUP> parameter.

=item B<MINPIX>

Minimum number of connected pixels defining a source. Default is 9.

=item B<POINT>

Flag to denote whether to return point sources in the
catalogue. Default is 0 (return all sources found).

=item B<WRITE_CATALOGUE>

Flag denote whether to write the catalogue to a disk file. Default is
0 (do not write catalogue).

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item EXTRACTOR

EXTRACTOR (via the C<Starlink::Extractor> perl module)

=item ORAC-DR PRIMITIVES

_GET_CATALOG_NAME_

=back

=head1 NOTES

Requires the following perl modules:

Starlink::Extractor, Astro::Catalog, Astro::WaveBand

See also L<_FIND_POINT_SOURCES_|_FIND_POINT_SOURCES_>.

=head1 OUTPUT DATA

On completion the primitive hash C<%_FIND_SOURCES_> contains
the following keys:

=over 4

=item CATALOGUE

A catalogue in the form of an C<Astro::Coords> object containing
sources

=item CATALOGUE_NAME

Name of disk file containing catalogue. Will be undef if no file was
written.

=back

The Frame object is not updated.

=head1 OUTPUT FILES

If the B<WRITE_CATALOGUE> flag is set, a catalogue file will be
written to disk. See L<_GET_CATALOGUE_NAME_|_GET_CATALOGUE_NAME_> for
details of the naming scheme.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2007 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Set input file - leave undefined if not specified
my $in = get_prim_arg( $_PRIM_ARGS_, "IMAGE", undef );

# If not input file was defined use the current group or frame
unless ( defined $in ) {
  # Determine if the user wants to use the current stacked Grp or Frm
  # image
  my $Obj;
  my $group = defined( $_FIND_SOURCES_{GROUP} ) ? 
    $_FIND_SOURCES_{GROUP} : 0;
  if( $group ) {
    $Obj = $Grp;
  } else {
    $Obj = $Frm;
  }
  if ( $Obj->nfiles == 1 ) {
    $in = $Obj->file;
  } else {
    orac_throw "Error: _FIND_SOURCES_ must be run after images have been combined\n";
  }
}

# Should the catalogue contain only point sources? Default is no.
my $point = get_prim_arg( $_PRIM_ARGS_, "POINT", 0 );

# Should the catalogue be written to disk? Default is no.
my $writecatalogue = get_prim_arg( $_PRIM_ARGS_, "WRITE_CATALOGUE", 0 );

# Minimum size of box defining a source
my $minpix = ( $_FIND_SOURCES_{MINPIX} || 9 );
# Obtain the detection sigma level.
my $detect = ( $_FIND_SOURCES_{DETECT_SIGMA} || 5 );

# Initialise the results array
$_FIND_SOURCES_{RESULTS} = [];

# Set ellipticity criteria for adding to source catalogue
my $maxel;
if ($point) {
  $maxel = 0.25; # Point-source definition
} else {
  $maxel = 5.0; # Weed out obviously dodgy sources
}

# Run SExtractor
use Starlink::Extractor;
use Astro::WaveBand;
use Astro::Catalog;
my $conf_file = $Cal->find_file("extractor_catalogue.sex");
my $extractor = new Starlink::Extractor( config => $conf_file );
# Set the detection threshold
$extractor->detect_thresh( $detect );
# And the analysis threshold
$extractor->analysis_thresh( 3.0 );
$extractor->verbose_type('NORMAL');

# Note that filter is a mandatory argument so create a dummy one
my $extracted_catalogue = $extractor->extract( frame => $in,
					     filter => new Astro::WaveBand( Filter => $Frm->uhdr("ORAC_FILTER") ) );

# Filter output catalogue to identify point sources
my $filtered_catalogue = new Astro::Catalog( origin => 'ORAC-DR primitive _FIND_SOURCES_');
my $source;
while ( $extracted_catalogue->sizeof > 0 ) {
  # Pop current source (returns an Astro::Catalog::Star object)
  $source = $extracted_catalogue->popstar;

  # Add suitable sources to output catalogue: note the `numbers'
  # returned by these methods are Number::Uncertainty objects, so call
  # the value method to obtain the actual value.
  if ( ( $source->morphology->area->value >= $minpix ) && 
       ( $source->morphology->ellipticity->value < $maxel ) ) {
    $filtered_catalogue->pushstar( $source ) ;
  }
}

if ( $filtered_catalogue->sizeof == 0 ) {
  orac_warn "No sources found in current image\n";
  if ( $writecatalogue ) {
    orac_warn "Will not write catalogue to disk\n";
    $writecatalogue = 0;
  }
}

# Store the resultant catalogue, even if it's empty
$_FIND_SOURCES_{CATALOGUE} = $filtered_catalogue;

# Write to disk if desired.
if ( $writecatalogue ) {
  _GET_CATALOGUE_NAME_
  my $catalogue_name = $_GET_CATALOGUE_NAME_{NAME};
  my $cat_file = File::Spec->catfile($ENV{'ORAC_DATA_OUT'}, $catalogue_name);
  my $status = $filtered_catalogue->write_catalog( file => $cat_file, format => 'Cluster');
  $_FIND_SOURCES_{CATALOGUE_NAME} = $catalogue_name;
  orac_print "Wrote catalogue to $cat_file.\n";
} else {
  $_FIND_SOURCES_{CATALOGUE_NAME} = undef;
}
