#! -*-perl-*-

=head1 NAME

_MAKE_MOSAIC_FRAME_ - Create frame mosaic

=head1 SYNOPSIS

 _MAKE_MOSAIC_FRAME_ METHOD=MEAN GENVAR=0

=head1 DESCRIPTION

This primitive takes all the aligned sub-frames and mosaics them into
a single output image. A check is made to see if the number of files
to mosaic is greater than the maximum allowed (a value which depends
on the version of CCDPACK installed), and if so the process is divided
into several steps to generate intermediate mosaicked files which are
then mosaicked at the end.

=head1 ARGUMENTS

=over 4

=item B<METHOD>

The method to be used to combine the images. In principle could be any
value supported by MAKEMOS (see MAKEMOS documentation for further
details). Currently, only MEAN or MEDIAN are supported. MEDIAN is the
default.

=item B<GENVAR>

Flag to determine whether or not to use genvar when
mosaicking. Default is 1 (yes),

=item B<VERBOSE>

Flag to denote whether to display extra information. Default is 0
(no).

=back

=head1 KNOWN ISSUES

Assumes the _ALIGN_ARRAYS_ primitive has been run on the input
images. The check for the number of files to mosaic ($maxmos) is done
only once, which means this primitive will fail if the number of steps
exceeds the maximum number of files. Thus the effective limit to the
number of files to mosaic is $maxmos**2.

=head1 ALGORITHMS

Uses CCDPACK MAKEMOS. This primitive is currently a very general
implementation.

=head1 FILE SUFFIX

Creates a single output image with a suffix of '_fmos'.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>,
Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2004-2005 Particle Physics and Astronomy Research
Council and University of British Columbia.  All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307, USA

=cut

# Method for combining images: mean or median
my $method = (exists $_MAKE_MOSAIC_FRAME_{METHOD} &&
	      defined $_MAKE_MOSAIC_FRAME_{METHOD}) ?
              lc($_MAKE_MOSAIC_FRAME_{METHOD}) : "median";

# Should check the method is a supported one
orac_throw "Error: unknown image combination method, $method - should be mean or median\n"
  unless ( ($method eq "mean") || ($method eq "median") );

# Flag to determine whether or not to use genvar when mosaicking
my $genvar = (exists $_MAKE_MOSAIC_FRAME_{GENVAR} &&
	      defined $_MAKE_MOSAIC_FRAME_{GENVAR}) ?
              lc($_MAKE_MOSAIC_FRAME_{GENVAR}) : 1;

# Should I be verbose (default to no)
my $verbose = (exists $_MAKE_MOSAIC_FRAME_{VERBOSE} &&
               defined $_MAKE_MOSAIC_FRAME_{VERBOSE}) ?
               $_MAKE_MOSAIC_FRAME_{VERBOSE} : 0;

# Check version of ccdpack. Older versions can only handle 100 files at a time
my $maxmosfiles = (starversion_lt('ccdpack', 'V4.0-17')) ? 100 : 1000;

# Extra arguments to makemos - not needed if doing intermedate mosaics
my $args; 

# Calculate the number of steps to break the mosaicking into
my @files = $Frm->files;

# Do we need to make intermediate mosaics?
my $intermediate = 0;
if ( @files > $maxmosfiles) {
  $intermediate = 1;
}

# Temp file names
my ($intmp, $outmos);

# List of files to combine in final mosaic
my @mosaiclist;

# Determine if we have to make intermediate mosaics to combine later
if ( $intermediate ) {
  use POSIX qw/ ceil /;
  my $nsteps = ceil(@files/$maxmosfiles);
  my $stepsize = ceil(@files/$nsteps);

  # Have to prevent ORAC-DR deleting temporary files when they go out of
  # scope in order for the `intermediate mosaicking' step to work
  $ORAC::TempFile::DEBUG = 1;

  my $i = 0;
  orac_print "Doing intermediate mosaics: STEP = $stepsize, NSTEPS = $nsteps\n" 
    if $verbose;

  # Intermediate mosaic step
  while ($i < $#files) {
    my $start = $i;
    my $end = $start + $stepsize - 1;

    # List of data files to combine into the current mosaic
    $intmp = new ORAC::TempFile;
    print {$intmp->handle} join("\n",@files[$start..$end]);
    
    # Intermediate mosaic
    $outmos = new ORAC::TempFile(0);

    # Additional arguments for makemos
    $args = ($genvar) ? "nousevar genvar" : "nousevar";
    $Mon{ccdpack_reg}->obeyw("makemos","in=^".$intmp->file." method=$method out=".$outmos->file." $args");
    push (@mosaiclist, $outmos->file);
	
    $i = $end + 1;
    $args = "usevar nogenvar"; # Don't need to generate variances now
  }
} else {
  @mosaiclist = @files;
  # If we're doing all of the files at once, we need to generate
  # variances if desired
  $args = ($genvar) ? "genvar" : "nousevar";
}

# Create output filename, derived from first input file since this is
# a many to one operation
my ($in, $mosaic) = $Frm->inout('_fmos', 0);

my $mostmp = new ORAC::TempFile;
#orac_print $mostmp->file ."\n";
print {$mostmp->handle} join("\n",@mosaiclist[0..$#mosaiclist]);

orac_print("Creating mosaic for frame\n");
$Mon{ccdpack_reg}->obeyw("makemos","in=^".$mostmp->file." out=$mosaic title=FrameMosaic".$args);

# Store the final output mosaic
$Frm->files( $mosaic );

if ( $intermediate ) {
  # Delete temp files
  $ORAC::TempFile::DEBUG = 0;
}
