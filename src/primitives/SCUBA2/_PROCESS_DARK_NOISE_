# -*-cperl-*-

=head1 NAME

_PROCESS_DARK_NOISE_ - calculate a dark white noise image for each subarray

=head1 SYNOPSIS

_PROCESS_DARK_NOISE_

=head1 DESCRIPTION

This primitive calculates a noise image for each subarray using only
the initial DARK in the observation.

=head1 ARGUMENTS

The following arguments are supported:

=item B<FREQRANGE>

Comma-separated pair of numbers indicating the frequency range (Hz)
over which to measure white noise portion of power spectrum. Default
is 2,10 (i.e. 2-10 Hz). May be overridden with the C<NOISE_FREQRANGE>
recipe parameter.

=item B<FREQLO>

Lower frequency at which to measure power spectrum. Default is 0.5 Hz.

=item B<VERBOSE>

Flag to denote whether to display extra information. Default is 1
(yes).

=back

=head1 EXTERNAL TASKS

The following external task is used:

=over 4

=item ORAC-DR PRIMITIVES:

_CALCULATE_NOISE_

=back

=head1 OUTPUT DATA

The current Frame object is updated with the output noise files.

The Frame uhdr contains a new entry, C<DARKSAMPLES>, which lists the
number of samples in the dark files.

=head1 OUTPUT FILES

A noise file is created for each subarray with the suffix C<_noi>.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2011 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

my $obstype = lc($Frm->hdr("OBS_TYPE"));
if  ($obstype eq "noise") {
  $obstype = "darknoise" if (defined $Frm->hdr("OBJECT") && $Frm->hdr("OBJECT") eq "DARK");
}
return ORAC__OK if ($obstype eq "setup" || $obstype eq "ramp" || $obstype eq "darknoise" || $obstype eq "focus");

# Should we be verbose (default to yes)?
my $verbose = get_prim_arg( $_PRIM_ARGS_, "VERBOSE", 1);

# Low frequency measurement point
my $freqlo = get_prim_arg( $_PRIM_ARGS_, "FREQLO", 0.5 );

# High frequency measurement range for estimating white part of
# spectrum, override with recipe parameter if present
my $freqrange = get_prim_arg( $_PRIM_ARGS_, "FREQRANGE", "2,10" );
$freqrange = $Frm->uhdr("RECPAR_NOISE_FREQRANGE")
  if ($Frm->uhdr("RECPAR_NOISE_FREQRANGE"));

# Force obsend to true (in case it's not already)
my $obsend_on_entry = $Frm->uhdr("OBSEND");
$Frm->uhdr("OBSEND", 1);

# Retrieve *first* set of dark files only - ignore the rest
my @darks;
for my $i ( 1 .. $Frm->nfiles ) {
  push(@darks, $Frm->file($i))
    if ($Frm->hdrval("SHUTTER", $i-1) == 0.0 && $Frm->hdrval("NSUBSCAN", $i-1) == 1);
}

my $darksamples;
if (defined $Frm->uhdr("RECPAR_NOISE_SAMPLES")) {
  $darksamples = $Frm->uhdr("RECPAR_NOISE_SAMPLES");
  my $tmpFrm = $Frm->new();
  $tmpFrm->files(@darks);
  @darks = ();
  for my $i (1 .. $tmpFrm->nfiles) {
    my $in = $tmpFrm->file($i) . "(,,1:$darksamples)";
    my $out = $tmpFrm->inout("_raw", $i);
    $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$in out=$out");
    push(@darks, $out);
  }
}

if (@darks) {
  # Localize Frm here to calculate the noise, retrieve the processed
  # files at the end and store in a new Frame object
  my ($uhdr, @dknoi);
  {
    $uhdr = $Frm->uhdr;
    my $Frm = $Frm->new;
    $Frm->files(@darks);
    $Frm->uhdr(%{$uhdr});
    _CALCULATE_NOISE_ FREQRANGE=$freqrange FREQLO=$freqlo
    @dknoi = $Frm->files;
    $uhdr = $Frm->uhdr;
    # Retrieve the number of dark samples - these should all be the same
    $darksamples = ($Frm->hdrval("SEQEND") - $Frm->hdrval("SEQSTART") + 1) unless ($darksamples);
  }
  my $dkFrm = $Frm->new();
  $dkFrm->files(@dknoi);
  $dkFrm->uhdr(%{$uhdr}) if ($uhdr);

  # Store the number of samples in the dark files
  $Frm->uhdr("DARKSAMPLES", $darksamples);

  # Add this Frame object to the Group for later analysis
  $Grp->push($dkFrm);
} else {
  orac_warn "Frame contains no DARKs\n";
}
