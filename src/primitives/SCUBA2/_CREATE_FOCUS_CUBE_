# -*-cperl-*-

=head1 NAME

_CREATE_FOCUS_CUBE_ - Create a cube suitable for analysis by the JCMT POINTING_FOCUS task

=head1 SYNOPSIS

 _CREATE_FOCUS_CUBE_

=head1 DESCRIPTION

This primitive create a 3-D data cube for analysis by the
POINTING_FOCUS task to determine the FOCUS offsets for the current SMU
axis. The cube has axes of Azimuth, Elevation and SMU offset in mm.

The primitive calculates the mean number of images per focus position,
and only creates the cube when the number of images for the final
focus position equals that mean value.

The sub-group mosaics created for each focus position (C<FOCPOSN>)
have a third axis added before they are combined into a cube. A new
WCS component is created based on the existing SKY frame with the
addition of a mapping from grid to mm offset for the third axis.

The image corresponding to each focus position is displayed in a
Kapview window.

Once the cube has been constructed, the primitive writes the name of
the file into a flag file which the POINTING_FOCUS task reads before
calculating the FOCUS offset.

=head1 ARGUMENTS

The following argument is supported:

=over 4

=item B<VERBOSE>

Flag to indicate whether informational messages should be given to the
user. Default is 1 (true).

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item ATOOLS:

ASTADDFRAME, ASTCMPFRAME, ASTCMPMAP, ASTFRAME, ASTFRAMESET,
ASTGETFRAME, ASTGETMAPPING, ASTWINMAP

=item CCDPACK:

MAKEMOS

=item KAPPA:

NDFCOPY, PASTE, SETBOUND, SETORIGIN

=item ORAC-DR PRIMITIVES:

_FIT_SOURCE_, _WRITE_FLAG_FILE_

=back

=head1 NOTES

Future enhancements may include:

=over 4

=item *

Checking the number of subgroups is the same as the number of focus
positions

=item *

Cropping images around source

=back

=head1 OUTPUT DATA

On completion, the Group uhdr entry C<FOCUS_CUBE> is set to unity.

The list of focus settings is stored in the C<FOCPOSNS> Group uhdr
entry.

=head1 OUTPUT FILES

The cube has suffix C<_foc>. Images for each focus position have
suffix C<_focN> where N is an integer which spans the range 1 to the
number of focus positions.

This primitive writes a .ok file in $ORAC_DATA_OUT for the JCMT
POINTING_FOCUS task to calculate the actual pointing offsets used by
the telescope.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2007-2008 the University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Should I be verbose? (Default to yes)
my $verbose = get_prim_arg($_PRIM_ARGS_, "VERBOSE", 1);

# Flag to indicate if we have a FOCUS observation
my $focusobs = ( lc($Frm->uhdr("ORAC_OBSERVATION_TYPE")) eq "focus" ) ? 1 : 0;

# Get current focus position
my $curfocposn = $Frm->hdrval("FOCPOSN");

# Work out how many focus positions we have actually got, store
# results as hash reference. Note that as the Grp gets larger, the
# memberhdrvals method becomes too slow to use in QL mode which is why
# we are counting.
my @focposns;
if ( $Grp->uhdr("FOCPOSNS") ) {
  @focposns = @{ $Grp->uhdr("FOCPOSNS") };
  # Flag for determining whether we have a new focus position
  my $new = 1;
  foreach my $focposn ( @focposns ) {
    if ( $curfocposn == $focposn ) {
      $new = 0;
    }
  }
  # If NEW is still set, then we have a new FOCPOSN to add to the array
  if ($new) {
    push (@focposns, $curfocposn);
    $Grp->uhdr("FOCPOSNS", \@focposns);
  }
} else {
  push (@focposns, $curfocposn);
  $Grp->uhdr("FOCPOSNS", \@focposns);
}

# Determine the mean number of Frames per focus position. Count the
# number of times this primitive is entered, and store the results in
# a hash (reference) indexed by the focus position. The mean is
# calculated every time.
my %focusnum;
if ( $Grp->uhdr("FOCUSNUM") ) {
  %focusnum = %{ $Grp->uhdr("FOCUSNUM") };
  if ( defined $focusnum{$curfocposn} ) {
    $focusnum{$curfocposn}++;
  } else {
    $focusnum{$curfocposn} = 1;
  }

  # NOTE - at the moment this is the mean of ALL of the focus
  # positions whereas it should be the mean of all except the current
  # focposn. In practice it doesn't make much difference.
  my @numbers = values %focusnum;
  use Statistics::Descriptive;
  my $stats = Statistics::Descriptive::Sparse->new();
  $stats->add_data( @numbers );
  my $mean = $stats->mean;
  # Convert to an integer, round down
  $Grp->uhdr("FOCMEANUM",int($mean));
  # Store hash reference for next time
  $Grp->uhdr("FOCUSNUM",\%focusnum);
} else {
  # Enter first key/value pair in hash and store reference in uhdr
  $focusnum{$curfocposn} = 1;
  $Grp->uhdr("FOCUSNUM",\%focusnum);
}

# Check if we are on the last focus position and whether we have
# enough data to create the Focus cube, by setting the OBSEND flag to
# true.
if ( scalar(@focposns) == $Frm->hdr("NFOCSTEP") ) {
  my $curnum = $focusnum{$curfocposn};
  my $mean = $Grp->uhdr("FOCMEANUM");
  if ( $curnum >= $mean ) {
    $Frm->uhdr("OBSEND", 1);
  } else {
    $Frm->uhdr("OBSEND", 0);
  }
}

# Do we have a completed FOCUS observation, and does the cube already
# exist? Other checks: should be a standard source
if ( $focusobs && $Frm->uhdr("OBSEND") && !$Grp->uhdr("FOCUS_CUBE") ) {
  orac_print "Enough data collected - creating FOCUS cube\n", 'green';
  # Which axis are we dealing with?
  my $axis = $Frm->hdr("FOCAXIS");

  # Sort focus positions from low to high
  @focposns = sort { $a <=> $b } @focposns;

  # Store this list for subsequent use by _FIND_FOCUS_OFFSETS_
  $Grp->uhdr("FOCPOSNS",\@focposns);
  # Create lookup table for focus position and plane file extension
  my $nfoc = scalar( @focposns);
  my %focposidx;
  for my $i ( 0 .. $#focposns) {
    $focposidx{$focposns[$i]} = "_foc".($i+1);
  }

  # Create the cube:
  # 1) Retrieve SKY mapping/frame for later use
  # 2) Add a third axis to each plane image, shift the pixel origin of
  #    that axis to correspond to the file extension
  # 3) Define name (add _foc at end)
  # 4) Paste the individual images together to make the cube
  # 5) Create new 3-D WCS frameset for cube using stored SKY mapping &
  #    frame
  # 6) Shift the WCS so source in middle focus position lies at 0,0
  # 7) Write .ok file for the POINTING_FOCUS task to pick up

  # Group all the frames by FOCPOSN (which is guaranteed to be distinct
  # in each Frm)
  my @unsortedsubgrps = $Grp->subgrps( "FOCPOSN" );

  # The subgrps array must be sorted by FOCPOSN
  my @subgrps;
  for my $i ( 0 .. $#focposns ) {
    foreach my $subgrp ( @unsortedsubgrps ) {
      if ( @{ $subgrp->members} ) {
       push ( @subgrps, $subgrp)
         if ($subgrp->members->[0]->hdrval("FOCPOSN") == $focposns[$i]);
      }
    }
  }

  # Loop over each Frame to create a Frame mosaic
  my @planes;
  my $args;
  my $i = 0;
  my $obs = $Frm->hdr("OBSNUM");
  foreach my $subgrp ( @subgrps ) {
    $i++;
    my @focfiles = map { $_->files } $subgrp->members;

    my $focposn = $subgrp->members->[0]->hdrval("FOCPOSN");
    orac_print "Processing focus position $axis = $focposn mm (offset #$i)\n"
        if $verbose;

    # Define output file based on Group file name
    my $planeimage = $Grp->inout( $focposidx{$focposn} );
    # Set the NDF title string
    my $title = $focposidx{$focposn};
    $title =~ s/\_foc//;	# remove underscores
    $title = "'Foc".$title." $axis=$focposn mm / Obs $obs'";

    # Create single image for the current focus plane
    if ( @focfiles > 1 ) {
      my $tmpfile = ORAC::TempFile->new( OPEN => 0, SUFFIX => ".sdf" );
      my $moslist = write_file_list( @focfiles );
      my $mosargs = "in=^".$moslist." out=$tmpfile method=median ref=! logto=neither nousevar nogenvar title=$title";
      $Mon{ccdpack_reg}->obeyw("makemos","$mosargs");
    }
    my $crop = new ORAC::TempFile;
    my $cropimage = $crop->file;
    my $focfile = "$focfiles[0]";
    _CROP_IMAGE_ HEIGHT=90 WIDTH=90 IMAGE=$focfile OUT=$cropimage

    # Strip frequency axis so we can add an SMU axis later
    my $cpargs = "in=$cropimage out=$planeimage title=$title";
    $Mon{ndfpack_mon}->obeyw("ndfcopy","$cpargs trim=true trimwcs=true");

    # Store output file in current subgrp
    $subgrp->files( $planeimage );

    # Derive sky mapping and frame
    $args = "this=$planeimage iframe1=ast__base iframe2=ast__current result=skymap$$.ast";
    $Mon{atools_mon}->obeyw("astgetmapping","$args");
    $args = "this=$planeimage iframe=ast__current result=skyframe$$.ast";
    $Mon{atools_mon}->obeyw("astgetframe","$args");

    # Retrieve coords of first pixel
    $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$planeimage");
    my ($ORAC_STATUS, @xy) = $Mon{ndfpack_mon}->get("ndftrace","lbound");
    # Now add a 1-pixel-wide third axis
    $args = "ndf=$planeimage(,,1:1)";
    $Mon{ndfpack_mon}->obeyw("setbound","$args");
    # Set the origin accordingly
    $args = "ndf=$planeimage origin=[$xy[0],$xy[1],$i]";
    $Mon{ndfpack_mon}->obeyw("setorigin","$args");

    # Store image name in array for pasting into the cube
    push ( @planes, $planeimage );

    # Set the format to display arcsec offsets
    my $newformat = "s.0";
    my $args = "ndf=$planeimage mode=mset setting='Format(1)=$newformat,Format(2)=$newformat'";
    $Mon{ndfpack_mon}->obeyw("wcsattrib","$args");

  }

  $Grp->files(@planes);

  # Check that we can make at least 3 planes on a cube to fit a quadratic
  orac_warn "Number of SMU positions is not sufficient to create a valid FOCUS cube\n"
    if ( $nfoc < 3 );

  # Define output cube name - replace _mos with _foc
  my $cubename = $Grp->inout("_foc");

  # Combine individual FOCPOSN mosaics into a 3-D cube
  my $inlist = write_file_list( @planes );
  $args = "in=^".$inlist." p1=! out=$cubename title='FOCUS cube'";
  $Mon{kappa_mon}->obeyw("paste","$args");
  orac_print "Creating FOCUS cube..." if $verbose;
  undef $inlist;

  # Now create suitable 3-D frameset to ensure 3rd axis is
  # offset in millimetres. Method mirrors that in
  # _CREATE_CUBE_WCS_ First create a FRAME for the focus offsets
  $args = "naxes=1 result=focusframe$$.ast options='Title=SMU offset on $axis axis,Label=SMU offset,Unit=mm,Domain=SMU-POSN'";
  $Mon{atools_mon}->obeyw("astframe","$args");
  # Combine this FRAME with the above SKYFRAME to create a compound frame, CMPFRAME
  $args = "frame1=skyframe$$.ast frame2=focusframe$$.ast options=! result=cmpframe$$.ast";
  $Mon{atools_mon}->obeyw("astcmpframe","$args");
  # Define a WINMAP to describe the third axis
  my $focmin = $focposns[0];
  my $focmax = $focposns[-1];
  $args = "ncoord=1 ina=1 inb=$nfoc outa=$focmin outb=$focmax options=! result=focusmap$$.ast";
  $Mon{atools_mon}->obeyw("astwinmap","$args");
  # Combine this WINMAP with the above SKYMAP to create a compound mapping, CMPMAP
  $args = "map1=skymap$$.ast map2=focusmap$$.ast series=f options=! result=cmpmapping$$.ast";
  $Mon{atools_mon}->obeyw("astcmpmap","$args");
  # Create an empty 3-D GRID frame
  $args = "naxes=3 options='Domain=GRID' result=grid$$.ast";
  $Mon{atools_mon}->obeyw("astframe","$args");
  # Add it to a skeleton FRAMESET
  $args = "frame=grid$$.ast options=! result=newwcs$$.ast";
  $Mon{atools_mon}->obeyw("astframeset","$args");
  # Add the CMPFRAME to the FRAMESET using the CMPMAP to tie it
  # to the GRID frame. Store as WCS in the output cube.
  $args = "this=newwcs$$.ast iframe=ast__base map=cmpmapping$$.ast frame=cmpframe$$.ast result=$cubename";
  $Mon{atools_mon}->obeyw("astaddframe","$args");
  orac_print " adding WCS..." if $verbose;

  # Remove all of the .ast text files with the mapping/frame info
  unlink glob( "*$$.ast" );

  # Find the peak position of the centre focus step (presumed to be
  # nearest the actual focus). Nfoc should be odd but make it an int
  # just in case...
  my $midplane = int(($nfoc + 1) / 2);
  my $midfile = "$cubename(,,$midplane)";
  # Find the centroid just in case the source is way off centre - in
  # practice just using 0,0 seems to work well enough
  _CENTROID_IMAGE_ IMAGE=$midfile
  my @xypos = ( $_CENTROID_IMAGE_{RESULTS}->[0],
		$_CENTROID_IMAGE_{RESULTS}->[1]);
  # Now slide all the images so that the source lies at 0,0 in the
  # mid-focus position image. Note that due to off-axis aberrations,
  # the source may still shift from 0,0 away from the in-focus SMU
  # position.
  if ( defined $xypos[0] && defined $xypos[1] ) {
    _FIT_SOURCE_ IMAGE=$midfile XYPOS=\@xypos BOX=15 VERBOSE=1
    my @newpos = (0, 0);
    if ( $_FIT_SOURCE_{FIT} == 1 ) {
      @newpos = ($_FIT_SOURCE_{POSITION}->[0], $_FIT_SOURCE_{POSITION}->[1]);
    } else {
      orac_warn "Fit to source failed - using centroid position to slide images\n";
      @newpos = @xypos;
    }
    if ( $newpos[0] ne "0" || $newpos[1] ne "0" ) {
      my $args = "stype=relative fid='0.0,0.0,0' obj='".
	$newpos[0].",".$newpos[1].",0' ndf=$cubename";
      $Mon{kappa_mon}->obeyw("wcsslide","$args");
    }
  } else {
    orac_warn "Unable to determine centroid of source at centre focus position: cube will not be adjusted\n";
  }

  orac_print (" done.\n");
  # Store the cube name as the Grp file
  $Grp->files($cubename);

  orac_print ("Cube created successfully and ready for processing.\n", 'green');
  $Grp->uhdr("FOCUS_CUBE",1);

  # Write the .ok file in the output directory
  _WRITE_FLAG_FILE_ FILE=$cubename PREFIX=s

  # Now display the data
  my ($min, $max) = (1.0e10, -1.0e10);
  # Find the stats in a 25 pixel-square box at the image centre,
  # which should include the source if detected
  orac_print "Finding min/max for displaying focus positions\n" if $verbose;
  foreach my $plane ($Grp->files) {
    my $args = "$plane(0:00:00.0~25,0:00:00.0~25,)";
    $Mon{kappa_mon}->obeyw("stats","$args");
    my ($ORAC_STATUS, $planemin) = $Mon{kappa_mon}->get("stats","minimum");
    ($ORAC_STATUS, my $planemax) = $Mon{kappa_mon}->get("stats","maximum");
    $min = $planemin if ($planemin < $min);
    $max = $planemax if ($planemax > $max);
  }
  my %options = ( ZAUTOSCALE => 0, ZMIN => $min, ZMAX => $max );
  if ( $min == 1.0e-10 || $max == 1.0e10 ) {
    orac_warn "Could not determine min/max for images in cube - images will be autoscaled\n";
    %options = (ZAUTOSCALE => 1);
  }
  # For some reason we need to loop over the subgrps and display each
  # in turn, rather than give the display system everything at
  # once. This should be investigated.
  foreach my $subgrp (@subgrps) {
    $Display->display_data( $subgrp, \%options, -1 );
  }

} else {
  $Grp->uhdr("FOCUS_CUBE",0);
}
