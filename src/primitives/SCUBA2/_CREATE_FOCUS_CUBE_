# -*-perl-*-

=head1 NAME

_CREATE_FOCUS_CUBE_ - Create a cube suitable for analysis by the POINTING_FOCUS task

=head1 DESCRIPTION

This primitive create a 3-D data cube for analysis by the
POINTING_FOCUS task to determine the FOCUS offsets for the current SMU
axis. The primitive checks for the OBSEND flag in the FITS header and
only proceeds if true. The sub-group mosaics created for each focus
position (FOCPOSN) have a third axis added before they are combined
into a cube. A new WCS component is created based on the existing SKY
frame with the addition of a mapping from grid to mm offset for the
third axis.

Once the cube has been constructed, the primitive writes the name of
the file into a flag file which the POINTING_FOCUS task reads before
calculating the FOCUS offset.

=head1 ARGUMENTS

The following argument is supported:

=item B<VERBOSE>

Flag to indicate whether informational messages should be 
given to the user. Default is 1 (true).

=back

=head1 EXTERNAL TASKS

=over 4

=item ATOOLS

ASTGETMAPPING, ASTWINMAP, ASTCMPMAP, ASTFRAME, ASTGETFRAME,
ASTCMPFRAME, ASTADDFRAME, ASTFRAMESET

=item KAPPA

NDFCOPY, PASTE, SETBOUND, SETORIGIN

=item CCDPACK

MAKEMOS

=back

=head1 OUTPUT DATA

This primitive writes a .ok file in $ORAC_DATA_OUT for the JCMT
POINTING_FOCUS task to calculate the actual pointing offsets used by
the telescope.

=head1 FUTURE DEVELOPMENT

Things to add: 
i) Check the number of subgroups = NFOCSTEP; 
ii) Crop images around source

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2007-2008 the University of British Columbia. All Rights
Reserved.

=cut

# Should I be verbose? (Default to yes)
my $verbose = get_prim_arg($_PRIM_ARGS_, "VERBOSE", 1);

# Flag to indicate if we have a FOCUS observation
my $focusobs = ( lc($Frm->uhdr("ORAC_OBSERVATION_TYPE")) eq "focus" ) ? 1 : 0;

# Get current focus position
my $curfocposn = $Frm->hdrval("FOCPOSN");

# Work out how many focus positions we have actually got, store
# results as hash reference. Note that as the Grp gets larger, the
# memberhdrvals method becomes too slow to use in QL mode which is why
# we are counting.
my @focposns;
if ( $Grp->uhdr("FOCPOSNS") ) {
  @focposns = @{ $Grp->uhdr("FOCPOSNS") };
  # Flag for determining whether we have a new focus position
  my $new = 1;
  foreach my $focposn ( @focposns ) {
    if ( $curfocposn == $focposn ) {
      $new = 0;
    }
  }
  # If NEW is still set, then we have a new FOCPOSN to add to the array
  if ($new) {
    push (@focposns, $curfocposn);
    $Grp->uhdr("FOCPOSNS", \@focposns);
  }
} else {
  push (@focposns, $curfocposn);
  $Grp->uhdr("FOCPOSNS", \@focposns);
}

# Determinre the mean number of Frames per focus position. Count the
# number of times this primitive is entered, and store the results in
# a hash (reference) indexed by the focus position. The mean is
# calculated every time.
my %focusnum;
if ( $Grp->uhdr("FOCUSNUM") ) {
  %focusnum = %{ $Grp->uhdr("FOCUSNUM") };
  if ( defined $focusnum{$curfocposn} ) {
    $focusnum{$curfocposn}++;
  } else {
    $focusnum{$curfocposn} = 1;
  }

  # NOTE - at the moment this is the mean of ALL of the focus
  # positions whereas it should be the mean of all except the current
  # focposn. In practice it doesn't make much difference.
  my @numbers = values %focusnum;
  use Statistics::Descriptive;
  my $stats = Statistics::Descriptive::Sparse->new();
  $stats->add_data( @numbers );
  my $mean = $stats->mean;
  # Convert to an integer, round down
  $Grp->uhdr("FOCMEANUM",int($mean));
  # Store hash reference for next time
  $Grp->uhdr("FOCUSNUM",\%focusnum);
} else {
  # Enter first key/value pair in hash and store reference in uhdr
  $focusnum{$curfocposn} = 1;
  $Grp->uhdr("FOCUSNUM",\%focusnum);
}

# Check if we are on the last focus position and whether we have
# enough data to create the Focus cube, by setting the OBSEND flag to
# true.
if ( scalar(@focposns) == $Frm->hdr("NFOCSTEP") ) {
  my $curnum = $focusnum{$curfocposn};
  my $mean = $Grp->uhdr("FOCMEANUM");
  if ( $curnum >= $mean ) {
    $Frm->uhdr("OBSEND", 1);
  } else {
    $Frm->uhdr("OBSEND", 0);
  }
}

# Do we have a completed FOCUS observation, and does the cube already
# exist? Other checks: should be a standard source
if ( $focusobs && $Frm->uhdr("OBSEND") && !$Grp->uhdr("FOCUS_CUBE") ) {
  orac_print "Enough data collected - creating FOCUS cube\n", 'green';
  # Which axis are we dealing with?
  my $axis = $Frm->hdr("FOCAXIS");

  # Store this list for subsequent use by _FIND_FOCUS_OFFSETS_
  $Grp->uhdr("FOCPOSNS",\@focposns);
  # Create lookup table for focus position and plane file extension
  my $nfoc = scalar( @focposns);
  my %focposidx;
  for my $i ( 0 .. $#focposns) {
    $focposidx{$focposns[$i]} = "_foc".($i+1);
  }

  # Create the cube:
  # 1) Retrieve SKY mapping/frame for later use
  # 2) Add a third axis to each plane image, shift the pixel origin of
  #    that axis to correspond to the file extension
  # 3) Define name (add _foc at end)
  # 4) Paste the individual images together to make the cube
  # 5) Create new 3-D WCS frameset for cube using stored SKY mapping &
  #    frame
  # 6) Write .ok file for the POINTING_FOCUS task to pick up

  # group all the frames by FOCPOSN (which is guaranteed to be distinct
  # in each Frm)
  my @unsortedsubgrps = $Grp->subgrps( "FOCPOSN" );

  # The subgrps array must be sorted by FOCPOSN
  my @subgrps;
  for my $i ( 0 .. $#focposns ) {
    foreach my $subgrp ( @unsortedsubgrps ) {
      push ( @subgrps, $subgrp)
	if ($subgrp->members->[0]->hdrval("FOCPOSN") == $focposns[$i]);
    }
  }

  # Loop over each Frame to create a Frame mosaic
  my @planes;
  my $args;
  my $i = 0;
  foreach my $subgrp ( @subgrps ) {
    $i++;
    my @focfiles = map { $_->files } $subgrp->members;
    my $focposn = $subgrp->members->[0]->hdrval("FOCPOSN");
    orac_print "Processing focus position $axis = $focposn mm (offset #$i)\n"
        if $verbose;

    # Define output file based on Group file name
    my $planeimage = $Grp->inout( $focposidx{$focposn} );
    # Set the NDF title string
    my $title = $focposidx{$focposn};
    $title =~ s/\_foc//;	# remove underscores
    $title = "'Focus".$title." $axis=$focposn mm'";

    # Create single image for the current focus plane
    if ( @focfiles > 1 ) {
      my $moslist = write_file_list( @focfiles );
      my $mosargs = "in=^".$moslist." out=$planeimage method=median ref=! logto=neither nousevar nogenvar title=$title";
      $Mon{ccdpack_reg}->obeyw("makemos","$mosargs");
    } else {
      my $cpargs = "in=".$focfiles[0]." out=$planeimage title=$title";
      $Mon{ndfpack_mon}->obeyw("ndfcopy","$cpargs");
    }
    # Store output file in Frm
    $subgrp->files( $planeimage );
    # Display this image
    $Display->display_data( $subgrp ) if (defined $Display);

    # Derive sky mapping and frame
    $args = "this=$planeimage iframe1=ast__base iframe2=ast__current result=skymap$$.ast";
    $Mon{atools_mon}->obeyw("astgetmapping","$args");
    $args = "this=$planeimage iframe=ast__current result=skyframe$$.ast";
    $Mon{atools_mon}->obeyw("astgetframe","$args");

    # Retrieve coords of first pixel
    $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$planeimage");
    my ($ORAC_STATUS, @xy) = $Mon{ndfpack_mon}->get("ndftrace","lbound");
    # Now add a 1-pixel-wide third axis
    $args = "ndf=$planeimage(,,1:1)";
    $Mon{ndfpack_mon}->obeyw("setbound","$args");
    # Set the origin accordingly
    $args = "ndf=$planeimage origin=[$xy[0],$xy[1],$i]";
    $Mon{ndfpack_mon}->obeyw("setorigin","$args");

    # Store image name in array for pasting into the cube
    push ( @planes, $planeimage );
  }

  # Check that we can make at least 3 planes on a cube to fit a quadratic
  orac_warn "Number of SMU positions is not sufficient to create a valid FOCUS cube\n"
    if ( $nfoc < 3 );
  
  # Define output cube name - replace _mos with _foc
  my $cubename = $Grp->inout("_foc");

  # Combine individual FOCPOSN mosaics into a 3-D cube
  my $inlist = write_file_list( @planes );
  $args = "in=^".$inlist." p1=! out=$cubename title='FOCUS cube'";
  $Mon{kappa_mon}->obeyw("paste","$args");
  orac_print "Creating FOCUS cube..." if $verbose;
  undef $inlist;

  # Now create suitable 3-D frameset to ensure 3rd axis is
  # offset in millimetres. Method mirrors that in
  # _CREATE_CUBE_WCS_ First create a FRAME for the focus offsets
  $args = "naxes=1 result=focusframe$$.ast options='Title=SMU offset on $axis axis,Label=SMU offset,Unit=mm,Domain=SMU-POSN'";
  $Mon{atools_mon}->obeyw("astframe","$args");
  # Combine this FRAME with the above SKYFRAME to create a compound frame, CMPFRAME
  $args = "frame1=skyframe$$.ast frame2=focusframe$$.ast options=! result=cmpframe$$.ast";
  $Mon{atools_mon}->obeyw("astcmpframe","$args");
  # Define a WINMAP to describe the third axis
  my $focmin = $focposns[0];
  my $focmax = $focposns[-1];
  $args = "ncoord=1 ina=1 inb=$nfoc outa=$focmin outb=$focmax options=! result=focusmap$$.ast";
  $Mon{atools_mon}->obeyw("astwinmap","$args");
  # Combine this WINMAP with the above SKYMAP to create a compound mapping, CMPMAP
  $args = "map1=skymap$$.ast map2=focusmap$$.ast series=f options=! result=cmpmapping$$.ast";
  $Mon{atools_mon}->obeyw("astcmpmap","$args");
  # Create an empty 3-D GRID frame
  $args = "naxes=3 options='Domain=GRID' result=grid$$.ast";
  $Mon{atools_mon}->obeyw("astframe","$args");
  # Add it to a skeleton FRAMESET
  $args = "frame=grid$$.ast options=! result=newwcs$$.ast";
  $Mon{atools_mon}->obeyw("astframeset","$args");
  # Add the CMPFRAME to the FRAMESET using the CMPMAP to tie it
  # to the GRID frame. Store as WCS in the output cube.
  $args = "this=newwcs$$.ast iframe=ast__base map=cmpmapping$$.ast frame=cmpframe$$.ast result=$cubename";
  $Mon{atools_mon}->obeyw("astaddframe","$args");
  orac_print " adding WCS..." if $verbose;

  # Remove all of the .ast text files with the mapping/frame info
  unlink glob( "*$$.ast" );
    
  # Store the cube name as the Grp file
  $Grp->file($cubename);
  orac_print (" done.\n");

  # Write the .ok file in the output directory
  _WRITE_FLAG_FILE_ FILE=$cubename PREFIX=s

  orac_print ("Cube created successfully and ready for processing.\n", 'green');
  $Grp->uhdr("FOCUS_CUBE",1);
} else {
  $Grp->uhdr("FOCUS_CUBE",0);
}
