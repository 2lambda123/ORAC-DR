#! -*-perl-*-

=head1 NAME

_ALIGN_AND_MOSAIC_SUBARRAY - Align and mosaic subarray frames together

=head1 SYNOPSIS

 _ALIGN_AND_MOSAIC_SUBARRAY

=head1 DESCRIPTION

This primitive aligns and mosaics the individual subarray frames into
array images either by using KAPPA WCSALIGN followed by CCDPACK
MAKEMOS or performing both steps with KAPPA WCSMOSAIC. The former
approach calls two other primitives to do the aligning and
mosaicking. A check is made to see if the version of KAPPA supports
WCSMOSAIC.

This primitive operates on the current Frame object and selects images
in groups of up to four (one for each subarray) and produces a mosaic
of these images. No operation is performed is there is only a single
subarray.

If the output need not be aligned to a celestial reference frame, then
if a group file exists, that is the reference for the alignment, else
the first image in the frame object is chosen as reference.

=head1 ARGUMENTS

=over 4

=item B<MAKEMOS>

A flag to denote whether to use CCDPACK MAKEMOS for mosaicking the
images. Default is 0 (no), which uses KAPPA WCSMOSAIC instead.

=item B<METHOD>

The method to be used for resampling the aligned images. This
corresponds to the C<method> parameter for WCSMOSAIC and WCSALIGN,
which is different from that for MAKEMOS. See WCSALIGN and/or
WCSMOSAIC documentation for further details. Default value is
C<nearest>.

=item B<MAKEMOS_METHOD>

The method by which MAKEMOS combines the images. Default is
C<mean>. See the MAKEMOS documentation for a description of the
possible values.

=item B<REBIN>

A flag to determine whether to rebin or resample. Default is
resample. See the WCSMOSAIC/WCSALIGN documentation for further
information.

=item B<SKYREF>

A flag to denote whether to align the images to a celestial coordinate
frame. The default is 0 (false) and the images will be aligned with
either the group file if it exists or the first image in the Frame.

=item B<VERBOSE>

A flag to denote whether the primitive should issue verbose
information messages. Default is true (1).

=back

=head1 ALGORITHMS

KAPPA: WCSMOSAIC, WCSALIGN. CCDPACK: MAKEMOS

=head1 FILE SUFFIX

An output file is created for each set of up-to-four subarray images
in the Frame with a suffix of C<_arr>.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2005-2008 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA

=cut

# Should I be verbose? (default to yes)
my $verbose = (exists $_ALIGN_AND_MOSAIC_SUBARRAY_{VERBOSE} &&
               defined $_ALIGN_AND_MOSAIC_SUBARRAY_{VERBOSE}) ?
               $_ALIGN_AND_MOSAIC_SUBARRAY_{VERBOSE} : 1;

# Check that we have more than one subarray to combine
if ( $Frm->numsubarrays == 1 ) {
  # Dummy warning for now
  orac_warn "Note: data exist for only 1 subarray - skipping this primitive" 
    if $verbose;

} else {
  # Check for input paramters: MAKEMOS
  my $makemos = (exists $_ALIGN_AND_MOSAIC_SUBARRAY_{MAKEMOS} &&
		 defined $_ALIGN_AND_MOSAIC_SUBARRAY_{MAKEMOS}) ?
		 $_ALIGN_AND_MOSAIC_SUBARRAY_{MAKEMOS} : 0;

  # Rebin or resample? Default is resample (rebin = 0).
  my $rebin = (exists $_ALIGN_AND_MOSAIC_SUBARRAY_{REBIN} &&
	       defined $_ALIGN_AND_MOSAIC_SUBARRAY_{REBIN}) ?
	       $_ALIGN_AND_MOSAIC_SUBARRAY_{REBIN} : 0;

  # Method for determining the output pixel values (used by WCSMOSAIC
  # and WCSALIGN
  my $method = (exists $_ALIGN_AND_MOSAIC_SUBARRAY_{METHOD} &&
		defined $_ALIGN_AND_MOSAIC_SUBARRAY_{METHOD}) ? 
		lc($_ALIGN_AND_MOSAIC_SUBARRAY_{METHOD}) : "bilinear"; 

  # Are we aligning images in a SKY frame? Default to yes.
  my $skyalign = (exists $_ALIGN_AND_MOSAIC_SUBARRAY_{SKYREF} &&
		  defined $_ALIGN_AND_MOSAIC_SUBARRAY_{SKYREF}) ?
		  $_ALIGN_AND_MOSAIC_SUBARRAY_{SKYREF} : 1;

  # MAKEMOS image combination method
  my $makemos_method = (exists $_ALIGN_AND_MOSAIC_SUBARRAY_{MAKEMOS_METHOD} &&
			defined $_ALIGN_AND_MOSAIC_SUBARRAY_{MAKEMOS_METHOD}) ?
			lc($_ALIGN_AND_MOSAIC_SUBARRAY_{MAKEMOS_METHOD}) : "mean";


  # Check version of KAPPA is new enough to use WCSMOSAIC
  if (starversion_lt('kappa', 'V1.5')) {
    $makemos = 1;
    orac_warn "Installed Kappa version does not support WCSMOSAIC, falling back on WCSALIGN+MAKEMOS";
  }

  # Determine reference image for alignment. Use default coordinate
  # frame
  _GET_REFERENCE_IMAGE_ SKYREF=$skyalign VERBOSE=$verbose
  my $refimage = $_GET_REFERENCE_IMAGE_{REFIMAGE};

  # Check to see if we're using MAKEMOS
  if ($makemos) {
    orac_print("Aligning and mosaicking subarray images with WCSALIGN+MAKEMOS\n")
      if $verbose;
  } else {
    orac_print("Aligning and mosaicking subarray images with WCSMOSAIC\n")
      if $verbose;
  }

  # Set the WLIM parameter for WCSMOSAIC
  my $wlim = 0.2;

  # Number of files in current frame
  my $nfiles = $Frm->nfiles;

  # Array of output filenames to store in Frame object on completion
  my @out;

  # Do we have sub-headers? If not, then we have just 4 (or
  # N_WORKING_SUBARRAYS) images to mosaic
  if ( defined $Frm->hdr->{SUBHEADERS}->[0]->{SEQSTART}  || 
       defined $Frm->hdr->{SUBHEADERS}->[0]->{NSUBSCAN} ) {
    # Hash to store each SEQSTART/NSUBSCAN combination as appropriate
    # images are mosaicked, plus an indexing hash to associate groups
    # of related files with the file index.
    my (%commonfiles, %indxr);

    # Loop over number of files to store associations
    my $j = 0;
    for my $i (1..$nfiles) {
      my $seqstart = $Frm->hdrval('SEQSTART',$i-1);
      my $nsubscan = $Frm->hdrval('NSUBSCAN',$i-1);
      # Define a unique identified key from subscan number and seqstart
      my $commonkey = $nsubscan."_".$seqstart;
      push @{ $commonfiles{$commonkey} }, $Frm->file($i);
      # Now we need a way to link the array of common files to the
      # correct file name for creating the output files. Do this with
      # another hash with the same keys as above with file indices as
      # values. This takes advantage of how the files are stored in
      # the Frm and ensures we match up files correctly.
      if (@{ $commonfiles{$commonkey} } == 1) {
	$j++;
	$indxr{$commonkey} = $j;
      }
    }

    # Loop over groups of files to mosaic them - sort to preserve time
    # order (KLUDGE: should sort on TIME not just on index)
    foreach my $arraygrp ( sort { $indxr{$a} <=> $indxr{$b} } keys %indxr ) {
      # For deciding the output file name 
      my ($in, $out) = $Frm->inout('_arr',$indxr{$arraygrp});
      my $intmp = new ORAC::TempFile;
      my $numingrp = scalar( @{ $commonfiles{$arraygrp} } );
      # Combine images with chosen method
      if ( $makemos ) {
	# Write filenames into temp file
	my $otmp = new ORAC::TempFile;
	for my $i (1 .. $numingrp) {
	  print {$intmp->handle} $commonfiles{$arraygrp}->[$i-1] ."\n" ;
	  print {$otmp->handle} $commonfiles{$arraygrp}->[$i-1] ."_al\n" ;
	}
	my $args = "ref=$refimage method=$method lbnd=! ubnd=! wlim=$wlim ".
	  "out=^".$otmp->file." in=^".$intmp->file;
	$Mon{kappa_mon}->obeyw("wcsalign","$args");
	$args = "in=^".$otmp->file." method=$makemos_method out=$out";
	$Mon{ccdpack_reg}->obeyw("makemos","$args");
      } else {
	# Write filenames into temp file
	for my $i (1 .. $numingrp) {
	  print {$intmp->handle} $commonfiles{$arraygrp}->[$i-1] ."\n" ;
	}
	my $args = "ref=$refimage method=$method lbnd=! ubnd=! wlim=$wlim ".
	  "out=$out in=^".$intmp->file;
	$Mon{kappa_mon}->obeyw("wcsmosaic","$args");
      }
      # Add to output array
      push (@out, $out);
      # Remove temp file
      undef $intmp;
    }

  } else {
    my ($in, $out) = $Frm->inout('_arr');
    my $intmp = new ORAC::TempFile;
    # Combine images with chosen method
    if ( $makemos ) {
      # Write filenames into temp file
      my $otmp = new ORAC::TempFile;
      for my $i (1 .. $nfiles) {
	print {$intmp->handle} $Frm->file($i) ."\n" ;
	print {$otmp->handle} $Frm->file($i) ."_al\n" ;
      }
      my $args = "ref=$refimage method=$method lbnd=! ubnd=! wlim=$wlim ".
	"out=^".$otmp->file." in=^".$intmp->file;
      $Mon{kappa_mon}->obeyw("wcsalign","$args");
      $args = "in=^".$otmp->file." method=$makemos_method out=$out";
      $Mon{ccdpack_reg}->obeyw("makemos","$args");
    } else {
      # Write filenames into temp file
      foreach my $i (1..$nfiles) {
	print {$intmp->handle} $Frm->file($i) ."\n";
      }
      my $args = "ref=$refimage method=$method lbnd=! ubnd=! wlim=$wlim ".
	"out=$out in=^".$intmp->file;
      $Mon{kappa_mon}->obeyw("wcsmosaic","$args");
    }
    # Add to output array
    push (@out, $out);
    # Remove temp file
    undef $intmp;
  }
  # Store the output files
  $Frm->files( @out );
}
