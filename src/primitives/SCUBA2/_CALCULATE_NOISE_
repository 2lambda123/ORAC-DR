# -*-cperl-*-

=head1 NAME

_CALCULATE_NOISE_ - calculate a white noise image for each subarray

=head1 SYNOPSIS

_CALCULATE_NOISE_

=head1 DESCRIPTION

This primitive calculates a noise image for each subarray. The noise
calculation should proceed differently depending on which pipeline is
being used. Usually, Frames which are only composed of darks are
ignored unless the observation is a Noise-Dark. If called from the
SUMMIT pipeline processing is deferred until the observation has
ended.

=head1 ARGUMENTS

The following arguments are supported:

=item B<FREQRANGE>

Comma-separated pair of numbers indicating the frequency range (Hz)
over which to measure white noise portion of power spectrum. Default
is 2,10 (i.e. 2-10 Hz). May be overridden with the C<NOISE_FREQRANGE>
recipe parameter.

=item B<FREQLO>

Lower frequency at which to measure power spectrum. Default is 0.5 Hz.

=item B<VERBOSE>

Flag to denote whether to display extra information. Default is 0
(no).

=back

=head1 EXTERNAL TASKS

The following external task is used:

=over 4

=item SMURF:

CALCNOISE

=back

=head1 OUTPUT DATA

The current Frame object is updated with the output noise files.

The Frame uhdr is updated to set an entry called C<NOISE> which is 1
if noise images were calculated, otherwise 0.

=head1 OUTPUT FILES

A noise file is created for each subarray with the suffix C<_noi>

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2009-2011 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Determine if the time is right to calculate the noise
# properties. Assume that we wish to proceed.
my $proceed = 1;

# Do not proceed if this is the SUMMIT pipeline and the observation
# has not ended
$proceed = 0 if ($Frm->uhdr("SUMMIT") && !$Frm->uhdr("OBSEND"));

# Do not proceed if the Frame contains only fast-ramp flatfield data
$proceed = 0 if ($Frm->uhdr("PROCESS_FASTFLAT"));

if ( $proceed ) {
  # OK now deal with input parameters
  # Should we be verbose (default to no)?
  my $verbose = get_prim_arg( $_PRIM_ARGS_, "VERBOSE", 1);

  # Low frequency measurement point
  my $freqlo = get_prim_arg( $_PRIM_ARGS_, "FREQLO", 0.5 );
  # High frequency measurement range for estimating white part of
  # spectrum, override with recipe parameter if present
  my $freqrange = get_prim_arg( $_PRIM_ARGS_, "FREQRANGE", "2,10" );
  $freqrange = $Frm->uhdr("RECPAR_NOISE_FREQRANGE")
    if ($Frm->uhdr("RECPAR_NOISE_FREQRANGE"));
  # Force obsend to true (in case it's not already)
  my $obsend_on_entry = $Frm->uhdr("OBSEND");
  $Frm->uhdr("OBSEND", 1);

  # Print out some information for the user
  if ($verbose) {
    my @freqlohi = split( /\,/, $freqrange, 2);
    orac_print "Estimating low-frequency noise at $freqlo Hz\n"
      ."Estimating white noise level between $freqlohi[0] and $freqlohi[1] Hz\n";
  }

  # Loop over each subarray - temporary fix until calcnoise can deal
  # with multiple subarrays
  my @subarrays = $Frm->subarrays;

  # Collect files
  my ($inlist, $outlist);
  my %files;

  # For the summit pipeline we need to wait until the end of the
  # observation and use all available data to calculate the noise. The
  # offline pipeline will do the same thing effectively as all the
  # input files will be in the current Frame.
  if ( $Frm->uhdr("SUMMIT") ) {
    my (@infiles, @outfiles);
    # Loop over all members of current Group
    foreach my $frmobj ( $Grp->members ) {
      my %frmfiles = $frmobj->get_files_by_subarray;

      foreach my $subarray (@subarrays) {
	if ($files{$subarray}) {
	  my @files = @{$files{$subarray}};
	  push(@files, $frmfiles{$subarray});
	  $files{$subarray} = \@files;
	} else {
	  $files{$subarray} = $frmfiles{$subarray};
	}
      }
    }
  } else {
    %files = $Frm->get_files_by_subarray;
  }

  # Inform the user which subarrays are being used to calculate noise
  # for (remember calcnoise can handle data from all subarrays at once
  # so there is no need to pre-sort the data)
  my $subinfostr;
  if ( @subarrays == 1 ) {
    $subinfostr = "subarray $subarrays[0]";
  } else {
    $subinfostr = "subarrays ".join(", ",@subarrays);
  }
#  orac_print "Calculating noise for $subinfostr...";
  orac_print "Calculating noise for ";

  my $resist = $Frm->uhdr("RECPAR_RESIST_CFG")
    if (defined $Frm->uhdr("RECPAR_RESIST_CFG"));

  # Calculate noise for each subarray
  my @alloutfiles;
  _RETRIEVE_FASTFLATS_
  my $fastflats = $_RETRIEVE_FASTFLATS_{FASTFLATS_SUB};
  foreach my $subarray (@subarrays) {
    orac_print "$subarray...";
    my @infiles = @{$files{$subarray}};
    # Define output file names
    my $tmpfrm = $Frm->new;
    $tmpfrm->files(@infiles);
    my @outfiles = map { scalar $tmpfrm->inout("_noi", $_ ) }
      (1..$tmpfrm->nfiles);
    my $outlist = write_file_list(@outfiles);

    # Add fast-ramp flatfield files if present and write input file list
    push(@infiles, $fastflats->{$subarray}) if ($fastflats);
    my $inlist = write_file_list( @infiles );

    # Calculate the noise
    my $outfiles = ORAC::TempFile->new();
    unlink $outfiles->file;
    my $args = "in=^$inlist out=^$outlist outfiles=$outfiles power=! freq=[$freqrange] flow=$freqlo";
    $args .= " resist=^$resist" if ($resist);
    $Mon{smurf_mon}->obeyw("calcnoise","$args");

    # Read the actual list of output files written. For skydip
    # observations this will be one file per elevation per subarray.
    push (@alloutfiles, read_file_list( $outfiles->file ));
  }

  orac_print " Storing ".(scalar(@alloutfiles))." noise files" if ($verbose);
  orac_print "\n";
  # Store in the Frame
  $Frm->files(@alloutfiles);
  $Frm->readhdr if (@alloutfiles > 1);

  # Add the current range to the header for logging purposes
  $Frm->hdr( "FRQRANGE" => $freqrange );

  # Set the NOISE uhdr flag to indicate a NOISE calculation was made
  $Frm->uhdr("NOISE",1);

  # Return OBSEND to original state
  $Frm->uhdr("OBSEND", $obsend_on_entry);
} else {
  # Copy raw data to output for the SUMMIT pipeline
  if ( $Frm->uhdr("SUMMIT") ) {
    _COPY_RAW_DATA_
  }
  # Unset the NOISE uhdr flag
  $Frm->uhdr("NOISE",0);
}
