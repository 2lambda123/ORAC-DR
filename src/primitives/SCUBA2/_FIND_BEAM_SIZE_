#! -*-perl-*-

=head1 NAME

_FIND_BEAM_SIZE_ - Calculate the beam size from a calibrator

=head1 DESCRIPTION

This primitive carries out a fit to a calibrator to determine the beam
size and position angle. An error is generated if the source is not a
calibrator. The reported values are the full-width-at-half-maximum
(FWHM) along the major and minor axes, and the beam position angle on
the sky at the time of obseration. The fit is performed in the SKY
domain so the FWHM is returned in arcsec.

The default is to allow the current fitting routine to determine the
shape of the beam. A flag may be specified to force the return of the
equivalent gaussian beam parameters.

The fit is carried out on the current Grp image or the current
co-added Frame and will fail if there is more than one file in the
Frame.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<METHOD>

Method for deriving the beam parameters. Valid options are BEAMFIT to
use C<beamfit>, or PSF to use C<psf>. Default is BEAMFIT. (In
practice, anything other than PSF will cause C<beamfit> to be used.)

=item B<SYSTEM>

Coordinate system in which to perform beam fit. If not set, the
default is AZEL. May be AZEL, RADEC or GALACTIC. Minimum match is
supported.

=item B<OFFSET>

A flag to denote whether to return the centroid in offset
coordinates. A value of 1 will force the primitive to set the SkyRefIs
attribute to C<Origin> if it has not already been set. Default is 0
(false) which will use the current value.

=item B<GAUSSIAN>

A flag to indicate whether the fit is forced to be gaussian. The
default is no. Only accessed if method=PSF.

=item B<GROUP>

Flag to indicate whether the primitive is to process the Group
image. Default is 0 (false), which will use the current stacked Frame
image.

=item B<LOGFILE>

A flag to indicate whether a pipeline log file should be written
containing the results of the fit. Default is true.

=item B<VERBOSE>

Flag to indicate whether informational messages should be 
given to the user. Default is verbose (true).

=back

=head1 EXTERNAL TASKS

=over 4

=item KAPPA

WCSFRAME, WCSATTRIB, BEAMFIT

=item Other SCUBA-2 primitives

_FIT_PSF_, _FIND_INTEGRATED_INTENSITY_, CENTROID_IMAGE_

=back

=head1 OUTPUT FILES

The following files are created (if necessary):

=over 4

=item C<log.beam>

Log of beam sizes.

=back

=head1 KNOWN ISSUES

Since the fit is currently carried out in the SKY domain, the reported
beam PA will rotate with the sky during the course of a single
night. The solution is to report the beam in the FPLANE coordinate
frame - the closest approximation is the PIXEL domain.

This method also only fits a single component to the beam. This is not
enough at 450 microns, but currently the beam is not sufficiently
well-known to do much more.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>
Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

Copyright (C) 2008 Science and Technology Facilities Council.
Copyright (C) 2005-2008 the University of British Columbia.  All
Rights Reserved.

=head1 TODO

=over 4

=item - Check source is a calibrator?

=item - Estimating contribution from error beam (Make sure UNITS for
  calc and integrated intensity measurement are the same!!)

=item - Retrieve CSO tau from Cal object?

=item - Error in errfrac?

=item - Correct log entries for Group file

=back

=cut

use constant RAD2ASEC => 206265.0;

# Are we looking at the group image?
my $group = get_prim_arg( $_PRIM_ARGS_,"GROUP", 0 );
my $in;
if ( $group ) {
  $in = $Grp->file;
} else {
  # Check that we only have one file in the Frame
  unless ($Frm->nfiles == 1) {
    orac_throw "Error: _FIND_BEAM_SIZE_ must be run after frames have been combined\n";
  } else {
    $in = $Frm->file;
  }
}

# Should I be verbose? (Default to yes)
my $verbose = get_prim_arg( $_PRIM_ARGS_, "VERBOSE", 1 );

# Are we writing an entry to a log file? Default Yes
my $uselog = get_prim_arg( $_PRIM_ARGS_, "LOGFILE", 1 );

# Has the user said to wait until the observation is complete before
# fitting?
my $dofit = get_prim_arg( $_PRIM_ARGS_, "OBSEND", 1 );
# Retrieve the OBSEND flag
my $obsend = $Frm->uhdr("OBSEND");
$dofit = ( $dofit && $obsend ) ? 1 : 0;

# Unset dofit if the input file does not exist
$dofit = 0 unless ( -e "$in.sdf" );

# Do we have a calibrator?
my $calib = $Cal->iscalsource($Frm->hdr('OBJECT')) ;

# Proceed with finding the beam size if the source is a calibrator and
# the DOFIT flag is true
if ($calib && $dofit) {

  # Do we want to use BEAMFIT or PSF? Default BEAMFIT
  my $method = get_prim_arg( $_PRIM_ARGS_, "METHOD", "BEAMFIT" );

  # Set usepsf flag
  my $usepsf = ( $method eq "PSF" ) ? 1 : 0;

  # Get the WCS object
  my $wcs = $Frm->read_wcs( $in );

  # Are we working in an offset coordinate system? Default to yes.
  my ($ORAC_STATUS, $skyrefis);
  my $offset = get_prim_arg( $_PRIM_ARGS_,"OFFSET", 1 );
  if ( $offset ) {
    # Check if we need to set it first
    $skyrefis = lc($wcs->Get("skyrefis"));
    if ( $skyrefis ne "origin" ) {
      $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=set name=skyrefis newval=origin");
    }
  }

  # Retrieve and store current domain and system so they can be reset on
  # exit
  my $incosys = $wcs->Get("system");

  # Determine whether the the fit coordinate system was supplied as an
  # argument, else set it to AzEl.
  my $fitcosys = uc(get_prim_arg($_PRIM_ARGS_, "SYSTEM", "AZEL"));

  # Kappa must be at least V0.15 to use PSF
  if (starversion_lt('kappa','V0.15-0')) {
    orac_throw "Installed version of KAPPA is too old to run _FIND_BEAM_SIZE_\n";
  }

  # See if KAPPA has beamfit
  if ( !$usepsf && starversion_lt('kappa','V1.7')) {
    orac_warn "Installed version of KAPPA is too old to use beamfit method, switching to PSF instead\n";
    $usepsf = 1;
  }

  # Set the coordinate system for the fit
  if ( $fitcosys =~ /AZ/ ) {
    $fitcosys = "AZEL";
  } elsif ( $fitcosys =~ /RA|FK|ICRS/ ) {
    $fitcosys = "ICRS";
  } elsif ( $fitcosys =~ /GAP/ ) {
    $fitcosys = "GAPPT";
  } elsif ( $fitcosys =~ /GAL/ ) {
    $fitcosys = "GALACTIC";
  } else {
    orac_warn "Unknown coordinate system, $fitcosys - will use input as is\n";
    $fitcosys = $incosys;
  }

  # Set coord system for fit if necessary
  if ( $fitcosys ne $incosys ) {
    $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in name=system mode=set newval=$fitcosys");
  }

  # Find the centroid of the source
  _CENTROID_IMAGE_ IMAGE=$in OFFSET=$offset SYSTEM=$fitcosys
  my @xy = @{ $_CENTROID_IMAGE_{RESULTS} };
  # If a source could be located then proceed with fit
  if ( defined $xy[0] && defined $xy[1] ) {

    orac_print "Deriving the beam in the $fitcosys coordinate system using $method\n";

    my (@amp, @majfwhm, @minfwhm, $axisr, @orient, $totalflux, %badbeam);
    # Now fit the source using PSF or BEAMFIT
    if ( $usepsf ) {
      orac_warn "Note that PSF does not return uncertainties - check results carefully\n";
      # Are we forcing a gaussian fit?
      my $gaussian = get_prim_arg($_PRIM_ARGS_, "GAUSSIAN", 0);

      # Create temporary file to write source position(s) in
      my $cofile = new ORAC::TempFile;
      print { $cofile->handle } $xy[0]." ".$xy[1]. "\n";
      $cofile->handle->close;

      # Fit the source with a PSF
      _FIT_PSF_ IMAGE=$in COFILE=$cofile->file GAUSSIAN=$gaussian
      # Retrieve parameters
      $amp[0] = $_FIT_PSF_{AMPLITUDE};
      $minfwhm[0] = $_FIT_PSF_{FWHM};
      $axisr = $_FIT_PSF_{AXISR};
      $orient[0] = $_FIT_PSF_{ORIENT};
      $totalflux = $_FIT_PSF_{TOTALFLUX};

      # Calculate FWHM for major axis
      $majfwhm[0] = $minfwhm[0] * $axisr;

      # Set unused `error' array elements to 0
      $amp[1] = 0.0;
      $majfwhm[1] = 0.0;
      $minfwhm[1] = 0.0;
      $orient[1] = 0.0;

      # Check that the fit gave sensible results
      unless ( defined $minfwhm[0] && defined $axisr && defined $amp[0] ) {
	$badbeam{MAJFWHM} = 1;
	$badbeam{MINFWHM} = 1;
	$badbeam{AMP} = 1;
      }

      # Warn user if the fit looks bad. Of course, this shouldn't happen
      # since we have already selected sources which satisfy this
      # criterion.
      if ($axisr > 1.3333 || $axisr < 0.75) {
	orac_warn "PSF fit appears to be poor or beam highly elongated \n";
	$badbeam{ELONG} = 1;
      }

    } else {
      # Set up args to beamfit
      my $pos = '"'.$xy[0].", ".$xy[1].'"';
      # Use a 15x15 pixel area - should this be an input variable?
      my $fitarea = 15;

      # Check we have a valid variance component
#      $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
#      ($ORAC_STATUS, my $var) = $Mon{ndfpack_mon}->get("ndftrace","variance");
#      if ( lc($var) eq "false" ) {
#	orac_warn "No VARIANCE in input file: will not use variance weighting\n" 
#	  if $verbose;
#      } else {
#	# OK we have variance but check we have enough good values to
#	# use variance weighting
#	($ORAC_STATUS, my $numgood) = $Mon{kappa_mon}->get("stats","numgood");
#	$var = ( $numgood > $fitarea*$fitarea ) ? "true" : "false";
#      }

      # Define args to beamfit
      my $var = "false";
      my $args = "mode=interface pos=".$pos." variance=$var fitarea=$fitarea";
      # Call beamfit
      $Mon{kappa_mon}->obeyw("beamfit","ndf=$in $args");

      # Retrieve parameters
      my @params = (qw/ majfwhm minfwhm orient amp /);
      ($ORAC_STATUS, my %bfitres) = $Mon{kappa_mon}->mget("beamfit",@params);

      # read the FWHM and convert to arcsec
      @majfwhm = map {$_ * RAD2ASEC} @{$bfitres{majfwhm}};
      @minfwhm = map {$_ * RAD2ASEC} @{$bfitres{minfwhm}};

      # amplitude and orientation with error
      @orient = @{$bfitres{orient}};
      @amp = @{$bfitres{amp}};

      # Now assess the fit. Check for highly elongated beam, for
      # magnitude of uncertainty in major/minor axis FWHM and amplitude.
      # Warn user if any parts of the fit look bad.
      $axisr = $majfwhm[0] / $minfwhm[0];
      if ($axisr > 1.3333 || $axisr < 0.75) {
	orac_warn "Beam fit appears to be poor or beam highly elongated \n";
	$badbeam{ELONG} = 1;
      }
      if ( $majfwhm[1] > $majfwhm[0] ) {
	orac_warn "Large uncertainty in FWHM for major axis\n" if $verbose;
	$badbeam{MAJFWHM} = 1;
      }
      if ( $minfwhm[1] > $minfwhm[0] ) {
	orac_warn "Large uncertainty in FWHM for minor axis\n" if $verbose;
	$badbeam{MINFWHM} = 1;
      }
      if ( $minfwhm[1] > $minfwhm[0] ) {
	orac_warn "Large uncertainty in fitted amplitude\n" if $verbose;
	$badbeam{AMP} = 1;
      }
    }

    # Check on status of fit
    if ( defined $badbeam{ELONG} && defined $badbeam{MAJFWHM} && 
	 defined $badbeam{MINFWHM} && defined $badbeam{AMP} ) {
      orac_warn "Beam fit looks poor - ignoring, fit will not be logged\n";
      $badbeam{BEAM} = 1;
    } else {
      $totalflux = 1.133 * $amp[0] * $majfwhm[0] * $minfwhm[0];
    }

    my ($beama, $beamb, $pa, $errfrac);
    # If the fit is bad then don't log it to the file
    if ( defined $badbeam{BEAM} ) {
      $uselog = 0;
    } else {

      # Calculate total power in main beam. Note if PSF was used, the
      # amplitude will be that of the first useable source in the
      # image. In practice, there is likely to be only one source in the
      # image so this will be the amplitude we want.
      my $Pmain = $totalflux;

      # Error in total power - assume errors add in quadrature
      my $dPmain = $Pmain * sqrt( $amp[1]*$amp[1]/($amp[0]*$amp[0]) +
				  $majfwhm[1]*$majfwhm[1]/($majfwhm[0]*$majfwhm[0]) +
				  $minfwhm[1]*$minfwhm[1]/($minfwhm[0]*$minfwhm[0]) );

      # Now do aperture photometry on source to measure total power in
      # image A 2 arcmin-diameter aperture should be big enough Future:
      # Iterative method to increase aperture from FWHM to image size
      my $radius = 60.0; 
      _FIND_INTEGRATED_INTENSITY_ RADIUS=$radius IMAGE=$in XYPOS=\@xy
      my $Pint = $_FIND_INTEGRATED_INTENSITY_{TOTALFLUX};
      # Error in $Pint = sigma * sqrt(n_pixels_used)
      my $dPint = $_FIND_INTEGRATED_INTENSITY_{SIGMA} *
	          sqrt($_FIND_INTEGRATED_INTENSITY_{NUMGOOD});

      # Calculate fraction of power in error beam as a percentage. Note
      # that the beam-fitting procedure typically over-estimates the
      # peak value in the map by about 5%.
      if ( $Pint > $Pmain ) {
	$errfrac = 100.0 * (1.0 - ($Pmain / $Pint) );
      } elsif ( (abs($Pint-$Pmain) < 3.*$dPint) || 
		(abs($Pint-$Pmain) < 3.*$dPmain) ) {
	# Look to see if the difference is <3 sigma
	orac_print "Flux difference within the noise - no discernible error beam\n" if $verbose;
	$errfrac = 0.0;
      } else {
	my $pmain = sprintf "%5.3f", $Pmain;
	my $pint = sprintf "%5.3f", $Pint;
	orac_warn "Total integrated power ($pint) is less than that in the main beam ($pmain)\n";
	$errfrac = 0.0;
      }

      # Store beam parameters
      $Cal->beampar( majfwhm => \@majfwhm, minfwhm => \@minfwhm, 
		     orient => \@orient, errfrac => $errfrac );

      # Reformat for pretty reporting
      $errfrac = sprintf "%3d", $errfrac;
      $beama = sprintf "%5.2f", $majfwhm[0];
      $beamb = sprintf "%5.2f", $minfwhm[0];
      $pa = sprintf "%6.2f", $orient[0];
    }

    # Write a log file if required
    if ($uselog) {
      my $time = gmtime();
      my $beamlog = new ORAC::LogFile("log.beam");
      $beamlog->header("#Beam log file - created on $time UT",
		       "#\n# UT                HST   Obs Source       Mode           Filter El CSO    Tau   Seeing  A      dA       B       dB      PA      dPA    Errbeam",
		       "#---------------------------------------------------------------------------------------------------------------------------------------------------"
	);

      # Get basic logging parameters from input file
      _GET_LOG_PARAMETERS_ GROUP=$group
      my ( $uttime, $hst, $run, $src, $mode, $filter, $el, $cso, $tau, $see ) 
          = @{ $_GET_LOG_PARAMETERS_{PARAMS} };

      # Reformat uncertainties in beam parameters for printing
      my $da = sprintf "%5.2f",  $majfwhm[1];
      my $db = sprintf "%5.2f", $minfwhm[1];
      my $dpa = sprintf "%5.2f", $orient[1];

      # Write to logfile
      $beamlog->addentry("$uttime $hst $run $src $mode $filter    $el $cso $tau  $see   $beama  $da  $beamb   $db   $pa   $dpa  $errfrac");

    }
    orac_print "Beam size: $beama x $beamb arcsec^2 at a PA of $pa deg E of N\n" if ($verbose && !($badbeam{BEAM}));

  } else {
    orac_warn "Unable to locate source to determine beam size\n";
  }

  # See if we need to reset wcs attributes
  my @attrs;

  # Return SYSTEM to original value if necessary
  if ( $fitcosys ne $incosys ) {
    push(@attrs, "system=$incosys");
  }
  # Reset the SkyRefIs parameter if necessary
  if ( defined $skyrefis && $skyrefis ne "origin") {
    push(@attrs, "skyrefis=$skyrefis");
  }

  # if need be, update them
  if (@attrs) {
    my $attrs = join(",",@attrs);
    $Mon{ndfpack_mon}->obeyw("wcsattrib", "ndf=$in mode=mset setting='$attrs'");
  }
}

