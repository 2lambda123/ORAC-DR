#! -*-perl-*-

=head1 NAME

_FIND_BEAM_SIZE_ - Calculate the beam size from a calibrator

=head1 DESCRIPTION

This primitive carries out a fit to a calibrator to determine the beam
size and position angle. An error is generated if the source is not a
calibrator. The reported values are the full-width-at-half-maximum
(FWHM) along the major and minor axes, and the beam position angle on
the sky at the time of obseration. The fit is performed in the SKY
domain so the FWHM is returned in arcsec.

The default is to allow the current fitting routine to determine the
shape of the beam. A flag may be specified to force the return of the
equivalent gaussian beam parameters.

The fit is to the current co-added Frame and will fail if there is
more than one file in the Frame.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item METHOD

Method for deriving the beam parameters. Valid options are BEAM to use
C<beamfit>, or PSF to use C<psf>. Default is BEAM.

=item GAUSSIAN

A flag to indicate whether the fit is forced to be gaussian. The
default is no. Only accessed if method=PSF.

=item LOGFILE

A flag to indicate whether a pipeline log file should be written
containing the results of the fit. Default is true.

=item VERBOSE

Flag to indicate whether informational messages should be 
given to the user. Default is verbose (true).

=back

=head1 EXTERNAL TASKS

=over 4

=item KAPPA

WCSFRAME, WCSATTRIB, BEAMFIT

=item Other SCUBA-2 primitives

_FIND_POINT_SOURCES, _FIT_PSF_, _FIND_INTEGRATED_INTENSITY_

=back

=head1 OUTPUT FILES

The following files are created (if necessary):

=over 4

=item C<log.beam>

Log of beam sizes.

=back

=head1 KNOWN ISSUES

Since the fit is currently carried out in the SKY domain, the reported
beam PA will rotate with the sky during the course of a single
night. The solution is to report the beam in the FPLANE coordinate
frame - the closest approximation is the PIXEL domain.

This method also only fits a single component to the beam. This is not
enough at 450 microns, but currently the beam is not sufficiently
well-known to do much more.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2005-2007 the University of British Columbia.  All
Rights Reserved.

=head1 TODO

=over 4

=item - Check source is a calibrator?

=item - Estimating contribution from error beam (Make sure UNITS for
  calc and integrated intensity measurement are the same!!)

=item - Decide the best coord frame for reporting beam PA

=item - Store results in Cal object?

=item - Retrieve CSO tau from Cal object?

=item - Error in errfrac?

=back

=cut

use constant RAD2ASEC => 206265.0;

# First check that we only have one file in the Frame
my $in;
unless ($Frm->nfiles == 1) {
  orac_throw "Error: _FIND_BEAM_SIZE_ must be run after frames have been combined\n";
} else {
  $in = $Frm->file;
}

# Should I be verbose? (Default to yes)
my $verbose = (exists $_FIND_BEAM_SIZE_{VERBOSE} && 
	       defined $_FIND_BEAM_SIZE_{VERBOSE}) ?
               $_FIND_BEAM_SIZE_{VERBOSE} : 1;

# Are we writing an entry to a log file? Default Yes
my $uselog = ( exists $_FIND_BEAM_SIZE_{LOGFILE} && 
	       defined $_FIND_BEAM_SIZE_{LOGFILE}) ?
               $_FIND_BEAM_SIZE_{LOGFILE} : 1;

# Do we want to use BEAMFIT or PSF?
my $method = ( exists $_FIND_BEAM_SIZE_{METHOD} && 
	       defined $_FIND_BEAM_SIZE_{METHOD}) ?
               $_FIND_BEAM_SIZE_{METHOD} : "BEAM";

my $usepsf = ( $method eq "PSF" ) ? 1 : 0;

# Do we have a calibrator?
my $calib = $Cal->iscalsource($Frm->hdr('OBJECT')) ;
#orac_throw "Error: source is not a known calibrator \n" 
#  unless ($calib);

# Retrieve and store current domain (frame) so it can be reset on exit
my $origframe;
my $ORAC_STATUS;
$Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in name=domain mode=get");
( $ORAC_STATUS, $origframe ) = $Mon{ndfpack_mon}->get("wcsattrib", "value");

# Determine whether the WCS frame (domain) was supplied as an
# argument, else set it to the input frame.
my $wcsframe = (exists $_FIND_BEAM_SIZE_{WCSFRAME} && 
		defined $_FIND_BEAM_SIZE_{WCSFRAME} ) ? 
                uc($_FIND_BEAM_SIZE_{WCSFRAME}) : $origframe;

# Test whether or not given frame is valid.
unless ($wcsframe =~ /AXIS|PIXEL|GRID|SKY/) {
  orac_throw "Unknown WCS frame, $wcsframe ";
}

# Check whether older versions of kappa are being used.
if (starversion_lt('kappa','V0.14-0')) {
  $wcsframe = "AXIS" if ($wcsframe eq "SKY"); # No SKY frame in older kappa
}

# If we have a SKY frame, determine the WCS SYSTEM parameter.
my ($system, $origsystem);
if ( $wcsframe eq "SKY" ) {
  $system = (exists $_FIND_BEAM_SIZE_{SYSTEM} && 
	     defined $_FIND_BEAM_SIZE_{SYSTEM} ) ? 
	     uc($_FIND_BEAM_SIZE_{SYSTEM}) : "";

  # Retrieve and store current system so it can be reset on exit
  $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in name=system mode=get");
  ( $ORAC_STATUS, $origsystem ) = $Mon{ndfpack_mon}->get("wcsattrib", "value");
}

# Set the WCS frame to that desired if necessary
if ( $origframe ne $wcsframe ) {
  $Mon{ndfpack_mon}->obeyw("wcsframe", "ndf=$in frame=$wcsframe");
}

# Initialise the log file if necessary
my $beamlog;
if ($uselog) {
  my $time = gmtime();
  $beamlog = new ORAC::LogFile("log.beam");
  $beamlog->header("Beam log file - created on $time\n",
		   "#     Time       Filter    A     dA     B     dB    PA    dPA    Seeing  El   Tau225",
		   "-------------------------------------------------------------------------------------"
            );
}

# Find the positions of all point sources in the image. Use current Frm.
_FIND_SOURCES_ POINT=1 DETECT_SIGMA=10

# Retrieve Astro::Catalog object from _FIND_SOURCES_
my $catalogue = $_FIND_SOURCES_{CATALOGUE};

# What if there are no point sources? Or more than 1?
if ( $catalogue->sizeof == 0 ) {
  orac_throw "No point sources found in current image: unable to determine beam parameters\n";
} elsif ( $catalogue->sizeof > 1 && $method eq "BEAM" ) { 
  orac_warn "Image appears to have multiple sources - switching to PSF method\n";
  $usepsf = 1;
}

# Parse DATE-OBS keyword
my @dateobs = split( /[-T:.]/, $Frm->hdr( 'DATE-OBS' ) );
# Create a DateTime object to allow coordinate conversions.
# Note: the format of DATE-OBS means that the fractional seconds is
# converted into miliseconds, hence the 1e6 in argument for nanosecond
# in the DateTime object.
my $dt = DateTime->new( year => $dateobs[0], month => $dateobs[1], 
			day => $dateobs[2], hour => $dateobs[3], 
			minute => $dateobs[4], second => $dateobs[5],
			nanosecond => $dateobs[6]*1e6, time_zone => 'UTC' );

my (@amp, @majfwhm, @minfwhm, $axisr, $gamma, @orient, @xy);
# Now fit the source using PSF or BEAMFIT
if ( $usepsf ) {
  # Are we forcing a gaussian fit?
  my $gaussian = (exists $_FIND_BEAM_SIZE_{GAUSSIAN} &&
		  defined $_FIND_BEAM_SIZE_{GAUSSIAN}) ?
		  $_FIND_BEAM_SIZE_{GAUSSIAN} : 0;

  # Create temporary file to write source position(s) in
  my $cofile = new ORAC::TempFile;

  # Since PSF can handle multiple sources, loop over all sources in
  # catalogue. Of course, in practice `There can be only one'... ;-)
  use Astro::Telescope;
  foreach my $i ( 1.. $catalogue->sizeof ) {
    my $source = $catalogue->starbyindex( $i - 1 );
    my $coords = $source->coords;
    # Set the telescope to JCMT
#    $coords->telescope( new Astro::Telescope( 'JCMT' ) );
    
    # Register DateTime object
#    $coords->datetime( $dt );

    use Data::Dumper;
#    print Dumper($catalogue);
    # Print out Az and El of current source
#    print $coords->ra." ".$coords->dec. "\n";
    print { $cofile->handle } $coords->ra." ".$coords->dec. "\n";
    # Store this position for later
    if ( $i == 1 ) {
      $xy[0] = $coords->ra;
      $xy[1] = $coords->dec;
    }
  }
  $cofile->handle->close;

  # Fit the source with a PSF
  _FIT_PSF_ IMAGE=$in USELOG=1 COFILE=$cofile->file GAUSSIAN=$gaussian
  ($amp[0], $minfwhm[0], $axisr, $gamma, $orient[0]) = @{ $_FIT_PSF_{RESULTS} };

  # Calculate FWHM for major axis
  $majfwhm[0] = $minfwhm[0] * $axisr;

  # Set unused `error' array elements to 0
  $amp[1] = 0.0;
  $majfwhm[1] = 0.0;
  $minfwhm[1] = 0.0;
  $orient[1] = 0.0;

  # Check that the fit gave sensible results
  unless ( defined $minfwhm[0] && defined $axisr && defined $gamma ) {
    orac_throw "Error fitting PSF\n";
  }

  # Warn user if the fit looks bad. Of course, this shouldn't happen
  # since we have already selected sources which satisfy this
  # criterion.
  if ($axisr > 1.3333 || $axisr < 0.75) {
    orac_warn "Warning: Fit appears to be poor or beam highly elongated \n";
  }

} else {
  # We only want to fit one beam so we assume the first (and only)
  # one in the catalogue is the one we are interested in.
  my $source = $catalogue->starbyindex( 0 );
  my $coords = $source->coords;
  # Set the telescope to JCMT
  $coords->telescope( new Astro::Telescope( 'JCMT' ) );
    
  # Register DateTime object
  $coords->datetime( $dt );

  $xy[0] = $coords->ra;
  $xy[1] = $coords->dec;  

  # Set args
  my $pos = '"'.$xy[0].", ".$xy[1].'"';
  my $fitarea = 15; # Use a 15x15 pixel area?
  my $args = "mode=interface pos=".$pos." variance=true fitarea=$fitarea";

  # Call beamfit
  $Mon{kappa_mon}->obeyw("beamfit","ndf=$in $args");

  # Retrieve parameters
  my $ORAC_STATUS;
  ($ORAC_STATUS, @majfwhm) = $Mon{kappa_mon}->get("beamfit","majfwhm");
  ($ORAC_STATUS, @minfwhm) = $Mon{kappa_mon}->get("beamfit","minfwhm");
  ($ORAC_STATUS, @orient) = $Mon{kappa_mon}->get("beamfit","orient");
  ($ORAC_STATUS, @amp) = $Mon{kappa_mon}->get("beamfit","amp");

  # FWHM are returned in radians: convert to arcsec
  for my $i (0..1) {
    $majfwhm[$i] *= RAD2ASEC;
    $minfwhm[$i] *= RAD2ASEC;
  }
}

# Calculate total power in main beam. Note if PSF was used, the
# amplitude will be that of the first useable source in the image. In
# practice, there is likely to be only one source in the image so this
# will be the amplitude we want.
my $Pmain = 1.133 * $amp[0] * $majfwhm[0] * $minfwhm[0];

# Error in total power - assume errors add in quadrature
my $dPmain = $Pmain * sqrt( $amp[1]*$amp[1]/($amp[0]*$amp[0]) +
			    $majfwhm[1]*$majfwhm[1]/($majfwhm[0]*$majfwhm[0]) +
			    $minfwhm[1]*$minfwhm[1]/($minfwhm[0]*$minfwhm[0]) );

# Now do aperture photometry on source to measure total power in image
# A 2 arcmin-diameter aperture should be big enough
# Future: Iterative method to increase aperture from FWHM to image size
my $radius = 60.0; 

_FIND_INTEGRATED_INTENSITY_ RADIUS=$radius IMAGE=$in XYPOS=\@xy
my $Pint = $_FIND_INTEGRATED_INTENSITY_{TOTALFLUX};
# Error in $Pint?
#my $Pint = 0.0;

# Calculate fraction of power in error beam as a percentage
my $errfrac;
if ( $Pint > $Pmain ) {
  $errfrac = 100.0 * (1.0 - ($Pmain / $Pint) );
} else {
  orac_warn "Total integrated power is less than that in the main beam\n";
  $errfrac = 0.0;
}

# Store beam parameters
$Cal->beampar( majfwhm => \@majfwhm, minfwhm => \@minfwhm, 
	       orient => \@orient, errfrac => $errfrac );


# Reformat for pretty reporting
$errfrac = sprintf "%3d", $errfrac;

# Now subtract parallactic angle to get PA in AzEl frame
#$orient -= $coords->pa(format => 'deg');

# Write a log file if required
if ($uselog) {
  my $num = sprintf "%04d", $Frm->hdr('OBSNUM');
  my $time= sprintf "%15.7f", $Frm->hdr('ORACTIME');
  my $filt= sprintf "%4s", $Frm->hdr('FILTER');

  # Get TAU from the header - should get from $Cal object?
  my $cso = sprintf "%6.3f", 0.5*($Frm->hdr('WVMTAUST') + $Frm->hdr('WVMTAUEN'));

  # Elevation
  my $el = int ( 0.5 * ($Frm->hdr('ELSTART') + $Frm->hdr('ELEND') ) );
  # Seeing
  my $see = sprintf "%5.2f", ( 0.5 * ($Frm->hdr('SEEINGST') + $Frm->hdr('SEEINGEN') ) );
  # Reformat beam parameters for printing
  my $beama = sprintf "%5.2f", $majfwhm[0];
  my $da = sprintf "%5.2f",  $majfwhm[1];
  my $beamb = sprintf "%5.2f", $minfwhm[0];
  my $db = sprintf "%5.2f", $minfwhm[1];
  my $pa = sprintf "%5.2f", $orient[0];
  my $dpa = sprintf "%5.2f", $orient[1];

  # Write to logfile
  $beamlog->addentry("$num  $time  $filt    $beama   $da   $beamb   $db   $pa   $dpa $see   $el  $cso");

  my $sources;
  if ( $catalogue->sizeof == 1 ) {
    $sources = " source\n";
  } else {
    $sources = " sources\n";
  }
  orac_print "Beam size for $filt: $beama x $beamb arcsec^2 at a PA of $pa deg E of N calculated from ".$catalogue->sizeof.$sources if ($verbose);
}

# Return SYSTEM to original value if necessary
if ( $system ne "" ) {
  $Mon{ndfpack_mon}->obeyw("wcsattrib", "ndf=$in mode=set name=system newval=$origsystem");
}

# Return DOMAIN to original value if necessary
if ( $wcsframe ne $origframe ) {
  $Mon{ndfpack_mon}->obeyw("wcsframe", "ndf=$in frame=$origframe");
}
