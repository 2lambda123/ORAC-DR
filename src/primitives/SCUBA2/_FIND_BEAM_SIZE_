# -*-perl-*-

=head1 NAME

_FIND_BEAM_SIZE_ - Calculate the beam size from a calibrator

=head1 SYNOPSIS

_FIND_BEAM_SIZE_ GAUSSIAN=1 METHOD=PSF

=head1 DESCRIPTION

This primitive carries out a fit to a calibrator to determine the beam
size and position angle using one of two available methods. The
reported values are the full-width-at-half-maximum (FWHM) along the
major and minor axes, and the beam position angle on the sky at the
time of obseration. The fit is performed in the SKY domain so the FWHM
is returned in arcsec.

The default is to allow the current fitting routine to determine the
shape of the beam. A flag may be specified to force the return of the
equivalent gaussian beam parameters.

The fit is carried out on the current Group image or the current
co-added Frame and will fail if there is more than one file in the
Frame.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<GAUSSIAN>

A flag to indicate whether the fit is forced to be gaussian. The
default is 0 (no). Only accessed if B<METHOD> is C<PSF>.

=item B<GROUP>

Flag to indicate whether the primitive is to process the Group
image. Default is 0 (false), which will use the current stacked Frame
image.

=item B<LOGFILE>

A flag to indicate whether a pipeline log file should be written
containing the results of the fit. Default is 1 (true).

=item B<METHOD>

Method for deriving the beam parameters. Valid options are C<BEAMFIT>
or C<PSF>. Default is C<BEAMFIT>. In practice, anything other than
C<PSF> will implies C<BEAMFIT>.

=item B<OBSEND>

Flag to indicate whether the primitive should wait until the
observation has ended before fitting the beam. The default is 1
(wait until end).

=item B<OFFSET>

A flag to denote whether to return the centroid in offset
coordinates. A value of 1 will force the primitive to set the SkyRefIs
attribute to C<Origin> if it has not already been set. Default is 0
(false) which will use the current value.

=item B<SYSTEM>

Coordinate system in which to perform the fit. The default is
C<AZEL>. May be C<AZEL>, C<ICRS>, C<FK5>, C<GAPPT> or
C<GALACTIC>. Minimum match is supported.

=item B<VERBOSE>

Flag to indicate whether informational messages should be 
given to the user. Default is verbose (true).

=back

=head1 EXTERNAL TASKS

=over 4

=item KAPPA:

BEAMFIT, WCSATTRIB

=item ORAC-DR PRIMITIVES:

_CENTROID_IMAGE_, _FIT_PSF_, _FIND_INTEGRATED_INTENSITY_,
_GET_LOG_PARAMETERS_

=back

=head1 NOTES

This method only fits a single component to the beam. This is not
enough at 450 microns, but currently the beam is not sufficiently
well-known to do much more.

Using coordinate frames other than AzEl will cause the beam to appear
to rotate during the course of an observation.

=head1 OUTPUT DATA

The beam parameters are stored in the calibration system.

=head1 OUTPUT FILES

If requested, the beam parameters are written to the log file
C<log.beam>.

=head1 LOGFILE FORMAT

The logfile has the following columns:

=over 4

=item UT

The UT date in C<YYYYMMDD.frac> format.

=item HST

The time of the observation in Hawaii.

=item Obs

The observation number.

=item Source

The source name.

=item Mode

The observing mode.

=item Filter

The filter associated with the current result.

=item Elevation

The elevation of the observation.

=item CSO

Equivalent CSO tau derived from the tau used to reduce
the observation.

=item Tau

The tau value used for the reduction.

=item Seeing

The seeing value as stored in the header.

=item A

Beam semi-major axis in arcsec.

=item dA

Error in A.

=item B

Beam semi-minor axis in arcsec.

=item dB

Error in B.

=item PA

Position of major axis, in degrees east of north.

=item dPA

Error in PA.

=item Errbeam

Fractional contribution of error beam (per cent).

=back

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>,
Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.
Copyright (C) 2005-2008 the University of British Columbia.  All
Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

use constant RAD2ASEC => 206265.0;

# Are we looking at the group image?
my $group = get_prim_arg( $_PRIM_ARGS_,"GROUP", 0 );
my $in;
if ( $group ) {
  $in = $Grp->file;
} else {
  # Check that we only have one file in the Frame
  unless ($Frm->nfiles == 1) {
    orac_throw "Error: _FIND_BEAM_SIZE_ must be run after frames have been combined\n";
  } else {
    $in = $Frm->file;
  }
}

# Should I be verbose? (Default to yes)
my $verbose = get_prim_arg( $_PRIM_ARGS_, "VERBOSE", 1 );

# Are we writing an entry to a log file? Default Yes
my $uselog = get_prim_arg( $_PRIM_ARGS_, "LOGFILE", 1 );

# Has the user said to wait until the observation is complete before
# fitting?
my $dofit = get_prim_arg( $_PRIM_ARGS_, "OBSEND", 1 );
# Retrieve the OBSEND flag
my $obsend = $Frm->uhdr("OBSEND");
$dofit = ( $dofit && $obsend ) ? 1 : 0;

# Unset dofit if the input file does not exist
$dofit = 0 unless ( -e "$in.sdf" );

# Do we have a calibrator?
my $calib = $Cal->iscalsource($Frm->hdr('OBJECT')) ;

# Proceed with finding the beam size if the source is a calibrator and
# the DOFIT flag is true
if ($calib && $dofit) {

  # Do we want to use BEAMFIT or PSF? Default BEAMFIT
  my $method = get_prim_arg( $_PRIM_ARGS_, "METHOD", "BEAMFIT" );

  # Set usepsf flag
  my $usepsf = ( $method eq "PSF" ) ? 1 : 0;

  # Get the WCS object
  my $wcs = $Frm->read_wcs( $in );

  # Are we working in an offset coordinate system? Default to yes.
  my ($ORAC_STATUS, $skyrefis);
  my $offset = get_prim_arg( $_PRIM_ARGS_,"OFFSET", 1 );
  if ( $offset ) {
    # Check if we need to set it first
    $skyrefis = lc($wcs->Get("skyrefis"));
    if ( $skyrefis ne "origin" ) {
      $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=set name=skyrefis newval=origin");
    }
  }

  # Retrieve and store current domain and system so they can be reset on
  # exit
  my $incosys = $wcs->Get("system");

  # Determine whether the the fit coordinate system was supplied as an
  # argument, else set it to AzEl.
  my $fitcosys = uc(get_prim_arg($_PRIM_ARGS_, "SYSTEM", "AZEL"));

  # Kappa must be at least V0.15 to use PSF
  if (starversion_lt('kappa','V0.15-0')) {
    orac_throw "Installed version of KAPPA is too old to run _FIND_BEAM_SIZE_\n";
  }

  # See if KAPPA has beamfit
  if ( !$usepsf && starversion_lt('kappa','V1.7')) {
    orac_warn "Installed version of KAPPA is too old to use beamfit method, switching to PSF instead\n";
    $usepsf = 1;
  }

  # Set the coordinate system for the fit
  if ( $fitcosys =~ /AZ/ ) {
    $fitcosys = "AZEL";
  } elsif ( $fitcosys =~ /RA|FK|ICRS/ ) {
    $fitcosys = "ICRS";
  } elsif ( $fitcosys =~ /GAP/ ) {
    $fitcosys = "GAPPT";
  } elsif ( $fitcosys =~ /GAL/ ) {
    $fitcosys = "GALACTIC";
  } else {
    orac_warn "Unknown coordinate system, $fitcosys - will use input as is\n";
    $fitcosys = $incosys;
  }

  # Set coord system for fit if necessary
  if ( $fitcosys ne $incosys ) {
    $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in name=system mode=set newval=$fitcosys");
  }

  # Find the centroid of the source
  _CENTROID_IMAGE_ IMAGE=$in OFFSET=$offset SYSTEM=$fitcosys
  my @xy = (defined $_CENTROID_IMAGE_{RESULTS}->[0] && 
	    defined $_CENTROID_IMAGE_{RESULTS}->[1]) ? 
	    @{ $_CENTROID_IMAGE_{RESULTS} } : ();
  # If a source could be located then proceed with fit
  if ( defined $xy[0] && defined $xy[1] ) {

    orac_print "Deriving the beam in the $fitcosys coordinate system using $method\n";

    my (@amp, @majfwhm, @minfwhm, $axisr, @orient, $totalflux, %badbeam);
    # Now fit the source using PSF or BEAMFIT
    if ( $usepsf ) {
      orac_warn "Note that PSF does not return uncertainties - check results carefully\n";
      # Are we forcing a gaussian fit?
      my $gaussian = get_prim_arg($_PRIM_ARGS_, "GAUSSIAN", 0);

      # Create temporary file to write source position(s) in
      my $cofile = new ORAC::TempFile;
      print { $cofile->handle } $xy[0]." ".$xy[1]. "\n";
      $cofile->handle->close;

      # Fit the source with a PSF
      _FIT_PSF_ IMAGE=$in COFILE=$cofile->file GAUSSIAN=$gaussian
      # Retrieve parameters
      $amp[0] = $_FIT_PSF_{AMPLITUDE};
      $minfwhm[0] = $_FIT_PSF_{FWHM};
      $axisr = $_FIT_PSF_{AXISR};
      $orient[0] = $_FIT_PSF_{ORIENT};
      $totalflux = $_FIT_PSF_{TOTALFLUX};

      # Calculate FWHM for major axis
      $majfwhm[0] = $minfwhm[0] * $axisr;

      # Set unused `error' array elements to 0
      $amp[1] = 0.0;
      $majfwhm[1] = 0.0;
      $minfwhm[1] = 0.0;
      $orient[1] = 0.0;

      # Check that the fit gave sensible results
      unless ( defined $minfwhm[0] && defined $axisr && defined $amp[0] ) {
	$badbeam{MAJFWHM} = 1;
	$badbeam{MINFWHM} = 1;
	$badbeam{AMP} = 1;
      }

      # Warn user if the fit looks bad. Of course, this shouldn't happen
      # since we have already selected sources which satisfy this
      # criterion.
      if ($axisr > 1.3333 || $axisr < 0.75) {
	orac_warn "PSF fit appears to be poor or beam highly elongated \n";
	$badbeam{ELONG} = 1;
      }

    } else {
      # Use BEAMFIT

      # Check we have a valid variance component
#      $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
#      ($ORAC_STATUS, my $var) = $Mon{ndfpack_mon}->get("ndftrace","variance");
#      if ( lc($var) eq "false" ) {
#	orac_warn "No VARIANCE in input file: will not use variance weighting\n" 
#	  if $verbose;
#      } else {
#	# OK we have variance but check we have enough good values to
#	# use variance weighting
#	($ORAC_STATUS, my $numgood) = $Mon{kappa_mon}->get("stats","numgood");
#	$var = ( $numgood > $fitarea*$fitarea ) ? "true" : "false";
#      }

      # Define args to beamfit
      my $var = "false";
      my $pos = '"'.$xy[0].", ".$xy[1].'"';
      # Use a 15x15 pixel area - should this be an input variable?
      my $fitarea = 15;
      my $args = "mode=interface pos=".$pos." variance=$var fitarea=$fitarea";
      # Call beamfit
      $Mon{kappa_mon}->obeyw("beamfit","ndf=$in $args");

      # Retrieve parameters
      my @params = (qw/ majfwhm minfwhm orient amp /);
      ($ORAC_STATUS, my %bfitres) = $Mon{kappa_mon}->mget("beamfit",@params);

      # Read the FWHM and convert to arcsec
      @majfwhm = map {$_ * RAD2ASEC} @{$bfitres{majfwhm}};
      @minfwhm = map {$_ * RAD2ASEC} @{$bfitres{minfwhm}};

      # Amplitude and orientation with error
      @orient = @{$bfitres{orient}};
      @amp = @{$bfitres{amp}};

      # Now assess the fit. Check for highly elongated beam, for
      # magnitude of uncertainty in major/minor axis FWHM and amplitude.
      # Warn user if any parts of the fit look bad.
      $axisr = $majfwhm[0] / $minfwhm[0];
      if ($axisr > 1.3333 || $axisr < 0.75) {
	orac_warn "Beam fit appears to be poor or beam highly elongated \n";
	$badbeam{ELONG} = 1;
      }
      if ( $majfwhm[1] > $majfwhm[0] ) {
	orac_warn "Large uncertainty in FWHM for major axis\n" if $verbose;
	$badbeam{MAJFWHM} = 1;
      }
      if ( $minfwhm[1] > $minfwhm[0] ) {
	orac_warn "Large uncertainty in FWHM for minor axis\n" if $verbose;
	$badbeam{MINFWHM} = 1;
      }
      if ( $amp[1] > $amp[0] ) {
	orac_warn "Large uncertainty in fitted amplitude\n" if $verbose;
	$badbeam{AMP} = 1;
      }
      if ( $amp[0] < 0 ) {
	orac_warn "Fitted amplitude is negative\n" if $verbose;
	$badbeam{AMP} = 1;
      }
      $totalflux = 1.133 * $amp[0] * $majfwhm[0] * $minfwhm[0];
    }

    # Check on status of fit - count the number of defined badbeam flags
    my $nbadbflags = 0;
    foreach my $flag ( qw/ AMP ELONG MAJFWHM MINFWHM /) {
      $nbadbflags++ if ( defined $badbeam{$flag} );
    }
    # Define a bad fit if 2 or more flags are set
    if ( $nbadbflags > 1 ) {
      orac_warn "Beam fit looks poor - fit will not be logged\n";
      $badbeam{BEAM} = 1;
    }

    my ($beama, $beamb, $pa, $errfrac);
    # If the fit is bad then don't log it to the file
    if ( defined $badbeam{BEAM} ) {
      $uselog = 0;
    } else {

      # Calculate total power in main beam. Note if PSF was used, the
      # amplitude will be that of the first useable source in the
      # image. In practice, there is likely to be only one source in the
      # image so this will be the amplitude we want.
      my $Pmain = $totalflux;

      # Error in total power - assume errors add in quadrature
      my $dPmain = $Pmain * sqrt( $amp[1]*$amp[1]/($amp[0]*$amp[0]) +
				  $majfwhm[1]*$majfwhm[1]/($majfwhm[0]*$majfwhm[0]) +
				  $minfwhm[1]*$minfwhm[1]/($minfwhm[0]*$minfwhm[0]) );

      # Now do aperture photometry on source to measure total power in
      # image A 2 arcmin-diameter aperture should be big enough Future:
      # Iterative method to increase aperture from FWHM to image size
      my $radius = 60.0; 
      _FIND_INTEGRATED_INTENSITY_ RADIUS=$radius IMAGE=$in XYPOS=\@xy
      my $Pint = $_FIND_INTEGRATED_INTENSITY_{TOTALFLUX};
      # Error in $Pint = sigma * sqrt(n_pixels_used)
      my $dPint = $_FIND_INTEGRATED_INTENSITY_{SIGMA} *
	          sqrt($_FIND_INTEGRATED_INTENSITY_{NUMGOOD});

      # Calculate fraction of power in error beam as a percentage. Note
      # that the beam-fitting procedure typically over-estimates the
      # peak value in the map by about 5%.
      if ( $Pint > $Pmain ) {
	$errfrac = 100.0 * (1.0 - ($Pmain / $Pint) );
      } elsif ( (abs($Pint-$Pmain) < 3.*$dPint) || 
		(abs($Pint-$Pmain) < 3.*$dPmain) ) {
	# Look to see if the difference is <3 sigma
	orac_print "Flux difference within the noise - no discernible error beam\n" if $verbose;
	$errfrac = 0.0;
      } else {
	my $pmain = sprintf "%5.3f", $Pmain;
	my $pint = sprintf "%5.3f", $Pint;
	orac_warn "Total integrated power ($pint) is less than that in the main beam ($pmain)\n";
	$errfrac = 0.0;
      }

      # Store beam parameters
      $Cal->beampar( majfwhm => \@majfwhm, minfwhm => \@minfwhm, 
		     orient => \@orient, errfrac => $errfrac );

      # Reformat for pretty reporting
      $errfrac = sprintf "%3d", $errfrac;
      $beama = sprintf "%5.2f", $majfwhm[0];
      $beamb = sprintf "%5.2f", $minfwhm[0];
      $pa = sprintf "%6.2f", $orient[0];
    }

    # Write a log file if required
    if ($uselog) {
      my $time = gmtime();
      my $beamlog = new ORAC::LogFile("log.beam");
      $beamlog->header("#Beam log file - created on $time UT",
		       "#\n# UT                HST   Obs Source       Mode           Filter El CSO    Tau   Seeing  A      dA       B       dB      PA      dPA    Errbeam",
		       "#---------------------------------------------------------------------------------------------------------------------------------------------------"
	);

      # Get basic logging parameters from input file
      _GET_LOG_PARAMETERS_ GROUP=$group
      my ( $uttime, $hst, $run, $src, $mode, $filter, $el, $cso, $tau, $see ) 
          = @{ $_GET_LOG_PARAMETERS_{PARAMS} };

      # Reformat uncertainties in beam parameters for printing
      my $da = sprintf "%5.2f",  $majfwhm[1];
      my $db = sprintf "%5.2f", $minfwhm[1];
      my $dpa = sprintf "%5.2f", $orient[1];

      # Write to logfile
      $beamlog->addentry("$uttime $hst $run $src $mode $filter    $el $cso $tau  $see   $beama  $da  $beamb   $db   $pa   $dpa  $errfrac");

    }
    orac_print "Beam size: $beama x $beamb arcsec^2 at a PA of $pa deg E of N\n" if ($verbose && !($badbeam{BEAM}));

  } else {
    orac_warn "Unable to locate source to determine beam size\n";
  }

  # See if we need to reset WCS attributes
  my @attrs;

  # Return SYSTEM to original value if necessary
  if ( $fitcosys ne $incosys ) {
    push(@attrs, "system=$incosys");
  }
  # Reset the SkyRefIs parameter if necessary
  if ( defined $skyrefis && $skyrefis ne "origin") {
    push(@attrs, "skyrefis=$skyrefis");
  }

  # Reset WCS attributes if necessary
  if (@attrs) {
    my $attrs = join(",",@attrs);
    $Mon{ndfpack_mon}->obeyw("wcsattrib", "ndf=$in mode=mset setting='$attrs'");
  }
}

