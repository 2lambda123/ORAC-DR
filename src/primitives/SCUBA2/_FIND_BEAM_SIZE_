#! -*-perl-*-

=head1 NAME

_FIND_BEAM_SIZE_ - Calculate the beam size from a calibrator

=head1 DESCRIPTION

This primitive carries out a fit to a calibrator to determine the beam
size and position angle. An error is generated if the source is not a
calibrator. The reported values are the full-width-at-half-maximum
(FWHM) along the major and minor axes, and the beam position angle on
the sky at the time of obseration. The fit is performed in the SKY
domain so the FWHM is returned in arcsec.

The default is to allow the current fitting routine to determine the
shape of the beam. A flag may be specified to force the return of the
equivalent gaussian beam parameters.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item GAUSSIAN

A flag to indicate whether the fit is forced to be gaussian. The
default is no.

=item LOGFILE

A flag to indicate whether a log file should be written containing the
results of the PSF fit. Default is true.

=item VERBOSE

Flag to indicate whether informational messages should be 
given to the user. Default is verbose (true).

=back

=head1 EXTERNAL TASKS

=over 4

=item KAPPA

WCSFRAME, WCSATTRIB

=item Other SCUBA-2 primitives

_FIND_POINT_SOURCES, _FIT_PSF_

=back

=head1 OUTPUT DATA

On completion, the primitive hash C<%_FIND_BEAM_SIZE_>
contains the following key:

=over 4

=item RESULTS

An array reference containing the beam major and minor axes and the
position angle (E of N).

=back

=head1 OUTPUT FILES

The following files are created (if necessary):

=over 4

=item C<log.beam>

Log of beam sizes.

=back

=head1 KNOWN ISSUES

Since the fit is currently carried out in the SKY domain, the reported
beam PA will rotate with the sky during the course of a single
night. The solution is to report the beam in the FPLANE coordinate
frame - the closest approximation is the PIXEL domain.

This method also only fits a single component to the beam. This is not
enough at 450 microns, but currently the beam is not sufficiently
well-known to do much more.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2005-2007 the University of British Columbia.  All
Rights Reserved.

=head1 TODO

=over 4

=item - Check source is a calibrator?

=item - Estimating contribution from error beam

=item - Decide the best coord frame for reporting beam PA

=item - Store results in Cal object?

=item - Retrieve CSO tau from Cal object?

=back

=cut

# First check that we only have one file in the Frame
my $in;
unless ($Frm->nfiles == 1) {
    orac_throw "Error: _FIND_BEAM_SIZE_ must be run after frames have been combined\n";
} else {
    $in = $Frm->file;
}

# Are we forcing a gaussian?
my $gaussian = (exists $_FIND_BEAM_SIZE_{GAUSSIAN} &&
		defined $_FIND_BEAM_SIZE_{GAUSSIAN}) ?
                $_FIND_BEAM_SIZE_{GAUSSIAN} : 0;

# Should I be verbose? (Default to yes)
my $verbose = (exists $_FIND_BEAM_SIZE_{VERBOSE} && 
	       defined $_FIND_BEAM_SIZE_{VERBOSE}) ?
               $_FIND_BEAM_SIZE_{VERBOSE} : 1;

# Are we writing an entry to a log file? Default Yes
my $uselog = ( exists $_FIND_BEAM_SIZE_{LOGFILE} && 
	       defined $_FIND_BEAM_SIZE_{LOGFILE}) ?
               $_FIND_BEAM_SIZE_{LOGFILE} : 1;

# Do we have a calibrator?
my $calib = $Cal->iscalsource($Frm->hdr('OBJECT')) ;
#orac_throw "Error: source is not a known calibrator \n" 
#  unless ($calib);

# Retrieve and store current domain (frame) so it can be reset on exit
my $origframe;
my $ORAC_STATUS;
$Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in name=domain mode=get");
( $ORAC_STATUS, $origframe ) = $Mon{ndfpack_mon}->get("wcsattrib", "value");

# Determine whether the WCS frame (domain) was supplied as an
# argument, else set it to the input frame.
my $wcsframe = (exists $_FIND_BEAM_SIZE_{WCSFRAME} && 
		defined $_FIND_BEAM_SIZE_{WCSFRAME} ) ? 
                uc($_FIND_BEAM_SIZE_{WCSFRAME}) : $origframe;

# Test whether or not given frame is valid.
unless ($wcsframe =~ /AXIS|PIXEL|GRID|SKY/) {
    orac_throw "Unknown WCS frame, $wcsframe ";
}

# Check whether older versions of kappa are being used.
if (starversion_lt('kappa','V0.14-0')) {
    $wcsframe = "AXIS" if ($wcsframe eq "SKY"); # No SKY frame in older kappa
}

# If we have a SKY frame, determine the WCS SYSTEM parameter.
my ($system, $origsystem);
if ( $wcsframe eq "SKY" ) {
  $system = (exists $_FIND_BEAM_SIZE_{SYSTEM} && 
	     defined $_FIND_BEAM_SIZE_{SYSTEM} ) ? 
	     uc($_FIND_BEAM_SIZE_{SYSTEM}) : "";

  # Retrieve and store current system so it can be reset on exit
  $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in name=system mode=get");
  ( $ORAC_STATUS, $origsystem ) = $Mon{ndfpack_mon}->get("wcsattrib", "value");
}

# Set the WCS frame to that desired if necessary
if ( $origframe ne $wcsframe ) {
  $Mon{ndfpack_mon}->obeyw("wcsframe", "ndf=$in frame=$wcsframe");
}

# Initialise the log file if necessary
my $beamlog;
if ($uselog) {
  my $time = gmtime();
  $beamlog = new ORAC::LogFile("log.beam");
  $beamlog->header("Beam log file - created on $time\n",
		   "#     Time       Filter    A       B       PA    Seeing  El   Tau225",
		   "----------------------------------------------------------------------"
            );
}

# Find the positions of all point sources in the image. Use current Frm.
_FIND_POINT_SOURCES_ DETECT_SIGMA=10

# Retrieve Astro::Catalog object from _FIND_BEAM_SIZE_
my $catalog = $_FIND_POINT_SOURCES_{CATALOGUE};

# What if there are no point sources?
if ( $catalog->sizeof == 0 ) {
  orac_throw "No point sources found in current image: unable to determine beam parameters\n";
}

# Parse DATE-OBS keyword
my @dateobs = split( /[-T:.]/, $Frm->hdr( 'DATE-OBS' ) );
# Create a DateTime object to allow coordinate conversions
my $dt = DateTime->new( year => $dateobs[0], month => $dateobs[1], 
			day => $dateobs[2], hour => $dateobs[3], 
			minute => $dateobs[4], second => $dateobs[5],
			nanosecond => $dateobs[6]*1e6, time_zone => 'UTC' );

# Create temporary file to write source position(s) in
my $cofile = new ORAC::TempFile;

# Loop over all sources in catalogue
use Astro::Telescope;
foreach my $source ( @{ $catalog->allstars }) {
  my $coords = $source->coords;
  # Set the telescope to JCMT
  $coords->telescope( new Astro::Telescope( 'JCMT' ) );

  # Register DateTime object
  $coords->datetime( $dt );

  # Print out Az and El of current source
#  print $coords->ra." ".$coords->dec. "\n";
  print { $cofile->handle } $coords->ra." ".$coords->dec. "\n";
}
$cofile->handle->close;

# Fit the source with a PSF
_FIT_PSF_ IMAGE=$in USELOG=1 COFILE=$cofile->file GAUSSIAN=$gaussian
my ($amp, $fwhm, $axisr, $gamma, $orient) = @{ $_FIT_PSF_{RESULTS} };

# Check that the fit gave sensible results
unless ( defined $fwhm && defined $axisr && defined $gamma ) {
  orac_throw "Error fitting PSF\n";
}

# Warn user if the fit looks bad
if ($axisr > 1.3333 || $axisr < 0.75) {
  orac_warn "Warning: Fit appears to be poor or beam highly elongated \n";
}

my $beama = $fwhm;
my $beamb = $fwhm * $axisr;

# Now subtract parallactic angle to get PA in AzEl frame
#$orient -= $coords->pa(format => 'deg');

# Store results
$_FIND_BEAM_SIZE_{RESULTS} = [$beama, $beamb, $orient];

# Register with $Cal object?

# Write a log file if required
if ($uselog) {
  my $num = $Frm->hdr('OBSNUM');
  my $time= sprintf "%12.3f", $Frm->hdr('ORACTIME');
  my $filt= sprintf "%4s", $Frm->hdr('FILTER');

  # Get TAU from the header - should get from $Cal object?
  my $cso = sprintf "%6.3f", 0.5*($Frm->hdr('WVMTAUST') + $Frm->hdr('WVMTAUEN'));

  # Elevation
  my $el = int ( 0.5 * ($Frm->hdr('ELSTART') + $Frm->hdr('ELEND') ) );
  # Seeing
  my $see = sprintf "%5.2f", ( 0.5 * ($Frm->hdr('SEEINGST') + $Frm->hdr('SEEINGEN') ) );
  # Reformat beam parameters for printing
  $beama = sprintf "%5.2f", $beama;
  $beamb = sprintf "%5.2f", $beamb;
  $orient = sprintf "%5.2f", $orient;

  # Write to logfile
  $beamlog->addentry("$num  $time  $filt    $beama   $beamb   $orient   $see   $el  $cso");

  orac_print "Beam size for filter 850: $beama x $beamb arcsec^2 at a PA of $orient deg E of N calculated from ".$catalog->sizeof." sources\n"
    if ($verbose);
}

# Return SYSTEM to original value if necessary
if ( $system ne "" ) {
  $Mon{ndfpack_mon}->obeyw("wcsattrib", "ndf=$in mode=set name=system newval=$origsystem");
}

# Return DOMAIN to original value if necessary
if ( $wcsframe ne $origframe ) {
  $Mon{ndfpack_mon}->obeyw("wcsframe", "ndf=$in frame=$origframe");
}
