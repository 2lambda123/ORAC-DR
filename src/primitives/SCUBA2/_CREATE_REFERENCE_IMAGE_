#! -*-perl-*-

=head1 NAME

_CREATE_REFERENCE_IMAGE_ - Create a 1x1 NDF aligned to a chosen Sky frame

=head1 SYNOPSIS

 _CREATE_REFERENCE_IMAGE FRAME=EQUATORIAL

=head1 DESCRIPTION

This primitive creates a 1x1 pixel NDF image to be used in aligning
and mosaicking individual DREAM/STARE images. The user has the option
of specifying the desired SKY frame. If none is specified then FK5
equatorial coordinates with a mean equinox J2000.0 is assumed.

The reference position and pixel scale is determined from the most
recent image added to the current Frame

This primitive is called only if a suitable reference image does not
already exist.

=head1 ARGUMENTS

=over 4

=item FRAME

The name of the chosen sky frame for the reference image. May be
almost any that AST knows about, i.e. ICRS, FK4, FK5, EQUATORIAL,
GAPPT or GALACTIC. Note: AZEL is not supported.

Default is ICRS (same as EQUATORIAL or FK5).

=item PIXEL_SCALE

The pixel scale for the reference image, in arcsec. It may also take
the special value 0 to indicate that the pixel scale should be derived
from the input image instead. If a value is given, the X and Y scales
are set equal. Leave unset to use the internal default values (3.09
arcsec at 450 um, 5.8 arcsec at 850 um).

=item VERBOSE

Flag to indicate whether informational messages should be given to the
user. Default is true.

=back

=head1 KNOWN ISSUES

Only ICRS (in its FK5, FK4 and EQUATORIAL guises), GAPPT and GALACTIC
coordinate systems are supported. Support for GAPPT needs to be more
thoroughly tested.

=head1 ALGORITHMS

Uses KAPPA CREFRAME, SETSKY and WCSATTRIB.

=head1

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2005-2007 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA

=cut

# Check for arguments...
# Should I be verbose? (default to yes)
my $verbose = (exists $_CREATE_REFERENCE_IMAGE_{VERBOSE} && 
	       defined $_CREATE_REFERENCE_IMAGE_{VERBOSE}) ?
	       $_CREATE_REFERENCE_IMAGE_{VERBOSE} : 1;

# Check for desired OUTPUT coordinate frame
my $cosys_out = (exists $_CREATE_REFERENCE_IMAGE_{FRAME} &&
		  defined $_CREATE_REFERENCE_IMAGE_{FRAME}) ?
                  uc($_CREATE_REFERENCE_IMAGE_{FRAME}) : "ICRS";

# Tell the user what's going on
orac_print "Creating reference image: " if $verbose;

# Create the blank 3x3 pixel reference NDF
my $refimage = $Frm->group."_ref";
my $imgargs = "lbound=\[1,1\] ubound=\[3,3\] mode=bl title=".$Frm->hdr('OBJECT');
$Mon{kappa_mon}->obeyw("creframe","out=$refimage ".$imgargs);
orac_print "create blank NDF, " if $verbose;

# Get first file in current Frame for WCS and FITS header info
my $datafile = $Frm->file(1);

# Calculate the pixel scale. Use default values if not set.
my $pixelscale = (exists $_CREATE_REFERENCE_IMAGE_{PIXEL_SCALE} &&
		  defined $_CREATE_REFERENCE_IMAGE_{PIXEL_SCALE}) ?
                  $_CREATE_REFERENCE_IMAGE_{PIXEL_SCALE} : $Cal->pixelscale;

# These should not be zero after this block...
my ($dx, $dy) = (0.0, 0.0);
if ( $pixelscale == 0 ) {
  _GET_PIXEL_SCALE_ IMAGE=$datafile DERIVE=0 UNITS=ARCSEC
  # Retrieve values in arcsec
  ($dx, $dy) = @{ $_GET_PIXEL_SCALE_{RESULTS}};
} else {
  # If we're not getting the pixel scale from the image, use the value
  # given and set the X and Y scales equal.
  $dx = $pixelscale;
  $dy = $dx;
}
# Check they're non-zero
if ( $dx == 0.0 || $dy == 0.0 ) {
  orac_err "Pixel scales still set to zero - something went very wrong\n";
}

# Get coords of reference pixel in current SKY coordinate system
my $args = "ndf=$datafile mode=get name=skyref";
$Mon{ndfpack_mon}->obeyw("wcsattrib","$args");
my ($ORAC_STATUS, $skyref) = $Mon{ndfpack_mon}->get("wcsattrib","value");
my ($xstr, $ystr) = split(/,/,$skyref,2);

# Get current INPUT coordinate system
$args = "ndf=$datafile mode=get name=system";
$Mon{ndfpack_mon}->obeyw("wcsattrib","$args");
($ORAC_STATUS, my $cosys_in) = $Mon{ndfpack_mon}->get("wcsattrib","value");

# Check that the OUTPUT coordinate system supported - use INPUT if not
# recognized
if ( ( $cosys_out ne "ICRS" ) && ( $cosys_out ne "GAPPT" ) 
     && ( $cosys_out ne "EQUATORIAL" ) && ( $cosys_out ne "GALACTIC" )
     && ( $cosys_out ne "FK5" ) && ( $cosys_out ne "FK4" ) ) {
  orac_warn "Warning: unsupported coordinate frame, $cosys_out. Using default (ICRS)\n";
  $cosys_out = $cosys_in;
}

# Get equinox
$args = "ndf=$datafile mode=get name=equinox";
$Mon{ndfpack_mon}->obeyw("wcsattrib","$args");
($ORAC_STATUS, my $equinox) = $Mon{ndfpack_mon}->get("wcsattrib","value");

# Epoch - for GAPPT retrieve from input data
my $epoch;
if ( $cosys_in eq "GAPPT" ) {
  $args = "ndf=$datafile mode=get name=epoch";
  $Mon{ndfpack_mon}->obeyw("wcsattrib","$args");
  ($ORAC_STATUS, $epoch) = $Mon{ndfpack_mon}->get("wcsattrib","value");
} else {
  # Else use equinox before redefining the equinox as a string
  $epoch = $equinox;
}

# Reformat equinox as suitable string for future use
if ( $equinox eq "2000.0" ) {
  $equinox = "J2000";
} elsif ( $equinox eq "1950.0" ) {
  $equinox = "B1950";
}

my ($x0, $y0);
# Create Astro::Coords object using information from sky frame in
# input data and then retrieve parameters in desired output frame.
use Astro::Coords;
my $coords; 
if ( $cosys_in eq "GALACTIC" ) {
  $coords = new Astro::Coords( long => $xstr, lat => $ystr,
			       units => 'deg', type => 'galactic' );
} else {
  $coords = new Astro::Coords( ra => $xstr, dec => $ystr, 
			       units => 'sex', type => $equinox );
}

# Now retrieve reference coordinates in desired output frame
if ( $cosys_out eq "GALACTIC" ) {
  # Retrieve coords in degrees: SETSKY uses degrees by default
  $x0 = $coords->glong( format => 'deg' );
  $y0 = $coords->glat( format => 'deg' );
} else {
  # Retrieve coords in radians
  $x0 = $coords->ra( format => 'rad' );
  $y0 = $coords->dec( format => 'rad' );

  # Convert to string and add units for SETSKY
  $x0 = $x0."r";
  $y0 = $y0."r";

  # Re-define output coordinate frame to be generically equatorial for
  # SETSKY but with appropriate equinox
  $cosys_out = "EQUATORIAL($equinox)";
}

# Add a WCS sky frame - forces pixel scale to match raw input data
orac_print "adding WCS " if $verbose;

# Define parameters of WCS. Pixelsize is in ARCSEC, lat and lon are as
# defined above.
# Note quoting around the pixelsize arguments
my $wcsargs = "coords=$cosys_out epoch=$epoch refcode=pixel pixelref=\[1.5,1.5\] pixelsize=\['".$dx."s', '".$dy."s'\] orient=0 positions=! projtype=gnom lon=".$x0." lat=".$y0;
$Mon{ndfpack_mon}->obeyw("setsky","ndf=$refimage $wcsargs");

# Now add a FITS header, copy from the first file in the Frm.
use Astro::FITS::Header::NDF;
my $fitshdr = new Astro::FITS::Header::NDF( File => $datafile );
$fitshdr->writehdr( File => $refimage );

# Store the SkyRef attribute in reference image
$args = "ndf=$refimage mode=set name=skyref newval='".$skyref."'";
$Mon{ndfpack_mon}->obeyw("wcsattrib","$args");

# And if necessary, set the SkyRefIs attribute
if ( $cosys_in eq "GAPPT" ) {
  $args = "ndf=$datafile mode=set name=skyrefis newval=origin";
  $Mon{ndfpack_mon}->obeyw("wcsattrib","$args");
}

# Store the reference image name in the RESULTS hash
$_CREATE_REFERENCE_IMAGE_{RESULTS} = $refimage;

# Register with the calibration object
$Cal->refimage( $Grp->name, $refimage );

orac_print "done. \nSuccessfully created reference image in coordinate system $cosys_out \n" if $verbose;
