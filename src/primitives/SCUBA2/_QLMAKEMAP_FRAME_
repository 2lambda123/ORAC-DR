# -*-cperl-*-

=head1 NAME

_QLMAKEMAP_FRAME_ - make a map as quickly as possible

=head1 SYNOPSIS

_QLMAKEMAP_FRAME_

=head1 DESCRIPTION

This primitive takes raw time-series data for the current Frame and
constructs an image as quickly as possible. This is achieved by
reducing the number of iterations and downsampling the data.

This is a many to one operation, with only a single output file
created.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<SYSTEM>

Coordinate system for output image. May be any supported by
B<AST>. Default is C<TRACKING>.

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item SMURF:

MAKEMAP

=item ORAC-DR PRIMITIVES

_GET_MAKEMAP_ARGS_, _GET_MAKEMAP_CONFIG_

=back

=head1 OUTPUT DATA

The Frame uhdr entries C<SKY_SUBTRACTION>, C<EXTINCTION> and
C<NEWIMAGE> are set to 1 on success.

=head1 OUTPUT FILES

Creates a single output file with a C<_fmos> suffix.

=head1 NOTES

The mean sky level is logged in C<log.sky>.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2006-2011 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

my @out;

# What checks should we carry out?

# Do not continue if this is not the QL pipeline
return ORAC__OK unless ($Frm->uhdr("QUICKLOOK"));

# Check for dark-only Frames and set a few uhdr flags so that
# subsequent primitives are skipped
if ($Frm->uhdr("DARKONLY")) {
  # Do not calibrate these data
  $Frm->uhdr("NOCALIB",1);
  # Set a flag to indicate a map was not made
  $Frm->uhdr("NEWIMAGE",0);
  # Force the sky subtraction and extinction flags to unity so that
  # these steps are not attempted on non-image data
  $Frm->uhdr("SKY_SUBTRACTION",1);
  $Frm->uhdr("EXTINCTION",1);
  return ORAC__OK;
}

my $system = uc(get_prim_arg( $_PRIM_ARGS_, "SYSTEM", "TRACKING"));

my (@infiles, @fastflats);
# Use all files in current Frame, except for POINTING and FOCUS
# observations where the instrument aperture is defined
if (($Frm->uhdr("ORAC_OBSERVATION_TYPE") =~ /point/i ||
     $Frm->uhdr("ORAC_OBSERVATION_TYPE") =~ /focus/i) &&
    defined $Frm->hdr("INSTAP") ) {

  my %allfiles = $Frm->get_files_by_subarray;
  my $instap = $Frm->instap_subarray;
  orac_print "Selecting files from subarray $instap only... ";
  my $infiles = $allfiles{$instap};
  if ($infiles) {
    @infiles = @{$infiles};
    my $origsub = $Frm->hdr("SUBARRAY");
    $Frm->hdr(SUBARRAY => $instap);
    push(@fastflats, $Cal->fastflat);
    $Frm->hdr(SUBARRAY => $origsub);
    orac_print "done\n";
  } else {
    orac_print "\n";
    orac_warn "Unable to retrieve data for the instrument aperture, $instap: using all data\n";
    @infiles = $Frm->files;
  }
} else {
  @infiles = $Frm->files;
}
if (@fastflats) {
  push(@infiles, @fastflats);
} else {
  _RETRIEVE_FASTFLATS_
  my $fastflats = $_RETRIEVE_FASTFLATS_{FASTFLATS};
  push(@infiles, @{$fastflats}) if ($fastflats);
}

# Quit processing if there is no data to make a map
my $object = $Frm->hdr("OBJECT");
my $obsnum = $Frm->hdr("OBSNUM");
my $subscan = $Frm->hdr("NSUBSCAN");
orac_term "No good data for $object from obs $obsnum / scan $subscan with which to make a map\n"
  unless (@infiles);

# Write list of filenames to a temp file
my $inlist = write_file_list( @infiles );

# Set output filename
my ($in, $out) = $Frm->inout("_fmos");
$out = $Frm->rewrite_outfile_subarray( $out );

# Define makemap argument list - mandatory arguments
_GET_MAKEMAP_CONFIG_
my $config = $_GET_MAKEMAP_CONFIG_{CONFIG};
my $args = "in=^$inlist out=$out config='^$config' ";

# Define the remaining arguments to makemap
my %makemapargs = ( method => "iterate" );
_GET_MAKEMAP_ARGS_ SYSTEM=$system
my %newmakemapargs = %{$_GET_MAKEMAP_ARGS_{ARGS}};
# Store these new arguments in the hash - existing entries will be
# overriden
foreach my $arg (keys %newmakemapargs) {
  $makemapargs{$arg} = $newmakemapargs{$arg};
}
$args .= join(" ", map { "$_=$makemapargs{$_}" } keys %makemapargs);

# Call makemap - really must have some sort of feedback to user
orac_print "Calling makemap using iterate method\n";

# Newimage will be used to determine if a new image was created by
# this primitive. Set an optimistic default.
my $newimage = 1;
# Error message text
my $msg;
my $fault_msg = "If this failure is not associated with a bad observation please file a fault\n";

my $nfiles = scalar(@infiles);
# Now create output map
orac_print "Making map from $nfiles input files\n";
my $SMURF_STATUS = $Mon{smurf_mon}->obeyw("makemap","$args");

# Check for SMF__NOMEM return status
if ( $SMURF_STATUS == ORAC__OK ) {
  # Check that an output file was actually created - in some
  # instances bad data can be dealt with by makemap which then exits
  # with good status and no output file.
  my $fullout = File::Spec->catfile($ENV{ORAC_DATA_OUT}, $out);
  $fullout .= ".sdf" unless ($fullout =~ /.sdf$/); # hack...
  if ( -e $fullout ) {
    # Register the new file name
    $Frm->files( $out );

    # Set the title to include the source name - add obs num if
    # running at the summit
    my $title = "'$object / $obsnum #$subscan'";
    $Mon{ndfpack_mon}->obeyw("settitle","ndf=$out title=$title");

    # Set Frame EXP_TIME and WEIGHTS flags
    $Frm->uhdr("EXP_TIME",1);
    $Frm->uhdr("WEIGHTS",1);
    # And of course sky subtraction and extinction correction have been
    # applied, though there really isn't much point to setting these
    # other than a desire for consistency.
    $Frm->uhdr("SKY_SUBTRACTION",1);
    $Frm->uhdr("EXTINCTION",1);

    # Mark current frame as good now that we have a map
    $Frm->isgood(1);

    # Set a flag to indicate a new map was made
    $newimage = 1;

    my $nbol = sprintf "%d", $Frm->hdr("NBOLOEFF");
    orac_print "Thank you for waiting: image $out created using $nbol bolometers\n";
    orac_warn "Map created from only $nbol bolometers: check map quality\n"
      if ($nbol < 100);
  } else {
    # Mark this frame as BAD. The only reason we would be here is
    # that the data are bad/corrupt.
    $Frm->isgood(0);
    $newimage = 0;
    $msg = "Makemap failed to create an output file (corrupt data): data from this Frame will be ignored.\n\n$fault_msg";
  }
} else {
  # OK we have bad exit status - check for known reasons
  if ( $SMURF_STATUS == 235176770 ) {
    # SMF__NOMEM: Memory allocation error
    $msg = "Output image will exceed maximum size 2 GB - will not continue\n";
  } elsif ( $SMURF_STATUS == 235176794 ) {
    # SMF__INSMP: insufficient samples for statistics
    $msg = "All data flagged bad: insufficient samples available for calculating statistics - will not continue\n";
  } elsif ( $SMURF_STATUS == 235176858 ) {
    # SMF__NOSCI: no science data found
    $msg = "No science data found: data from this Frame will be ignored\n";
  } else {
    # Everything else...
    $msg = "Makemap failed for an unknown reason: data from this Frame will be ignored\n$fault_msg";
  }
  $Frm->isgood(0);
  $newimage = 0;
}

# Set a flag to indicate whether or not a map was made
$Frm->uhdr("NEWIMAGE",$newimage);
# If no new image was created issue an error saying why
unless ($newimage) {
  $Frm->uhdr("NOCALIB",1);
  # Terminate the recipe unless we're processing the last member and
  # have more than one member in the group, in which case we still
  # want a Group file to be created if possible.
  my @members = $Grp->allmembers;
  if ($Grp->lastmember($Frm) && @members > 1) {
    orac_err $msg;
  } else {
    orac_termerr $msg;
  }
}

# Check the image to see if the target is covered by good pixels
_CHECK_IMAGE_FOR_TARGET_
