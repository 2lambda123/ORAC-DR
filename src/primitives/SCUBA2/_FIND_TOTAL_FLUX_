# -*-perl-*-

=head1 NAME

_FIND_TOTAL_FLUX_ - Determine the total flux of a source

=head1 SYNOPSIS

_FIND_TOTAL_FLUX_ USEPSF=1

=head1 DESCRIPTION

Finds the total flux of a source either by fitting a PSF or aperture
photometry.

The total flux can be determined by fitting a Sersic profile to the
source and integrating underneath that profile using a standard
integral solution. If the fit is poor (defined by the axis ratio
falling outside a pre-defined range) then the default aperture
photometry method is used instead.

This primitive is designed to work on a single image and will fail if
the current Frame object contains more than one file.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<LOGFILE>

A flag to indicate whether a log file should be written containing
the results of the integrated intensity calculation. Default is
true.

=item B<USEPSF>

A flag to indicate whether to calculate the source flux from either a
fit the source using the Kappa PSF function or using an aperture
photometry method. Default is to use aperture photometry (USEPSF = 0).

=item B<VERBOSE>

Flag to indicate whether informational messages should be 
given to the user. Default is true.

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA:

WCSFRAME

=item ORAC-DR PRIMITIVES:

_FIND_BRIGHTEST_SOURCE_, _FIND_INTEGRATED_INTENSITY_, _FIT_PSF_,
_GET_PIXEL_SCALE_

=back

=head1 OUTPUT DATA

On completion, the primitive hash C<%_FIND_TOTAL_FLUX_>
contains the following keys:

=over 4

=item RESULTS

The total flux for brightest source in the current Frame. Contains
C<undef> if the calculation did not complete sucessfully.

=back

=head1 OUTPUT FILES

The following file is created:

=over 4

=item C<log.flux>

Log of flux values.

=back

The Frame object is not updated.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>, 
Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2005 Particle Physics and Astronomy Research Council and
the University of British Columbia.  All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# First check that we only have one file in the Frame
unless ($Frm->nfiles == 1) {
    orac_throw "Error: _FIND_TOTAL_FLUX_ must be run after frames have been combined\n";
}

# Also should check that this has been run after calibration?

# Define useful constants, Radians to arcsec and pi
use constant RAD2ASEC => 206265.0;
use constant PI => 3.1415926535;

# Write logfile (default to true)
my $uselog = get_prim_arg( $_PRIM_ARGS, "LOGFILE", 1 );

# Should I be verbose? (Default to yes)
my $verbose = get_prim_arg( $_PRIM_ARGS, "VERBOSE", 1 );

# Initialize the results array
$_FIND_TOTAL_FLUX_{RESULTS} = [];

# Check the desired flux calculation method.
my $usepsf = get_prim_arg( $_PRIM_ARGS, "USEPSF", 0 );

# Initialise the log file if necessary
my $log;
if ($uselog) {
  $log = new ORAC::LogFile("log.flux");
  my $time = gmtime();
  $log->header("Flux log file - created on $time",
               "\n#     Time   Filter        TotalFlux    CSO   El",
             "----------------------------------------------------------"
            );
}

# Find the brightest source in the frame
# Use SKY frame to get source position in RA, Dec
my $wcsframe = "sky";
_FIND_BRIGHTEST_SOURCE_ LOGFILE=0 WCSFRAME=$wcsframe

# Find the input file
my $in = $Frm->file(1);
# Set the desired WCS frame
$Mon{ndfpack_mon}->obeyw("wcsframe","ndf=$in frame=$wcsframe");

# We now run PSF if possible else simply use the peak position from
# centroiding
my $totalflux = undef;
if (starversion_lt('kappa', 'V0.15-0')) {
  # warn
  orac_warn "Your kappa version is too old to use PSF properly. Using stats to find total flux\n";
  # Resort to stats method
  _FIND_INTEGRATED_INTENSITY_ VERBOSE=0 LOGFILE=0;
  $totalflux = $_FIND_INTEGRATED_INTENSITY_{RESULTS} ;
} else {

  # Create temporary file with the position in
  my $tmp = new ORAC::TempFile;
  my $cofile = $tmp->file;
  print { $tmp->handle } $_FIND_BRIGHTEST_SOURCE_{RESULTS}->[0]," ",
                         $_FIND_BRIGHTEST_SOURCE_{RESULTS}->[1], "\n";
  $tmp->handle->close;

  my $ORAC_STATUS;
  if ($usepsf) {

    _FIT_PSF_ IMAGE=$in USELOG=1 COFILE=$cofile
    $totalflux = $_FIT_PSF_{TOTALFLUX};

    # Check the axis ratio
    if ($axisr > 1.4 || $axisr < 0.75) {
      orac_warn "Axis ratio of source out of specification (was $axisr). Ignoring fit.\n";
      # Use stats instead
      orac_warn "Using aperture photometry at centroid position for $in instead.\n";
      $usepsf = 0;
      # Call _FIND_INTEGRATED_INTENSITY_ primitive on the current image
      _FIND_INTEGRATED_INTENSITY_ VERBOSE=0 LOGFILE=0;
      $totalflux = $_FIND_INTEGRATED_INTENSITY_{RESULTS}->[1] ;
    }
    
  } else {
    # Use an aperture photometry method
    _FIND_INTEGRATED_INTENSITY_ VERBOSE=0 LOGFILE=0;
    $totalflux = $_FIND_INTEGRATED_INTENSITY_{RESULTS}->[1] ;
  }
}

# Determine Pixel scale - returned in radians but convert to sq arcsec
_GET_PIXEL_SCALE_ IMAGE=$in
my $xscale = RAD2ASEC * $_GET_PIXEL_SCALE_{RESULTS}->[0];
my $yscale = RAD2ASEC * $_GET_PIXEL_SCALE_{RESULTS}->[1];
my $pixelarea = $xscale*$yscale;

# Allow for beam or pixel size - wcsframe must be SKY!
my $fluxcorr; # Flux correction
#my $units = $Frm->hdr('UNITS');
my $units = "Jy/beam";
if ($units =~ /beam/) {
  # Retrieve beam dimensions
  my $fwhm = $Cal->fwhm;
  my $beamarea = PI * $fwhm * $fwhm / 4.0; # sq arcsec
  $fluxcorr = ($usepsf) ? $beamarea : $beamarea/$pixelarea ;
} elsif ($units =~ /arcsec/) {
  $fluxcorr = ($usepsf) ? 1.0 : 1.0/$pixelarea;
} elsif ($units =~ /V/) { # V is effectively V/pixel
  $fluxcorr = ($usepsf) ? $pixelarea : 1.0;
} else {
  orac_throw "Error: unknown units, $units \n";
}

# Units of flux density are Jy or V
my $fluxunits;
if ($units =~ /Jy/) {
  $fluxunits = 'Jy';
} elsif ($units =~ /V/) {
  $fluxunits = 'V';
} else {
  orac_throw "Error: unknown units, $units \n";
}

$totalflux = $totalflux / $fluxcorr;

# Store the result in the hash
$_FIND_TOTAL_FLUX_{RESULTS} = $totalflux;

# Write a log file if required
if ($uselog) {

  my $num = sprintf "%-4d", $Frm->number;
  my $time= sprintf "%12.3f", $Frm->hdr('ORACTIME');
  my $filt= sprintf "%4s", $Frm->hdr('FILTER');

  # Format nicely for printing to log
  $totalflux = sprintf "%10.4f", $totalflux;

  # Tau
  my $cso = sprintf "%5.2f", 0.5*($Frm->hdr('WVMTAUST') + $Frm->hdr('WVMTAUEN'));

  # elevation
  my $el = int ( 0.5 * ($Frm->hdr('ELDST') + $Frm->hdr('ELDEN') ) );

  # Write the entry
  $log->addentry("$num $time $filt $totalflux  $cso $el " . $Frm->hdr('OBJECT'));
}

if (defined $totalflux) {

  my $method = ($usepsf) ? "fitting PSF" : "integrating in aperture";
  orac_print "Total flux for filter 850: $totalflux $fluxunits estimated from $method \n"
    if $verbose;

  orac_print "Calculated total signal from map\n" if $verbose;
} else {
  orac_print "Error: unable to calculate flux from image" if $verbose;
}

