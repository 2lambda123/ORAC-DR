# -*-perl-*-

=head1 NAME

_FIND_TOTAL_FLUX_ - Determine the total flux of a source

=head1 DESCRIPTION

Finds the total flux of a source either by fitting or aperture
photometry.

The total flux can be determined by fitting a Sersic profile to the
source and integrating underneath that profile using a standard
integral solution. If the fit is poor (defined by the axis ratio
falling outside a pre-defined range) then the default aperture
photometry method is used instead.

Note that the C<Math::Gsl> module must be installed for the PSF
integrator.

This primitive is designed to work on a single image and will fail if
the current Frame object contains more than one file.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item USEPSF

A flag to indicate whether to calculate the source flux from either a
fit the source using the Kappa PSF function or using an aperture
photometry method. Default is to use aperture photometry (USEPSF = 0).

=item LOGFILE

A flag to indicate whether a log file should be written containing
the results of the integrated intensity calculation. Default is
true.

=item VERBOSE

Flag to indicate whether informational messages should be 
given to the user. Default is verbose (true).

=back

=head1 EXTERNAL TASKS

=over 4

=item KAPPA

PSF, WCSFRAME

=item Other SCUBA-2 primitives

_FIND_INTEGRATED_INTENSITY_, _FIND_BRIGHTEST_SOURCE_

=back

=head1 OUTPUT DATA

On completion, the primitive hash C<%_FIND_TOTAL_FLUX_>
contains the following keys:

=over 4

=item RESULTS

The total flux for the current Frame. Contains C<undef> if the
calculation did not complete sucessfully.

=back

=head1 OUTPUT FILES

The following files are created:

=over 4

=item C<log.flux>

Log of flux values.

=back

The frame object is not updated.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt> and 
Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2005 Particle Physics and Astronomy Research Council and
the University of British Columbia.
All Rights Reserved.

=cut

# First check that we only have one file in the Frame
unless ($Frm->nfiles == 1) {
    orac_throw "Error: _FIND_TOTAL_FLUX_ must be run after frames have been combined\n";
#    exit;
}

# Write logfile (default to true)
my $uselog = (exists $_FIND_TOTAL_FLUX_{LOGFILE} &&
          defined $_FIND_TOTAL_FLUX_{LOGFILE}) ?
  $_FIND_TOTAL_FLUX_{LOGFILE} : 1;

# Should I be verbose (default to yes)
my $verbose = (exists $_FIND_TOTAL_FLUX_{VERBOSE} && 
	       defined $_FIND_TOTAL_FLUX_{VERBOSE}) ?
  $_FIND_TOTAL_FLUX_{VERBOSE} : 1;

# initialise the results array
$_FIND_TOTAL_FLUX_{RESULTS} = [];

# Check the desired flux calculation method.
my $usepsf = (exists $_FIND_TOTAL_FLUX_{USEPSF} &&
	      defined $_FIND_TOTAL_FLUX_{USEPSF}) ?
    $_FIND_TOTAL_FLUX_{USEPSF} : 0;

# Initialise the log file if necessary
my $log;
if ($uselog) {
  $log = new ORAC::LogFile("log.flux");
  my $time = gmtime();
  $log->header("Flux log file - created on $time",
               "\n#     Time   Filter        TotalFlux    CSO   El",
             "----------------------------------------------------------"
            );

}

# Find the brightest source in the frame
_FIND_BRIGHTEST_SOURCE_ LOGFILE=0 WCSFRAME=grid

# Find the input file
my $in = $Frm->file(1);

# We now run PSF if possible else simply use the peak position from
# centroiding
my $totalflux;
if (starversion_lt('kappa', 'V0.15-0')) {
    # warn
    orac_warn "Your kappa version is too old to use PSF properly. Using stats to find total flux\n";
    # Resort to stats method
    _FIND_INTEGRATED_INTENSITY_ VERBOSE=0 LOGFILE=0;
    $totalflux = $_FIND_INTEGRATED_INTENSITY_{RESULTS} ;

} else {
    # Need to make sure we are using a AXIS coordinate frame
#    $Mon{ndfpack_mon}->obeyw("wcsframe","ndf=$in frame=axis");
    $Mon{ndfpack_mon}->obeyw("wcsframe","ndf=$in frame=pixel");

    # Create temporary file with the position in
    my $tmp = new ORAC::TempFile;
    my $tmpfile = $tmp->file;
    print { $tmp->handle } $_FIND_BRIGHTEST_SOURCE_{RESULTS}->[0]," ",
       $_FIND_BRIGHTEST_SOURCE_{RESULTS}->[1], "\n";
    $tmp->handle->close;

    my $ORAC_STATUS;
    if ($usepsf) {

	my $args = "incat=! device=! cofile=$tmpfile";

	# Run PSF
	$Mon{kappa_mon}->obeyw("psf","norm=no range=4 isize=15 in=$in $args");

	# Retrieve the answer
	( $ORAC_STATUS, my $amp)  = $Mon{kappa_mon}->get("psf","amp1");
	( $ORAC_STATUS, my $axisr) = $Mon{kappa_mon}->get("psf","axisr");
	( $ORAC_STATUS, my $fwhm) = $Mon{kappa_mon}->get("psf","fwhm");
	( $ORAC_STATUS, my $gamma) = $Mon{kappa_mon}->get("psf","gamma");

	# Find the integrated intensity under the fitted PSF, given these parameters
	# The units will be in ...

	# Check the axis ratio
	if ($axisr > 1.4 || $axisr < 0.75) {
	    orac_warn "Axis ratio of source out of specification (was $axisr). Ignoring fit.\n";
	    # Use stats instead
	    orac_warn "Using aperture photometry at centroid position for $in instead.\n";
	    # Call _FIND_INTEGRATED_INTENSITY_ primitive on the current image
	    _FIND_INTEGRATED_INTENSITY_ VERBOSE=0 LOGFILE=0;
	    $totalflux = $_FIND_INTEGRATED_INTENSITY_{RESULTS} ;
	} else {
	    # integrate_profile or Something::Sersic->integrate_profile;
	    $totalflux = integrate_profile($amp, $fwhm, $axisr, $gamma, 2);
	}

    } else {
	# Use an aperture photmetry method
	_FIND_INTEGRATED_INTENSITY_  VERBOSE=0 LOGFILE=0;
	$totalflux = $_FIND_INTEGRATED_INTENSITY_{RESULTS} ;
    }
}

# Store the result in the hash
$_FIND_TOTAL_FLUX_{RESULTS} = $totalflux;

# Write a log file if required
if ($uselog) {

    my $num = sprintf "%-4d", $Frm->number;
    my $time= sprintf "%12.3f", $Frm->hdr('ORACTIME');
    my $filt= sprintf "%4s",   "850";
    $totalflux = sprintf "%9.2f", $totalflux;

    # Get the tau from calibration object
#    my $tau = sprintf "%5.2f", $Cal->tau($filters[$i-1]);

    # Use that tau to calculate CSO
#    my ($cso, $status) = JCMT::Tau::get_tau('CSO',$filters[$i-1], $tau);
#    if ($status != 0) {
#      $cso = "*****";
#    } else {
#      $cso = sprintf "%5.2f", $cso;
#    }
    my $cso = sprintf "%5.2f", "1.0";

    # elevation
    my $el = int (($Frm->hdr('STRT_ELD') + $Frm->hdr('END_ELD') ) /2.0 );

    # Write the entry
    $log->addentry("$num $time $filt $totalflux  $cso $el " . $Frm->hdr('OBJECT'));

}

orac_print "Total flux for filter 850: $totalflux\n"
    if $verbose;

orac_print "Calculated total signal from map\n" if $verbose;

