# -*-cperl-*-

=head1 NAME

_SCUBA2_SETUP_ - make SCUBA-2 infrastructure available to PICARD

=head1 SYNOPSIS

_SCUBA2_SETUP_

=head1 DESCRIPTION

Sets up a few useful user-header entries for dealing with SCUBA-2 data.

=head1 ARGUMENTS

This primitive has no arguments.

=head1 EXTERNAL TASKS

The following external task is used:

=over 4

=item KAPPA

NDFTRACE

=back

=head1 NOTES

Since the first file is used to set the current units, and downstream
decisions may be made based on those units, passing in a mix of
calibrated and uncalibrated data is likely to lead to strange results
and is not recommended.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2009 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Use a SCUBA2 calibration object
use ORAC::Core qw/ orac_calib_override /;
use ORAC::Calib::SCUBA2;

# For Picard, the observation has always ended :-)
$Frm->uhdr("OBSEND",1);

# And there's always a new image
$Frm->uhdr("NEWIMAGE",1);

# Get the current units so we quote the calibration factor - assume
# that all input data have the same units, so pick the first file in
# the Frame and use that as a template.
my $in = $Frm->file(1);
$Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
my ($ORAC_STATUS, $dataunits) = $Mon{ndfpack_mon}->get("ndftrace","units");
$Frm->uhdr("DATA_UNITS", $dataunits);

# Check the units to see if the data need calibrating. For example,
# NEFDs can only be calculated for calibrated data.
if ( $Frm->uhdr("DATA_UNITS") eq "pW") {
  $Frm->uhdr("NOCALIB", 0);
} else {
  $Frm->uhdr("NOCALIB", 1);
}

# For the purposes of Picard, say that sky subtraction has been done
# so background-subtracted images have the suffix _back
$Frm->uhdr("SKY_SUBTRACTION", 1);

# Tell user how many files we're processing
my $nfiles = $Frm->nfiles;
my $files = ($nfiles == 1) ? "file" : "files";
orac_print "Processing $nfiles $files...\n";

# Recipe parameters
ORAC::Recipe::Parameters::verify_parameters( \%RECPARS, ['APERTURE_RADIUS',
							 'FLUX_850',
							 'FLUX_450',
							 'MAP_WIDTH',
							 'MAP_HEIGHT',
							 'LOGFILE',
							 'USEFCF',
							 'BACKGROUND_MASK',
							 'NEFD_CFP',
							 'FINDBACK_BOX',
							 'DISPLAY',
							 'PSF_MATCHFILTER',
							 'PSF_NORM',
							 'FITSURFACE_FITTYPE',
							 'FITSURFACE_FITPAR',
							 'VERBOSE'] );

# Allow a VERBOSE flag to get extra info printed to screen
if ( defined $RECPARS{'VERBOSE'} ) {
  $Frm->uhdr("RECPAR_VERBOSE", $RECPARS{VERBOSE});
}

# Does the user want to use the FCF derived in the recipe?
if ( defined $RECPARS{'USEFCF'} ) {
  $Frm->uhdr("RECPAR_USEFCF", $RECPARS{USEFCF});
}

# Flag to denote whether to collect info to write to a log file
if ( defined $RECPARS{'LOGFILE'} ) {
  $Frm->uhdr("RECPAR_LOGFILE", $RECPARS{LOGFILE});

  # If LOGFILE has been specified, start off by storing the original
  # file names for later retrieval
  if ($Frm->uhdr("RECPAR_LOGFILE")) {
    # Store name of log file
    my @picard_results;
    for my $i ( 1 .. $Frm->nfiles ) {
      $picard_results[$i-1] = { file => $Frm->file($i) };
    }
    $Frm->uhdr("PICARD_RESULTS",\@picard_results);
  }
}

# Radius of aperture for masking/photometry
if ( defined $RECPARS{'APERTURE_RADIUS'} ) {
  $Frm->uhdr("RECPAR_APERTURE_RADIUS", $RECPARS{APERTURE_RADIUS});
}

# Do we want to write the CfP NEFD to a log file?
if ( defined $RECPARS{'NEFD_CFP'} ) {
  $Frm->uhdr("RECPAR_NEFD_CFP", $RECPARS{'NEFD_CFP'});
}

# Parameters for background removal
# Does the user want to remove a background by masking out the source?
if ( defined $RECPARS{'BACKGROUND_MASK'} ) {
  $Frm->uhdr("RECPAR_BACKGROUND_MASK", $RECPARS{BACKGROUND_MASK});
}
# Size of box for findback
if ( defined $RECPARS{'FINDBACK_BOX'} ) {
  $Frm->uhdr("RECPAR_FINDBACK_BOX", $RECPARS{'FINDBACK_BOX'});
}
# Fitsurface - fittype and parameters
if ( defined $RECPARS{'FITSURFACE_FITTYPE'} ) {
  $Frm->uhdr("RECPAR_FITSURFACE_FITTYPE", lc($RECPARS{'FITSURFACE_FITTYPE'}));
}
if ( defined $RECPARS{'FITSURFACE_FITPAR'} ) {
  # Store the fit parameters in an array
  my @fitpar;
  if (ref($RECPARS{'FITSURFACE_FITPAR'}) eq "ARRAY") {
    @fitpar = @{$RECPARS{'FITSURFACE_FITPAR'}};
  } else {
    @fitpar = ($RECPARS{'FITSURFACE_FITPAR'}, $RECPARS{'FITSURFACE_FITPAR'});
  }
  $Frm->uhdr("RECPAR_FITSURFACE_FITPAR", \@fitpar);
}

# Source fluxes at 850/450 um.
if ( defined $RECPARS{'FLUX_850'} ) {
  $Frm->uhdr("RECPAR_FLUX_850", $RECPARS{FLUX_850});
}
if ( defined $RECPARS{'FLUX_450'} ) {
  $Frm->uhdr("RECPAR_FLUX_450", $RECPARS{FLUX_450});
}

# New map width and height
if ( defined $RECPARS{'MAP_WIDTH'} ) {
  $Frm->uhdr("RECPAR_MAP_WIDTH", $RECPARS{MAP_WIDTH});
}
if ( defined $RECPARS{'MAP_HEIGHT'} ) {
  $Frm->uhdr("RECPAR_MAP_HEIGHT", $RECPARS{MAP_HEIGHT});
}

# Flag to denote whether or not to display data
if ( defined $RECPARS{'DISPLAY'} ) {
  $Frm->uhdr("RECPAR_DISPLAY", $RECPARS{DISPLAY});
}

# Name of PSF file in current directory for matched filter
if ( defined $RECPARS{'PSF_MATCHFILTER'} ) {
  $Frm->uhdr("RECPAR_PSF_MATCHFILTER", $RECPARS{PSF_MATCHFILTER});
}
# Name of PSF normalization scheme (must be peak or sum)
if ( defined $RECPARS{'PSF_NORM'} ) {
  $Frm->uhdr("RECPAR_PSF_NORM", $RECPARS{PSF_NORM});
}
