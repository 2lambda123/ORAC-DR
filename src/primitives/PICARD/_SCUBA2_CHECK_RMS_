# -*-cperl-*-

=head1 NAME

_SCUBA2_CHECK_RMS_ - determine RMS and NEFD from SCUBA-2 files

=head1 SYNOPSIS

_SCUBA2_CHECK_RMS_

=head1 DESCRIPTION

This PICARD primitive determines the RMS and NEFD for a given SCUBA-2
image and calculates corresponding values from the integration tiem
calculator (ITC). It also calculates values based on the average NEP
as determined from the quick-look pipeline logfile.

Results are written to a log file, C<log.checkrms>.

=head1 ARGUMENTS

This primitive has no arguments.

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item ORAC-DR primitives:

SCUBA2: _CALCULATE_NEFD_, _COMPONENT_EXISTS_, _FIND_IMAGE_STATISTICS_

=back

=head1 NOTES

None.

=head1 OUTPUT DATA

None.

=head1 OUTPUT FILES

None.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2013 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

orac_print "\nCalling _SCUBA2_CHECK_RMS_: determine RMS and NEFD from map and ITC\n", "yellow";

# Required modules
use DateTime::Format::ISO8601;
use JCMT::Tau::SCUBA2;

# A few things to sort out ahead of time
my $dt_obs = DateTime::Format::ISO8601->parse_datetime($Frm->hdr("DATE-OBS"));
my $dt_end = DateTime::Format::ISO8601->parse_datetime($Frm->hdr("DATE-END"));
my $t_elapsed = $dt_end->epoch - $dt_obs->epoch;
my $wave = ($Frm->hdr("FILTER") =~ /850/) ? "850" : "450";

# Calculate average transmission during observation
my ($tauzen_st, $status) = JCMT::Tau::SCUBA2::get_tau($wave, 'CSO',
						      $Frm->hdr("WVMTAUST"));
my $tau_st = $Frm->hdr("AMSTART") * $tauzen_st;

(my $tauzen_en, $status) = JCMT::Tau::SCUBA2::get_tau($wave, 'CSO',
						      $Frm->hdr("WVMTAUEN"));
my $tau_en = $Frm->hdr("AMEND") * $tauzen_en;
my $trans = exp(-0.5 * ($tau_st + $tau_en));
my $meantauzen = 0.5 * ($tauzen_st + $tauzen_en);
my $el = 0.5 * ($Frm->hdr("ELSTART") + $Frm->hdr("ELEND"));

# Determine mean exposure time
my $comp = "more.smurf.exp_time";
my $texp = "NaN";
_COMPONENT_EXISTS_ COMPONENT=$comp FILE=$Frm->file
if ($_COMPONENT_EXISTS_{EXISTS}) {
  my $texp_image = $Frm->file . ".more.smurf.exp_time";
  _FIND_IMAGE_STATISTICS_ IMAGE=$texp_image VERBOSE=0
  $texp = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MEAN};
}

# Estimator for noise and NEFD
my $estimator = (defined $Frm->uhdr("RECPAR_STATS_ESTIMATOR"))
  ? $Frm->uhdr("RECPAR_STATS_ESTIMATOR") : "MEDIAN";

# Determine "f" from the pixel scale and wavelength
_GET_PIXEL_SCALE_ IMAGE=$Frm->file VERBOSE=0
my $pixscale = $_GET_PIXEL_SCALE_{PIXSCALE};
my $defpixarea = ($wave == 850) ? 16 : 4;
my $f = $_GET_PIXEL_SCALE_{AREA} / $defpixarea;

# Code ref to check for bad values
my $check_good = sub {
  my $val = shift;
  my $val_type = shift;
  if ($val == &NDF::VAL__BADD()) {
    orac_warn "$val_type is bad - setting to NaN\n";
    $val = "NaN";
  }
  return $val;
};

# Determine RMS and NEFD from map
my $nefd_map = "NaN";
$comp = "more.smurf.nefd";
_COMPONENT_EXISTS_ COMPONENT=$comp FILE=$Frm->file
if ($_COMPONENT_EXISTS_{EXISTS}) {
  my $nefdimage = $Frm->file . ".more.smurf.nefd";
  _FIND_IMAGE_STATISTICS_ IMAGE=$nefdimage VERBOSE=0
  $nefd_map = $_FIND_IMAGE_STATISTICS_{RESULTS}->{$estimator};
} else {
  _CALCULATE_NEFD_ GROUP=0 LOGFILE=0 ESTIMATOR=$estimator
  $nefd_map = $_CALCULATE_NEFD_{NEFD};
}
$nefd_map = $check_good->($nefd_map, "NEFD_map");

_FIND_IMAGE_STATISTICS_ IMAGE=$Frm->file COMP=ERR VERBOSE=0
my $rms_map = $_FIND_IMAGE_STATISTICS_{RESULTS}->{$estimator};
$rms_map = $check_good->($rms_map, "RMS_map");

# Determine RMS and NEFD from ITC
use Astro::ITC::SCUBA2 qw/calcrms exposure_time_fraction/;
# Determine ITC observation type from map size and scan pattern
my $scan_pat = lc($Frm->hdr("SCAN_PAT"));
my $itc_obstype;
if ($scan_pat =~ /pong/) {
  $itc_obstype = "Pong".int($Frm->hdr("MAP_WDTH"));
  unless (grep {$_ eq $itc_obstype} @Astro::ITC::SCUBA2::obsmodes) {
    orac_warn "Pong type $itc_obstype not known to ITC - some results will be undefined\n";
  }
} elsif ($scan_pat =~ /daisy/) {
  $itc_obstype = "Daisy";
}

my $texp_frac = exposure_time_fraction($itc_obstype, $wave);
my $telapsed_eff = (defined $texp_frac) ? $texp_frac * $t_elapsed : 0;
my $rms_itc = calcrms( $itc_obstype, $wave, $trans, $f, $t_elapsed );
my $nefd_itc = "NaN";
my $rms_ratio = "NaN";
if (defined $rms_itc) {
  $nefd_itc = $rms_itc * sqrt($telapsed_eff);
  $rms_ratio = $rms_map / $rms_itc if ($rms_itc > 0);
}

# Retrieve NEP from earlier calculation
my $nep_av = (defined $Frm->uhdr("NEP_AV")) ? $Frm->uhdr("NEP_AV") : "NaN";
my $nep_av_err = (defined $Frm->uhdr("NEP_AV_ERR")) ? $Frm->uhdr("NEP_AV_ERR") : "NaN";

# Determine RMS and NEFD from NEP: remember the factor of 10**12 to
# convert to pW
my $fcf = (defined $Frm->hdr("FCF")) ? $Frm->hdr("FCF") :
  $Cal->gain($wave, "BEAM");
my $nefd_nep = 1.0e12 * $nep_av * $fcf / $trans;
my $rms_nep = ($telapsed_eff > 0) ? $nefd_nep / sqrt($telapsed_eff) : "NaN";

# Show results
my $logfile = ORAC::LogFile->new("log.checkrms");
my @keys = qw/UT Source Obs Filter telapsed texp trans nep_av nep_av_err rms_nep nefd_nep rms_map nefd_map rms_itc nefd_itc itc_obstype rms_ratio El Tau Radius pixscale f project/;
$logfile->header("# CHECK_RMS log file - created on ".gmtime(),
		 "# ".join(" ",@keys));

my $object = uc($Frm->hdr("OBJECT"));
$object =~ s/\s+/_/g;
my $map_radius = (defined $Frm->uhdr("RECPAR_MAP_RADIUS"))
  ? $Frm->uhdr("RECPAR_MAP_RADIUS") : 90;

my $entry = join("  ", $Frm->hdr('ORACTIME'), $object, $Frm->hdr("OBSNUM"), $wave,
		 (sprintf "%.1f", $t_elapsed), (sprintf "%.2f", $texp),
		 (sprintf "%.2f", $trans),
		 (sprintf "%.2e", $nep_av), (sprintf "%.2e", $nep_av_err),
		 (sprintf "%.2e", $rms_nep), (sprintf "%.2e", $nefd_nep),
		 (sprintf "%.1f", $rms_map), (sprintf "%.1f", $nefd_map),
		 (sprintf "%.1f", $rms_itc), (sprintf "%.1f", $nefd_itc),
		 $itc_obstype, (sprintf "%.2f", $rms_ratio),
		 (sprintf "%.1f", $el), (sprintf "%.3f", $meantauzen),
		 $map_radius, (sprintf "%.1f", $_GET_PIXEL_SCALE_{PIXSCALE}), $f,
		 $Frm->hdr("PROJECT")
		);

orac_print "Writing results in log.checkrms...\n";
$logfile->addentry($entry);
