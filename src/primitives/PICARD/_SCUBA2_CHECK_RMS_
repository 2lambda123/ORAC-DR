# -*-cperl-*-

=head1 NAME

_SCUBA2_CHECK_RMS_ - determine RMS and NEFD from SCUBA-2 files

=head1 SYNOPSIS

_SCUBA2_CHECK_RMS_

=head1 DESCRIPTION

This PICARD primitive determines the RMS and NEFD for a given SCUBA-2
image and calculates corresponding values from the integration tiem
calculator (ITC). It also calculates values based on the average NEP
as determined from the quick-look pipeline logfile.

Results are written to a log file, C<log.checkrms>.

=head1 ARGUMENTS

This primitive has no arguments.

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item ORAC-DR primitives:

SCUBA2: _CALCULATE_NEFD_, _COMPONENT_EXISTS_, _FIND_IMAGE_STATISTICS_

=back

=head1 NOTES

None.

=head1 OUTPUT DATA

None.

=head1 OUTPUT FILES

None.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2013 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

orac_print "\nCalling _SCUBA2_CHECK_RMS_: determine RMS and NEFD from map and ITC\n", "yellow";

# Required modules
use DateTime::Format::ISO8601;
use JCMT::Tau::SCUBA2;

# A few things to sort out ahead of time
my $dt_obs = DateTime::Format::ISO8601->parse_datetime($Frm->hdr("DATE-OBS"));
my $dt_end = DateTime::Format::ISO8601->parse_datetime($Frm->hdr("DATE-END"));
my $t_elapsed = $dt_end->epoch - $dt_obs->epoch;
my $wave = ($Frm->hdr("FILTER") =~ /850/) ? "850" : "450";

# Calculate average transmission during observation
my $airmass = 0.5 * ($Frm->hdr("AMSTART") + $Frm->hdr("AMEND"));
my $tau = 0.5 * ($Frm->hdr("WVMTAUST") + $Frm->hdr("WVMTAUEN"));
my ($tauval, $status) = JCMT::Tau::SCUBA2::get_tau($wave, 'CSO', $tau);
my $trans = exp(-$airmass * $tauval);

# Determine mean exposure time
my $comp = "more.smurf.exp_time";
my $texp = "NaN";
_COMPONENT_EXISTS_ COMPONENT=$comp FILE=$Frm->file
if ($_COMPONENT_EXISTS_{EXISTS}) {
  my $texp_image = $Frm->file . ".more.smurf.exp_time";
  _FIND_IMAGE_STATISTICS_ IMAGE=$texp_image VERBOSE=0
  $texp = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MEAN};
}

# Estimator for noise and NEFD
my $estimator = (defined $Frm->uhdr("RECPAR_STATS_ESTIMATOR"))
  ? $Frm->uhdr("RECPAR_STATS_ESTIMATOR") : "MEDIAN";

# Determine RMS and NEFD from map
my $nefd_map = "NaN";
$comp = "more.smurf.nefd";
_COMPONENT_EXISTS_ COMPONENT=$comp FILE=$Frm->file
if ($_COMPONENT_EXISTS_{EXISTS}) {
  my $nefdimage = $Frm->file . ".more.smurf.nefd";
  _FIND_IMAGE_STATISTICS_ IMAGE=$nefdimage VERBOSE=0
  $nefd_map = $_FIND_IMAGE_STATISTICS_{RESULTS}->{$estimator};
} else {
  _CALCULATE_NEFD_ GROUP=0 LOGFILE=0 ESTIMATOR=$estimator
  $nefd_map = $_CALCULATE_NEFD_{NEFD};
}

_FIND_IMAGE_STATISTICS_ IMAGE=$Frm->file COMP=ERR VERBOSE=0
my $rms_map = $_FIND_IMAGE_STATISTICS_{RESULTS}->{$estimator};

# Retrieve NEP from earlier calculation
my $nep_av = (defined $Frm->uhdr("NEP_AV")) ? $Frm->uhdr("NEP_AV") : "Nan";
my $nep_av_err = (defined $Frm->uhdr("NEP_AV_ERR")) ? $Frm->uhdr("NEP_AV_ERR") : "NaN";

# Determine RMS and NEFD from NEP: remember the factor of 10**12 to
# convert to pW
my $fcf = (defined $Frm->hdr("FCF")) ? $Frm->hdr("FCF") :
  $Cal->gain($wave, "BEAM");
my $nefd_nep = 1.0e12 * $nep_av * $fcf / $trans;
my $rms_nep = $nefd_nep / sqrt($t_elapsed);

# Determine RMS and NEFD from ITC
use Astro::ITC::SCUBA2 qw/calcrms exposure_time_fraction/;
# Determine ITC observation type from map size and scan pattern
my $mapsize = int($Frm->hdr("MAP_WDTH"));
my $scan_pat = lc($Frm->hdr("SCAN_PAT"));
my $itc_obstype;
if ($scan_pat =~ /pong/) {
  unless ($mapsize =~ /^[900|1800|3600|7200]/) {
    orac_warn "Pong type Pong".$mapsize." not known to ITC - assuming Pong3600\n";
    $mapsize = 3600;
  }
  $itc_obstype = "Pong".$mapsize;
} elsif ($scan_pat =~ /daisy/) {
  $itc_obstype = "Daisy";
}

my $f = (defined $Frm->uhdr("RECPAR_ITC_F")) ? $Frm->uhdr("RECPAR_ITC_F") : 1;
my $rms_itc = calcrms( $itc_obstype, $wave, $trans, $f, $t_elapsed );
my $nefd_itc = $rms_itc * sqrt(exposure_time_fraction($itc_obstype, $wave) * $t_elapsed);

# Show results
my $logfile = ORAC::LogFile->new("log.checkrms");
my @keys = qw/utdate object obsnum wave telapsed texp trans nep_av nep_av_err rms_nep nefd_nep rms_map nefd_map rms_itc nefd_itc/;
$logfile->header("# CHECK_RMS log file - created on ".gmtime(),
		 "# ".join(" ",@keys));

my $object = uc($Frm->hdr("OBJECT"));
$object =~ s/\s+/_/g;
my $entry = join("  ", $Frm->hdr("UTDATE"), $object, $Frm->hdr("OBSNUM"), $wave,
		 (sprintf "%.1f", $t_elapsed), (sprintf "%.1f", $texp),
		 (sprintf "%.2f", $trans),
		 (sprintf "%.2e", $nep_av), (sprintf "%.2e", $nep_av_err),
		 (sprintf "%.2e", $rms_nep), (sprintf "%.2e", $nefd_nep),
		 (sprintf "%.1f", $rms_map), (sprintf "%.1f", $nefd_map),
		 (sprintf "%.1f", $rms_itc), (sprintf "%.1f", $nefd_itc),
		);

orac_print "Writing results in log.checkrms...\n";
$logfile->addentry($entry);
