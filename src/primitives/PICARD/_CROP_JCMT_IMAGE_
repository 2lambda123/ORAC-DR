# -*-cperl-*-

=head1 NAME

_CROP_JCMT_IMAGE_ - trim JCMT image to specified map size

=head1 SYNOPSIS

 _CROP_JCMT_IMAGE_

 _CROP_JCMT_IMAGE_ GROUP=1

=head1 DESCRIPTION

This PICARD primitive is designed to trim an input image to the size
given by the map parameters in the header or to a user-specified size.

The user may specify the desired map width and height or a map radius
(for a circular ouput region) via recipe parameters.

The desired map size is checked against the input image dimensions and
the smaller of the two sizes is used for the output image.

=head1 ARGUMENTS

This primitive supports the following argument.

=over 2

=item B<GROUP>

If true, use the current Group file. Otherwise, use the current
Frame. Default is 0 (false).

=item B<METHOD>

Crop method to use. May be C<spatial> to use a defined map size or
C<statistical> to apply a statistical threshold. Default is
C<spatial>. May be overridden with the C<CROP_METHOD> recipe
parameter.

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA

NDFTRACE

=item ORAC-DR primitives:

SCUBA2: _CROP_IMAGE_REGION_, _MASK_IMAGE_

=back

=head1 OUTPUT DATA

The current object is updated with the cropped file and tagged
C<crop>.

=head1 OUTPUT FILES

Creates output file with the suffix C<_crop> or as given by the
C<OUTPUT_NAME> recipe parameter.

=head1 NOTES

Currently only works for SCUBA-2 but the primitives used are not
specific to that instrument and should work for heterodyne data.

There is a possibly undesireable interaction between the
C<APERTURE_RADIUS> and the various output map size recipe parameters
(e.g. C<MAP_RADIUS> etc). If the given map size is less than 4 times
the aperture radius, the map size will be set to 4 times the aperture
radius. Note there is a default value of 30 arcsec. The workaround is
to also set the C<APERTURE_RADIUS> parameter and to make it small (say
1 arcsec).

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2010-2013 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

my $group = get_prim_arg($_PRIM_ARGS_, "GROUP", 0);
my $Obj = ($group) ? $Grp : $Frm;

if ($Obj->file_exists) {
  my $verbose = ( defined $Frm->uhdr("RECPAR_VERBOSE") ) ?
    $Frm->uhdr("RECPAR_VERBOSE") : 1;

  my $method = lc(get_prim_arg($_PRIM_ARGS_, "METHOD", "spatial"));
  $method = $Frm->uhdr("RECPAR_CROP_METHOD")
    if (defined $Frm->uhdr("RECPAR_CROP_METHOD"));

  # Input file
  my $in = $Obj->file;
  # Output file name is taken from the recipe parameter iff a single
  # file is to be processed
  my $out = (defined $Frm->uhdr("RECPAR_OUTPUT_NAME") && $Grp->num == 0 && !$group)
    ? $Frm->uhdr("RECPAR_OUTPUT_NAME") : $in . "_crop";

  if ($method =~ /^stat/) {
    orac_print ("\nCalling _CROP_JCMT_IMAGE_: trim image using statistical estimator\n", "yellow");
    _THRESHOLD_IMAGE_ IMAGE=$in OUT=$out GROUP=$group
  } else {
    orac_print ("\nCalling _CROP_JCMT_IMAGE_: trim image to specified map size\n", "yellow");

    # Check the input map dimensions
    $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
    my ($ORAC_STATUS, @dims) = $Mon{ndfpack_mon}->get("ndftrace","dims");
    ($ORAC_STATUS, my @pixscale) = $Mon{ndfpack_mon}->get("ndftrace","fpixscale");
    my $mapwidth = 0.5*$pixscale[0]*$dims[0];
    my $maphght = 0.5*$pixscale[1]*$dims[1];
    my $mapsize = ($dims[0] < $dims[1]) ? $mapwidth : $maphght;

    # If a map radius has been given then use that to create a circular output map
    my $mapradius = $Frm->uhdr("RECPAR_MAP_RADIUS")
      if (defined $Frm->uhdr("RECPAR_MAP_RADIUS"));
    if ($mapradius) {
      # Set a minimum size if an aperture radius is given
      if (defined $Frm->uhdr("RECPAR_APERTURE_RADIUS")) {
	my $minmapsize = 4.0 * $Frm->uhdr("RECPAR_APERTURE_RADIUS");
	if ($mapradius < $minmapsize) {
	  orac_warn "Input radius ($mapradius arcsec) is smaller than minimum based on photometry aperture ($minmapsize arcsec)\n";
	  $mapradius = $minmapsize;
	}
      }
      # However, the circular region cannot extend beyond the existing map boundary.
      if ($mapradius > $mapsize) {
	$mapradius = $mapsize;
	orac_warn "Output image radius cannot exceed input map size ($mapradius arcsec)\n"
      }
      orac_print "Output image will be a circle of radius $mapradius arcsec\n" if $verbose;
      # Trim image to the specified radius
      my $masked = ORAC::TempFile->new(0);
      _MASK_IMAGE_ INVERT=1 IMAGE=$in MASKED=$masked RADIUS=$mapradius
      # Shrink the image by eliminating bad pixels around the edge
      $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$masked out=$out trimbad");
    } else {
      # Output image will be rectangular: check for recipe parameters
      my $extraparams = "";
      my $newwidth = $Frm->uhdr("RECPAR_MAP_WIDTH")
	if (defined $Frm->uhdr("RECPAR_MAP_WIDTH"));
      my $newheight = $Frm->uhdr("RECPAR_MAP_HEIGHT")
	if (defined $Frm->uhdr("RECPAR_MAP_HEIGHT"));

      # If the aperture radius is defined then ensure that the map height
      # and width exceed twice the diameter of the aperture
      if (defined $Frm->uhdr("RECPAR_APERTURE_RADIUS")) {
	my $minmapsize = 4.0 * $Frm->uhdr("RECPAR_APERTURE_RADIUS");
	if ($newwidth) {
	  $newwidth = $minmapsize if (defined $Frm->uhdr("RECPAR_MAP_WIDTH") &&
				      $Frm->uhdr("RECPAR_MAP_WIDTH") < $minmapsize);
	} else {
	  $newwidth = $minmapsize if ($mapwidth < $minmapsize);
	}
	if ($newheight) {
	  $newheight = $minmapsize if (defined $Frm->uhdr("RECPAR_MAP_HEIGHT") &&
				       $Frm->uhdr("RECPAR_MAP_HEIGHT") < $minmapsize);
	} else {
	  $newheight = $minmapsize if ($maphght < $minmapsize);
	}
      }

      $extraparams .= " WIDTH=$newwidth" if (defined $newwidth);
      $extraparams .= " HEIGHT=$newheight" if (defined $newheight);

      if ( $extraparams ne "" ) {
	orac_print "Output image will have".$extraparams." arcsec\n" if $verbose;
      } else {
	orac_print "Trimming $in...\n" if $verbose;
      }

      # Trim image to the specified size
      _CROP_IMAGE_REGION_ IN=$in OUT=$out $extraparams
    }
  }

  # Store trimmed file
  $Obj->files($out);
  $Obj->tagset("crop");
}
