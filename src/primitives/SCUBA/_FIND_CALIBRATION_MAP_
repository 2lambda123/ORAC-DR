=head1 NAME

_FIND_CALIBRATION_MAP_ - determine the map flux conversion factor

=head1 SYNOPSIS

 _FIND_CALIBRATION_MAP_

=head1 DESCRIPTION

For calibrators, finds the total integrated intensity
using L<_FIND_INTEGRATED_INTENSITY_|_FIND_INTEGRATED_INTENSITY_>
and calculates a flux conversion factor from the known flux
of the calibrator:

  fcf = V_sum /  S_tot

This value is then stored in the index file C<index.gains>.

=head1 EXTERNAL TASKS

None.

=head1 NOTES

This primitive is frame based (C<$Frm>).

=head1 ARGUMENTS

None.

=head1 OUTPUT DATA

Entry in C<index.gains> log file if the frame is a calibrator.

=cut

use JCMT::Tau;

# Check that we are a calibrator (regardless of filter)
if ($Cal->iscalsource($Frm->hdr("OBJECT"))) {


  # Find the integrated intensity
  # turn off logfile in production code
  _FIND_INTEGRATED_INTENSITY_  LOGFILE=0


  my @filter = $Frm->filters;

  # Get results from integrated intensity
  my $results = $_FIND_INTEGRATED_INTENSITY_{'RESULTS'};

  # Now Loop over frames
  for my $i (1.. $Frm->nfiles ) {

    # skip if we have no result for this filter
    # or it is negative
    next unless (defined $results->[$i] && $results->[$i] > 0);

    # Now get the flux
    my $flux = $Cal->fluxcal($Frm->hdr("OBJECT"), $filter[$i-1], 1);

    if (defined $flux) {

      print "Flux: $flux, ". $results->[$i]. "\n";
      # Calculate the new gain
      my $gain = $flux / $results->[$i];

      # Announce the new gain
      orac_print("Storing new gain for ".$filter[$i-1].": $gain Jy/V\n",'yellow');

      # Set the current gain - add to index file
      # This means that we have to create a hash with the
      # new keyword GAIN and the selected filter FILTER
      my %hdr = %{$Frm->hdr};
      $hdr{GAIN} = $gain;
      $hdr{FILTER} = uc($filter[$i-1]);

      $Cal->gainsindex->add($Frm->file($i), \%hdr);

      # Additionally it seems that a user-friendly logfile is
      # a requirement
      my $log = new ORAC::LogFile("log.fcf");
      # Write header to logfile
      my $time = gmtime();
      $log->header("# Flux conversion factor log file - created on $time",
                   "\nUT        Obs  HST   Source    Thr El Filter    WLen  Tau  CSO  See   FCF",
                   "#------------------------------------------------------------------------",
                  );


      # FRom FITS header need
      # FILTER (+filter[$i])
      my $flt    = $Frm->hdr("FILTER");
      my $wav    = $filter[$i-1];
      # ORACUT
      my $utdate = $Frm->hdr('ORACUT');
      my $uttime = $Frm->hdr('ORACTIME');
      # RUN
      my $run    = sprintf "%4d", $Frm->hdr('RUN');
      # HSTSTART (no decimal places)
      my $hst    = $Frm->hdr('HSTSTART');
      my (@hst)  = split(/:/, $hst);
      $hst = sprintf '%5s', $hst[0] . ":" . $hst[1];

      # Chop throw
      my $thr = sprintf "%3d", $Frm->hdr('CHOP_THR');

      # OBJECT
      my $src    = uc($Frm->hdr('OBJECT'));
      $src    = sprintf "%-10s", $src;
      # Average of END_ELD and STRT_ELD
      my $el     = ($Frm->hdr('END_ELD') + $Frm->hdr('STRT_ELD'))/ 2.0;
      $el        = sprintf "%2d", $el;
      # TAU from calibration object
      my $tau = sprintf "%5.2f", $Cal->tau($filter[$i-1]);

      # Use that tau to calculate CSO
      my ($cso, $status) = JCMT::Tau::get_tau('CSO',$filter[$i-1], $tau);
      if ($status != 0) {
        $cso = "*****";
      } else {
        $cso = sprintf "%5.2f", $cso;
      }

      # Seeing
      my $see = sprintf "%4.2f", $Frm->hdr('SEEING');

      # GAIN
      $gain   = sprintf "%5.3f", $gain;

      $log->addentry("$utdate $run $hst $src $thr $el $flt $wav $tau $cso $see $gain $uttime");

    }


  }


}
