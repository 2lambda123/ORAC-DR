=head1 NAME

CALCULATE_POLARISATION_FROM_CUBE_GROUP

=head1 DESCRIPTION

Calculate the I,P and THETA from the groups by coadding the 
IQU cubes generated by _GENERATE_IQU_CUBE_FRAME_.

=head1 PARAMETERS

BIN - binning factor (default = 2)
S2N - Signal-to-noise clip level (default = 2)

=head1 TASKS

CCDPACK mosaic is used to average the cubes since it can take
origin information into account.

Will fall back to Kappa MATHS if CCDPACK is not available.
This will lead to truncation of areas not covered by both maps
and should be avoided if possible!

The _CALCULATE_POLARISATION_FROM_CUBE_FRAME_ is used to calculate
and display the polarisation properties.

=head1 PREREQUISITES

The previous frame primitive should leave the Frames so that
they contain an IQU cube. This primitive will not work if that
is not the case (eq the cube generation step is missing or
the frame now points to an I frame).

=head1 NOTES

The group coadding only occurs when there are at least two observations
in the group.

If kappa MATHS is used for the averaging, no mor than 26 cubes
can be combined.

=cut

# Bin parameter
my $bin = ($_CALCULATE_POLARISATION_FROM_CUBE_GROUP_{BIN} || 2);
my $Sig2N = ($_CALCULATE_POLARISATION_FROM_CUBE_GROUP_{'S2N'} || 2);

# Check that we are processing the last frame of the group
if ($Grp->lastmember($Frm) && $Grp->num >=1) {
      
  # Loop over sub-instruments and group members
  # and generate
  my @out;  # Averaged cube names

  # Loop over sub instruments that are found in the current frame
  foreach my $sub ($Frm->subs) {

    # Now need to find all the input frames for this sub-instrument
    # that are part of this group
    my @members = $Grp->membernamessub($sub);
    my $ncubes = $#members + 1;


    # No point averaging one cube
    if ($ncubes > 1) {
      # Generate a temp output name from the group
      my $out = $Grp->grpoutsub($sub) . '_avcube';
      push(@out, $out);

      orac_print "Calculating mean of IQU cubes for sub $sub from $ncubes cubes.\n";

      if (exists $Mon{ccdpack_reg}) {

	# need to mosaic the I, Q and U planes separately and then
	# regenerate the cube

	my @planes = qw(I Q U);

	orac_print "Mosaicing the following frames:\n".join("\n",@members)."\n";

	foreach my $i (0..$#planes) {
	  my $plane = $i + 1;
	  orac_print "Mosaicing the $planes[$i] data\n";

	  # Create text file for mosaic names
	  my $tmp = new ORAC::TempFile || die "Error opening makemos input file\n";
	  print {$tmp->handle} join("(,,$plane)\n", @members) ."(,,$plane)\n";
	  $tmp->handle->close || die "Error closing makemos input file\n";

	  # We are using the first member as a reference
	  my $ref = $members[0] . "(,,$plane)";

	my $args = "in=^". $tmp->file ." noscale nozero method=mean usevar genvar title='Average $planes[$i]'";

	  # Run CCDPACK with noscale but with zero correction relative
	  # to the reference image
	  $Mon{ccdpack_reg}->obeyw("makemos","$args out=${out}_mos$planes[$i] ref=$ref");

	}

	orac_print "Putting cube back together...\n";
	# Now paste the planes back into the cube
	$Mon{kappa_mon}->obeyw("paste","in=${out}_mos$planes[0] p1=${out}_mos$planes[1] p2=${out}_mos$planes[2] title='Average IQU cube' out=$out");


	# Copy world coordinates
	$Mon{ndfpack_mon}->obeyw("wcscopy","ndf=$out like=$members[0] ok=true");

      } else {
	orac_print "MAKEMOS not available -- using KAPPA instead.\n This will lead to truncation of non-overlapping regions\n";

	# Kappa maths can only combine up to 26 input files
	if ($#members > 25) {
	  orac_err("Can only process a maximum of 26 IQU cubes\n");
	  my $ORAC_STATUS = ORAC__ERROR;
	}

	# Create maths string (not unicode compliant!)
	# generate "ia + ib + ic .... " expression for kappa maths
	my $exp = '('.join ("+",grep {$_ = "i".chr($_+96)} (1..$ncubes)) . ")/$ncubes";

	# Generate "ia=cube1 ib=cube2...."
	my $args = join(" ", grep {
	  $_ = "i".chr($_+96)."=" . $members[$_-1];
	} (1..$ncubes));

	# Run maths
	$Mon{kappa_mon}->obeyw("maths","exp='$exp' out=$out $args title='Average IQU'");
	
      }
    } else {
      push(@out, $members[0]);
    }

  }

  # Dont really like this next bit but I cant work out how to 
  # have a primitive that truly can be used for frame and
  # group calculations

  my $TFrm = new $Frm;
  {
    # Now we want to call the frame cal_pol primitive
    # Need to create a $Frm that maskes the main $Frm
    # So that the primitive will use our pseudo frame
    # This frame will know nothing except the file names
    # so dont expect to use header information or sub instruments
    my $Frm = new $TFrm;

    $Frm->files(@out);  # Load it up with the output cube names

    # The only problem is that the gui_id will return sN**
    # rather than gN**. Will live with this for now
    # Easiest fix is the make the prefix configurable in the Frame
    # object ->   $Frm->gui_prefix('g');

    _CALCULATE_POLARISATION_FROM_CUBE_FRAME_ BIN=$bin S2N=$Sig2N

    # Note that we do not erase the average cube

  }
  undef $TFrm;

}
