=head1 NAME

CALCULATE_POLARISATION_FROM_CUBE_GROUP

=head1 DESCRIPTION

Calculate the I,P and THETA from the groups by coadding the 
IQU cubes generated by _GENERATE_IQU_CUBE_FRAME_.

=head1 PARAMETERS

BIN - binning factor (default = 2)

=head1 TASKS

KAPPA maths is used to average the cubes.

The _CALCULATE_POLARISATION_FROM_CUBE_FRAME_ is used to calculate
and display the polarisation properties.

=head1 PREREQUISITES

The previous frame primitive should leave the Frames so that
they contain an IQU cube. This primitive will not work if that
is not the case (eq the cube generation step is missing or
the frame now points to an I frame).

=head1 NOTES

The group coadding only occurs when there are at least to observations
in the group.

=cut


# Bin parameter
$bin = ($_CALCULATE_POLARISATION_FROM_CUBE_GROUP_{BIN} || 2);


# Check that we are processing the last frame of the group
if ($Grp->lastmember($Frm) && $Grp->num >=1) {
      
  # Loop over sub-instruments and group members
  # and generate
  my @out;  # Averaged cube names

  # Loop over sub instruments that are found in the current frame
  foreach $sub ($Frm->subs) {

    # Now need to find all the input frames for this sub-instrument
    # that are part of this group
    @members = $Grp->membernamessub($sub);

    # We are going to run MATHS
    # First we have to generate the MATHS string that will be used
    # to average all this

    # Generate a temp output name from the group
    $out = $Grp->file() . '_avcube';
    push(@out, $out);

    # Kappa maths can only combine up to 26 input files
    if ($#members > 25) {
      orac_err("Can only process a maximum of 26 IQU cubes\n");
      $ORAC_STATUS = ORAC__ERROR;
    }
    my $ncubes = $#members + 1;


    # No point averagine one cube
    if ($ncubes > 1) {
      orac_print "Calculating mean of IQU cubes for sub $sub from $ncubes cubes.\n";

      # Create maths string (not unicode compliant!)
      # generate "ia + ib + ic .... " expression for kappa maths
      my $exp = '('.join ("+",grep {$_ = "i".chr($_+96)} (1..$ncubes)) . ")/$ncubes";

      # Generate "ia=cube1 ib=cube2...."
      my $args = join(" ", grep {
	$_ = "i".chr($_+96)."=" . $members[$_-1];
      } (1..$ncubes));

      # Run maths
      $Mon{kappa_mon}->obeyw("maths","exp='$exp' out=$out $args title='Average IQU'");

    } else {
      push(@out, $members[$i-1]);
    }

  }

  my $TFrm = new $Frm;
  {
    # Now we want to call the frame cal_pol primitive
    # Need to create a $Frm that maskes the main $Frm
    # So that the primitive will use our pseudo frame
    my $Frm = new $TFrm;

    $Frm->files(@out);  # Load it up with the output cube names

    # The only problem is that the gui_id will return sN**
    # rather than gN**. Will live with this for now
    # Easiest fix is the make the prefix configurable in the Frame
    # object ->   $Frm->gui_prefix('g');

    _CALCULATE_POLARISATION_FROM_CUBE_FRAME_ BIN=$bin

    # Note that we do not erase the average cube

  }
  undef $TFrm;

}
