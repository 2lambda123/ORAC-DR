=head1 NAME

CALCULATE_POLARISATION_FROM_CUBE_FRAME

=head1 DESCRIPTION

Takes the IQU cube (IQU are intensities) and converts
to P and THETA. The output frame associated with this primitive
just contains the I image. The P and THETA are stored in an 
extension. This behaviour is related to the Kappa display system
(ORAC::Display::KAPVIEW::vectors) which currently is the only
supported vector display. P and THETA images are also
created separately and displayed if required.

=head1 ARGUMENTS

BIN - number of pixels to bin vectors [default is 2x2]

=head1 SUFFIXES

The following suffixes are generated:

- _pol - I image with P,THETA extensions
- _p   - P image
- _theta - Theta image

=head1 TASKS

The following tasks are used:

 POLPACK: POLVEC to generate P and THETA from Q and U

 KAPPA: THRESH is used to threshold the P vectors

If POLPACK is not available, KAPPA MATHS is used to calculate the
P and THETA images from the Q and U.

 KAPPA - MATHS for averaging

=head1 DISPLAY
 
The display system will be asked to display the _I frame.  
A VECTOR display automatically looks for P and
THETA in an ORAC extension if an _I suffix is found 
A _I suffix should be associated with TYPE=VECTOR if
required.  [A VECTOR plot displays P and THETA over an I image]
 
Additionally, the P and theta components will be sent to the
display system separately (P and THETA suffices) - this is primarily
intended for HISTOGRAM output.
 
Currently it is not possible to display the Q and U images
automatically.

In order to support KAPPA VECPLOT and POLPACK POLPLOT in the display
engine, this routine generates an I image  along with P and theta 
images. In addition, if we are using POLPACK, a CATALOGUE is generated
with the same name as the I image (except for a .FIT extension).

=head1 NOTES

This primitive does not update the frame object. This is because the
group primitive has to work on the IQU cubes - there is not way
for the group primitive to find out the name of the cube if it runs
after this primitive and this primitive has set the I frame as the
current.

=cut

# Create dummy frame object to store P and THETA output
$P_frm = $Frm->new;
$Theta_frm = $Frm->new;
$I_frm = $Frm->new;

# Read the arguments
$bin = ($_CALCULATE_POLARISATION_FROM_CUBE_FRAME_{'BIN'} || 2);


# Check for POLPACK
if (exists $Mon{polpack_mon}) {

  # Loop over frames
  for my $i (1..$Frm->nfiles) {
  
    # Output names
    ($in, $iout[$i]) = $Frm->inout('_pol',$i);
    ($in, $pout[$i]) = $Frm->inout('_p',$i);
    ($in, $ptemp[$i]) = $Frm->inout('_ptemp',$i);
    ($in, $thout[$i]) = $Frm->inout('_theta',$i);

    # unlink an existing catalogue (assume .FIT)
    # Since POLVEC will not overwrite
    unlink "$iout[$i].FIT";

    orac_print "Binning at $bin pixels\n" if $bin > 1;
    # Just run POLVEC
    $Mon{polpack_mon}->obeyw('polvec',"in=$in cat=$iout[$i] ang=$thout[$i] p=$ptemp[$i] i=$iout[$i] box=$bin method=mean");

    # We will smooth the catalogue here....
    # The p image is thresholded later on.


  }

} else {

  # Loop over frames
  for my $i (1..$Frm->nfiles) {
  
    # Output names
    ($in, $iout[$i]) = $Frm->inout('_pol',$i);
    ($in, $pout[$i]) = $Frm->inout('_p',$i);
    ($in, $ptemp[$i]) = $Frm->inout('_ptemp',$i);
    ($in, $thout[$i]) = $Frm->inout('_theta',$i);
    ($in, $utemp) = $Frm->inout('_utemp',$i);
    ($in, $qtemp) = $Frm->inout('_qtemp',$i);

    # If we are going to bin the IQU cube, we have to do it here.
    # We can use compave to bin the cube as a whole by [$bin,$bin,1]
    # and then use SQORST to expand it. There is every likelihood
    # that WCS are lost during this. Origin information will be lost
    # when SQORST is used

    if ($bin > 1) {
      orac_print "Binning at $bin pixels\n";
      $f = $Frm->file($i);
      ($in,$avout) = $Frm->inout('_compave',$i);
      $Mon{kappa_mon}->obeyw('compave',"in=$in out=$avout compress=[$bin,$bin,1]");
      # Use the compave output as the in
      $in = $avout;
    }

    # Need to extract the I Q and U images from the cube
    # and setbound to be ,,1 so that maths can combine them
    $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$in(,,1) out=$iout[$i]");  
    $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$in(,,2) out=$qtemp");  
    $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$in(,,3) out=$utemp");  

    # Now setbounds
    $Mon{ndfpack_mon}->obeyw("setbound","ndf=$qtemp(,,1)");
    $Mon{ndfpack_mon}->obeyw("setbound","ndf=$utemp(,,1)");
    $Mon{ndfpack_mon}->obeyw("setbound","ndf=$iout[$i](,,1)");

    # Else use kappa maths
    # Note that we have Q,U intensities so have to divide by I
    $Mon{kappa_mon}->obeyw("maths","exp='100*sqrt(ia*ia+ib*ib/(ic*ic))' ia=$qtemp ib=$utemp ic=$iout[$i] out=$ptemp[$i] title='Polarisation'");
    $Mon{kappa_mon}->obeyw("maths","exp='0.5*atan2d(ia,ib)' ia=$utemp ib=$qtemp out=$thout[$i] title='Polarisation angle'");
    
    # Set the units
    $Mon{ndfpack_mon}->obeyw("setunits", "ndf=$ptemp[$i] units=% ");
    $Mon{ndfpack_mon}->obeyw("setunits", "ndf=$thout[$i] units=degrees ");

    # Erase q and utemp
    $Mon{ndfpack_mon}->obeyw("erase","object=$qtemp ok=true");
    $Mon{ndfpack_mon}->obeyw("erase","object=$utemp ok=true");
    
  }
}

# Independent of KAPPA or POLPACK we now have 
# P, Theta and I images
# P is in $ptemp and has to be thresholded

# Loop over nfiles again
for my $i (1..$Frm->nfiles) {

  # Dont need to recaculate output names since we stored them in
  # arrays

  # Just threshold the P
  $Mon{kappa_mon}->obeyw("thresh", "in=$ptemp[$i] out=$pout[$i] thrlo=0.0 thrhi=10.0 newlo=BAD newhi=BAD");

  # Erase ptemp
  $Mon{ndfpack_mon}->obeyw("erase","object=$ptemp[$i] ok=true");

  # Create an .ORAC extension
  ndf_begin;
  ndf_open(&NDF::DAT__ROOT(), $iout[$i],'UPDATE','OLD', $indf, $place,$status);
  ndf_xnew($indf, 'ORAC', 'ORAC_EXT', 0, @null, $xloc, $status);
  dat_annul($xloc, $status);
  ndf_annul($indf, $status);
  ndf_end($status);
  if ($status != &NDF::SAI__OK) {
    orac_err("Failed to create HDS container: $iout[$i]!");
    $ORAC_STATUS = ORAC__ERROR;
  }


  # Copy P and THETA into $iout 
  $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$thout[$i] out=$iout[$i].more.orac.theta");
  $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$pout[$i] out=$iout[$i].more.orac.p");

  # Update dummy frame
  $I_frm->file($i,$iout[$i]);

  # Update dummy P and Theta frames
  $P_frm->file($i, $pout[$i]);
  $Theta_frm->file($i,$thout[$i]);

}


# Display P and theta and _pol
$Display->display_data($P_frm) if defined $Display;
$Display->display_data($Theta_frm) if defined $Display;
$Display->display_data($I_frm) if defined $Display;

# Now undef the temporary frames
$P_frm = undef;
$Theta_frm = undef;
$I_frm = undef;
 

