=head1 NAME

CALCULATE_POLARISATION_FROM_CUBE_FRAME

=head1 DESCRIPTION

Takes the IQU cube (IQU are intensities) and converts
to P and THETA. The output frame associated with this primitive
just contains the I image. The P and THETA are stored in an 
extension. This behaviour is related to the Kappa display system
(ORAC::Display::KAPVIEW::vectors) which currently is the only
supported vector display. P and THETA images are also
created separately and displayed if required.

=head1 ARGUMENTS

BIN - number of pixels to bin vectors [default is 2x2]
S2N - signal to noise criterion for vectors (default is 2)

=head1 SUFFIXES

The following suffixes are generated:

- _pol - I image with P,THETA extensions and catalogue
- _p   - P image
- _theta - Theta image

=head1 TASKS

The following tasks are used:

 POLPACK: POLVEC to generate P and THETA from Q and U

 CURSA: CATSELECT to select good vectors

 KAPPA: THRESH is used to threshold the P vectors

If POLPACK is not available, KAPPA MATHS is used to calculate the
P and THETA images from the Q and U.

 KAPPA - MATHS for averaging

=head1 DISPLAY

The display system will be asked to display the _I frame.  
A VECTOR display automatically looks for P and
THETA in an ORAC extension if an _I suffix is found 
A _I suffix should be associated with TYPE=VECTOR if
required.  [A VECTOR plot displays P and THETA over an I image]

Additionally, the P and theta components will be sent to the
display system separately (P and THETA suffices) - this is primarily
intended for HISTOGRAM output.

Currently it is not possible to display the Q and U images
automatically.

In order to support KAPPA VECPLOT and POLPACK POLPLOT in the display
engine, this routine generates an I image  along with P and theta 
images. In addition, if we are using POLPACK, a CATALOGUE is generated
with the same name as the I image (except for a .FIT extension).

The catalogue supports signal to noise clipping. The
selection is

   i>0 & p>0.001 & p<15 & p/dp > S2N

where S2N can be supplied as an argument.

Since the KAPVIEW vector display uses kapview and optionally
POLPACK -- the catalogue is used in preference to the P and THETA
images for display if one exists.

=head1 NOTES

This primitive does not update the frame object. This is because the
group primitive has to work on the IQU cubes - there is not way
for the group primitive to find out the name of the cube if it runs
after this primitive and this primitive has set the I frame as the
current.

=cut

# Create dummy frame object to store P and THETA output
my $P_frm = $Frm->new;
my $Theta_frm = $Frm->new;
my $I_frm = $Frm->new;
my $S2N_frm = $Frm->new;

# Read the arguments
my $bin = ($_CALCULATE_POLARISATION_FROM_CUBE_FRAME_{'BIN'} || 2);
my $Sig2N = ($_CALCULATE_POLARISATION_FROM_CUBE_FRAME_{'S2N'} || 2);

my ($in, @iout, @pout, @ptemp, @thout, @catout);

# Check for POLPACK
if (exists $Mon{polpack_mon}) {

  # Loop over frames
  for my $i (1..$Frm->nfiles) {
  
    # Output names
    ($in, $iout[$i]) = $Frm->inout('_pol',$i);
    ($in, $pout[$i]) = $Frm->inout('_p',$i);
    ($in, $ptemp[$i]) = $Frm->inout('_ptemp',$i);
    ($in, $thout[$i]) = $Frm->inout('_theta',$i);
    ($in, $catout[$i]) = $Frm->inout('_cat', $i);

    # unlink an existing catalogue (assume .FIT)
    # Since POLVEC will not overwrite
    unlink "$iout[$i].FIT", "$catout[$i].FIT";

    orac_print "Binning at $bin pixels\n" if $bin > 1;
    # Just run POLVEC
    $Mon{polpack_mon}->obeyw('polvec',"in=$in cat=$catout[$i] ang=$thout[$i] p=$ptemp[$i] i=$iout[$i] box=$bin method=mean");

    # Set the I image to be the slice from the cube rather than
    # the binned image (for now) until we decide whether POLVEC
    # will bin up or not
    $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$in(,,1) out=$iout[$i] title='Stokes I image'");


    # Turn history recording back on
    $Mon{ndfpack_mon}->obeyw("hisset","ndf=$iout[$i] mode=normal");
    $Mon{ndfpack_mon}->obeyw("hisset","ndf=$thout[$i] mode=normal");
    $Mon{ndfpack_mon}->obeyw("hisset","ndf=$ptemp[$i] mode=normal");


    # Binning should be done in POLBIN but can be done in POLVEC
    # so long as we dont use the binned I image
    # Main reason not to is that we are keeping support for KAPPA
    # fallback mode and VECPLOT display. VECPLOT does not support
    # p/theta images different size to the I image


    # The p image is thresholded later on.


  }

} else {

  # Loop over frames
  for my $i (1..$Frm->nfiles) {
  
    # Output names
    my ($utemp, $qtemp);
    ($in, $iout[$i]) = $Frm->inout('_pol',$i);
    ($in, $pout[$i]) = $Frm->inout('_p',$i);
    ($in, $ptemp[$i]) = $Frm->inout('_ptemp',$i);
    ($in, $thout[$i]) = $Frm->inout('_theta',$i);
    ($in, $utemp) = $Frm->inout('_utemp',$i);
    ($in, $qtemp) = $Frm->inout('_qtemp',$i);

    # If we are going to bin the IQU cube, we have to do it here.
    # We can use compave to bin the cube as a whole by [$bin,$bin,1]
    # and then use SQORST to expand it. There is every likelihood
    # that WCS are lost during this. Origin information will be lost
    # when SQORST is used - only compress for now

    my $avout;
    if ($bin > 1) {
      orac_print "Binning at $bin pixels\n";
      $avout = new ORAC::TempFile(0);
      $Mon{kappa_mon}->obeyw('compave',"in=$in out=".$avout->file." compress=[$bin,$bin,1]");
      # Use the compave output as the in
      $in = $avout->file;
    }

    # Need to extract the I Q and U images from the cube
    # and setbound to be ,,1 so that maths can combine them
    $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$in(,,1) out=$iout[$i]");  
    $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$in(,,2) out=$qtemp");  
    $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$in(,,3) out=$utemp");  

    # Now setbounds
    $Mon{ndfpack_mon}->obeyw("setbound","ndf=$qtemp(,,1)");
    $Mon{ndfpack_mon}->obeyw("setbound","ndf=$utemp(,,1)");
    $Mon{ndfpack_mon}->obeyw("setbound","ndf=$iout[$i](,,1)");

    # Else use kappa maths
    # Note that we have Q,U intensities so have to divide by I
    $Mon{kappa_mon}->obeyw("maths","exp='100*sqrt(ia*ia+ib*ib/(ic*ic))' ia=$qtemp ib=$utemp ic=$iout[$i] out=$ptemp[$i] title='Polarisation'");
    $Mon{kappa_mon}->obeyw("maths","exp='0.5*atan2d(ia,ib)' ia=$utemp ib=$qtemp out=$thout[$i] title='Polarisation angle'");
    
    # Set the units
    $Mon{ndfpack_mon}->obeyw("setunits", "ndf=$ptemp[$i] units=% ");
    $Mon{ndfpack_mon}->obeyw("setunits", "ndf=$thout[$i] units=degrees ");

    # Erase q and utemp
    $Mon{ndfpack_mon}->obeyw("erase","object=$qtemp ok=true");
    $Mon{ndfpack_mon}->obeyw("erase","object=$utemp ok=true");
    
  }
}

# Independent of KAPPA or POLPACK we now have 
# P, Theta and I images
# P is in $ptemp and has to be thresholded

# Loop over nfiles again
for my $i (1..$Frm->nfiles) {

  # At this pont we have I, P and THETA images
  # Also, with POLPACK we will have a FITS catalogue
  # We have already binned up using POLVEC with POLPACK

  # When we dont have CURSA the only thing we can really do
  # is threshold P and throw away the large values

  if (exists $Mon{catselect} && exists $Mon{polpack_mon}) {

    # threshold catalogue on I>0 && p/dp> 3
    # and write it to a catalogue of the same name as the I image
    unlink "$iout[$i].FIT";
    $Mon{catselect}->obeyw("catselect"," catin=$catout[$i] catout=$iout[$i] rejcat=no seltyp=e expr='i>0 & p<15 & p>0.001 & p/dp>$Sig2N'");

    orac_print "Clipping vectors below signal-to-noise of $Sig2N\n";

    # Convert the catalogue to an image in P so that we can generate
    # a signal to noise map

    my $pimag = new ORAC::TempFile(0);
    $Mon{polpack_mon}->obeyw("polimage"," in=$iout[$i] coldat=p colvar='dp**2' method=mean shape=true out=" . $pimag->file);

    my $s2n = $Frm->inout('_s2n',$i);
    $Mon{kappa_mon}->obeyw("maths","exp='ia/sqrt(va)' ia=".$pimag->file ." out=$s2n title='p S/N'");

    $S2N_frm->file($i, $s2n);

  } else {
    orac_print "CURSA/POLPACK not available -- can only threshold p\n";
  }

  # Just threshold the P
  $Mon{kappa_mon}->obeyw("thresh", "in=$ptemp[$i] out=$pout[$i] thrlo=0.001 thrhi=15.0 newlo=BAD newhi=BAD");

  # Erase ptemp
  $Mon{ndfpack_mon}->obeyw("erase","object=$ptemp[$i] ok=true");


  # Create an .ORAC extension
  ndf_begin;
  my ($indf,@null,$xloc, $place);
  my $status = &NDF::SAI__OK;
  ndf_open(&NDF::DAT__ROOT(), $iout[$i],'UPDATE','OLD', $indf, $place,$status);
  ndf_xnew($indf, 'ORAC', 'ORAC_EXT', 0, @null, $xloc, $status);
  dat_annul($xloc, $status);
  my @lines = ( "Add ORAC extension");
  ndf_hput('NORMAL', "$ORAC_PRIMITIVE (ORAC-DR)", 1, 1, @lines,0,0,0,$indf,$status);
  ndf_annul($indf, $status);
  ndf_end($status);
  if ($status != &NDF::SAI__OK) {
    orac_err("Failed to create HDS container: $iout[$i]!");
    my $ORAC_STATUS = ORAC__ERROR;
  }


  # Copy P and THETA into $iout 
  $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$thout[$i] out=$iout[$i].more.orac.theta");
  $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$pout[$i] out=$iout[$i].more.orac.p");

  # Update dummy frame
  $I_frm->file($i,$iout[$i]);

  # Update dummy P and Theta frames
  $P_frm->file($i, $pout[$i]);
  $Theta_frm->file($i,$thout[$i]);

}


# Display P and theta and _pol
$Display->display_data($P_frm) if defined $Display;
$Display->display_data($Theta_frm) if defined $Display;
$Display->display_data($I_frm) if defined $Display;
$Display->display_data($S2N_frm) if defined $Display;

# Now undef the temporary frames
$P_frm = undef;
$Theta_frm = undef;
$I_frm = undef;
 

