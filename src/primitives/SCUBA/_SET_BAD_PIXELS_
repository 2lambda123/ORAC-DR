=head1 NAME

SET_BAD_PIXELS

=head1 DESCRIPTION

Determine requested bad pixels and set those bolometers
to 'bad' in the input file. The bad bolometer list can
be determined in a number of ways specified by the 
badbol() calibration method.

The pipeline can be configured to use 3 different methods
to determine the bad bolometer list:

 - 'index': Use an index file generated by noise observations
            using the reflector blade. The bolometers stored in this
            file are those that were above the noise threshold in 
            the _REDUCE_NOISE_ primitive. The index file is generated
            by the _REDUCE_NOISE_ primitive
 - 'file' : Uses the contents of the file badbol.lis (contains a space
            separated list of bolometer names in the first line). This
            file is in ORAC_DATA_OUT. If the file is not found, no
            bolometers will be flagged.
            The input file is generated by hand, stored in $ORAC_DATA_OUT
            and is called badbol.lis. Currently the format should be:

              A1 A3 B15 H7

            or whatever (ie space separated).
 - colon separated list of bad bolometers
            If badbols=h7:12:g4,... then this list will be used
            as the bad bolometers throughout the reduction.

Which one is used can be specified on the oracdr command line
by using the -cal option. Default is to look for the 'file'
(badbol.lis).

The one wrinkles is that it is more helpful if we accept bolometer
names for the bad pixel designation in the file BUT change_quality
accepts bolometer numbers in the file.


This means that we have to convert the bolometer name to a
ADC number and channel number (fairly easy) and then see whether
this is present in the data before turning it off.

=head1 TASKS

SURF: CHANGE_QUALITY

=head1 NOTES

- Uses NDF calls to read the BOL_CHAN and BOL_ADC extensions!

=cut




# Read the bad bolometers in from 'wherever'
@badbols = $Cal->badbol_list;

# Now that we have a list we should read in the BOL_ADC
# and BOL_CHAN arrays
if ($#badbols > -1) {
  use NDF;  # Import commands into my namespace
  my ($xloc, $indf, $status);
  # Open $Frm for read
  $status = &NDF::SAI__OK;
  ndf_begin();
  ndf_find(&NDF::DAT__ROOT(), $Frm->file, $indf, $status);

  # Find the SCUBA extension
  ndf_xloc($indf, 'SCUBA', 'READ', $xloc, $status);

  # Read BOL_CHAN and BOL_ADC
  cmp_getvd($xloc, 'BOL_CHAN', 200, @bolchan, $el, $status);
  cmp_getvd($xloc, 'BOL_ADC', 200, @boladc, $el, $status);

  # Annul locator and NDF id
  dat_annul($xloc, $status);
  ndf_annul($indf, $status);

  ndf_end($status);

  if ($status != &NDF::SAI__OK) {
    @bolchan = ();
    @boladc = ();
  }

  # Only proceed if we have something in @bolchan or @boladc

  if ($#bolchan > -1 && $#boladc > -1) {

    # Generate a look up table for the ADC lookup
    # I'm sure there is a better way to do this but...
    # Could do this using ord() and offsets from 'A'
    # but I have a feeling that might not be very general
    # (it assumes that B follows A in the character set....)

    my %lut = ( A => 1, B => 2, C => 3, D => 4, E => 5, F => 6,
		G => 7, H => 8, I => 9);

    # Now loop over the selected bolometers.
    # so that a CHANGE_QUALITY string can be created
    my @match = (); # Store matching bolometers
    my @mname = (); # Names of matching bolometers

    foreach my $bol (@badbols) {
      my $adc = uc(substr($bol,0,1));
      my $chan = substr($bol,1);

      # Convert ADC letter to a ADC number
      my $adcl = $lut{$adc};

      # Now need to match the adc and chan with that
      # read from the file. Can I think of a fast way
      # to do this with grep? Unfortunately we need to
      # compare two files and remember the index of the 
      # unique match
      for (my $i=0; $i <= $#bolchan; $i++) {
	if ($adcl == $boladc[$i] && $chan == $bolchan[$i]) {
	  push(@match, $i+1); # Count from 1 not 0
	  push(@mname, $bol);
	  last;
	}
      }
    }

    # Now if @match contains some entries we can construct
    # a string for CHANGE_QUALITY and set the bolometers bad
    if ($#match > -1) {
      $in = $Frm->file . '{B' . join(",",@match) . '}';
      
      # Run change_quality
      $Mon{surf_mon}->obeyw("change_quality","in='$in' bad_quality=yes");

      # message
      my $bolstring = join(",",@mname);
      orac_print("Setting bolometers [$bolstring] to bad\n");

    }

  }
}

