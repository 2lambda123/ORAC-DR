#+
# Name:
#    _ARRAY_TEST_STATISTICS_
#
# Purpose:
#    Determines the state of the UFTI detector for the ARRAY_TESTS
#    recipe.
#
# Language:
#    Perl5
#
# Description:
#    This primitive evaluates the readout noise in electrons and the
#    dark current in electrons per second for UFTI.  The script also
#    reports these statistics, indicating whether or not they are
#    nominal.  The results are also logged to a text file,
#    ufti_array_tests.log in the $ORAC_DATA_OUT directory, to monitor
#    secular trends. The ND_STARE readnoise is written to the
#    calibration index.
#
#    The primitive expects sets of four frames.  In each set the first
#    refresh frame is ignored, then come two ND_STARE frames, followed
#    by a dark.
#
# Notes:
#    -  The exposure time comes from the ORAC_EXPOSURE_TIME header,
#    defaulting to 60.0s if the header is undefined.  The ADU comes
#    from the _GET_GAIN_ primitive.
#    -  If the log file does not exist, a new one is created containing
#    a two-line heading, and the fact is reported.
#    -  The log file stores the results in a fixed columnar format.
#    -  The noise is the standard deviation per frame of the second and
#    third frames subtracted, and converted from counts to electrons.
#    -  The dark current is the three-sigma-clipped mean count of the
#    dark count normalised to unit time and converted to electrons.
#    -  The nominal readout noise is 8 to 30 electrons, and the nominal
#    dark current is -1 to 1 electron per second.
#
# Deficiencies:
#    -  There is no validation of the frame types.
#
# Tasks:
#    KAPPA: STATS, SUB.
#
# Authors:
#    MJC: Malcolm J. Currie (JAC)
#
# Copyright:
#    Copyright (C) 1998--2002 Particle Physics and Astronomy Research
#    Council.  All Rights Reserved.
#
#-

# Create the results file if needed.
# ==================================

# Create a results file if one does not exist.
     my $results = $ENV{'ORAC_DATA_OUT'} . "/ufti_array_tests.log";
     my $fh_results;
     if ( !( -e $$fh_results ) ) {
       open( $fh_results, ">$results" ) ||
         orac_throw "Unable to open a new array-test $results log file.  Error: $!.\n";

        orac_print "Creating a new results file called $results\n";

# Write the column headings into the result file.
        print $fh_results " UT  Date       ND_STARE_RN      Dark Current\n";
        print $fh_results "----------      -----------      ------------\n";
     } else {
       open( $fh_results, ">>$results" ) ||
         orac_throw "Unable to append to the array-test $results log file.  Error: $!.\n";
     }

# Compute the statistics.
# =======================

# Wait until all the array tests are completed.  Should be four frames.
# Change to be "every four frames" rather than "four frames" to
# compensate for current lack of implementation of UFTI groups.
     if ( ( $Grp->num + 1 ) % 4 == 0 ) {

# Obtain the exposure time of the last and current frame.
        my $exptime = $Frm->uhdr( "ORAC_EXPOSURE_TIME" );
        $exptime = defined( $exptime ) ? $exptime : 60.0;

# Obtain the gain.
        _GET_GAIN_
        my $adu = $_GET_GAIN_{GAIN};
  
# Obtain the names of the group members.
        my @frames = $Grp->membernames;

# Difference the first two (ND_STARE) frames.  The first ARRAY_TESTS frame
# is ignored.
        my $param = "in1=$frames[1] in2=$frames[2] out=array_test";
        $Mon{ "kappa_mon" }->obeyw( "sub", "$param" );

# Find the standard deviation of the difference frame after a 3-sigma clipping.
        $Mon{ "kappa_mon" }->obeyw( "stats", "ndf=array_test clip=3" );
        ( my $ORAC_STATUS, my $nd_stare_sigma ) = $Mon{ "kappa_mon" }->get( "stats", "sigma" );
        my $nd_stare_rn = $nd_stare_sigma / sqrt( 2.0 ) * $adu;

# Find the clipped mean of the fourth frame, a dark frame.
        $Mon{ "kappa_mon" }->obeyw( "stats", "ndf=$frames[3] clip=3" );
        ( $ORAC_STATUS, my $mean ) = $Mon{ "kappa_mon" }->get( "stats", "mean" );
        my $dark = $mean / $exptime * $adu;

# Obtain the date.
        my $utdate = substr( $Frm->hdr( "DATE-OBS" ), 0, 10 );

# Remove the temporary file.
        _DELETE_A_FRAME_ FRAME=array_test

# Output the results.
# ===================

# Format the results.
        my $fs_nsr = sprintf( "%9.2f", $nd_stare_rn );
        my $fs_dark = sprintf( "%9.2f", $dark );

# Write the results to the log file.
        printf $fh_results "%10s %16s %17s\n", $utdate, $fs_nsr, $fs_dark;
        close( $fh_results );

# Remove leading spaces.
        $fs_nsr =~ s/ //;
        $fs_dark =~ s/ //;

# Report the results to the user.
        orac_print "\n";
        orac_print "ND_STARE mode readout noise (e-) = $fs_nsr\n";
        orac_print "Dark current (e-/sec)            = $fs_dark\n";
        orac_print "\n";

# Report upon the status of the results.
# ======================================

# ND_STARE readout noise.  May need to make the nominal value a parameter.
        if ( $nd_stare_rn < 8.0 ) {
           orac_warn "ND_STARE readout noise is LOW with respect to nominal 23e-.  Repeat the exec.\n";
        } elsif ( $nd_stare_rn > 30.0 ) {
           orac_warn "ND_STARE readout noise is HIGH with respect to nominal 23e-\n";
        } else {
           orac_print "** ND_STARE readout noise is nominal **\n";
        }

# Dark current.  May need to make the nominal value a parameter.  Negative allows for
# noise and possible small systematic bias. 
        if ( $dark < -1.0 ) {
           orac_warn "Dark current is NEGATIVE, weird; nominal is -1 to 1e-/sec\n";
        } elsif ( $dark > 1.0 ) {
           orac_warn "Dark current is HIGH with respect to nominal 0 to 1e-/sec\n";
        } else {
           orac_print "** Dark current is nominal **\n";
        }
        orac_print "\n";

# File the readnoise in the calibration system.
# =============================================

# The value needs to be in a hash.  Use the current frame as a reference
# for this, as it has the same readout mode and speed/well depth as the
# others.
        my %hash = ( %{ $Frm->hdr }, READNOISE => $nd_stare_rn );
        $Cal->readnoiseindex->add( $Frm->file, \%hash );

        orac_print "Readnoise filed with the calibration system.\n\n";

     }

# Podule
# ======

=head1 NAME

_ARRAY_TEST_STATISTICS_ -- Determines the state of the UFTI detector for the ARRAY_TESTS recipe.

=head1 DESCRIPTION

This primitive evaluates the readout noise in electrons and the
dark current in electrons per second for UFTI.  The script also
reports these statistics, indicating whether or not they are
nominal.  The results are also logged to a text file,
F<ufti_array_tests.log> in the F<$ORAC_DATA_OUT> directory, to
monitor secular trends. The ND_STARE readnoise is written to the
calibration index.

The primitive expects sets of four frames.  In each set the first
refresh frame is ignored, then come two ND_STARE frames, followed
by a dark.

=head1 NOTES

=over 4

=item *

The exposure time comes from the ORAC_EXPOSURE_TIME header,
defaulting to 60.0s if the header is undefined.  The ADU comes
from the L<_GET_GAIN_|_GET_GAIN_> primitive.

=item *

If the log file does not exist, a new one is created containing
a two-line heading, and the fact is reported.

=item *

The log file stores the results in a fixed columnar format.

=item *

The noise is the standard deviation per frame of the second and
third frames subtracted, and converted from counts to electrons.

=item *

The dark current is the three-sigma-clipped mean count of the
dark count normalised to unit time and converted to electrons.

=item *

The nominal readout noise is 8 to 30 electrons, and the nominal
dark current is -1 to 1 electron per second.

=back

=head1 DEFICIENCIES

=over 4

=item *

There is no validation of the frame types.

=back

=head1 TASKS

KAPPA: STATS, SUB.

=head1 AUTHORS

MJC: Malcolm J. Currie (JAC)

=head1 COPYRIGHT

Copyright (C) 1998--2002 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut
