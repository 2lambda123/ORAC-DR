#+
# Name:
#    _IMAGING_HELLO_
#
# Purpose:
#    Performs global data-reduction tasks for Michelle in imaging mode.
#
# Language:
#    Perl5
#
# Description:
#    This primitive does the preparatory work for recipes used by 
#    Michelle in imaging mode.
#
#    It permits display of the raw data, sets the pixel origin, and
#    switches on history recording.  It copies the raw data integrations;
#    and if there's only one integration, it merges the integration and
#    the headers into a simple NDF.  The data values for ND modes are
#    brought into line with other instruments, and are total ADU, not
#    ADU/s.
#
# Notes:
#    -  The readout lower bounds in the frame internal headers
#    ORAC_X_LOWER_BOUND and ORAC_Y_LOWER_BOUND define the pixel origin. 
#    No origin is set if these do not exist.  A default 1,1 origin is
#    set for undefined bounds (to cope with early data).
#    -  Corrects the acquisition bug which sets ORAC_WAVEPLATE_ANGLE
#    internal header to be a comment instead of value 0.  It changes both
#    the actual headers and the $Frm->uhdr hash.
#
# Output Data:
#    -  Copied frame inheriting the current frame's name but with 
#    the _cl (IRCAM) and the _raw suffix (Michelle).
#    -  Linearity-corrected frame inheriting the current frame's name
#    but with the _nl suffix (IRCAM only).
#    -  For NDSTARE and NDCHOP Michelle data, the data scaled to ADU
#    in a frame inheriting the current frame's name but with the _adu
#    suffix.  The read type comes from header ORAC_DETECTOR_READ_TYPE. 
#
# Tasks:
#    KAPPA: CMULT, FITSMOD, HISSET, NDFCOPY, SETORIGIN.
#
# Authors:
#    MJC: Malcolm J. Currie (JAC)
#
# Copyright:
#    Copyright (C) 1998-2001 Particle Physics and Astronomy Research
#    Council.  All Rights Reserved.
#
#-

# Every imaging recipe must display the raw data.
    _DISPLAY_FRAME_IMAGE_
    orac_print "\n";

    my ( $in, $out, $param1, $param2 );

# Are the data chopped?
    my $chop = $Frm->uhdr( "ORAC_DETECTOR_READ_TYPE" ) eq "CHOP" ||
               $Frm->uhdr( "ORAC_DETECTOR_READ_TYPE" ) eq "NDCHOP";

# Copy the original data.
# =======================
    if ( $Frm->nfiles == 1 && ! $chop ) {

# Generate list of input and output filenames.
       ( $in, $out ) = $Frm->inout( "_raw" );

# Copy the single integration to an _raw output frame, which may be
# manipulated.
       $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "in=$in out=$out" );

# Update the output filename in the Frame object.  Merge the headers.
       $Frm->files( $out );
       $Frm->mergehdr;

# Report the processing status.
       orac_print "$in to $out: Copied NDF component.\n";

# For chopped data there must be two integrations, both of which must
# be copied.
    } elsif ( $chop && $Frm->nfiles == 2 ) {
       foreach my $i ( 1 .. $Frm->nfiles ) {

# Copy the raw data to an _raw output frame, which may be manipulated.
          ( my $in, my $out ) = $Frm->inout( "_raw", $i );
          $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "in=$in out=$out title=$out" );

# Report the processing status.
          orac_print "$in to $out: Copied NDF component.\n";

# Update the Frame object.
          $Frm->file( $i, $out );
       }

# Abort if more integrations are present.
    } elsif ( $chop ){ 
       orac_err "Only two integrations (one in each chopped beam) " .
                "per observation is supported.\n";  
    } else {
       orac_err "Only one integration per observation is supported.";
    }

# Correct the WPLANGLE header.
# ============================

# Specify the NDF.
    $in = $Frm->file;

# See if WPLANGLE has a value.
    if ( !defined( $Frm->uhdr( "ORAC_WAVEPLATE_ANGLE" ) ) ) {

# Set the internal hash for WPLANGLE to value 0.  This will allow the
# flat-field rules to work even if WPLANGLE had no value in the raw
# frame.
       $Frm->uhdr( "ORAC_WAVEPLATE_ANGLE", 0 );

# The data also need to be changed so that the flat can be filed.
# Thus correct the FITS header WPLANGLE value too.  This assumes that
# there is a keyword corresponding to the ORAC_WAVEPLATE_ANGLE.  Note
# that the input file name remains the same.
       my %keywords =  $Frm->translate_hdr( "ORAC_WAVEPLATE_ANGLE" );
       my @wplakey = keys( %keywords );
       $param1 = "edit=update keyword=$wplakey[ 0 ] value=0.0 comment=\\\$C position=!"; 
       $Mon{ "ndfpack_mon" }->obeyw( "fitsmod", "ndf=$in $param1" );
    }

# Set the bounds of the NDF.
# ==========================

# Wavefront sensing uses ORAC-DR where readout bounds may not
# be present.  The default origin of (1,1) will be used.
    if ( exists $Frm->uhdr->{ "ORAC_X_LOWER_BOUND" } ) {

# Read readout bounds from the headers.
       my $x1 = $Frm->uhdr( "ORAC_X_LOWER_BOUND" );
       my $y1 = $Frm->uhdr( "ORAC_Y_LOWER_BOUND" );

# Allow for old data where the headers were not available.
       if ( ! ( defined( $x1 ) && defined( $y1 ) ) ) {
          $x1 = 1;
          $y1 = 1;
       }

# Set the parameters for the task.
       $param1 = "ndf=$in origin=[$x1,$y1]";

# Set the pixel origin.
       $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "$param1" );

# Report the processing status.
       orac_print "Frame $in has origin set to ($x1,$y1).\n";
    }

# Initiate history recording.
# ===========================
    $Mon{"ndfpack_mon"}->obeyw( "hisset", "ndf=$in" );

# Report the processing status.
    orac_print "Frame $in has history recording enabled.\n";

# Correct data units to standard
# ==============================

# This correction only applies to NDSTARE and NDCHOP modes.
    if ( substr( $Frm->uhdr( "ORAC_DETECTOR_READ_TYPE" ), 0, 2 ) eq "ND" ) {

# The data are in ADU/s, which is not the UKIRT standard.  So obtain
# the exposure time and multiply the data by this factor.
       my $exp_time = $Frm->uhdr( "ORAC_EXPOSURE_TIME" );

       foreach my $i ( 1 .. $Frm->nfiles ) {

# Generate list of input and output filenames.
          ( $in, $out ) = $Frm->inout( "_adu", $i );

# Scale the data.
          $Mon{ "kappa_mon" }->obeyw( "cmult", "in=$in scalar=$exp_time out=$out" );

# Report the processing status.
          orac_print "$in to $out: Scaled data by the exposure time " .
                     "($exp_time) to make the units ADUs.\n";

# Now update the output filename in the Frame object.
          $Frm->file( $i, $out );
       }
    }

# Report completed processing status for Michelle.
    orac_print "Global Michelle tasks performed.\n\n";

# Podule
# ======

=head1 NAME

_IMAGING_HELLO_  -- Performs global data-reduction tasks for Michelle in imaging mode.

=head1 DESCRIPTION

This primitive does the preparatory work for recipes used by 
Michelle in imaging mode.

It permits display of the raw data, sets the pixel origin, and
switches on history recording.  It copies the raw data integrations;
and if there's only one integration, it merges the integration and the
headers into a simple NDF.  The data values for ND modes are brought
into line with other instruments, and are total ADU, not ADU/s.

=head1 NOTES

=over 4

=item *

The readout lower bounds in the frame internal headers
ORAC_X_LOWER_BOUND and ORAC_Y_LOWER_BOUND define the pixel origin.  No
origin is set if these do not exist.  A default 1,1 origin is set for
undefined bounds (to cope with early data).

=item *

Corrects the acquisition bug which sets ORAC_WAVEPLATE_ANGLE internal
header to be a comment instead of value 0.  It changes both the actual
headers and the $Frm->uhdr hash.

=back

=head1 OUTPUT DATA

=over 4

=item *

Copied frame inheriting the current frame's name but with 
the _raw suffix.

=item *

For NDSTARE and NDCHOP Michelle data, the data scaled to ADU
in a frame inheriting the current frame's name but with the _adu
suffix.  The read type comes from header ORAC_DETECTOR_READ_TYPE. 

=back

=head1 TASKS

KAPPA: CMULT, FITSMOD, HISSET, NDFCOPY, SETORIGIN.

=head1 AUTHORS

MJC: Malcolm J. Currie (JAC)

=head1 COPYRIGHT

Copyright (C) 1998-2001 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut
