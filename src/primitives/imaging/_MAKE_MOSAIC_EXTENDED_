#+
# Name:
#    _MAKE_MOSAIC_EXTENDED_
#
# Purpose:
#    Forms mosaics for an EXTENDED recipe.
#
# Language:
#    Perl5
#
# Description:
#    This primitive either makes a mosaic of object frames either
#    in the current row or a `grand' mosaic of the whole of the
#    current $Grp of an EXTENDED recipe.  There are two main
#    stages: resampling and making the mosaic.
#
#    The primitive either resamples each frame using the non-integer
#    Cartesian offsets, or merely finds the offsets between frames to
#    the nearest pixel and shifts the origin (see argument RESAMPLE).
#    The resampling or shifting imposes no limit to the frame bounds,
#    so the mosaic extends to include all pixels in contributing frames. 
#
#    The primitive then makes a mosaic using zero-point shifts to give
#    the most self-consistent mosaic based upon the statistics of
#    overlapping pixels.  On the final row the primitive creates 
#    the grand mosaic combining all target frames.  On the first cycle 
#    of the recipe (normally there is only one) the grand mosaic becomes
#    the group file and its headers read.  On subsequent recipe cycles,
#    the current grand mosaic is added into the group `grand' mosaic.
#
# Arguments:
#    INT_METHOD = CHARACTER (Given)
#       The interpolation method.  This is either "linint" for bi-linear
#       interpolation, or "nearest" for nearest neighbour.  The latter
#       takes about half the time.  ["linint"]
#    RESAMPLE = LOGICAL (Given)
#       If true (1), resample the current cycle's frames to the same
#       Cartesian co-ordinate system using the method given by argument
#       INT_METHOD.  If false (0), use integer offsets and changes of
#       origin to register the frames.  The latter is many times
#       faster and is recommended for pipeline operation.
#
# Notes:
#    -  This primitive is suitable for UFTI, IRCAM, and Michelle 
#    in imaging mode.
#    -  Processing only occurs for object and sky frames, and when
#    either steering header MAKE_MOSAIC or MAKE_GRAND_MOSAIC is
#    true.  Mosaic making occurs only for groups members with the
#    steering header TARGET_OR_SKY is "target", and for a grand
#    mosaic only within the current recipe as given by steering
#    header CYCLE_NUMBER.
#    -  When RESAMPLE is false, the offset files (.off extension)
#    associated with each frame are interrogated to find one common
#    object---the one with identifier 1---as would be the case if
#    telescope or central-source offsets are used.  For each frame
#    the read x-y co-ordinates rounded to the nearest integer and
#    with opposite sign become the new origin.
#    -  Group internal header ROOT_NAME stores the name of the grand
#    mosaic excluding any suffix.  It is written for the first cycle,
#    and read back for subsequent cycles of the recipe.
#    -  The end airmass of the mosaics are revised to the limiting
#    value for the last contributing frame.
#    -  The individual row mosaic and grand mosaic are displayed.
#    -  The frame titles are propagated.
#    -  The optimum number of overlaps for the mosaic creation is 
#    two for a row and six for a grand mosaic.
#    -  Code to concatenate field rotation into the resampling is
#    commented out.  This is because rotation should be handled by the
#    world co-ordinate system, not by resampling and hence degrading the
#    data.
#
# Tasks:
#    CCDPACK: MAKEMOS, TRANNDF; KAPPA: ADD, FITSMOD, NDFCOPY,
#    SETORIGIN.
#
# Output Data:
#    -  The grand mosaic, which is called is "<groupname>", where
#    <groupname> is the name of the group.  For multiple cycles,
#    individual grand mosaics are also retained and called
#    <groupname>_<cyclenumber>", where <cyclenumber> is the cycle
#    number derived from steering header CYCLE_NUMBER.
#    -  The row mosaics of the last cycle in <groupname>_mos_<row>,
#    where <row> is the number of the row.
#    -  Resampled frames each inheriting the name of its input frame but
#    with the _trn suffix, when RESAMPLE is true.
#
# Authors:
#    MJC: Malcolm J. Currie (JAC)
#
# Copyright:
#    Copyright (C) 1998-2001 Particle Physics and Astronomy Research
#    Council.  All Rights Reserved.
#
#-

# Arguments
# =========

# Obtain the value for the interpolation.
    my $intmethod = ( $_MAKE_MOSAIC_EXTENDED_{INT_METHOD} || "linint" );
    if ( $intmethod ne "linint" && $intmethod ne "nearest" ) {
       $intmethod = "linint";
    }

# Determine whether or not to resample.
    my $resample = $_MAKE_MOSAIC_EXTENDED_{RESAMPLE};
    $resample = defined( $resample ) ? $resample : 1;

# Selection
# =========

# This should only be performed on OBJECT frames.
    if ( $Frm->uhdr( "ORAC_OBSERVATION_TYPE" ) eq "OBJECT"  ||
         $Frm->uhdr( "ORAC_OBSERVATION_TYPE" ) eq "SKY" ) {

# Obtain the cycle number.  Default to zero if undefined, so that recipes
# which do not support this feature will continue to work.
       my $cycleno = $Frm->uhdr( "CYCLE_NUMBER" );
       $cycleno = defined( $cycleno ) ? $cycleno : 0;

# Obtain the current row number.
       my $ext_row = $Frm->uhdr( "EXTENDED_ROW" );

# Determine whether it is time to make a mosaic.
       my $makemosaic = $Frm->uhdr( "MAKE_MOSAIC" );
       my $grandmosaic = $Frm->uhdr( "MAKE_GRAND_MOSAIC" );
       if ( $makemosaic || $grandmosaic ) {

# Determine whether the full mosaic is required, otherwise make the
# mosaic for the current row.
          my $tarGrp;
          if ( $grandmosaic ) {

# Form a subgroup comprising all the target frames within the current
# cycle.
             $tarGrp = $Grp->subgrp( TARGET_OR_SKY => "target",
                                     CYCLE_NUMBER => $cycleno );

          } else {

# Form a subgroup comprising all the target frames in the current row.
             $tarGrp = $Grp->subgrp( TARGET_OR_SKY => "target",
                                     EXTENDED_ROW => $ext_row );
          }

# Form a list of the input and output target file names for CCDPACK tasks.
          ( my $inref, my $outref ) = $tarGrp->inout( "_trn" );

# Specify the mosaic suffix.
          my $osuffix = "_mos";

# Convert the list to a comma-separated list as needed by CCDPACK (GRP).
          my $inlist = join( ",", @$inref );
          my $outlist= join( ",", @$outref );

# Concatenate rotation to transformation
# ======================================

# Specify the other parameters for the TRANJOIN stage.  Note that the
# rotation occurs first and the translation seconds as we are using 
# offsets measured in equatorial not Cartesian co-ordinates.
          my ( $param1, $param2 );
          if ( $resample ) {

#             $param2 = "in1=".$Cal->rotation." dest=second"; 

# Join the rotation transformation to each of the CCDPACK extensions.
# The rotation transformation follows the shift-of-origin and is stored
# in the input frame.  Unfortunately, CCDEDIT doesn't support joining
# transformations, and KAPPA/TRANJOIN does operate on lists of files.
# Write the input file names to the text files.
#             foreach $flatted (@$inref) {
#                $param1 = "in2=${flatted}.more.ccdpack.transform";
#                $Mon{ "kappa_mon" }->obeyw( "tranjoin", "$param1 $param2 accept" );
#             }

# Report the status.
#             orac_print "Rotation transformation joined\n";

# Resampling
# ==========

# Create text files to hold the list of input and output files, one per line.
# This is needed because expanded lists of files may make the command line
# too long for the ADAM message system.
             unlink( "tranndf.inlist$$", "tranndf.outlist$$" );

             open( INLIST, ">tranndf.inlist$$" ) ||
               orac_throw "Unable to open tranndf.inlist$$ to create a list of frames to resample.  Error: $!.\n";
             print INLIST join( "\n", @$inref ), "\n";
             close( INLIST );

             open( OUTLIST, ">tranndf.outlist$$" ) ||
               orac_throw "Unable to open objlist.outlist$$ to create a list of resampled frames.  Error: $!.\n";
             print OUTLIST join( "\n", @$outref ), "\n";
             close( OUTLIST );

# Assign the other parameters.  Determime the bounds automatically.  It takes
# the origin from the first target frame.
             $param1 = "in='^tranndf.inlist$$' out='^tranndf.outlist$$'";
             $param2 = "shape=auto method=$intmethod title=!";

# Shift and resample the flat-field object frames.  This determines
# the bounds automatically.  It takes the origin from the first object
# frame.
             $Mon{ "ccdpack_reg" }->obeyw( "tranndf", "$param1 $param2" );

# Report the processing status.
             orac_print "Frames $inlist resampled\n";
             orac_print "Resampled frames are $outlist\n";

          } else {

# Derive the offsets
# ==================

# The matched offsets may not be with the first-ranked item, especially 
# if it is extended, although most cases it will find a #1.  So prepare
# to loop a few times until an identification number is available.
# Currently it is limited to nine id numbers, so it's far from perfect, but
# it will be very rare (in practice once a year) for this not to work.
# It will be a faint or low surface-brightness  galaxy at low galactic
# latitude where the stars relegate the galaxy to a high id number.
             my $id = 1;
             my $match = 0;
             my ( @xoffsets, @yoffsets );
             NEXTID: while ( $id < 10 && !$match ) {

# Open the offset files and store the co-ordinates.  Note that this
# assumes central-source or telescope offsets have been used, and that there
# is but one position in each.
                @xoffsets = ();
                @yoffsets = ();
                foreach my $Frame ( $tarGrp->members ) {
                   my $offfile = $Frame->file . ".off";

                   open( OFFFILE, "<$offfile" ) ||
                     orac_throw "Missing $offfile offset text file.\n";

# Store the offsets.
                   my $offfound = 0;
                   foreach my $line ( <OFFFILE> ) {

# Match the identification number  followed by a space in case there are
# more than nine objects, unlikely but possible.
                      my @fields;
                      if ( $line =~ /^$id\s/ ) {
                         @fields = split( /\s+/, $line );
                         push( @xoffsets, $fields[ 1 ] );
                         push( @yoffsets, $fields[ 2 ] );
                         $offfound = 1 ;
                         last;
                      }
                   }
                   close( OFFFILE );

# Cannot proceed unless the x-y offsets were found.
                   if ( ! $offfound ) {
                      orac_err "No object #$id in $offfile offset text file.\n";

# Try the next identification.
                      $id++;
                      next NEXTID;
                   }
                }

# Convert the offsets to be displacements of the origin to the nearest pixel.
                my $framecount = 0;
                foreach my $frame ( @xoffsets ) {
                   $xoffsets[ $framecount ] = -int( $xoffsets[ $framecount ] + 0.5 );
                   $yoffsets[ $framecount ] = -int( $yoffsets[ $framecount ] + 0.5 );
                   $framecount++;
                }

# We have a match, so exit the loop.
                $match = 1;
             }

# Change of origin
# ================

# Loop through all the members of the group, as KAPPA task can only handle
# one data file at a time.
             foreach my $Frame ( $tarGrp->members ) {
                my $frame = $Frame->file;

# Assign the other parameters.  Use the original bounds.  Note we do not
# resample the main mosaic if one exists.
                $param1 = "ndf=$frame origin=[$xoffsets[0],$yoffsets[0]]";

# Shift the first item from the lists of displacements.
                shift( @xoffsets );
                shift( @yoffsets );

# Apply change of origin to the current frame.
                $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "$param1" );
             }

# Create text files to hold the list of 'output' files, one per line.
# The files are modified in situ, but are the equivalent of the output files
# if resampling is performed.  This is needed because the command may be long.
# Expanded lists of files may make the command line too long for the ADAM
# message system.
             unlink( "tranndf.outlist$$" );

             open( INLIST, ">tranndf.outlist$$" ) ||
               orac_throw "Unable to open tranndf.outlist$$ to create a list of frames to form mosaic.  Error: $!.\n";
             print INLIST join( "\n", @$inref ), "\n";
             close( INLIST );

# Report the processing status.
             orac_print "Frames $inlist have origin shifted.\n";
          } 

# Make mosaic.
# ============

# Derive a reasonable number of overlaps to generate a mosaic, yet not
# make all the possible comparisons for efficiency.
          my $optov;
          if ( $grandmosaic ) {
             $optov = 6;
          } else {
             $optov = 2;
          }

# Define the mosaic name.  Define root name for the group for the first
# cycle.  On later grand mosaics read the group root name from the group
# header.
          my ( $grproot, $outname );
          if ( $grandmosaic ) {
             if ( $cycleno == 0 ) {
                $grproot = $Grp->file;
                $outname = $grproot . $osuffix

             } else {
                $grproot = $Grp->uhdr( "ROOT_NAME" );
                $outname = $grproot . $osuffix . "_" . $cycleno
             }

          } else {
             if ( defined $Grp->uhdr( "ROOT_NAME" ) ) {
                $outname = $Grp->uhdr( "ROOT_NAME" ) . "_row" . $ext_row . $osuffix; 
             } else {
                $outname = $Grp->file . "_row" . $ext_row . $osuffix; 
             }
          }

# Assign other parameters.  The scale might become a user parameter.
          $param1 = "in='^tranndf.outlist$$' out=$outname title=!";
          $param2 = "zero optov=$optov";

# Make the mosaic correcting for differences in offset.
          $Mon{ "ccdpack_reg" }->obeyw( "makemos", "$param1 $param2" );
          unlink( "tranndf.inlist$$", "tranndf.outlist$$" );

# Report the processing status.
          orac_print "Mosaic $outname formed\n";

# Display the resultant mosaic.
          $tarGrp->file( $outname );
          $Display->display_data( $tarGrp ) if ( defined $Display );

# Define the group file and headers.
# ==================================

# Set the group name in the Group object...
          if ( $grandmosaic && $cycleno == 0 ) {

             $Grp->file( $outname );

# ...and read the header.
             $Grp->readhdr;

# Store the root name.
             $Grp->uhdr( "ROOT_NAME", $grproot );

          }

# On the second and subsequent grandmosaic cycle, we just need to
# add the single-cycle mosaic into the main mosaic.
          if ( $cycleno > 0 && $grandmosaic ) {

# Make a duplicate of the main mosaic.
             my $tmpmos = "mainmos$$";
             $param1 = "in=" . $Grp->file . " out=$tmpmos";
             $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$param1" );

# Add the frames.
             $param1 = "in1=$tmpmos in2=$outname out=" . $Grp->file;
             $Mon{ "kappa_mon" }->obeyw( "add", "$param1" );

# Copy the first cycle mosaic from its temporary home.  This leaves the
# mosaics for each and every individual jitter to be examined later.
# Remove the temporary copy.
             if ( $cycleno == 1 ) {
                $param1 = "in=$tmpmos out=" . $Grp->file . "_0";
                $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$param1" );
             }
             _DELETE_A_FRAME_ FRAME=$tmpmos

             orac_print "Frame $outname added into main mosaic " . $Grp->file . "\n";

# Display the main mosaic.
             _DISPLAY_GROUP_IMAGE_
          }

# Change the end airmass to reflect the last frame included in the mosaic. 
# Note this is done to the physical file as well as the ORAC-DR internal
# header.  This applies to both the row and grand mosaics.  The start
# airmass is defined by the first frame used to make either type of mosaic.
          my $amendname = "ORAC_AIRMASS_END";
          my %keywords = $Frm->translate_hdr( $amendname );
          my @amendkey = keys( %keywords );
          my $amend = $tarGrp->frame( $tarGrp->num )->uhdr( $amendname );
          $tarGrp->uhdr( $amendname, $amend );
          if ( $grandmosaic ) { $Grp->uhdr( $amendname, $amend ); }
          $param1 = "ndf=$outname keyword=$amendkey[ 0 ] edit=update value=$amend position=!";
          $Mon{ "ndfpack_mon" }->obeyw( "fitsmod", "$param1 comment=\\\$C" );

          orac_print "\n";
       }
    }

# Podule
# ======

=head1 NAME 

_MAKE_MOSAIC_EXTENDED_ -- Forms mosaics for an EXTENDED recipe.

=head1 DESCRIPTION

This primitive either makes a mosaic of object frames either
in the current row or a `grand' mosaic of the whole of the
current $Grp of an EXTENDED recipe.  There are two main
stages: resampling and making the mosaic.

The primitive either resamples each frame using the non-integer
Cartesian offsets, or merely finds the offsets between frames to
the nearest pixel and shifts the origin (see argument RESAMPLE).
The resampling or shifting imposes no limit to the frame bounds,
so the mosaic extends to include all pixels in contributing frames. 

The primitive then makes a mosaic using zero-point shifts to give
the most self-consistent mosaic based upon the statistics of
overlapping pixels.  On the final row the primitive creates 
the grand mosaic combining all target frames.  On the first cycle 
of the recipe (normally there is only one) the grand mosaic becomes
the group file and its headers read.  On subsequent recipe cycles,
the current grand mosaic is added into the group `grand' mosaic.

=head1 ARGUMENTS

=over 4

=item INT_METHOD = CHARACTER (Given)

The interpolation method.  This is either "linint" for bi-linear
interpolation, or "nearest" for nearest neighbour.  The latter
takes about half the time.  ["linint"]

=item RESAMPLE = LOGICAL (Given)

If true (1), resample the current cycle's frames to the same
Cartesian co-ordinate system using the method given by argument
INT_METHOD.  If false (0), use integer offsets and changes of
origin to register the frames.  The latter is many times
faster and is recommended for pipeline operation.

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for UFTI, IRCAM, and Michelle in imaging mode.

=item *

Processing only occurs for object and sky frames, and when either
steering header MAKE_MOSAIC or MAKE_GRAND_MOSAIC is true.  Mosaic
making occurs only for groups members with the steering header
TARGET_OR_SKY is "target", and for a grand mosaic only within the
current recipe as given by steering header CYCLE_NUMBER.

=item *

When RESAMPLE is false, the offset files (.off extension)
associated with each frame are interrogated to find one common
object---the one with identifier 1---as would be the case if
telescope or central-source offsets are used.  For each frame
the read x-y co-ordinates rounded to the nearest integer and
with opposite sign become the new origin.

=item *

Group internal header ROOT_NAME stores the name of the grand mosaic
excluding any suffix.  It is written for the first cycle, and read
back for subsequent cycles of the recipe.

=item *

The end airmass of the mosaics are revised to the limiting value for
the last contributing frame.

=item *

The individual mosaic and grand mosaic are displayed.

=item *

The frame titles are propagated.

=item *

The optimum number of overlaps for the mosaic creation is 
two for a row and six for a grand mosaic.

=item *

Code to concatenate field rotation into the resampling is
commented out.  This is because rotation should be handled by the
world co-ordinate system, not by resampling and hence degrading the
data.

=back

=head1 TASKS

CCDPACK: MAKEMOS, TRANNDF; KAPPA: ADD, FITSMOD, NDFCOPY, SETORIGIN.

=head1 OUTPUT DATA

=over 4

=item *

The grand mosaic, which is called is "E<lt>groupnameE<gt>", where
E<lt>groupnameE<gt> is the name of the group.  For multiple cycles,
individual grand mosaics are also retained and called
"E<lt>groupnameE<gt>_E<lt>cyclenumberE<gt>", where E<lt>cyclenumberE<gt> is the cycle
number derived from steering header CYCLE_NUMBER.

=item *

The row mosaics of the last cycle in E<lt>groupnameE<gt>_mos_E<lt>rowE<gt>,
where E<lt>rowE<gt> is the number of the row.

=item *

Resampled frames each inheriting the name of its input frame but
with the _trn suffix, when RESAMPLE is true.

=back

=head1 AUTHORS

MJC: Malcolm J. Currie (JAC)

=head1 COPYRIGHT

Copyright (C) 1998-2001 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut
