=head1 NAME

_MEASURE_READNOISE_ - measures readnoise for an array tests sequence
for UIST.

=head1 DESCRIPTION

This primitive measures the readnoise for a group of UIST dark frames,
reports it to the user, and files this readnoise in a log file if it
is being run at UKIRT.

This primitive assumes the following order for an array tests sequence:

=over 4

=item One throwaway frame used to "clean up" the array before statistics
are done on the remaining frames.

=item A group of frames that will be used to determine the readnoise.
These frames should be short-exposure DARKs.

=back

=head1 NOTES

=over 4

=item *

The readnoise is nominal if it falls between 40 and 45 e-/seconds.

=back

=head1 AUTHORS

Brad Cavanagh <b.cavanagh@jach.hawaii.edu>

=head1 COPYRIGHT

Copyright (C) 2002 Particle Physics and Astronomy Research
Council. All Rights Reserved.

=cut

# Bring in Starlink::HDSPACK::copobj
use Starlink::HDSPACK qw/ copobj /;

if ( $Frm->uhdr( "MEASURE_READNOISE" ) ) {

  # Initially flag the file as not being writable.
  my $writable = 0;
  if( -e "/ukirt_sw/logs" ) {

    # Create a results file if one does not exist.
    my $results = "/ukirt_sw/logs/uist_array_tests.log";

    if( -w $results ) {
      $writable = 1;
    }
    if( !( -e $results) ) {
      if( $writable ) {
        open( RESULTS, ">$results" ) ||
          orac_throw "Unable to open a new array-test $results log file. Error: $!.\n";
        orac_print "Creating a new results file called $results\n";

        print RESULTS " UT  Date         Readnoise     Dark Current\n";
        print RESULTS "----------        ---------     ------------\n";
      } else {
        orac_warn "Unable to write to new array-test $results log file.\n";
      }
    } else {
      if( $writable ) {
        open( RESULTS, ">>$results" ) ||
          orac_throw "Unable to append to the array-test $results log file. Error: $!.\n";
      } else {
        orac_warn "Unable to append to the array-test $results log file.\n";
      }
    }
  }

  orac_print "Calculating NDSTARE readnoise.\n";

  # Create a new output file name.
  my $out = "readnoise_" . $Frm->findgroup;

  # Grab the list of filenames in the current group.
  my @files = $Grp->membernames;

  # Determine the number of DARK frames and total frames in the group.
  my $dark_frames = $Frm->uhdr("DARK_FRAMES");
  my $nfiles = $#files; # This is actually total frames - 1.

  # Create a temporary file to hold the 'mean' image.
  my $tfile1 = new ORAC::TempFile;
  my $tfile1name = $tfile1->file;

  # Form the parameter string.
  my $param1 = "alpha=0 expose=1 keepin=true logfile=! method=mean";
  my $param2 = "out=$tfile1name in='^makecal.inlist$$'";

  # Create a textfile containing the names of the files we'll be
  # averaging together.
  unlink( "makecal.inlist$$" );
  open( INLIST, ">makecal.inlist$$" ) ||
    orac_throw "Unable to open makecal.inlist$$ to create a list of frames to combine. Error: $!.\n";
  print INLIST join( "\n", @files[$nfiles-$dark_frames+1..$nfiles] ), "\n";
  close( INLIST );

  $Mon{'ccdpack_red'}->obeyw( "makecal", "$param1 $param2" );

  # Remove the Variance array in the 'mean' image, just in case
  # one was put in.
  $Mon{'ndfpack_mon'}->obeyw( "setvar", "ndf=$tfile1name Variance=!" );

  # Now we need to calculate the population variance estimate, then 
  # copy that into the the Variance array in the 'mean' image.
  my $tfile2 = new ORAC::TempFile;
  my $tfile2name = $tfile2->file;

  # Form the parameter strings for KAPPA/MATHS.
  my $add = "";
  my $files = "";

  # If there are more than nine DARK frames, we're stuffed.
  my %hash = (1=>"IA", 2=>"IB", 3=>"IC", 4=>"ID", 5=>"IE", 6=>"IF", 7=>"IG", 8=>"IH", 9=>"II");
  my $mfile = $dark_frames + 1;
  foreach my $i ($nfiles-$dark_frames+1..$nfiles) {
    my $file = $files[$i];
    my $hashnumber = $i - $nfiles + $dark_frames;
    $files .= $hash{$hashnumber} . "=" . $file . " ";
    $add .= "((" . $hash{$hashnumber} . "-" . $hash{$mfile} . ")*(" . $hash{$hashnumber} . "-" . $hash{$mfile} . "))";
    $add .= " + " if($i != $nfiles);
  }

  my $exp = "( $add ) / ( $dark_frames - 1 )";
  $files .= $hash{$mfile} . "=" . $tfile1name;
  my $param = sprintf("$files exp='(%s)' out=$tfile2name", $exp);

  $Mon{'kappa_mon'}->obeyw( "maths", "$param" );

  # Create a zeroed-out NDF
  $Mon{'kappa_mon'}->obeyw( "cmult", "in=$tfile2name out=$out scalar=0");
  
  # Copy the variance to the Variance array
  my $status = &Starlink::EMS::SAI__OK();
  my $ORAC_STATUS = copobj( "$tfile2name.DATA_ARRAY", "$out.VARIANCE", $status );

  # Obtain the mean of the variance frame
  $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$out comp=Variance clip=3" );

  ( $ORAC_STATUS, my $mean ) = $Mon{'kappa_mon'}->get( "stats", "mean" );

  $mean = sqrt( $mean );

  my $nreads = $Frm->uhdr( "ORAC_NUMBER_OF_READS" ) || 2;
  my $readint = $Frm->hdr( "READINT" ) || 1.0;
  _GET_GAIN_
  my $gain = $_GET_GAIN_{GAIN};
  my $multirds = $Frm->hdr( "MULTIRDS" ) || 1;

  my $readnoise = $mean * ( $nreads - 1 ) * $readint * $gain / ( $multirds );
  
  # Format the output for easier display.
  my $o_readnoise = sprintf( "%9.3f", $readnoise );
  orac_print "NDSTARE readnoise is: $o_readnoise e-/sec.\n";

  # And get an error in the mean as well.
  ( $ORAC_STATUS, my $meanerr ) = $Mon{'kappa_mon'}->get( "stats", "sigma" );

  $meanerr = sqrt( $meanerr );
  # Format the output for easier display.
  my $o_meanerr = sprintf( "%9.3f", $meanerr );
  orac_print "NDSTARE readnoise standard deviation is: $o_meanerr e-/sec.\n\n";

  # Report if low, nominal, or high.
  if( $readnoise < 40.0 ) {
    orac_warn "Readout noise is LOW with respect to nominal 40 e-/sec.\n";
  } elsif ( $readnoise > 45.0 ) {
    orac_warn "Readout noise is HIGH with respect to nominal 45 e-/sec.\n";
  } else {
    orac_print "** Readout noise is nominal **\n";
  }

  # Write to the log file.
  if( -e "/ukirt_sw/logs" && $writable ) {
    my $utdate = substr( $Frm->hdr( "DATE-OBS" ), 0, 10 );
    printf RESULTS "%10s %16s\n", $utdate, $o_readnoise;
    close( RESULTS );
  }

  # File the readnoise with the Cal system.
  # Needs to be in a hash
  my %calhash = (%{$Frm->hdr}, READNOISE=>$readnoise);
  $Cal->readnoiseindex->add($Frm->file, \%calhash);
  orac_print "Readnoise filed with the calibration system.\n";
  
  # Remove temporary text file.
  unlink( "makecal.inlist$$" );

}
