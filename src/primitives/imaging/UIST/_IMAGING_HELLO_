#+
# Name:
#    _IMAGING_HELLO_
#
# Purpose:
#    Performs global data-reduction tasks for UIST in imaging mode.
#
# Language:
#    Perl5
#
# Description:
#    This primitive does the preparatory work for recipes used by 
#    UIST in imaging mode.
#
#    It permits display of the raw data, sets the pixel origin, and
#    switches on history recording.  It copies the raw data integrations;
#    and if there's only one integration, it merges the integration and
#    the headers into a simple NDF.  The data values for ND modes are
#    brought into line with other instruments, and are total ADU, not
#    ADU/s.
#
# Notes:
#    -  The readout lower bounds in the frame internal headers
#    ORAC_X_LOWER_BOUND and ORAC_Y_LOWER_BOUND define the pixel origin. 
#    No origin is set if these do not exist.  A default 1,1 origin is
#    set for undefined bounds (to cope with early data).
#    -  Any AXIS structure and blank title are removed.
#    -  Corrects the acquisition bug which sets ORAC_WAVEPLATE_ANGLE
#    internal header to be a comment instead of value 0.  It changes both
#    the actual headers and the $Frm->uhdr hash.  If the waveplate
#    angle is 180 or greater, the script takes modulo 180 of the waveplate
#    angle, updating both the internal and external headers with the new
#    value.
#
# Output Data:
#    -  Copied frame inheriting the current frame's name but with 
#    the _raw suffix.
#    -  For NDSTARE and NDCHOP UIST data, the data scaled to ADU
#    in a frame inheriting the current frame's name but with the _adu
#    suffix.  The read type comes from header ORAC_DETECTOR_READ_TYPE. 
#
# Tasks:
#    KAPPA: CMULT, FITSMOD, HISSET, NDFCOPY, SETORIGIN.
#
# Authors:
#    MJC: Malcolm J. Currie (JAC)
#
# Copyright:
#    Copyright (C) 1998-2002 Particle Physics and Astronomy Research
#    Council.  All Rights Reserved.
#
#-

# Every imaging recipe must display the raw data.
    _DISPLAY_FRAME_IMAGE_
    orac_print "\n";

    my ( $in, $out, $param1, $param2 );

# Are the data chopped?
    my $chop = $Frm->uhdr( "ORAC_DETECTOR_READ_TYPE" ) eq "CHOP" ||
               $Frm->uhdr( "ORAC_DETECTOR_READ_TYPE" ) eq "NDCHOP";

# Copy the original data.
# =======================
    if ( $Frm->nfiles == 1 && ! $chop ) {

# Generate list of input and output filenames.
       ( $in, $out ) = $Frm->inout( "_raw" );

# Copy the single integration to an _raw output frame, which may be
# manipulated.
       $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "in=$in out=$out" );

# Update the output filename in the Frame object.  Merge the headers.
       $Frm->files( $out );
       $Frm->mergehdr;

# Report the processing status.
       orac_print "$in to $out: Copied NDF component.\n";

# For chopped data there must be two integrations, both of which must
# be copied.
    } elsif ( $chop && $Frm->nfiles == 2 ) {
       foreach my $i ( 1 .. $Frm->nfiles ) {

# Copy the raw data to an _raw output frame, which may be manipulated.
          ( my $in, my $out ) = $Frm->inout( "_raw", $i );
          $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "in=$in out=$out" );

# Report the processing status.
          orac_print "$in to $out: Copied NDF component.\n";

# Update the Frame object.
          $Frm->file( $i, $out );
       }

# Abort if more integrations are present.
    } elsif ( $chop ){ 
       orac_err "Only two integrations (one in each chopped beam) " .
                "per observation is supported.\n";  
    } else {
       orac_err "Only one integration per observation is supported.";
    }

# Correct the WPLANGLE header.
# ============================

# Specify the NDF.
    $in = $Frm->file;

# ***** Kludge Alert ******
#
# There is currently no means of accessing the FITS airlock in the
# multi-NDF container file generically, forced to assumed the
# the data structure for now.  So hardwire the name.
       ( my $inheader = $in ) =~ s/I1BEAMA/HEADER/;

# See if WPLANGLE has a value.
    if ( !defined( $Frm->uhdr( "ORAC_WAVEPLATE_ANGLE" ) ) ) {

# Set the internal hash for WPLANGLE to value 0.  This will allow the
# flat-field rules to work even if WPLANGLE had no value in the raw
# frame.
       $Frm->uhdr( "ORAC_WAVEPLATE_ANGLE", 0 );

# The data also need to be changed so that the flat can be filed.
# Thus correct the FITS airlock value too.  This assumes that there
# is a keyword corresponding to the ORAC_WAVEPLATE_ANGLE.  Note that
# the input file name remains the same.  The implied wildcarding of
# the multi-NDF file by KAPPA would deal with this at one time.
# However, now due to changes in the DR conversion from raw frames, 
# there is only one set of user and external headers per Frm.   Hence
# there is no looping over the integrations.  The current frame is the
# first integration, so we have to access the header NDF.  
       my %keywords =  $Frm->translate_hdr( "ORAC_WAVEPLATE_ANGLE" );
       my @wplakey = keys( %keywords );
       $param1 = "edit=update keyword=$wplakey[ 0 ] value=0.0 comment=\\\$C position=!"; 
       $Mon{ "ndfpack_mon" }->obeyw( "fitsmod", "ndf=$inheader $param1" );

# Correct the waveplate angle to modulo 180 degrees.
# ==================================================

    } elsif ( $Frm->uhdr( "ORAC_WAVEPLATE_ANGLE" ) > 179.99 ) {

# For the polarimetry reductions the waveplate angles are 0, 45, 22.5,
# and 67.5.  Values 180, 225, 202.5, and 247.5 are equivalent.
       my $wplangle = $Frm->uhdr( "ORAC_WAVEPLATE_ANGLE" );
       my $newangle = $wplangle % 180;

# For some reason the orientation angle zero is written as 0.0 rather
# than 0 (unlike 45).  However, below a 180-degree waveplate angle
# mod 180, becomes 0 when written by FITSMOD will change a 180-degree
# angle, thus not be matched by various invocations of the subgrp
# method in the polarimetry code.  So make 0 into 0.0 before storing
# in the user header.  Make it a string to force the trailing 0 to
# appear in the user header.
       if ( abs( $newangle ) < 1E-4 ) {
          $newangle = "0.0";
       } 

# Store the revised value.
       $Frm->uhdr( "ORAC_WAVEPLATE_ANGLE", $newangle );

# The data also need to be changed so that the mosaic will inherit it.
# Thus correct the FITS airlock value too.  This assumes that
# there is a keyword corresponding to the ORAC_WAVEPLATE_ANGLE.  Note
# that the input file name remains the same.  Again we are forced to
# the header-NDF kludge for now.  See the earlier FITSMOD comments for
# more details.
       my %keywords =  $Frm->translate_hdr( "ORAC_WAVEPLATE_ANGLE" );
       my @wplakey = keys( %keywords );
       $param1 = "edit=update keyword=$wplakey[ 0 ] value=$newangle comment=\\\$C position=!"; 
       $Mon{ "ndfpack_mon" }->obeyw( "fitsmod", "ndf=$inheader $param1" );

# Report the processing status.
       orac_print "Frame $in has waveplate angle changed from " .
                  "$wplangle to $newangle (modulo 180).\n";
    }

# Remove unwanted components.
# ===========================
    _REMOVE_AXES_
    _REMOVE_BLANK_TITLE_

# Set the bounds of the NDF.
# ==========================

# Repeat for all the integrations.
    foreach my $i ( 1 .. $Frm->nfiles ) {

# Wavefront sensing uses ORAC-DR where readout bounds may not
# be present.  The default origin of (1,1) will be used.
       if ( exists $Frm->uhdr->{ "ORAC_X_LOWER_BOUND" } ) {

# Read readout bounds from the headers.
          my $x1 = $Frm->uhdr( "ORAC_X_LOWER_BOUND" );
          my $y1 = $Frm->uhdr( "ORAC_Y_LOWER_BOUND" );

# Allow for old data where the headers were not available.
          if ( ! ( defined( $x1 ) && defined( $y1 ) ) ) {
             $x1 = 1;
             $y1 = 1;
          }

# Set the parameters for the task.
          my $in = $Frm->file( $i );
          $param1 = "ndf=$in origin=[$x1,$y1]";

# Set the pixel origin.
          $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "$param1" );

# Report the processing status.
          orac_print "Frame $in has origin set to ($x1,$y1).\n";
       }
    }

# Initiate history recording.
# ===========================

# Repeat for all the integrations.
    foreach my $i ( 1 .. $Frm->nfiles ) {
       $in = $Frm->file( $i );
       $Mon{ "ndfpack_mon" }->obeyw( "hisset", "ndf=$in" );

# Report the processing status.
       orac_print "Frame $in has history recording enabled.\n";
    }

# Correct data units to standard
# ==============================

# Since it's using the same underlying data access as Michelle,
# we'll assume the normalisation to ADU/s has been applied.

# This correction only applies to NDSTARE and NDCHOP modes.
    if ( substr( $Frm->uhdr( "ORAC_DETECTOR_READ_TYPE" ), 0, 2 ) eq "ND" ) {

# The data are in ADU/s, which is not the UKIRT standard.  So obtain
# the exposure time and multiply the data by this factor.
       my $exp_time = $Frm->uhdr( "ORAC_EXPOSURE_TIME" );

       foreach my $i ( 1 .. $Frm->nfiles ) {

# Generate list of input and output filenames.
          ( $in, $out ) = $Frm->inout( "_adu", $i );

# Scale the data.
          $Mon{ "kappa_mon" }->obeyw( "cmult", "in=$in scalar=$exp_time out=$out" );

# Report the processing status.
          orac_print "$in to $out: Scaled data by the exposure time " .
                     "($exp_time) to make the units ADUs.\n";

# Now update the output filename in the Frame object.
          $Frm->file( $i, $out );
       }
    }

# Report completed processing status for UIST.
    orac_print "Global UIST tasks performed.\n\n";

# Podule
# ======

=head1 NAME

_IMAGING_HELLO_  -- Performs global data-reduction tasks for UIST in imaging mode.

=head1 DESCRIPTION

This primitive does the preparatory work for recipes used by 
UIST in imaging mode.

It permits display of the raw data, sets the pixel origin, and
switches on history recording.  It copies the raw data integrations;
and if there's only one integration, it merges the integration and the
headers into a simple NDF.  The data values for ND modes are brought
into line with other instruments, and are total ADU, not ADU/s.

=head1 NOTES

=over 4

=item *

The readout lower bounds in the frame internal headers
ORAC_X_LOWER_BOUND and ORAC_Y_LOWER_BOUND define the pixel origin.  No
origin is set if these do not exist.  A default 1,1 origin is set for
undefined bounds (to cope with early data).

=item *

Any AXIS structure and blank title are removed.

=item *

Corrects the acquisition bug which sets ORAC_WAVEPLATE_ANGLE internal
header to be a comment instead of value 0.  It changes both the actual
headers and the $Frm->uhdr hash.  If the waveplate angle is 180 or
greater, the script takes modulo 180 of the waveplate angle, updating
both the internal and external headers with the new value.

=back

=head1 OUTPUT DATA

=over 4

=item *

Copied frame inheriting the current frame's name but with 
the _raw suffix.

=item *

For NDSTARE and NDCHOP UIST data, the data scaled to ADU
in a frame inheriting the current frame's name but with the _adu
suffix.  The read type comes from header ORAC_DETECTOR_READ_TYPE. 

=back

=head1 TASKS

KAPPA: CMULT, FITSMOD, HISSET, NDFCOPY, SETORIGIN.

=head1 AUTHORS

MJC: Malcolm J. Currie (JAC)

=head1 COPYRIGHT

Copyright (C) 1998-2002 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut
