# -*-perl-*-

use Astro::FITS::CFITSIO qw(:longnames :constants);
use Starlink::HDSPACK qw/ create_hdsobj copy_hdsobj /;

# Create input and output names

my $tmpCvt = new ORAC::Convert;

# Create a temporary HDS file in $ORAC_DATA_OUT.
my $tmp = new ORAC::TempFile;
my $tmpfile = $tmp->file;

my $ORAC_STATUS = ( create_hdsobj( $tmpfile, 'NDF', [0]) ? ORAC__OK : ORAC__ERROR );

my $header_copied = 0;

my $exptime = $Frm->uhdr( "ORAC_EXPOSURE_TIME" );

my $out;

foreach my $i ( 1 .. $Frm->nfiles ) {
  ( my $in, $out ) = $Frm->inout( "_adu", $i );

  if( ! $header_copied ) {

    $ORAC_STATUS = ( create_hdsobj( "$tmpfile.HEADER", "NDF" ) ? ORAC__OK : ORAC__ERROR );

    my $file = $Frm->raw;
    $file =~ s/\.sdf$//;

    $ORAC_STATUS = ( copy_hdsobj( "$file.HEADER", "$tmpfile.HEADER" ) ? ORAC__OK : ORAC__ERROR );

    $header_copied = 1;
  }

  $ORAC_STATUS = ( create_hdsobj( "$tmpfile.I${i}", "NDF", [0] ) ? ORAC__OK : ORAC__ERROR );

  if( $Frm->uhdr( "ORAC_DATA_UNITS" ) eq "counts/sec" ) {

    orac_print "Adjusting for exposure time.\n";
    $Mon{'kappa_mon'}->obeyw( "cmult", "in=$in scalar=$exptime out=$out" );

    $ORAC_STATUS = ( copy_hdsobj( "$out", "$tmpfile.I${i}" ) ? ORAC__OK : ORAC__ERROR );

  } else {

    my $file = $Frm->raw;
    $file =~ s/\.sdf$//;

    $ORAC_STATUS = ( copy_hdsobj( "$file.I${i}", "$tmpfile.I${i}" ) ? ORAC__OK : ORAC__ERROR );

  }
}

( undef, undef, my $infile ) = File::Spec->splitpath( $tmpfile );

orac_print "Converting $infile to Rice-compressed FITS file.\n";

my $outfile = "c" . $Frm->raw;
my $outfile_proper = $Frm->raw;
$outfile_proper =~ s/\.sdf$/\.fit/;
$infile = $Frm->raw;

my @outfiles = $tmpCvt->convert( $infile, { IN => 'HDS', OUT => 'WFCAM_MEF' } );

# Check to see if it's already been compressed. Rice compressed data looks like
# a FITS table, so check for that...

my $hdutype;
my $status = 0;
my $fptr = Astro::FITS::CFITSIO::open_file($outfiles[1],READONLY,$status);
$fptr->movabs_hdu(2,$hdutype,$status);

# If it's an image then do the compression
if ($hdutype == IMAGE_HDU) {
    my $errmsg;
    my $nread = $Frm->hdr("NEXP");
    $nread = 1 if (! $nread);

    # Get file name (just for orac_err messages).
    my $fname = $outfiles[1];

    # Get the number of header units

    my ($msg,$nhdu);
    $fptr->get_num_hdus($nhdu,$status);
    if ($nhdu <= 1) {
	orac_err("File $fname isn't a MEF (nhdus = $nhdu)\n");
    }

    # Create the output file and copy the primary header

    my ($optr);
    unlink $outfile if (-f $outfile);
    $optr = Astro::FITS::CFITSIO::create_file($outfile,$status);
    if ($status != 0) {
	Astro::FITS::CFITSIO::fits_get_errstatus($status,$msg);
	$fptr->close_file($status);
	orac_err("Failed to create file: $outfile\n$msg\n");
    }
    $fptr->copy_hdu($optr,0,$status);
    if ($status != 0) {
	Astro::FITS::CFITSIO::fits_get_errstatus($status,$msg);
	$fptr->close_file($status);
	$optr->close_file($status);
	orac_err("Failed to copy primary from $fname to $outfile\n$msg\n");
    }

    # Set compression parameters

    $optr->set_compression_type(RICE_1,$status);

    # Now loop for each of the input header units

    my ($i,$bitpix,$naxis,@naxes,$npix,@fdata,$anynul,$j,$bscale,$bzero);
    my ($nkeys,$card);
    for ($i = 1; $i < $nhdu; $i++) {
	$fptr->movabs_hdu($i+1,$hdutype,$status);

	# Get the image parameters and create a similar output image

	if ($status != 0) {
	    Astro::FITS::CFITSIO::fits_get_errstatus($status,$msg);
	    $fptr->close_file($status);
	    $optr->close_file($status);
	    orac_err("Failed to create output image $i in $outfile\n$msg\n");
	}

	# Read the input data

	$npix = $naxes[0]*$naxes[1];
	$fptr->read_img(TFLOAT,1,$npix,undef,\@fdata,$anynul,$status);
	if ($status != 0) {
	    Astro::FITS::CFITSIO::fits_get_errstatus($status,$msg);
	    $fptr->close_file($status);
	    $optr->close_file($status);
	    orac_err("Failed to read input image $i in $fname\n$msg\n");
	}
	if ($nread != 1) {
	    for ($j = 0; $j < $npix; $j++) {
		$fdata[$j] *= $nread;
	    }
	}

	# Now write the output data

	$fptr->read_key(TDOUBLE,"BSCALE",$bscale,undef,$status);
	if ($status != 0) {
	    $bscale = 1.0;
	    $status = 0;
	}
	$fptr->read_key(TDOUBLE,"BZERO",$bzero,undef,$status);
	if ($status != 0) {
	    $bzero = 0.0;
	    $status = 0;
	}
	$optr->set_bscale($bscale,$bzero,$status);
	$bscale /= $nread;
	$optr->write_img(TFLOAT,1,$npix,\@fdata,$status);
	if ($status != 0) {
	    Astro::FITS::CFITSIO::fits_get_errstatus($status,$msg);
	    $fptr->close_file($status);
	    orac_err("Failed to write output image $i in $outfile\n$msg\n");
	}

	# Write all the relevant header cards to the output file

	$fptr->get_hdrspace($nkeys,undef,$status);
	for ($j = 1; $j <= $nkeys; $j++) {
	    $fptr->read_record($j,$card,$status);
	    if (Astro::FITS::CFITSIO::fits_get_keyclass($card) > TYP_CMPRS_KEY) {
		$optr->write_record($card,$status);
	    }
	}
	$optr->update_key(TDOUBLE,"BSCALE",$bscale,undef,$status);
	if ($status != 0) {
	    Astro::FITS::CFITSIO::fits_get_errstatus($status,$msg);
	    $fptr->close_file($status);
	    $optr->close_file($status);
	    orac_err("Failed to write output header $i in $outfile\n$msg\n");
	}
    }

    $fptr->close_file($status);
    $optr->close_file($status);
    orac_print("CASU file $outfile_proper created\n");
    unlink $outfiles[1];
    rename($outfile,$outfile_proper);
} else {
    $fptr->close_file($status);
    orac_print("$outfile_proper is already compressed\n");
}

( my $in, $out ) = $Frm->inout( "_adu" );
$out =~ s/\..*$//;
$out .= ".sdf";
unlink $out;

=head1 NAME

_COPY_COMPRESSED_ -- Make a copy of an input FITS file to a Rice tile
compressed FITS file

=head1 DESCRIPTION

A copy of the current input fits frame is made. This is done with the CFITSIO
Rice tile compression algorithm. The result is written a directory pointed
to by ORAC_DATA_CASU

=head1 ARGUMENTS

None

=head1 NOTES

The environment variable ORAC_DATA_CASU must be defined and must point to
a directory that can be created and written to.

=head1 AUTHORS

JRL: Jim Lewis (CASU, IoA)

=head1 COPYRIGHT

Copyright (C) 2004-2007 Cambridge Astronomy Survey Unit.
All Rights Reserved

=cut
