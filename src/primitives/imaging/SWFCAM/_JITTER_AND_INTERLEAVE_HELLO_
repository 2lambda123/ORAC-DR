# -*-perl-*-

# Set up some user headers.
my $number_of_microsteps = $Frm->hdr( "NUSTEP" );
my $microstep_position = $Frm->hdr( "USTEP_I" );
my $microstep_x = $Frm->hdr( "USTEP_X" );
my $microstep_y = $Frm->hdr( "USTEP_Y" );

my $pixelsize = $Frm->hdr( "PIXLSIZE" );

my $pixoff_x = $microstep_x / $pixelsize;
my $pixoff_y = $microstep_y / $pixelsize;

$Frm->uhdr( "NUMBER_OF_MICROSTEPS", $number_of_microsteps );
$Frm->uhdr( "MICROSTEP_POSITION", $microstep_position );
$Frm->uhdr( "MICROSTEP_X", $microstep_x );
$Frm->uhdr( "MICROSTEP_Y", $microstep_y );

# Set up steering headers.
if( ( $microstep_position % $number_of_microsteps ) == 0 &&
    $number_of_microsteps != 1 ) {

  $Frm->uhdr( "INTERLEAVE_MICROSTEPS", 1 );

} else {

  $Frm->uhdr( "INTERLEAVE_MICROSTEPS", 0 );

}

# Set "new pixel origin" headers
$Frm->uhdr( "NEW_X_ORIGIN", nint( $pixoff_x * sqrt( $number_of_microsteps ) + 1 ) );
$Frm->uhdr( "NEW_Y_ORIGIN", nint( $pixoff_y * sqrt( $number_of_microsteps ) + 1 ) );

# Set origin shift for interleave mask.
$Frm->uhdr( "MASK_X_ORIGIN", nint( $pixoff_x * sqrt( $number_of_microsteps ) ) % sqrt( $number_of_microsteps ) + 1 );
$Frm->uhdr( "MASK_Y_ORIGIN", nint( $pixoff_y * sqrt( $number_of_microsteps ) ) % sqrt( $number_of_microsteps ) + 1 );
