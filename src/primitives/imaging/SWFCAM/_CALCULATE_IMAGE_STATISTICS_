# -*-perl-*-

=head1 NAME

_CALCULATE_IMAGE_STATISTICS_ - Calculate various image quality
statistics based on an input catalogue.

=head1 DESCRIPTION

This primitive calculates image quality statistics based on an input
catalogue. This catalogue is typically the output from either
C<Starlink::Extractor> or C<Starlink::Autoastrom>, so that object
morphology information is available for calculations.

This primitive calculates the mean axial ratio of bright sources, the
average object diameter converted to K-band equivalent, the sky
brightness, the limiting magnitude, and the instrumental zero point.

=head1 ARGUMENTS

=over 4

=item GROUP = LOGICAL (Given)

If true, use the current Group file for sky brightness
calculations. Otherwise, use the current Frame. [0]

=item IMAGE_CATALOGUE = C<Astro::Catalog> object (Given)

=item MAGNITUDE_TYPE = CHARACTER (Given)

The magnitude type to use when  calculating zeropoint. This can be any
of the MAG_* output parameters from SExtractor. [MAG_ISO]

=back

=head1 NOTES

=over 4

=item *

Files results with the Calibration system. FWHM is obtained with the
fwhm() method, axial ratio is obtained with the axial_ratio() method,
sky brightness is obtained with the sky_brightness() method, limiting
magnitude is obtained with the limiting_mag() method, and the zero
point is obtained with the zeropoint() method.

=back

=head1 OUTPUT DATA

=over 4

None.

=back

=head1 TASKS

=head1 REQUIRED PERL MODULES

Astro::Catalog.

=head1 AUTHORS

Brad Cavanagh <b.cavanagh@jach.hawaii.edu>

=head1 COPYRIGHT

Copyright (C) 2005 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut

# Find out if we want to do statistics on the current Group or Frame
# object.
my $group = $_CALCULATE_IMAGE_STATISTICS_{GROUP};
my $Obj;
$group = defined( $group ) ? $group : 0;
if( $group ) {
  $Obj = $Grp;
} else {
  $Obj = $Frm;
}

# Get the magnitude type, defaulting to MAG_ISO.
my $magnitude_type = $_CALCULATE_IMAGE_STATISTICS_{MAGNITUDE_TYPE} || 'MAG_ISO';

# Get the image catalogue.
my $image_catalogue = $_CALCULATE_IMAGE_STATISTICS_{IMAGE_CATALOGUE};

# Only run if we actually have an image catalogue.
if( defined( $image_catalogue ) ) {

  # Strip out any Astro::Catalog::Item objects that don't have a
  # quality of 0 (which means good), or an area greater than 78.5
  # pixels (which is a circle with a radius of five pixels) multiplied
  # by the square of the expansion ratio, or an ellipticity greater
  # than 0.25. This will eliminate any galaxies, saturated stars,
  # blended objects, etc. from the image quality calculations.
  my @gooditems;
  my @catmatchitems;

  _GET_EXPANSION_RATIO_
  my $maxarea = 78.5 * ( $_GET_EXPANSION_RATIO_{X_EXPANSION} ) ** 2;

  foreach my $item ( $image_catalogue->stars ) {

    next if $item->quality;
    next if ( defined( $item->morphology->area ) &&
              $item->morphology->area > $maxarea );
    next if ( defined( $item->morphology->ellipticity ) &&
              $item->morphology->ellipticity > 0.25 );
    push @gooditems, $item;

    my $fluxes = $item->fluxes;
    my @allfluxes = $fluxes->allfluxes;
    my $cat_match = 0;
    my $waveband = new Astro::WaveBand( Filter => $Frm->uhdr( "ORAC_FILTER" ) );
    my %standard_filters;

    foreach my $flux ( @allfluxes ) {
      if( uc( $flux->type ) eq 'MAG_CATALOG' ) {
        $standard_filters{uc($flux->waveband)}++;
      }
    }
    if( $standard_filters{'J'} &&
        $standard_filters{'K'} &&
        $standard_filters{'H'} ) {
      push @catmatchitems, $item;
    }
  }

  my $newcat = new Astro::Catalog;
  $newcat->pushstar( @gooditems );
  $image_catalogue = $newcat;

  # Create a temporary file to hold the input catalogue to PSF.
  my $psf_input_temp = new ORAC::TempFile( SUFFIX => '.txt' );

  # Write the catalogue to disk.
  $image_catalogue->write_catalog( File => $psf_input_temp->file,
                                   Format => 'STL' );

  # Set up the parameters for PSF.
  my $params = "incat=" . $psf_input_temp->file . " "
             . "device=! gauss=false logfile=! ";

  if( $group ) {
    $params .= "in=" . $Grp->file;
  } else {
    $params .= "in=" . $Frm->file;
  }

  # Run PSF.
  $Mon{'kappa_mon'}->obeyw( "psf", "$params" );

  # Obtain statistics.
  ( my $ORAC_STATUS, my $axialratio ) = $Mon{'kappa_mon'}->get( "psf", "axisr" );
  ( $ORAC_STATUS, my $fwhm ) = $Mon{'kappa_mon'}->get( "psf", "fwhm" );
  ( $ORAC_STATUS, my $gamma ) = $Mon{'kappa_mon'}->get( "psf", "gamma" );
  ( $ORAC_STATUS, my $orient ) = $Mon{'kappa_mon'}->get( "psf", "orient" );

  my $ellipticity = 1 - ( 1 / $axialratio );

  # Calculate the K-band equivalent seeing. It goes as
  # (wavelength^(-0.2)), so we need to get the current wavelength and
  # the K wavelength, do the division and the power, and scale the
  # measured FWHM.
  _GET_FILTER_PARAMETERS_
  my $wavelength = $_GET_FILTER_PARAMETERS_{WAVELENGTH};
  my $k_wavelength = 2.25;
  my $scale = ( $wavelength / $k_wavelength ) ** ( -0.2 );
  my $k_fwhm = $scale * $fwhm;

  # Obtain the mean extinction coefficient.
  my $waveband = $_GET_FILTER_PARAMETERS_{WAVEBAND};
  my $extinction = $_GET_FILTER_PARAMETERS_{EXTINCTION};
  my $filter = $Frm->uhdr( "ORAC_FILTER" );

  # Obtain the airmass from the FITS headers. Find the
  # approximate mean airmass from the start and end values. This
  # should be adequate unless it is a long integration with the
  # source crossing the meridian.
  my $amstart = $Obj->uhdr( "ORAC_AIRMASS_START" );
  my $amend   = $Obj->uhdr( "ORAC_AIRMASS_END" );
  my $airmass = 0.5 * ( $amstart + $amend );

  # Derive the extinction correction using the IR standard of
  # one airmass.
  my $extcor = ( $airmass - 1.0 ) * $extinction;

  # Obtain the exposure time.
  my $exptime = $Frm->uhdr( "ORAC_EXPOSURE_TIME" );

  my @image_mags;
  my @standard_mags;
  my @diffs;

  # Now, go through the list of objects that had catalogue magnitudes
  # and calculate the zeropoint.
  foreach my $catmatchitem ( @catmatchitems ) {

    my $jmag = $catmatchitem->get_flux_quantity( waveband => 'J',
                                                 type => 'MAG_CATALOG' );
    my $hmag = $catmatchitem->get_flux_quantity( waveband => 'H',
                                                 type => 'MAG_CATALOG' );
    my $kmag = $catmatchitem->get_flux_quantity( waveband => 'K',
                                                 type => 'MAG_CATALOG' );

    # Calculate the Z, Y, J, H, and K magnitudes in the MK system.
    my $mk_zmag = $jmag + 0.95  * ( $jmag - $hmag );
    my $mk_ymag = $jmag + 0.5   * ( $jmag - $hmag );
    my $mk_jmag = $jmag - 0.075 * ( $jmag - $hmag );
    my $mk_hmag = $hmag + 0.075 * ( $jmag - $hmag );
    my $mk_kmag = $kmag - 0.015 * ( $jmag - $kmag );

    # Get the magnitude in the current waveband.
    my $im_mag = $catmatchitem->get_flux_quantity( waveband => $filter,
                                                   type => $magnitude_type );
    my $st_mag;
    if( $filter eq 'Z' ) {
      $st_mag = $mk_zmag;
    } elsif( $filter eq 'Y' ) {
      $st_mag = $mk_ymag;
    } elsif( $filter eq 'J' ) {
      $st_mag = $mk_jmag;
    } elsif( $filter eq 'H' ) {
      $st_mag = $mk_hmag;
    } elsif( $filter eq 'K' ) {
      $st_mag = $mk_kmag;
    }

    # Correct the measured magnitude for exposure time.
    $im_mag += 2.5 * log10( $exptime );

    # Correct the measured magnitude for extinction.
    $im_mag -= $extcor;

    # Push the magnitudes onto the arrays, correcting the
    # magnitude from the EXTRACTOR-based catalogue.
    push( @image_mags, $im_mag );
    push( @standard_mags, $st_mag );
    push( @diffs, $st_mag - $im_mag );

  }

  # Calculate the mean difference and the variance in the
  # difference between the standard magnitudes and the measured
  # magnitudes.
  my $sum = 0;
  foreach my $diff ( @diffs ) {
    $sum += $diff;
  }
  my $zeropoint = $sum / ( $#diffs + 1 );
  my $sumsqu = 0;
  foreach my $diff( @diffs ) {
    $sumsqu += ( $diff - $zeropoint ) * ( $diff - $zeropoint );
  }
  my $zeropoint_variance = sqrt( $sumsqu / ( $#diffs + 1 ) );

  # Now that we have the zeropoint, we can calculate the sky
  # brightness statistics.

  # Run clipped mean stats on the Object.
  $params = "ndf=" . $Obj->file . " clip=[2,3,3]";
  $Mon{'kappa_mon'}->obeyw( "stats", "$params" );
  ( $ORAC_STATUS, my $sky_mean ) = $Mon{'kappa_mon'}->get( "stats", "mean" );
  ( $ORAC_STATUS, my $sky_stddev ) = $Mon{'kappa_mon'}->get( "stats",  "sigma" );

  # Now to calculate the sky level in magnitudes/arcsec^2.
  _GET_PLATE_SCALE_
  my $plate_scale = $_GET_PLATE_SCALE_{PLATESCALE};
  my $counts_per_square_arcsecond = $sky_mean
                                  / ( $plate_scale * $plate_scale );
  my $mag_per_square_arcsecond = $zeropoint
                               - 2.5
                               * log10( $counts_per_square_arcsecond /
                                        $exptime );

  # Create printable versions.
  my $p_axial = sprintf( "%.3f", $axialratio );
  my $p_ell = sprintf( "%.3f", $ellipticity );
  my $p_fwhm = sprintf( "%.3f", $fwhm );
  my $p_k_fwhm = sprintf( "%.3f", $k_fwhm );
  my $p_orient = sprintf( "%.3f", $orient );
  my $p_gamma = sprintf( "%.3f", $gamma );
  my $p_num_obj = sprintf( "%d", $#diffs + 1 );
  my $p_zp = sprintf( "%.3f", $zeropoint );
  my $p_zpvar = sprintf( "%.3f", $zeropoint_variance );
  my $p_ext = sprintf( "%.3f", $extcor );
  my $p_sky_mean = sprintf( "%.2f", $sky_mean );
  my $p_sky_stddev = sprintf( "%.2f", $sky_stddev );
  my $p_mag = sprintf( "%.2f", $mag_per_square_arcsecond );

  my $p_filter = $Frm->uhdr( "ORAC_FILTER" );
  my $p_exptime = sprintf( "%.1f", $Frm->uhdr( "ORAC_EXPOSURE_TIME" ) );
  my $p_object = $Frm->uhdr( "ORAC_OBJECT" );

  # Output statistics to the user.
  orac_print( "Image information for " .
              ( $group ? $Grp->file : $Frm->file ) .
              ":\n", "blue" );
  orac_print( " Filter:        $p_filter\n", "blue" );
  orac_print( " Exposure time: $p_exptime seconds\n", "blue" );
  orac_print( " Object name:   $p_object\n", "blue" );
  orac_print( "\n" );
  orac_print( "Image quality statistics on " .
              ( $group ? $Grp->file : $Frm->file ) .
              ":\n", "blue" );
  orac_print( " Axial ratio:  $p_axial\n", "blue" );
  orac_print( " Ellipticity:  $p_ell\n", "blue" );
  orac_print( " FWHM:         $p_fwhm arcseconds\n", "blue" );
  orac_print( " K-band equiv: $p_k_fwhm arcseconds\n", "blue" );
  orac_print( " Orientation:  $p_orient degrees east of north\n", "blue" );
  orac_print( " Gamma:        $p_gamma (2 = gaussian)\n", "blue" );
  orac_print( "\n" );
  orac_print( "Photometric statistics on " .
              ( $group ? $Grp->file : $Frm->file ) .
              ":\n", "blue" );
  orac_print( " Instrumental zero-point: $p_zp +/- $p_zpvar ($p_num_obj objects used)\n", "blue" );
  orac_print( " Background sky level:    $p_sky_mean +/- $p_sky_stddev counts.\n",
              "blue" );
  orac_print( " Sky brightness:          $p_mag magnitudes/arcsec^2.\n",
              "blue" );
  orac_print( "  Extinction coefficient of $p_ext was used.\n", "blue" );

  # File the whole shebang with the calibration system.
  my %calhash = ( %{$Obj->hdr},
                  AXIALRATIO => $axialratio,
                  ELLIPTICITY => $ellipticity,
                  FWHM => $fwhm,
                  FWHM_K => $k_fwhm,
                  GAMMA => $gamma,
                  ORIENT => $orient,
                  SKY_VALUE => $sky_mean,
                  SKY_VALUE_ERROR => $sky_stddev,
                  SKY_VALUE_MAG => $mag_per_square_arcsecond,
                  ZEROPOINT => $zeropoint,
                  ZEROPOINT_ERROR => $zeropoint_variance,
                );
  $Cal->dqcindex->add( $Obj->file, \%calhash );
}
