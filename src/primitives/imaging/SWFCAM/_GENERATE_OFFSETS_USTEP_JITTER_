# -*-perl-*-

# Are we looking at a moving target?
my $moving_target = $_GENERATE_OFFSETS_USTEP_JITTER_{MOVING_TARGET};
$moving_target = defined( $moving_target ) ? $moving_target : 0;

# Determine whether or not telescope offsets should only be used.
my $usetele = $_GENERATE_OFFSETS_USTEP_JITTER_{TELEOFF};
$usetele = defined( $usetele ) ? $usetele : 0;

# Obtain the parameters for the detection.
my ( $complete, $minpix, $percentile );
if ( ! $usetele ) {
  $percentile = ( $_GENERATE_OFFSETS_USTEP_JITTER_{PERCENTILE} || 98 );
  $minpix = ( $_GENERATE_OFFSETS_USTEP_JITTER_{MINPIX} || 9 );
  $complete = ( $_GENERATE_OFFSETS_USTEP_JITTER_{COMPLETE} || 0.4 );
}

# This should only be performed on OBJECT frames.
if ( $Frm->uhdr( "ORAC_OBSERVATION_TYPE" ) eq "OBJECT" ||
     $Frm->uhdr( "ORAC_OBSERVATION_TYPE" ) eq "SKY" ) {

# Test whether or not it is time to make a mosaic.
  my $makemos = $Frm->uhdr( "MAKE_MOSAIC" );
  if ( $makemos ) {

    my $intGrp = $Grp->subgrp( 'INTERLEAVED' => 1 );

    my $cycleno = $Frm->uhdr( "CYCLE_NUMBER" );
    $cycleno = defined( $cycleno ) ? $cycleno : 0;

    my $cycleGrp = $intGrp->subgrp( 'CYCLE_NUMBER' => $cycleno );

    my ( $tempFrm, $tempGrp );
    if ( $cycleno == 0 ) {
      $tempGrp = $cycleGrp;

# For a moving target we want to register to the first frame, because
# it is the reference frame for the moving target.  The motions are
# calculated with respect to its time of observation.  We do not
# register to the co-added mosaic (as happens for stationary sources)
# or even the first cycle mosaic, because the fiducial stars are
# extended and thus shifts the centroid of the sources.  There is no
# guarantee that telescope offsets will be used.  The mosaic stellar
# images are also possibly multiple, which can confuse the registration.
# It's a two-stage process.  First check that the reference frame
# exists...
    } elsif ( $moving_target ) {
      $tempFrm = new $Frm;
      $tempFrm->file( $Grp->frame( 0 )->file );
      if ( ! $tempFrm->file_exists() ) {
        orac_throw "Reference frame " . $Grp->frame( 0 )->file .
                   " for moving target does not exist.\n";
      }

# then form the temporary group.  Insert the reference frame first and
# then the current cycle's members.
      $tempGrp = new $Grp;
      $tempGrp->push( $Grp->frame( 0 ) );
      $tempGrp->push( $cycleGrp->members );

# On later cycles a mosaic file should exist, and we shall to register
# with that as the reference frame.  So place the file into a temporary
# frame pushed onto a temporary $Grp-like group.  Then append the members
# of the subgroup.
    } else {
      $tempFrm = new $Frm( $Grp->file );
      $tempGrp = new $Grp;
      $tempGrp->push( $tempFrm );
      $tempGrp->push( $cycleGrp->members );
    }

# Telescope offsets
# =================
    if ( $usetele ) {

# Make a local $Grp.
      my $Grp = $tempGrp;

# Use telescope offsets from the headers to register the frames.
      _GENERATE_TELE_OFFSETS_ MOVING_TARGET=$moving_target

# Attempt automatic registration
# ==============================
    } else {

# Generate the offsets
# ====================

# Call the generic primitive which does most of the work.  Do not use central
# source as a backup.  Use the reference mosaic's co-ordinate system so ensure
# that central-source offsets are with respect to that, if the
# CENTRAL_SOURCE flag is switched.
      my $Grp = $tempGrp;
      _GENERATE_OFFSETS_ PERCENTILE=$percentile MINPIX=$minpix COMPLETE=$complete CENTRAL_SOURCE=FALSE MOVING_TARGET=$moving_target

# End of scope of local $Grp aka $tempGrp.
    }
  }
}
