#+
# Name:
#    _FIXED_APERTURE_PHOTOMETRY_
#
# Purpose:
#    Performs aperture photometry on a point source.
#
# Language:
#    Perl5
#
# Description:
#    This primitive performs aperture photometry of a point source
#    for the group frame, and target-frame members of the current $Grp
#    within the current cycle.  The results are reported and stored in
#    a text file---a Starlink STL table (see SUN/190).
#
#    The photometry is in circular aperture located at the centroid of
#    the source with the sky measured from a concentric annulus outside
#    the aperture.  The photometry engine accounts for fractional pixels
#    at the aperture edge but without allowance for the local gradient.
#    The photometry also yields an internal error determined from the 
#    sky variance.  The magnitudes are given by the expression 
#    -2.5 * log10( abs( counts ) per second exposure time ).  Therefore
#    negative sources can be measured too.
#
#    The source must lie within the specified aperture.  See arguments
#    XOFF and YOFF for the location of the aperture.
#
#    A case- and space-insensitive comparison of the object name 
#    with the entries in a table provides a catalogue magnitude in I,
#    Z, J, H, K, L, or M for a standard star.  Also a mean extinction is 
#    applied for the mean of the start and end airmasses.  Thus the
#    primitive calculates an approximate zero point.
#
#    The primitive also finds the best-fitting two-dimensional Gaussian
#    as an indicator of the seeing.
#
#  Arguments:
#     APERTURE = REAL (Given)
#        The aperture in arcseconds for the photometry.  [6.0]
#     INNER = REAL (Given)
#        The ratio of the diameters of inner ring of the sky annulus to
#        that of the object aperture (APERTURE).  It is constrained
#        to be in the range 1.1 to 3.0.  The mode of the pixel values in 
#        the annulus is used to subtract the sky for statistics 3) and
#        4) listed above.  [1.5]
#     OUTER = REAL (Given)
#        The ratio of the diameters of outer ring of the sky annulus to
#        that of the object aperture (APERTURE).  It is constrained to
#        be in the range 1.4 to 5.0 and be at least 0.3 greater than the
#        inner scale factor of the annulus.  [2.5]
#     POSITIVE = LOGICAL (Given)
#        If 1 (true), the point source is positive, i.e. has values
#        above the sky level.  If 0 (false), the point source is
#        negative.  [1]
#     SKY_EST = INTEGER (Given)
#        Sky estimations method as per AUTOPHOTOM parameter SKYEST.  The
#        default is the mode, so as to exclude contaminating sources.
#        1 is the mean; 2 is the average of values within two standard
#        deviations of the mean; 3 is the mode from PHOTOM, 4 is a 
#        multiply clipped mean emulating the mode but without involving
#        the median.  It is supplied as a constant to AUTOPHOTOM (hence
#        option 4).  The final option is to cope with self-flat frames
#        with a spike artifact in the histogram thus giving the wrong
#        median, and hence biased mode.  The default is used should 
#        the supplied value not be one of the allowed options. [3]
#     SUFFIX = CHARACTER (Given)
#        Suffix to be applied to the name of the frame in the log of
#        the results.  It is usually not set.  The NOD recipes need it
#        to discriminate between the positive and negative images.
#        [""]
#     XOFF = REAL (Given)
#        The approximate x pixel offset of the centroid of the point
#        source to be measured with respect to the nominal position.
#        The nominal position is the y centre of the array plus the
#        x telescope offset.  (It's plus because R.A. increases with
#        negative x.)  [0.0]
#     YOFF = REAL (Given)
#        The approximate y pixel offset of the centroid of the point
#        source to be measured with respect to the nominal position.
#        The nominal position is the y centre of the array minus the
#        telescope offset.  [0.0]
#
# Notes:
#    -  This primitive is suitable for UFTI, IRCAM, and Michelle 
#    in imaging mode.
#    -  Processing only occurs when it is time to perform photometry,
#    i.e. when the steering header DO_APHOT is true; and on target
#    object frames when the steering header TARGET_OR_SKY is "target".
#    -  The photometry text file is aphot_results.txt.  The format of
#    this file is described in primitive _MAKE_PHOTOMETRY_TABLE_.
#    -  Items reported in order are the frame and object names;
#    UT start time; filter; mean airmass; raw and extinction-corrected
#    instrumental magnitude and their error (if available); error
#    flag, notably B indicating that bad pixels were inside the
#    aperture; aperture diameter and the radii of the sky annulus in
#    arcseconds; the sky level; the catalogue magnitude; calculated
#    raw and extinction-corrected zeropoint (if the catalogue magnitude
#    is known); and the FWHM of the best-fitting two-dimensional
#    Gaussian to the source.
#    -  A saturation level is set at 14000 counts for UFTI; 16000
#    for IRCAM in a STARE mode, and 32000 in Deepwell mode.
#    -  The mean extinction coefficients are: I: 0.07, Z: 0.03, J: 0.08;
#    H: 0.03; K: 0.07; L: 0.10; L':0.09, and M: 0.30.  Zero extinction
#    applies to any other filter.
#    -  A warning appears should the object not be found in the
#    standards file.
#    -  Where a value is unknown or cannot be computed, its entry in the
#    table is "<null>".
#    -  The standard-star catalogue used is $ORAC_DATA_CAL/fs2001.dat.
#    However, if this file is unavailable, the script accesses the old
#    $ORAC_DATA_CAL/fs2000.dat, but only for JHK data.  An error
#    results a catalogue cannot be opened.
#    -  The ADU factor and exposure time stored in frame header are
#    validated.  Non-positive values cause a warning message to appear,
#    but the primitive continues defaulting the header value to 1.
#
# Tasks:
#    KAPPA: ARDMASK, NDFCOPY, PSF; PHOTOM: AUTOPHOTOM.
#
# Authors:
#    MJC: Malcolm J. Currie (JAC)
#
# Copyright:
#    Copyright (C) 1998-2001 Particle Physics and Astronomy Research
#    Council.  All Rights Reserved.
#
#-

# Determine whether it is time to do aperture photometry.
# We have to specify this since we have to decide whether we
# are using $Frm or $Grp and in general this routine is run
# on reduced images.
    my $do_aphot = $Frm->uhdr( "DO_APHOT" );
    if ( $do_aphot ) {

# Arguments
# =========

# Obtain the suffix value for the file name in the log.  Used
# for NOD positive and negative images, but normally set to null
       my $suffix = ( $_FIXED_APERTURE_PHOTOMETRY_{SUFFIX} || "" );

# Process as positive or negative source.
       my $positive = $_FIXED_APERTURE_PHOTOMETRY_{POSITIVE};
       $positive = defined( $positive ) ? $positive : 1;

# Obtain the offsets of the point-source images.
       my $xoff = $_FIXED_APERTURE_PHOTOMETRY_{XOFF};
       $xoff = defined( $xoff ) ? $xoff : 0.0;
       my $yoff = $_FIXED_APERTURE_PHOTOMETRY_{YOFF};
       $yoff = defined( $yoff ) ? $yoff : 0.0;

# Obtain the aperture diameter in arcseconds.
       my $as_aperture = ( $_FIXED_APERTURE_PHOTOMETRY_{APERTURE} || 6 );
 
# Calculate the radius of the inner and outer extent of the aperture.
       my $inner = ( $_FIXED_APERTURE_PHOTOMETRY_{INNER} || 1.5 );
       my $outer = ( $_FIXED_APERTURE_PHOTOMETRY_{OUTER} || 2.5 );
       $inner = min( 3.0, max( $inner, 1.1 ) );
       $outer = min( 5.0, max( $inner + 0.3, $outer, 1.4 ) );

# Obtain the sky-estimation-method index.
       my $skyest = ( $_FIXED_APERTURE_PHOTOMETRY_{SKY_EST} || 3 );
       if ( $skyest !~ /^[+]?\d$/ || $skyest < 1 || $skyest > 4 ) {
          orac_warn "Invalid sky estimation ($skyest).  Should be 1, 2, 3, or 4.  Using the PHOTOM mode.\n";
          $skyest = 3;
       }

# Selection
# =========

# This should only be performed on OBJECT frames.
       if ( $Frm->uhdr( "ORAC_OBSERVATION_TYPE" ) eq "OBJECT" ) {
          my $incflag = "T";

# Define a useful variable for a null catalogue magnitude.
          my $nullmag = 99.999;

# Obtain the cycle number from the header.
          my $cycleno = $Frm->uhdr( "CYCLE_NUMBER" );
          $cycleno = defined( $cycleno ) ? $cycleno : 0;

# Form new group
# ==============
#
# Create a temporary frame object.  Use the new method rather than
# new ORAC::Frame for generality (otherwise we would have to do
# new ORAC::Frame::UFTI for UFTI primitives and so on) to inherit
# from the current Frame.

# Set the file method for this frame.  $Grp->file is name of the main
# mosaic.  There's a bug/feature that requires a header to have been read
# in before it is accessed.  So cannot use file method to associate
# the group frame; do it with the new method.
          my $tmpFrm = $Frm->new( $Grp->file );

# Create a temporary group object as used by _FAO_.  Use the new method
# rather than new ORAC::Group for generality to inherit from the current
# group.
          my $phoGrp = $Grp->new;

# Push the current cycle's target members of the existing group into the
# temporary group.  Exclude any sky frames.
          my $tarGrp = $Grp->subgrp( TARGET_OR_SKY => "target",
                                     CYCLE_NUMBER => $cycleno );
          $phoGrp->push( $tarGrp->members );

# Push the temporary frame into the temporary group.  Note that the
# Orac::Group class can contain anything.  However in ORAC-DR we want
# to stick with Frame objects for generality.  So now $reggrp is a
# group consisting of the current group members and group file.
          $phoGrp->push( $tmpFrm );

# Perform photometry for all the individual jitter frames and the final
# mosaic.
          my ( $catmag, $fs_magdif_ext, $magdif, $magdif_ext );
          foreach $Frm ( $phoGrp->members ) {

# Open the results file
# =====================

# Create log file if necessary.
             my $logfile = "aphot_results.txt";
             if ( ! -e $logfile ) {
                _MAKE_PHOTOMETRY_TABLE_ FILE=$logfile
             }

# Open the file for appending results.
             open ( LOGFILE, ">>$logfile" );

# Get information from the headers
# ================================

# Obtain the filter from the FITS headers.
             my $filter = $Frm->uhdr( "ORAC_FILTER" );

# Obtain the mean extinction coefficient.  Specify the corresponding catalogue
# column number for the filter.
             my ( $catcol, $extinction );
             SWITCH: {
                if ( $filter =~ /^J/ ) {
                   $extinction = 0.08; $catcol = 2; last SWITCH;
                }
                if ( $filter =~ /^H/ ) { 
                   $extinction = 0.03; $catcol = 3; last SWITCH;
                }
                if ( $filter =~ /^K/ ) {
                   $extinction = 0.07; $catcol = 4; last SWITCH;
                }
                if ( $filter =~ /^L'/ ) {
                   $extinction = 0.09; $catcol = 5; last SWITCH;
                }
                if ( $filter =~ /^L/ ) {
                   $extinction = 0.10; $catcol = 5; last SWITCH;
                }
                if ( $filter =~ /^M/ ) {
                   $extinction = 0.30; $catcol = 6; last SWITCH;
                }
                if ( $filter =~ /^I/ ) {
                   $extinction = 0.07; $catcol = 0; last SWITCH;
                }
                if ( $filter =~ /^Z/ ) {
                   $extinction = 0.03; $catcol = 1; last SWITCH;
                }
                $extinction = 0.0; $catcol = -1;
             }

# Obtain the airmass from the FITS headers.  Find the approximate
# mean airmass from the start and end values.  This should be
# adequate unless it is a long integration with the source crossing
# the meridian.
             my $amstart = $Frm->uhdr( "ORAC_AIRMASS_START" );
             my $amend   = $Frm->uhdr( "ORAC_AIRMASS_END" );
             my $airmass = 0.5 * ( $amstart + $amend );

# Derive the extinction-correction using the IR standard of one airmass.
             my $extcor = ( $airmass - 1.0 ) * $extinction;

# Obtain the object name, exposure time, time of observation, and
# the number of electrons per data number.
             my $exptime = $Frm->uhdr( "ORAC_EXPOSURE_TIME" );
             my $objname = $Frm->uhdr( "ORAC_OBJECT" );
             my $ut = $Frm->uhdr( "ORAC_UTSTART" );
             my $padu = $Frm->uhdr( "ORAC_GAIN" );

# Obtain the pixel scale.
             _GET_PLATE_SCALE_
             my $pixelscale = $_GET_PLATE_SCALE_{RASCALE};         

# Set the saturation level.  This is missing a high-gain mode value
# for UFTI as it is yet to be determined.
             my $sature;
             if ( $Frm->uhdr( "ORAC_INSTRUMENT" ) =~ /UFTI/ ) {
                $sature = 14000;

# IRCAM3 & (Michelle for now)
             } elsif ( $Frm->uhdr( "ORAC_READMODE" ) =~ /STARE/ ) {
                $sature = 16000;

             } elsif ( $Frm->uhdr( "ORAC_READMODE" ) =~ /Deepwell/ ) {
                $sature = 32000;
             }

# Validate some headers.
# ======================

# Constrain PADU as we'll need to divide by it later.
             if ( $padu < 0.0001 ) {
                orac_warn "Data number per ADU $padu is not positive.  It is set to 1.\n";
                $padu = 1.0;
             }

# Constrain exposure time as it is used multiplicatively in a logarithm
# below.
             if ( $exptime < 0.0001 ) {
                orac_warn "Exposure time $exptime is not positive.  It is set to 1.\n";
                $exptime = 1.0;
             }

# Extract the system magnitude of faint standards
# ===============================================

# Remove spaces from the name, and convert to uppercase for later
# comparison.
             ( my $starname = uc( $objname ) ) =~ s/ //g;

# Faint standards have name FSn, where n is the number.  Only JHK
# magnitudes are tabulated.
             if ( $catcol > -1 ) {
                my $standards_file;
                my $jhk = 1;

# Define the character to indicate a null value in the standrds' table.
                my $nullcol = "&";

# Open the faint-standards file and store its records in an array.
                my $catpath = $ENV{ "ORAC_DATA_CAL" };
                $standards_file = $catpath . "/fs2001.dat";

# For IZLM the raw file must be fs2001.
                if ( -e $standards_file ) {
                   open( $fh_standards, "<$standards_file" ) || 
                   open( STANDARDS, "<$standards_file" ) || 
                         orac_warn "Standards file $standards_file could not be opened\n";

# Record the fact that we are reading the new-format IZJHKLM file, not
# the old file of just JHK data.
                   $jhk = 0;

# Try the old JHK file incase the latest standards compilation is not
# available.
                } elsif ( $filter =~ /^[JHK]/ ) {
                   $standards_file = $catpath . "/fs2000.dat";d322 1
                   if ( !-e $standards_file ) {
                      $standards_file = "fs2000.dat";
                   }
                   open( STANDARDS, "<$standards_file" ) || 
                         orac_warn "JHK Standards file $standards_file could not be opened\n";
                }
                my @stds = <STANDARDS>;

# Remove trailing blanks and newline.
                for ( @stds ) {
                   chomp;
                   s/\s+$//;
                }

# Search through the table finding a line containing the object name.  The
# file currently consists of some column headings, then a relational table.
# Columns in the table include the star name, and the various magnitudes
# or (J-H) and (H-K) colours in the old-format.

# Look at each line.  Extract the name, stripping the blanks.  Proceed
# until an uppercase match is found.
                my $recno = 1;
                my $name = " ";
                my $othername = " ";
                until ( uc( $name ) eq $starname || $recno > $#stds ||
                        uc( $othername ) eq $starname ) {
                   $recno++;

# New file does not have FS prefix in the first column.
                   if ( $jhk ) {
                      $name = substr( $stds[ $recno ], 0, 6 );
                      $othername = substr( $stds[ $recno ], 8, 9 );
                   } else {
                      $name = "FS" . substr( $stds[ $recno ], 0, 3 );
                      $othername = substr( $stds[ $recno ], 5,11 );
                   }
                   $name =~ s/ //g;
                   $othername =~ s/ //g;
                }

# Check that a match has been found.  Use a special value to indicate
# a null magnitude.
                if ( $recno > $#stds ) {
                   if ( -e $standards_file ) {
                      orac_warn "Standard $objname has no tabulated $filter magnitude in $standards_file\n";
                   } else {
                      orac_warn "The standards file $standards_file does not exist\n";
                   }
                   $catmag = $nullmag;
                } else {

# Extract the columns.
                   my @fields = split( / +/, $stds[ $recno ] );
                   if ( $jhk ) {

# Extract and evaluate the magnitudes from the colours.  This could be done
# more succinctly, but use more friendly intermediate variables.
                      my $Kmag = $fields[ 9 ];
                      my $Hmag = $Kmag + $fields[ 15 ];
                      my $Jmag = $Hmag + $fields[ 12 ];
                      my @mags = ( $Jmag, $Hmag, $Kmag );

# Obtain the desired magnitude.  Subtract the two because I and Z are
# omitted.
                      $catmag = $mags[ $catcol - 2 ];

# Extract the IZJHKLM magnitudes.
                   } else {
                      my $Imag = $fields[ 8 ];
                      my $Zmag = $fields[ 11 ];
                      my $Jmag = $fields[ 14 ];
                      my $Hmag = $fields[ 17 ];
                      my $Kmag = $fields[ 20 ];
                      my $Lmag = $fields[ 23 ];
                      my $Mmag = $fields[ 26 ];

                      my @mags = ( $Imag, $Zmag, $Jmag, $Hmag, $Kmag, $Lmag, $Mmag );

# Obtain the desired magnitude.
                      $catmag = $mags[ $catcol ];
                   }
                }

# Close the stamdards data file.
                close( STANDARDS );

# Set a null magnitude if there is no value in the table for the
# chosen star and waveband.
                if ( $catmag eq $nullcol ) {
                   $catmag = $nullmag;
                }

# Since we could not locate or open the standards file, the magnitude
# is null.
             } else {
                $catmag = $nullmag;
             }

# Find location and dimensions of the aperture and annulus
# ========================================================

# Locate the image centre within the aperture sized box.  The
# current S Frame becomes PIXEL for KAPPA versions from 0.14.
             _FIND_SOURCE_CENTROID_ XOFF=$xoff YOFF=$yoff POSITIVE=$positive BOXSIZE=$as_aperture

# It is possible that no centroid was found.  Get a reference to the flag,
# test the status, and report an error where centroiding failed.
             my $found = $_FIND_SOURCE_CENTROID_{FOUND};
             if ( ! $$found ) {
                orac_err "Unable to locate source for aperture photometry.\n";

# Skip to the next frame.
                next;
             }

# Get the reference to the centre co-ordinates.
             my $centre = $_FIND_SOURCE_CENTROID_{CENTRE};

# Gaussian FWHM
# =============

# Store the located centroid within a text file of the format PSF expects.
             unlink ( "centre$$.dat" );
             open ( PSFIN, ">centre$$.dat" );
             print PSFIN "@$centre\n";
             close ( PSFIN );

# Specify the other parameters for the PSF stage.  Read from an old-style
# file not a table.  Increase the box size to include several arcseconds.
             my $ndf = $Frm->file;
             my $param1 = "in=$ndf gauss device=! incat=! cofile=centre$$.dat isize=101";

# Calculate the best-fitting Gaussian psf, using the star alone.  
             my $psf_status = $Mon{"kappa_mon"}->obeyw("psf","$param1");

# Use null values if PSF fails to converge.
             my ( $axisratio, $gfwhm, $ORAC_STATUS ); 
             if ( $psf_status != ORAC__OK ) {
                $gfwhm = "<null>";

             } else {

# Obtain the fit parameters of the point-spread function.
                ( $ORAC_STATUS, $gfwhm ) = $Mon{"kappa_mon"}->get("psf","fwhm");
                ( $ORAC_STATUS, $axisratio ) = $Mon{"kappa_mon"}->get("psf","axisr");

# Derive desired values from the results, namely the average FWHM
# Protect against nonsense axis ratios.  Convert to arcseocnds.
                $gfwhm = $gfwhm * sqrt( min( 10, $axisratio ) ) * $pixelscale;
             }
             unlink "centre$$.dat";

# Determine sky level by clipping.
# ================================

# This is a workaround the fact that there is no multiple clipping in
# PHOTOM's sky estimators.  This assumes a circular aperture.
             my ( $skymode, $skysigma );
             if ( $skyest == 4 ) {

# First find the radii of the sky annulus radii in pixels, then the
# diameter of the annulus in pixels.  The latter assumes that we know the
# centroid's position.
                my $innerrad = 0.5 * $inner * $as_aperture / $pixelscale;
                my $outerrad = 0.5 * $outer * $as_aperture / $pixelscale;
                my $pannulus = int( 2.0 * $outerrad ) + 1;

# Copy the annulus section to a temporary frame. 
                my $annbox = "annulus_box$$";
                my $param = "in=$ndf" . "(" . "$$centre[ 0 ]~$pannulus," .
                            "$$centre[ 1 ]~$pannulus" . ")";
                $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$param out=$annbox" );

# Create an ARD file to define the annulus whose statistics we want.
# Remove any existing annulus ARD definition file.
                unlink( "annulus.ard" );

# Defines pixels which are not in the annulus.  Work in pixel co-ordinates,
# not pixel indices.
                open( ARDFILE, ">annulus.ard" );
                print ARDFILE ".NOT. ( CIRCLE( $$centre[ 0 ], $$centre[ 1 ], $outerrad ) .AND. .NOT. CIRCLE( $$centre[ 0 ], $$centre[ 1 ], $innerrad ) )\n";
                close( ARDFILE );

# Mask all the pixels except those within the annulus.
                my $annout = "annulus$$";
                $param = "in=$annbox out=$annout ardfile=annulus.ard cosys=w";
                $Mon{"kappa_mon"}->obeyw("ardmask","$param");
                unlink( "annulus.ard" );

# Create a temporary frame just enclosing the sky annulus.
                my $Frm = $Frm->new( $annout );

# Find the clipped mean (effectively the mode) for the annulus.
                _CLIPPED_STATS_ CLIP=2,2,2.5,3
                $skymode = $_CLIPPED_STATS_{MEAN};
                $skysigma = $_CLIPPED_STATS_{SIGMA};

# Remove temporary frames.
                _DELETE_A_FRAME_ FRAME=$annbox
                _DELETE_A_FRAME_ FRAME=$annout
            }

# Automatic photometry
# ====================
#
# The automatic photometry task needs a text file to control the
# type and location of the photometry, and the size and shape of the
# aperture.  In this primitive these are fixed except the size, but
# we could use parameters for these in a hierarchy of scripts.  We have a
# circular aperture obtaining the sky from an annulus between the INNER
# and OUTER times the diameter of the main aperture.
             my $rapture = 0.5 * $as_aperture / $pixelscale;
             open ( PHOTOM, ">photom$$.dat" );
             print PHOTOM "#ANN 1 $inner $outer\n";
             print PHOTOM "1 @$centre 0.0 0.0 0.0 0.0 OK $rapture 0.0 0.0 annulus circle\n";
             close ( PHOTOM );

# Specify the user parameters.
             my $zp = 0.0;
             my $user;
             if ( $skyest == 4 ) {
                $user = "skyest=$skyest skymag=$zp sky=$skymode skysig=$skysigma";
             } else {
                $user = "skyest=$skyest skymag=$zp ";
             }
 
# Specify the other parameters for AUTOPHOTOM.  Strictly we should check the
# headers for the readout mode
             my $param1 = "in=$ndf infile=photom$$.dat outfile=photom$$.res";
             my $param2;
             if ( $positive ) {
                $param2 = "nocentro padu=$padu biasle=0 photon=2 positive sature=12000 nousemask";
             } else {
                $param2 = "nocentro padu=$padu biasle=0 photon=2 nousemags nopositive sature=12000 nousemask";
             }

# Perform the photometry, however, for this case compute a centroid
# about which to integrate.
# Use different modes of AUTOPHOTOM if the source is negative.
             $Mon{"photom_mon"}->obeyw("autophotom","$param1 $user $param2");
             unlink( "photom$$.dat" );

# Extract and present the results.
# ================================
#
# The magnitude and error are the fourth and fifth fields in the output
# file.  The sky estimate is the sixth.  The error code is the eighth.
             open ( PHOTOM, "photom$$.res" );
             my @results = map { (split)[3..7] } <PHOTOM>;
             close ( PHOTOM );

# Use more lucid variable names for the results.  Normalise by the
# exposure time.  The magnitude returned by AUTOPHOTOM is calculated
# using the expression -2.5log10( photons/s ).  However, the UKIRT
# standard is to use -2.5log10( counts/s ), so correct the instrumental
# magnitude by the ADU factor.
             my ( $errcode, $magerr, $magnorm, $sky_level );
             $errcode = $results[4];
             if ( $positive ) {
                $magnorm = $results[0] + 2.5 * log10( $exptime * $padu );
                $magerr = $results[1];

# Convert from counts to magnitudes for negative sources.  Add in zero
# point which is ignored when parameter usemags is false.
             } else {
                $magnorm = -2.5 * ( log10( abs( $results[3] ) ) -
                                    log10( $exptime * $padu ) ) + $zp;
                if ( abs( $results[ 0 ] ) > 1E-6 ) {
                   $magerr = 1 - 10 ** ( -0.4 * abs( $results[1] / $results[0] ) );
                } else {
                   $magerr = "<null>"
                }
             }

# Convert the sky level back to counts.
             $sky_level = $results[2] / $padu;

# Correct for the mean extinction.
             my $magext = $magnorm - $extcor;

# Convert annulus radii into arcseconds.
             my $as_inner = $inner * $as_aperture;
             my $as_outer = $outer * $as_aperture;

# Format the results to give a sensible number of significant figures.
             my ( $fs_mag, $fs_err, $fs_sky, $fs_airmass, $fs_apdiam );
             my ( $fs_catmag, $fs_inner, $fs_outer, $fs_gfwhm );
             $fs_mag = sprintf( "%7.3f", $magnorm );
             $fs_mag =~ s/ //g;
             if ( $magerr ne "<null>" ) {
                $fs_err = sprintf( "%6.3f", $magerr );
                $fs_err =~ s/ //g;
             } else {
                $fs_err = $magerr;
             }
             $fs_sky = sprintf( "%9.3f", $sky_level );
             $fs_sky =~ s/ //g;
             $fs_airmass = sprintf( "%6.4f", $extcor );
             $fs_apdiam = sprintf( "%5.2f", $as_aperture );
             $fs_apdiam =~ s/ //g;
             $fs_inner =  sprintf( "%5.2f", $as_inner );
             $fs_inner =~ s/ //g;
             $fs_outer =  sprintf( "%5.2f", $as_outer );
             $fs_outer =~ s/ //g;

             if ( $catmag < $nullmag ) {
                $magdif = $catmag - $magnorm;
                $magdif_ext = $catmag - $magext;

# IZLM only have two decimal places.  Some may be less than ten, so
# strip leading blanks.
                if ( $filter =~ /^[LMIZ]/ ) {
                   $fs_catmag = sprintf( "%5.2f", $catmag );
                   $fs_magdif_ext =  sprintf( "%5.2f", $magdif_ext );
                } else {
                   $fs_catmag = sprintf( "%6.3f", $catmag );
                   $fs_magdif_ext =  sprintf( "%6.3f", $magdif_ext );
                }
                $fs_catmag =~ s/ //g;
                $fs_magdif_ext =~ s/ //g;
             }

             if ( $gfwhm ne "<null>" ) {
                $fs_gfwhm = sprintf( "%5.3f", $gfwhm );
             }

# Print the results.
             orac_print "\n";
             orac_print "Frame:                  $ndf$suffix\n";
             orac_print "Filter:                 $filter\n";

             if ( $magerr ne "<null>" ) {
                if ( $errcode ne "OK" ) {
                   orac_print "Instrumental Magnitude: $fs_mag +/- $fs_err (error $errcode)\n";
                } else {
                   orac_print "Instrumental Magnitude: $fs_mag +/- $fs_err\n";
                }

             } else {
                if ( $errcode ne "OK" ) {
                   orac_print "Instrumental Magnitude: $fs_mag (error $errcode)\n";
                } else {
                   orac_print "Instrumental Magnitude: $fs_mag\n";
                }
             }

             orac_print "Airmass correction:     $fs_airmass\n";
             if ( $catmag < $nullmag ) {
                orac_print "Catalogue Magnitude:    $fs_catmag ($starname)\n";
                orac_print "Calculated zeropoint:   $fs_magdif_ext\n"
             }

             if ( $gfwhm ne "<null>" ) {
                orac_print "2-D Gaussian FWHM:      $fs_gfwhm arcsec\n";
             }

             orac_print "Sky:                    $fs_sky\n";
             orac_print "Aperture diameter:      $fs_apdiam arcsec\n";
             orac_print "Annulus radii:          $fs_inner to $fs_outer arcsec\n";
             orac_print "\n";

# Remove the photometry text file.
             unlink( "photom$$.res" );

# Write results to text logfile.
# ==============================

# Specify formats for the CURSA table.
             my @formats = qw( %22s %12s %8.5f %7s %5.3f %7.3f %7.3f %6.3f %2s
                               %5.1f %5.1f %5.1f %8.2f %1s %6.3f %6.3f %6.3f %5.3f );

# Allow for null strings instead of numerical values when something has
# gone awry.
             if ( $magerr eq "<null>" ) {
                $formats[7] = "%6s";
             }

# Convert array to a space-separated list.
             my $formatlist = join( " ", @formats );

# Write the results for the current observation to the logfile.  Use sprintf
# to format the statistics in the specified formats for the columns of
# the table.  Append the formatted row to the logging file.  Note in case
# some of the header information is null, output the results as strings
# rather than integer or real; and assume a fixed format in the FITS headers
# matching the STL format when the keywords are present.
             printf LOGFILE ( "$formatlist \n",
               $ndf.$suffix, $objname, $ut, $filter, $airmass, $magnorm,
               $magext, $magerr, $errcode, $as_aperture, $as_inner, $as_outer,
               $sky_level, $incflag, $catmag, $magdif, $magdif_ext, $gfwhm );

          }

# Close the results file.
          close ( LOGFILE );
       }
    }

# Podule
# ======

=head1 NAME

_FIXED_APERTURE_PHOTOMETRY_ -- Performs aperture photometry on a point source.

=head1 DESCRIPTION

This primitive performs aperture photometry of a point source
for the group frame, and target-frame members of the current $Grp
within the current cycle.  The results are reported and stored in
a text file---a Starlink STL table (see SUN/190).

The photometry is in circular aperture located at the centroid of
the source with the sky measured from a concentric annulus outside
the aperture.  The photometry engine accounts for fractional pixels
at the aperture edge but without allowance for the local gradient.
The photometry also yields an internal error determined from the 
sky variance.  The magnitudes are given by the expression 
-2.5 * log10( abs( counts ) per second exposure time ).  Therefore
negative sources can be measured too.

The source must lie within the specified aperture.  See arguments
XOFF and YOFF for the location of the aperture.

A case- and space-insensitive comparison of the object name with the
entries in a table provides a catalogue magnitude in I<I>, I<Z>, I<J>,
I<H>, I<K>, I<L>, or I<M> for a standard star.  Also a mean extinction
is applied for the mean of the start and end airmasses.  Thus the
primitive calculates an approximate zero point.

=head1 ARGUMENTS

=over 4

=item APERTURE = REAL (Given)

The aperture in arcseconds for the photometry.  [6.0]

=item INNER = REAL (Given)

The ratio of the diameters of inner ring of the sky annulus to
that of the object aperture (APERTURE).  It is constrained
to be in the range 1.1 to 3.0.  The mode of the pixel values in 
the annulus is used to subtract the sky for statistics 3) and
4) listed above.  [1.5]

=item OUTER = REAL (Given)

The ratio of the diameters of outer ring of the sky annulus to
that of the object aperture (APERTURE).  It is constrained to
be in the range 1.4 to 5.0 and be at least 0.3 greater than the
inner scale factor of the annulus.  [2.5]

=item POSITIVE = LOGICAL (Given)

If 1 (true), the point source is positive, i.e. has values
above the sky level.  If 0 (false), the point source is
negative.  [1]

=item SKY_EST = INTEGER (Given)

Sky estimations method as per AUTOPHOTOM parameter SKYEST.  The
default is the mode, so as to exclude contaminating sources.
1 is the mean; 2 is the average of values within two standard
deviations of the mean; 3 is the mode from PHOTOM, 4 is a 
multiply clipped mean emulating the mode but without involving
the median.  It is supplied as a constant to AUTOPHOTOM (hence
option 4).  The final option is to cope with self-flat frames
with a spike artifact in the histogram thus giving the wrong
median, and hence biased mode.   The default is used should 
the supplied value not be one of the allowed options. [3]

=item SUFFIX = CHARACTER (Given)

Suffix to be applied to the name of the frame in the log of
the results.  It is usually not set.  The NOD recipes need it
to discriminate between the positive and negative images.
[""]

=item  XOFF = REAL (Given)

The approximate x pixel offset of the centroid of the point
source to be measured with respect to the nominal position.
The nominal position is the y centre of the array plus the
x telescope offset.  (It's plus because R.A. increases with
negative x.)  [0.0]

=item YOFF = REAL (Given)

The approximate y pixel offset of the centroid of the point
source to be measured with respect to the nominal position.
The nominal position is the y centre of the array minus the
telescope offset.  [0.0]

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for UFTI, IRCAM, and Michelle in imaging mode.

=item *

Processing only occurs when it is time to perform photometry,
i.e. when the steering header DO_APHOT is true; and on target
object frames when the steering header TARGET_OR_SKY is "target".

=item *

The photometry text file is aphot_results.txt.  The format of
this file is described in primitive
L<_MAKE_PHOTOMETRY_TABLE_|_MAKE_PHOTOMETRY_TABLE_>.

=item *

Items reported in order are the frame and object names; UT start time;
filter; mean airmass; raw and extinction-corrected instrumental
magnitude and their error (if available); error flag, notably B
indicating that bad pixels were inside the aperture; aperture diameter
and the radii of the sky annulus in arcseconds; the sky level; the
catalogue magnitude; calculated raw and extinction-corrected zeropoint
(if the catalogue magnitude is known); and the FWHM of the
best-fitting two-dimensional Gaussian to the source.

=item *

A saturation level is set at 12000 counts.

=item *

The mean extinction coefficients are: I<I>: 0.07, I<Z>: 0.03, I<J>:
0.08; I<H>: 0.03; I<K>: 0.07; I<L>: 0.10; I<L'>:0.09, and I<M>: 0.30.
Zero extinction applies to any other filter.

=item *

A warning appears should the object not be found in the
standards file.

=item *

Where a value is unknown or cannot be computed, its entry in the
table is "E<lt>nullE<lt>".

=item *

The standard-star catalogue used is F<$ORAC_DATA_CAL/fs2001.dat>.
However, if this file is unavailable, the script accesses the old
F<$ORAC_DATA_CAL/fs2000.dat>, but only for JHK data.  An error
results a catalogue cannot be opened.

=item *

The ADU factor and exposure time stored in frame header are
validated.  Non-positive values cause a warning message to appear,
but the primitive continues defaulting the header value to 1.

=back

=head1 TASKS

KAPPA: ARDMASK, NDFCOPY, PSF; PHOTOM: AUTOPHOTOM.

=head1 AUTHORS

MJC: Malcolm J. Currie (JAC)

=head1 COPYRIGHT

Copyright (C) 1998-2001 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut
