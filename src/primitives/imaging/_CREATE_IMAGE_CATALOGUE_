# -*-perl-*-

=head1 NAME

_CREATE_IMAGE_CATALOGUE__ - source extraction and photometry on all sources

=head1 DESCRIPTION

For the group file, find all the sources and calculate the flux
of each detected source. Write the results to a catalogue file.

=head1 BUGS

 - Catalogue is currently given a fixed name rather than a name
   that changes with the group file (or possibly eSTAR Agent ID)

=head1 NOTES

Currently uses SEXTRACTOR for source extraction and for photometry.

=head1 AUTHOR

Brad Cavanagh <b.cavanagh@jach.hawaii.edu>

=head1 COPYRIGHT

Copyright (C) 2003 Particle Physics and Astronomy Research Council.
All Rights Reserved.

=cut

# Do only if it's time to create a catalogue.
if( $Frm->uhdr("CREATE_CATALOGUE") ) {

  # Delay loading so that ORAC-DR does not require these.

  use Astro::Catalog;
  use Astro::Catalog::Star;

# Obtain the minimum number of pixels in the objects.
  my $minpix = ( $_CREATE_IMAGE_CATALOGUE_{MINPIX} || 12 );

# Obtain the filter.
  my $filter = $Grp->uhdr("ORAC_FILTER");

# Perform inventory on the field
#
# Specify the EXTRACTOR parameters.  Can't change the default minimum area
# in pixels without editing the sex file...  Other parameters like the
# saturation level and plate scale should be edited in the sex file.  Also
# the name and format of the results catalogue is fixed (to match PISA) and is
# in the ASCII file ${ORAC_DATA_CAL}/extractor_mask.param.
  my $in = $Grp->file;
  my $resfile = "object_cat.cat";
  my $param1 = "image=$in config=$ENV{ORAC_DATA_CAL}/extractor_catalogue.sex";

# Report the processing status.
  orac_print "Detecting objects in $in with at least $minpix connected pixels\n";
  orac_print "   at 1.1 times sky noise above sky.\n";

# Derive an inventory of the images in $resfile.
  my $extractor_status = $Mon{ "extractor" }->obeyw( "extract", "$param1" );

# We can handle a failure here by making a null ARD file.  So we test a
# local status rather than let ORAC go on to the next file.
  if ( $extractor_status == ORAC__OK ) {

# Read the results file into an array.  Obtain the number of objects.
# Remove the results file.
    open( my $fh_resfile, "< $resfile" ) ||
      orac_throw "Unable to open $resfile to read the source inventory.  Error: $!.\n";
    my @lines = <$fh_resfile>;
    my $numobject = $#lines + 1;
    close( $fh_resfile );
#    unlink ( $resfile );

# Create the Astro::Catalog object.
    my $catalog = new Astro::Catalog( origin => 'UKIRT');

    my $pi = atan2( 1, 1 ) * 4;
    my $id = 0;

# Create a file to hold the locations of the found objects.
    my $objfile = "obj_file.txt";
    open( my $fh_objfile, "> $objfile" ) ||
      orac_throw "Unable to open $objfile for writing object locations. Error: $!.\n";

# Perform operations on every object
#
# We will perform the following steps for every object found by
# EXTRACTOR as long as that object is larger than the minimum
# number of pixels given by $minpix:
#
# - convert the pixel coordinates into RA/Dec
# - convert the flux into a magnitude
# - create an Astro::Catalog::Star object
# - push that object onto the Astro::Catalog object

    foreach my $line (@lines) {

      my @fields = split /\s+/, $line;

      my $ea = sqrt( $fields[6] / $pi /
                     max( ( 1.0 - $fields[8] ), 0.99999 ) );
      $ea = min( $ea, 0.5 * $fields[6] );
      my $eb = $ea * ( 1.0 - $fields[8] );

# Test for objects too small.  This is important, as EXTRACTOR can throw
# out objects of zero size.
      next if ( ( sqrt( max( 1.0E-7, $ea * $eb ) ) * $pi ) < $minpix );

#      print ( ( map { "($_)" } @fields ), "\n" );

# Write the x and y coordinates to file for conversion
# x coordinate is held in $fields[2]
# y coordinate is held in $fields[3]

      print $fh_objfile $fields[2], " ", $fields[3], "\n";

# Convert the flux into a magnitude
#
# The flux is in $fields[4]. We're not going for a calibrated magnitude here,
# so just do -2.5*log(flux).

      my $magnitude = -2.5 * log( $fields[4] ) / log( 10 );

# Approximation of error in magnitude is (error in flux) / (flux). It's an
# approximation but it's good to a few percent.
      my $mag_err = $fields[5] / $fields[4];

# Create the Astro::Catalog::Star object

      my $star = new Astro::Catalog::Star( ID => $id,
                                           Field => 0,
                                           Magnitudes => { $filter => $magnitude },
                                           MagErr => { $filter => $mag_err },
                                         );

# Push the Astro::Catalog::Star object into the Astro::Catalog object.
      $catalog->pushstar( $star );

      $id++;
    }

# Close the object list file.
    close( $fh_objfile );

    my $radecfile = "radec_objects.txt";

# Convert the pixel coordinates in the object list file to RA/Dec.
# We first need to set the WCS to PIXEL in the input NDF.
    $Mon{'ndfpack_mon'}->obeyw("wcsframe", "ndf=$in frame=GRID");

    my $params = "mode=file file=$objfile ndf=$in outcat=$radecfile";
    $Mon{'kappa_mon'}->obeyw("listmake", "$params");

# Switch the WCS back to SKY.
    $Mon{'ndfpack_mon'}->obeyw("wcsframe", "ndf=$in frame=SKY");

# Now the output file is a CURSA small text list file, and has
# formatting and coordinate system information in an extensive
# header. We do not need to worry about this, and our table of
# results begins the line after BEGINTABLE.

    open( my $fh_radecfile, "< $radecfile" ) ||
      orac_throw "Could not open $radecfile to read in RA/Dec positions. Error: $!.\n";

# Advance the file pointer.
    while( <$fh_radecfile> !~ /^BEGINTABLE/ ) { };

    $id = 0;
    while( <$fh_radecfile> ) {
      my @ra_fields = split /\s+/;

#      print ( ( map { "($_)" } @ra_fields ), "\n" );

# At this point we have the RA in $ra_fields[2] and the Dec in $ra_fields[3],
# but both are in radians, so we need to convert.
      my $ra = $ra_fields[2] * 180 / $pi;
      my $dec = $ra_fields[3] * 180 / $pi;

      if( $ra < 0 ) { $ra += 360; };
      $ra /= 15;

# Convert to sexagesimal.
      my $radeg = int( $ra );
      my $ramin = int( ( $ra - $radeg ) * 60 );
      my $rasec = ( ( ( $ra - $radeg ) * 60 ) - $ramin ) * 60;

      my $decsign = $dec > 0 ? "+" : "-";
      my $decres = abs( $dec );
      my $decdeg = int( $decres );
      $decres = $decres - $decdeg;
      my $decmin = int( 60.0 * $decres );
      $decres -= $decmin / 60.0;
      my $decsec = 3600.0 * $decres;

      my $ra_string = sprintf("%d:%02d:%05.2f", $radeg, $ramin, $rasec);
      my $dec_string = sprintf("%s%d:%02d:%05.2f", $decsign, $decdeg, $decmin, $decsec);

# Create an Astro::Coords object.
      my $coords = new Astro::Coords( ra => $ra_string,
                                      dec => $dec_string,
                                      units => 'sexagesimal',
                                      type => 'J2000',
                                    );

# Pop the star out of the catalogue.
      my @stars = $catalog->popstarbyid( $id );
      my $star = $stars[0];

# Set its position.
      $star->coords( $coords );

# And push it back into the catalogue.
      $catalog->pushstar( $star );

      $id++;
    }

# Dump the catalog to disk.
    _GET_CATALOGUE_NAME_
    my $catalogue = $_GET_CATALOGUE_NAME_{NAME};
    my $cat_file = $ENV{'ORAC_DATA_OUT'} . "/" . $catalogue;

    my @filters = ( $filter );
    my $status = $catalog->write_catalog( file => $cat_file,
					  format => 'Cluster',
                                        );
    orac_print "Wrote catalogue to $cat_file with status $status\n\n";

  }

}
