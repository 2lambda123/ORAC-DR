# -*-perl-*-

# Do only if we are "eSTAR-enabled".
if( $Frm->uhdr("DO_ESTAR_PHOTOMETRY") ) {

  require "/home/bradc/data/downloads/misc/Astro-Catalog-2.1.2/Catalog.pm";
  use Astro::Catalog::Star;

# Obtain the minimum number of pixels in the objects.
  my $minpix = ( $_EXTRACTOR_PHOTOMETRY_ESTAR_{MINPIX} || 12 );

# Obtain the filter.
  my $filter = $Grp->uhdr("ORAC_FILTER");

# Perform inventory on the field
#
# Specify the EXTRACTOR parameters.  Can't change the default minimum area
# in pixels without editing the sex file...  Other parameters like the
# saturation level and plate scale should be edited in the sex file.  Also
# the name and format of the results catalogue is fixed (to match PISA) and is
# in the ASCII file ${ORAC_DATA_CAL}/extractor_mask.param.
  my $in = $Grp->file;
  my $resfile = "object_mask.cat";
  my $param1 = "image=$in config=$ENV{ORAC_DATA_CAL}/extractor_mask.sex";

# Report the processing status.
  orac_print "Detecting objects in $in with at least $minpix connected pixels\n";
  orac_print "   at 1.1 times sky noise above sky.\n";

# Derive an inventory of the images in $resfile.
  my $extractor_status = $Mon{ "extractor" }->obeyw( "extract", "$param1" );

# We can handle a failure here by making a null ARD file.  So we test a
# local status rather than let ORAC go on to the next file.
  if ( $extractor_status == ORAC__OK ) {

# Read the results file into an array.  Obtain the number of objects.
# Remove the results file.
    open( my $fh_resfile, "< $resfile" ) ||
      orac_throw "Unable to open $resfile to read the source inventory.  Error: $!.\n";
    my @lines = <$fh_resfile>;
    my $numobject = $#lines + 1;
    close( $fh_resfile );
#    unlink ( $resfile );

# Create the Astro::Catalog object.
    my $catalog = new Astro::Catalog;

    my $pi = atan2( 1, 1 ) * 4;
    my $id = 0;

# Create a file to hold the locations of the found objects.
    my $objfile = "obj_file.txt";
    open( my $fh_objfile, "> $objfile" ) ||
      orac_throw "Unable to open $objfile for writing object locations. Error: $!.\n";

# Perform operations on every object
#
# We will perform the following steps for every object found by
# EXTRACTOR as long as that object is larger than the minimum
# number of pixels given by $minpix:
#
# - convert the pixel coordinates into RA/Dec
# - convert the flux into a magnitude
# - create an Astro::Catalog::Star object
# - push that object onto the Astro::Catalog object

    foreach my $line (@lines) {

      my @fields = split /\s+/, $line;

      my $ea = sqrt( $fields[5] / $pi /
                     max( ( 1.0 - $fields[7] ), 0.99999 ) );
      $ea = min( $ea, 0.5 * $fields[5] );
      my $eb = $ea * ( 1.0 - $fields[7] );

# Test for objects too small.  This is important, as EXTRACTOR can throw
# out objects of zero size.
      next if ( ( sqrt( max( 1.0E-7, $ea * $eb ) ) * $pi ) < $minpix );

#      print ( ( map { "($_)" } @fields ), "\n" );

# Write the x and y coordinates to file for conversion
# x coordinate is held in $fields[2]
# y coordinate is held in $fields[3]

      print $fh_objfile $fields[2], " ", $fields[3], "\n";

# Convert the flux into a magnitude
#
# The flux is in $fields[4]. We're not going for a calibrated magnitude here,
# so just do -2.5*log(flux).

      my $magnitude = -2.5 * log( $fields[4] ) / log( 10 );

# Create the Astro::Catalog::Star object

      my $star = new Astro::Catalog::Star( ID => $id,
                                           Magnitudes => { $filter => $magnitude },
                                         );

# Push the Astro::Catalog::Star object into the Astro::Catalog object.
      $catalog->pushstar( $star );

      $id++;
    }

# Close the object list file.
    close( $fh_objfile );

    my $radecfile = "radec_objects.txt";

# Convert the pixel coordinates in the object list file to RA/Dec.
# We first need to set the WCS to PIXEL in the input NDF.
    $Mon{'ndfpack_mon'}->obeyw("wcsframe", "ndf=$in frame=GRID");

    my $params = "mode=file file=$objfile ndf=$in outcat=$radecfile";
    $Mon{'kappa_mon'}->obeyw("listmake", "$params");

# Switch the WCS back to SKY.
    $Mon{'ndfpack_mon'}->obeyw("wcsframe", "ndf=$in frame=SKY");

# Now the output file is a CURSA small text list file, and has
# formatting and coordinate system information in an extensive
# header. We do not need to worry about this, and our table of
# results begins the line after BEGINTABLE.

    open( my $fh_radecfile, "< $radecfile" ) ||
      orac_throw "Could not open $radecfile to read in RA/Dec positions. Error: $!.\n";

# Advance the file pointer.
    while( <$fh_radecfile> !~ /^BEGINTABLE/ ) { };

    $id = 0;
    while( <$fh_radecfile> ) {
      my @ra_fields = split /\s+/;

#      print ( ( map { "($_)" } @ra_fields ), "\n" );

# At this point we have the RA in $ra_fields[2] and the Dec in $ra_fields[3],
# but both are in radians, so we need to convert.
      my $ra = $ra_fields[2] * 180 / $pi;
      my $dec = $ra_fields[3] * 180 / $pi;

      if( $ra < 0 ) { $ra += 360; };
      $ra /= 15;

# Convert to sexagesimal.
      my $radeg = int( $ra );
      my $ramin = int( ( $ra - $radeg ) * 60 );
      my $rasec = ( ( ( $ra - $radeg ) * 60 ) - $ramin ) * 60;

      my $decsign = $dec < 0 ? "+" : "-";
      my $decres = abs( $dec );
      my $decdeg = int( $decres );
      $decres = $decres - $decdeg;
      my $decmin = int( 60.0 * $decres );
      $decres -= $decmin / 60.0;
      my $decsec = 3600.0 * $decres;

      my $ra_string = sprintf("%d:%02d:%05.2f", $radeg, $ramin, $rasec);
      my $dec_string = sprintf("%s%d:%02d:%05.2f", $decsign, $decdeg, $decmin, $decsec);
#      print "RA: $ra_string\nDec: $dec_string\n";

      my @stars = $catalog->popstarbyid( $id );
      my $star = $stars[0];

      $star->ra( $ra_string );
      $star->dec( $dec_string );

      $catalog->pushstar( $star );

      $id++;
    }

# Dump the catalog to disk.
    my $cat_file = $ENV{'ORAC_DATA_OUT'} . "/estar_cat.txt";
    my $status = $catalog->write_catalog( $cat_file );
    orac_print "Wrote ESTAR catalogue to $cat_file\n\n";

  }

}
