# Name:
#    _NORMALISE_TO_MODE_EXTENDED_
#
# Purpose:
#    Normalises a frame's mode to that of a reference frame for EXTENDED_nxm recipes.
#
# Language:
#    Perl5
#
# Description:
#    The primitive is for EXTENDED_nxm recipes.  It makes an additive
#    normalisation to the current sky frame so as the mode of the
#    current frame matches that of a reference sky frame.  It reports a
#    successful normalisation, the frames concerned, and the value of
#    the normalisation offset.
#
#    When the steering header REFERENCE_FRAME is true, the primitive
#    stores the mode into internal header REFERENCE_SKY, and reports the
#    frame and mode.  Otherwise the reference frame is accessed and its
#    REFERENCE_SKY read to obtain the fiducial sky level.
#
#    The primitive also pushes the offset into an array called SKY_LEVELS
#    within the reference frame's internal header.  This array is created
#    whenever a reference frame is encountered, i.e. the first in a cycle
#    of the recipe.  The levels stored in SKY_LEVELS are used by primitive
#    _SUBTRACT_SKY_CHOP_SKY_ to interpolate sky contributions in the
#    target frames.

# Notes:
#    -  This primitive is suitable for both UFTI and IRCAM.
#    -  Processing only occurs for frames where the steering header
#    TARGET_OR_SKY equals "sky".
#    -  Only a warning is given if the reference mode could not be
#    accessed, and a zero offset is adopted.
#    -  Clips at 2, 2.5, 3, and 3 sigma to derive the mode.
#    -  The normalised image can be displayed.
#    -  The frame title is "Normalised to mode".
#
# Output Data:
#    -  A normalised frame inheriting its corresponding input frame's name
#    but with the _nm suffix.
#
# Tasks:
#    KAPPA: CADD.
#
# Authors:
#    MJC: Malcolm J. Currie (JAC)
#
# Imports:
#    _CLIPPED_STATS_                      : RESULT
#
# Copyright:
#    Copyright (C) 1998-2001 Particle Physics and Astronomy Research
#    Council.  All Rights Reserved.
#
#-

# Test whether or not this is an object frame.
    if ( $Frm->uhdr( "ORAC_OBSERVATION_TYPE" ) eq "OBJECT" ||
         $Frm->uhdr( "ORAC_OBSERVATION_TYPE" ) eq "SKY" ) {

# Test whether or not this is an object frame or a sky frame. 
       my $class = $Frm->uhdr( "TARGET_OR_SKY" );

# Test whether or not this is a target frame or a sky frame.
       if ( $class eq "sky" ) {

# Find the clipped mean (effectively the mode) for the frame.
          _CLIPPED_STATS_ CLIP=2,2.5,3,3
          my $mode = $_CLIPPED_STATS_{MEAN};

# Format to a sensible number of decimal places for output.
          my $fs_mode = sprintf( "%12.4f", $mode );
          $fs_mode =~ s/ //g;

# Generate the input and output filenames.
          ( my $in, my $out ) = $Frm->inout( "_nm" );

# Determine whether or not this is the first sky frame, and hence whether or
# not a reference mode is needed.  We need a global variable to store
# this value, and the only one we have available for the first frame
# is the frame header.  There is no group header.
          my $refframe = $Frm->uhdr( "REFERENCE_FRAME" );
          my ( $refindex, $sky_offset );
          if ( $refframe ) {
             $Frm->uhdr( "REFERENCE_SKY", $mode );
             orac_print "Mode for reference frame $in is $fs_mode\n";
          }

# Define the reference mode for the reference frame.  Record the index
# of the reference frame.
          if ( $mode > 1.0E-7 ) {
             my $refmode;
             if ( $refframe ) {
                $refmode = $mode;
                $refindex = $Grp->num;

# Recall the reference level from the most-recent reference frame within
# the group.  We know that the current frame is not a reference frame so
# start searching from the previous frame.
             } else {
                my $refFrm;
                my $numframe = $Grp->num + 1;
                $refframe = 0;
                until ( $refframe || $numframe == 0 ) {
                   $numframe--;
                   $refFrm = $Grp->frame( $numframe );
                   $refframe = $refFrm->uhdr( "REFERENCE_FRAME" );
                }

# Check that reference frame has been located.  If not fudge the
# sky level for now so the recipe completes, albeit with a poorer
# mosaic.
                if ( ! $refframe ) {
                   orac_warn "There is no reference frame from which to obtain ".
                             "a reference sky level.  Assume a constant level.\n";
                   $refmode = $mode;
                   $refindex = 0;

                } else {
                   $refmode = $refFrm->uhdr( "REFERENCE_SKY" );
                   $refindex = $numframe;

                }
             }

# Evaluate the normalisation offset.
             $sky_offset = $refmode - $mode;

# Format to the offset to sensible number of decimal places.
             my $fs_offset = sprintf( "%12.4f", $sky_offset );
             $fs_offset =~ s/ //g;

# Report the processing status.
             orac_print "Modal sky for frame $in is $fs_mode\n";
             orac_print "Offset for frame $in is $fs_offset\n\n";

          } else {
             orac_err "Unable to normalise frame $in.  Mode ($fs_mode) is too small.\n";
          }

# Normalise the current frame to the current reference frame.
          my $param1 = "in=$in out=$out scalar=$sky_offset title=\'Normalised to mode\'";
          $Mon{ "kappa_mon" }->obeyw( "cadd", "$param1" );

# Record the sky level for later sky subtraction.  Need to retain a reference
# to the hash to preserve it between frames.
          my $refFrm = $Grp->frame( $refindex );
          my $skyref = $refFrm->uhdr( "SKY_LEVELS" );
          unless ( defined $skyref ) {
             $skyref = [];
             $refFrm->uhdr( "SKY_LEVELS", $skyref );
          }
          push( @$skyref, $mode );

# Report the processing.
          orac_print "$in to $out: Data normalised\n\n";

# Record the new file name in the frame object.
          $Frm->file( $out );                       # obligatory update step

# Display the image.
          _DISPLAY_FRAME_IMAGE_

       }
    }

# Podule
# ======

=head1 NAME

_NORMALISE_TO_MODE_EXTENDED_ -- Normalises a frame's mode to that of a reference frame for EXTENDED_I<n>xI<m> recipes.

=head1 DESCRIPTION

The primitive is for EXTENDED_I<n>xI<m> recipes.  It makes an additive
normalisation to the current sky frame so as the mode of the
current frame matches that of a reference sky frame.  It reports a
successful normalisation, the frames concerned, and the value of
the normalisation offset.

When the steering header REFERENCE_FRAME is true, the primitive stores
the mode into internal header REFERENCE_SKY, and reports the frame and
mode.  Otherwise the reference frame is accessed and its REFERENCE_SKY
read to obtain the fiducial sky level.

The primitive also pushes the offset into an array called SKY_LEVELS
within the reference frame's internal header.  This array is created
whenever a reference frame is encountered, i.e. the first in a cycle
of the recipe.  The levels stored in SKY_LEVELS are used by primitive
L<_SUBTRACT_SKY_CHOP_SKY_|_SUBTRACT_SKY_CHOP_SKY_> to interpolate sky
contributions in the target frames.

=head1 NOTES

=over 4

=item *

This primitive is suitable for UFTI, IRCAM, and Michelle in imaging mode.

=item *

Processing only occurs for frames where the steering header
TARGET_OR_SKY equals "sky".

=item *

Only a warning is given if the reference mode could not be
accessed, and a zero offset is adopted.

=item *

Clips at 2, 2.5, 3, and 3 sigma to derive the mode.

=item *

The normalised image can be displayed.

=item *

The frame title is "Normalised to mode".

=back

=head1 OUTPUT DATA

=over 4

=item *

A normalised frame inheriting its corresponding input frame's name
but with the _nm suffix.

=back

=head1 TASKS

KAPPA: CADD.

=head1 AUTHORS

MJC: Malcolm J. Currie (JAC)

=head1 COPYRIGHT

Copyright (C) 1998-2001 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut
