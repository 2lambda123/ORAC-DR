#+
# Name:
#    _COMBINE_CHOPPED_SOURCE_
#
# Purpose:
#    Combines chopped and nodded images for NOD_CHOP recipes.
#
# Language:
#    Perl5
#
# Description:
#    This primitive forms a combined source file from the current group
#    file.  It expects the group file to be an integrated chopped and
#    nodded image, in which the source appears as two positive and two
#    negative images.  The primitive optionally locates the centroid of
#    each source, and extracts a symmetric region about each source. 
#    These regions are combined (see argument METHOD) to create an image
#    of the source of twice the signal-to-noise of a single image, but
#    normalised to yield the average signal of a single image.  This
#    maintains the scaling of flux per unit exposure time. 
#
#    The primitive also forms a quality map indicating the contributions
#    from each image of the source to help interpret the final combined
#    frame.
#
# Arguments:
#    CENTROID = LOGICAL (Given)
#       If true (1), centroid on the source in each sub-frame before
#       combining.  If successful, the resultant combined file has the
#       source centred.  Centroiding is not suitable for objects near
#       the detection limit.  Setting CENTROID to false (0), means
#       the combined file is centred about the expected position of
#       the source.  [1] 
#    CLEAN = LOGICAL (Given)
#       If true (1), column then row patterns, say due to pickup or
#       bias variations, are filtered out by subtracting the median
#       of each column or row from all the values in that column or
#       row.  It's useful to help see faint sources.  [0]
#    METHOD = CHARACTER (Given)
#       The method used to combine frames, once all have the same
#       polarity.  See parameter METHOD of CCDPACK/MAKEMOS (SUN/139) for
#       the options.  The main two in practice will be "Median" or
#       "Mean".  The former excludes outliers but has problems in good
#       seeing where the registration is poor, as it biases against the
#       peak values of the steepening profile near the core, and hence
#       underestimate the flux.  In this circumstance the mean blurs the
#       psf profile, making it more of a plateau than a sharp peak.
#       However, the mean preserves the flux, at the cost of the odd
#       rogue value affecting the result.  ["Mean"]
#    QMAP = LOGICAL (Given)
#       If true (1), a quality map is generated. [0]
#    SMOOTH = INTEGER (Given)
#       If greater than 1 apply block smoothing with a square block size
#       equal to SMOOTH to the combined image.  For all other values, 
#       there is no smoothing.  [0]
#
# Notes:
#    -  This primitive is suitable for Michelle in imaging mode.
#    -  Processing only occurs for object frames, and when the
#    steering header MAKE_MOSAIC is true.
#    -  The file to be combined may be specified through group user 
#    header MOSAIC_FRAME, if $Grp->file is not the file from which to
#    combine images.
#    -  The centroid is found by first setting the initial positions to
#    the telescope offset in Cartesian co-ordinates for each nod position
#    from the centre of the mosaic, and using a search window equal
#    to the larger absolute telescope offset.  The telescope offsets are
#    derived from the first and second frames in the current-cycle group.
#    -  The average offsets of the centroid positions from the nominal
#    source locations are found; the nearest-integer offsets are stored
#    in $Cal->baseshift.  When argument CENTROID is false,
#    $Cal->baseshift is accessed, and if there is a valid shift vector,
#    the script offsets the nominal position of each region by this
#    vector.  This is to allow for misplaced instrument apertures
#    whenever the weak flux prevents centroiding. 
#    -  The regions are made as large as possible such that there is no
#    duplication of pixels from the original group file.  In other words
#    the regions extend to the midpoints of the chop throw and nod
#    offsets.  User header ORAC_CHOP_ANGLE is used to select one of two
#    orientations (0 or +/-90 degrees) to derive the x-y half-widths of
#    the regions.
#    -  Before addition, the origins of each identically sized frame
#    are set to 0,0.
#    -  It determines for the current recipe cycle the two nod positions
#    from the first two frames (nod to beam A then beam B) of the current
#    cycle.  Those coupled with the chop throw and angle, and the mosaic
#    centre specify the approximate locations of the sources for the
#    centroid locating.
#    -  The quality map is derived from the four sub-frames, with
#    recommended smoothing if argument SMOOTH=1.  It is the sum of the 
#    pixel values divided by their abslute values, after changing sign
#    for the negative sources.  In the map +4 indicates that a pixel had 
#    positive contributions from the positive images and negative signal
#    from the negative images.  Thus it helps to discriminate from sources
#    which have been chopped into view, for which there are no positive
#    or negative counterparts (values +/-2) or noise (0, +/-2).
#    -  The steering header CYCLE_NUMBER specifies the recipe cycle
#    number.
#    -  The smoothed and raw combined images, and the quality map may
#    be displayed.
#    -  The name of the combined frame is stored is the group user
#    header called COMBINED_SOURCE_FRAME.
#
# Output Data:
#    -  Combined source frame inheriting the group file's name but with the
#    _cab suffix.  The smoothed version has a _scab suffix.
#    -  The quality map inheriting the group file's name but with the
#    _qcab suffix.
#    -  The extracted sections about image within the mosaic, inheriting
#    the group file's name but with the suffices _Ap, _An, _Bp, _Bn for
#    the positive (p) and negative (n) images in the A and B beams.
#
# Tasks:
#    CCDPACK: MAKEMOS; KAPPA: BLOCK, MATHS, NDFCOPY, SETORIGIN.
#
# Deficiencies:
#    -  Assumes an ABBA pattern comprising two positive and two negative
#    images.  If the nodding and jitter are in the same direction it
#    is possible to have a double positive image and two negatives.
#    -  The group and frame management is tricky.   In part it's having
#    access to both steering and mosaic headers.  The created _cab frame
#    needs to be accessed within primitives directly rather than using
#    the current frame.
#
# Authors:
#    MJC: Malcolm J. Currie (JAC)
#
# Copyright:
#    Copyright (C) 2001--2002 Particle Physics and Astronomy Research
#    Council.  All Rights Reserved.
#
#-

# Selection
# =========

# This should only be performed on OBJECT frames.
    if ( $Frm->uhdr( "ORAC_OBSERVATION_TYPE" ) =~ /OBJECT/ &&
         $Frm->uhdr( "MAKE_MOSAIC" ) ) {

# Obtain the cycle number.  Default to zero if undefined, so that recipes
# which do not support this feature will continue to work.
       my $cycleno = $Frm->uhdr( "CYCLE_NUMBER" );
       $cycleno = defined( $cycleno ) ? $cycleno : 0;

# Select those members in the current cycle.
       my $cycleGrp = $Grp->subgrp( CYCLE_NUMBER => $cycleno );

# Arguments
# =========
# Obtain the value for the combination method.
       my $method = ( lc( $_COMBINE_CHOPPED_SOURCE_{METHOD} ) || "mean" );

# Determine whether or not to fill bad pixels.
       my $centroid = $_COMBINE_CHOPPED_SOURCE_{CENTROID};
       $centroid = defined( $centroid ) ? $centroid : 1;

# Determine whether or not to filter column and row patterns.
       my $clean = $_COMBINE_CHOPPED_SOURCE_{CLEAN};
       $clean = defined( $clean ) ? $clean : 0;

# Determine whether or not to generate a quality map.
       my $qmap = $_COMBINE_CHOPPED_SOURCE_{QMAP};
       $qmap = defined( $qmap ) ? $qmap : 0;

# Determine whether or not to fill bad pixels.
       my $smoothbox = $_COMBINE_CHOPPED_SOURCE_{SMOOTH};
       $smoothbox = defined( $smoothbox ) ? int( $smoothbox ) : 0;

       my $aperture;
       if ( $centroid ) {

# Specify the aperture.  Want to approximate it to the size of the symmetric
# non-overlapping region about a source.  Place a lower limit to ensure
# that there is a window to find an object with poor co-ordinates.  Since
# the signals of the same sign are diametrically opposite this can be moderately
# large, but set it lower in case the chops and nods are small for a reason.
          $aperture = max( abs( $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET" ) ), 
                           abs( $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET" ) ) );
          $aperture = min( $Frm->uhdr( "ORAC_CHOP_THROW" ), 2.0 * $aperture );
          $aperture = max( $aperture, 3 );
       }

# Frame preliminaries.
# ====================

# Obtain the frame containing the mosaic from which the combined image
# is to be generated.  First try the user header for the reference.
       my $in;
       my $mosFrm = $Grp->uhdr( "MOSAIC_FRAME" );
       if ( defined( $mosFrm ) ) {
          $in = $mosFrm->file;

       } else {

# Create a new frame containing the mosaic.  This is needed to find the
# frame centre.  Process the group file by default.
          $in = $Grp->file;
          $mosFrm = new $Frm;
          $mosFrm->file( $in );

# Propagate the headers.
          %{ $mosFrm->hdr } = %{ $Grp->hdr };
          %{ $mosFrm->uhdr } = %{ $Grp->uhdr };
       }

# Record original telescope offsets.
       my $mos_raoff = $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET" );
       my $mos_decoff = $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET" );

# Find the nominal locations of the images.
# =========================================

# Find the bounds of the array, and hence its centre.
       my ( $xmid, $ymid );
       {
          my $Frm = $mosFrm;
          _GET_FRAME_CENTRE_
          $xmid = $_GET_FRAME_CENTRE_{XCENTRE};
          $ymid = $_GET_FRAME_CENTRE_{YCENTRE};
       }

# Find the limiting telescope offsets.  Obtain the telescope offsets
# and apply the rotation matrix to convert these to pixels.  Assume
# that the first two frames are at the A and B offsets.
       my ( $xpA, $xpB, $xnA, $xnB, $ypA, $ypB, $ynA, $ynB );
       my ( $x_chop_offset, $y_chop_offset, $x_nod_offset, $y_nod_offset );
       my ( $Ara_chop_offset, $Adec_chop_offset, $Bra_chop_offset, $Bdec_chop_offset );
       my ( $A_raoff, $A_decoff, $B_raoff, $B_decoff );
       my $first = 1;

# Form a new temporary group.
       my $tempGrp = new $Grp;
       $tempGrp->push( $cycleGrp->frame( 0 ) );
       $tempGrp->push( $cycleGrp->frame( 1 ) );

       foreach my $Frm ( $tempGrp->members ) {
          _GET_CARTESIAN_TELESCOPE_OFFSETS_
          $x_nod_offset = $_GET_CARTESIAN_TELESCOPE_OFFSETS_{XOFF};
          $y_nod_offset = $_GET_CARTESIAN_TELESCOPE_OFFSETS_{YOFF};

# Obtain the chop throw offsets.
          _GET_CHOP_OFFSETS_
          $x_chop_offset = $_GET_CHOP_OFFSETS_{XOFF};
          $y_chop_offset = $_GET_CHOP_OFFSETS_{YOFF};

          if ( $first ) {
             $Ara_chop_offset = $_GET_CHOP_OFFSETS_{RAOFF};
             $Adec_chop_offset = $_GET_CHOP_OFFSETS_{DECOFF};

# Since the sense of the chop throw is not provided, we assume the ABBA
# convention.  Note we have to subtract the offsets to obtain the
# positions.
             $xpA = $xmid + $x_nod_offset;
             $ypA = $ymid + $y_nod_offset;
             $xnA = $xpA - $x_chop_offset;
             $ynA = $ypA - $y_chop_offset;

# Record telescope offsets for centroiding.
             $A_raoff = $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET" );
             $A_decoff = $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET" );
             $first = 0;

          } else {

             $Bra_chop_offset = $_GET_CHOP_OFFSETS_{RAOFF};
             $Bdec_chop_offset = $_GET_CHOP_OFFSETS_{DECOFF};

             $xnB = $xmid + $x_nod_offset;
             $ynB = $ymid + $y_nod_offset;
             $xpB = $xnB - $x_chop_offset;
             $ypB = $ynB - $y_chop_offset;

# Record telescope offsets for centroiding.
             $B_raoff = $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET" );
             $B_decoff = $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET" );
          }
       }

# Use approximate positions to find the centroids.
# ================================================
       my ( $sectionAp, $sectionAn, $sectionBp, $sectionBn );

       {

# Want to find centroids within the mosaic.
          my $Frm = $mosFrm;

          if ( $centroid ) {

# Initialise displacement measures.
             my ( $centre, $init );
             my $xdisp = 0;
             my $ydisp = 0;
             my $num_centroid = 0;

# Locate the centroid of the A positive image.  This uses the telescope
# offsets to locate the source.  Hence first set the telescope offsets
# to those of the A beam.
             $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET", $A_raoff  );
             $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET", $A_decoff );

             _FIND_SOURCE_CENTROID_ POSITIVE=1 BOXSIZE=$aperture

# It is possible that no centroid was found.  Get a reference to the flag,
# test the status, and report an error where centroiding failed.  The
# centroiding can fail without giving an error, hence there is a test
# that the position is defined.  When there is no centroid found, give a
# warning but carry on with nominal position.  Update the position with the
# centroid's co-ordinates.
             my $found = $_FIND_SOURCE_CENTROID_{FOUND};
             $centre = $_FIND_SOURCE_CENTROID_{CENTRE};

             if ( $$found && defined( $$centre[ 0 ] ) ) {
                $xpA = $$centre[ 0 ];
                $ypA = $$centre[ 1 ];

# Find the pixel displacement between the source and its expected
# location and add to the sum of the displacements.
                $init = $_FIND_SOURCE_CENTROID_{INIT};
                $xdisp += $$centre[ 0 ] - $$init[ 0 ];
                $ydisp += $$centre[ 1 ] - $$init[ 1 ];
                $num_centroid++; 

             } else {
                orac_err "Unable to locate positive A-beam source for " .
                         "aperture photometry.\n";
             }

# Locate the centroid of the negative A beam.  This is approximately
# displaced from the A positive by the negative chop throw.
             my $neg_Ara_chop_offset = -1 * $Ara_chop_offset;
             my $neg_Adec_chop_offset= -1 * $Adec_chop_offset;
             _FIND_SOURCE_CENTROID_ POSITIVE=0 BOXSIZE=$aperture RAOFF=$neg_Ara_chop_offset DECOFF=$neg_Adec_chop_offset

# It is possible that no centroid was found.  Get a reference to the flag,
# test the status, and report an error where centroiding failed.  The
# centroiding can fail without giving an error, hence there is a test
# that the position is defined.  When there is no centroid found, give a
# warning but carry on with nominal position.  Update the position with the
# centroid's co-ordinates.
             $found = $_FIND_SOURCE_CENTROID_{FOUND};
             $centre = $_FIND_SOURCE_CENTROID_{CENTRE};
             if ( $$found && defined( $$centre[ 0 ] ) ) {
                $xnA = $$centre[ 0 ];
                $ynA = $$centre[ 1 ];

# Find the pixel displacement between the source and its expected
# location and add to the sum of the displacements.
                $init = $_FIND_SOURCE_CENTROID_{INIT};
                $xdisp += $$centre[ 0 ] - $$init[ 0 ];
                $ydisp += $$centre[ 1 ] - $$init[ 1 ];
                $num_centroid++; 

             } else {
                orac_err "Unable to locate negative A-beam source for " .
                         "aperture photometry.\n";
             }

# Locate the centroid of the B negative image.  This uses the telescope
# offsets to locate the source.  Hence first set the telescope offsets
# to those of the B beam.
             $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET", $B_raoff  );
             $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET", $B_decoff );

             _FIND_SOURCE_CENTROID_ POSITIVE=0 BOXSIZE=$aperture

# It is possible that no centroid was found.  Get a reference to the flag,
# test the status, and report an error where centroiding failed.  The
# centroiding can fail without giving an error, hence there is a test
# that the position is defined.  When there is no centroid found, give a
# warning but carry on with nominal position.  Update the position with the
# centroid's co-ordinates.
             $found = $_FIND_SOURCE_CENTROID_{FOUND};
             $centre = $_FIND_SOURCE_CENTROID_{CENTRE};
             if ( $$found && defined( $$centre[ 0 ] ) ) {
                $xnB = $$centre[ 0 ];
                $ynB = $$centre[ 1 ];

# Find the pixel displacement between the source and its expected
# location and add to the sum of the displacements.
                $init = $_FIND_SOURCE_CENTROID_{INIT};
                $xdisp += $$centre[ 0 ] - $$init[ 0 ];
                $ydisp += $$centre[ 1 ] - $$init[ 1 ];
                $num_centroid++; 

             } else {
                orac_err "Unable to locate negative B-beam source for " .
                         "aperture photometry.\n";
             }

# Locate the centroid of the positive A beam.  This is approximately
# displaced from the B negative by the negative chop throw.
             my $neg_Bra_chop_offset = -1 * $Bra_chop_offset;
             my $neg_Bdec_chop_offset = -1 * $Bdec_chop_offset;
             _FIND_SOURCE_CENTROID_ POSITIVE=1 BOXSIZE=$aperture RAOFF=$neg_Bra_chop_offset DECOFF=$neg_Bdec_chop_offset

# It is possible that no centroid was found.  Get a reference to the flag,
# test the status, and report an error where centroiding failed.  The
# centroiding can fail without giving an error, hence there is a test
# that the position is defined.  When there is no centroid found, give a
# warning but carry on with nominal position.  Update the position with the
# centroid's co-ordinates.
             $found = $_FIND_SOURCE_CENTROID_{FOUND};
             $centre = $_FIND_SOURCE_CENTROID_{CENTRE};
             if ( $$found && defined( $$centre[ 0 ] ) ) {
                $xpB = $$centre[ 0 ];
                $ypB = $$centre[ 1 ];

# Find the pixel displacement between the source and its expected
# location and add to the sum of the displacements.
                $init = $_FIND_SOURCE_CENTROID_{INIT};
                $xdisp += $$centre[ 0 ] - $$init[ 0 ];
                $ydisp += $$centre[ 1 ] - $$init[ 1 ];
                $num_centroid++; 

             } else {
                orac_err "Unable to locate positive B-beam source for " .
                         "aperture photometry.\n";
             }

# Determine the mean displacements from the nominal positions, and
# report the displacements.
             if ( $num_centroid > 0 ) {
                $xdisp /= $num_centroid;
                $ydisp /= $num_centroid;
                my $fs_x = sprintf( "%.2f", $xdisp );
                my $fs_y = sprintf( "%.2f", $ydisp );

                orac_print "Target displaced ($fs_x,$fs_y) pixels from " .
                           "nominal position.\n";

# For storage correct to the nearest pixel.
                my $xbase = nint( $xdisp );
                my $ybase = nint( $ydisp );
                my @base = ( $xbase, $ybase );

# File the base location in the calibration system.
# =================================================

# The value needs to be in a hash.  Use the current frame as a reference
# for this, as it has the same readout mode and speed/well depth as the
# others.
                my %hash = ( %{ $Frm->hdr }, BASESHIFT => \@base );
                $Cal->baseshiftindex->add( $Frm->file, \%hash );

                orac_print "Base shift filed with the calibration system.\n";
             }

# Obtain the displacement from the calibration.
          } else {

# First attempt to obtain the value from the calibration system.
# If it's successful extract the x and y displacements, of which there
# must be two, and shift the nominal positions, otherwise use the current
# values.
             my $base = eval { $Cal->baseshift };
             if ( !$@ ) {
                my @disp = @$base;
                if ( $#disp == 1 ) {
                   $xpA += $disp[ 0 ];
                   $ypA += $disp[ 1 ];
                   $xnA += $disp[ 0 ];
                   $ynA += $disp[ 1 ];
                   $xpB += $disp[ 0 ];
                   $ypB += $disp[ 1 ];
                   $xnB += $disp[ 0 ];
                   $ynB += $disp[ 1 ];
                }
             }
          }

# Find bounds of regions about images.
# ====================================

# Derive the bounds of four equal-sized rectangles centred on each
# positive and negative image.  We could access the chop rotation angle
# but it's simpler to decide on the position (quadrant) of the
# positive A signal. 
#
# This combination loses sub-pixel registration, but should be adequate
# for aperture photometry.  This is also somewhat smaller than the
# telescope pointing errors.  This makes an assumption regarding the
# orientation, being either 0, or +/-90 degrees.
# and needs a header.
          my ( $halfx, $halfy );
          my $chopangle = ( $Frm->uhdr( "ORAC_CHOP_ANGLE" ) || 0 );
          if ( abs( $chopangle ) < 45 ) {
             $halfx = int( 0.5 * abs( $xpA - $xnA ) );
             $halfy = int( 0.5 * abs( $ypA - $ynB ) );
          } else {
             $halfx = int( 0.5 * abs( $xpA - $xnB ) );
             $halfy = int( 0.5 * abs( $ypA - $ynA ) );
          }

# Create an NDF bounds string for the positive A beam.
          my ( $x_lbnd, $y_lbnd, $x_ubnd, $y_ubnd );
          $x_lbnd = int( $xpA - $halfx );
          $y_lbnd = int( $ypA - $halfy );
          $x_ubnd = int( $xpA + $halfx );
          $y_ubnd = int( $ypA + $halfy );
          $sectionAp = "($x_lbnd:$x_ubnd,$y_lbnd:$y_ubnd)";

# Create an NDF bounds string for the negative A beam.
          $x_lbnd = int( $xnA - $halfx );
          $y_lbnd = int( $ynA - $halfy );
          $x_ubnd = int( $xnA + $halfx );
          $y_ubnd = int( $ynA + $halfy );
          $sectionAn = "($x_lbnd:$x_ubnd,$y_lbnd:$y_ubnd)";

# Create an NDF bounds string for the positive B beam.
          $x_lbnd = int( $xpB - $halfx );
          $y_lbnd = int( $ypB - $halfy );
          $x_ubnd = int( $xpB + $halfx );
          $y_ubnd = int( $ypB + $halfy );
          $sectionBp = "($x_lbnd:$x_ubnd,$y_lbnd:$y_ubnd)";

# Create an NDF bounds string for the negative B beam.
          $x_lbnd = int( $xnB - $halfx );
          $y_lbnd = int( $ynB - $halfy );
          $x_ubnd = int( $xnB + $halfx );
          $y_ubnd = int( $ynB + $halfy );
          $sectionBn = "($x_lbnd:$x_ubnd,$y_lbnd:$y_ubnd)";

# End of new $Frm context.
       }

# Restore the original telescope offsets for the mosaic.
       $mosFrm->uhdr( "ORAC_RA_TELESCOPE_OFFSET", $mos_raoff  );
       $mosFrm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET", $mos_decoff );

# Remove column and row structure.
# ================================
       if ( $clean ) {
          my $Frm = $mosFrm;
          _REMOVE_COLUMN_ROW_STRUCTURE_
          $in = $Frm->file;
       }

# Extract the four sections.
# ==========================

# There is a problem in that the $Grp user headers contain updated end
# time, end airmass, and integrated exposure time.  If we update
# $Frm->file with $in---the group file---that gives # the correct
# steering headers, but lacks the revised group headers.  On the other
# hand, using the $mosFrm gets the revised data but loses the steering
# headers.  The former while on the face of it is easier, it does have
# side effects, since the original mainline frame is lost (and is needed
# for things like tidying).  Choose the latter to preserve the steering
# operations.  Primitives requiring the combined frame should access it
# through the COMBINED_SOURCE_FRAME group user header, but steer using
# the mainline frame.

# Define the name for the positive A beam.  Create a new image
# which is the section approximately centred about that beam's
# nominal location.  Set the origin to 1,1 for the arithmetic
# later.
       my $Ap_name = $in . "_Ap";
       my $param = "in=$in$sectionAp out=$Ap_name";
       $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$param" );
       $param = "ndf=$Ap_name origin=[1,1]";
       $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "$param" );
       orac_print "Positive A-beam image extracted in $Ap_name\n";

# Repeat for the negative A beam.
       my $An_name = $in . "_An";
       $param = "in=$in$sectionAn out=$An_name";
       $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$param" );
       $param = "ndf=$An_name origin=[1,1]";
       $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "$param" );
       orac_print "Negative A-beam image extracted in $An_name\n";

# Repeat for the negative A beam.
       my $Bp_name = $in . "_Bp";
       $param = "in=$in$sectionBp out=$Bp_name";
       $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$param" );
       $param = "ndf=$Bp_name origin=[1,1]";
       $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "$param" );
       orac_print "Positive B-beam image extracted in $Bp_name\n";

# Repeat for the negative B beam.
       my $Bn_name = $in . "_Bn";
       $param = "in=$in$sectionBn out=$Bn_name";
       $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$param" );
       $param = "ndf=$Bn_name origin=[1,1]";
       $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "$param" );
       orac_print "Negative B-beam image extracted in $Bn_name\n";

# Form quality map.
# =================

# Smooth the combined image.
# ==========================
       my $out;
       if ( $qmap ) {
          if ( $smoothbox > 1 ) {

# Block-averaged smooth using the supplied box size for each
# positive and negative section, and assign each new name to the
# corresponding original variable.
             $in = $Ap_name;
             $out = $in . "_sm";
             $param = "in=$in out=$out box=$smoothbox accept";
             $Mon{ "kappa_mon" }->obeyw( "block", "$param" );
             $Ap_name = $out;

             $in = $Bp_name;
             $out = $in . "_sm";
             $param = "in=$in out=$out box=$smoothbox accept";
             $Mon{ "kappa_mon" }->obeyw( "block", "$param" );
             $Bp_name = $out;

             $in = $An_name;
             $out = $in . "_sm";
             $param = "in=$in out=$out box=$smoothbox accept";
             $Mon{ "kappa_mon" }->obeyw( "block", "$param" );
             $An_name = $out;

             $in = $Bn_name;
             $out = $in . "_sm";
             $param = "in=$in out=$out box=$smoothbox accept";
             $Mon{ "kappa_mon" }->obeyw( "block", "$param" );
             $Bn_name = $out;
          }

# Generate name Quality of Combined A and B signals
          ( $in, $out ) = $mosFrm->inout( "_qcab" );
          $param = "exp='IA/abs(IA)+IB/abs(IB)-IC/abs(IC)-ID/abs(ID)' out=$out " .
                   "ia=$Ap_name ib=$Bp_name ic=$An_name id=$Bn_name"; 
          $Mon{ "kappa_mon" }->obeyw( "maths", "$param" );
          orac_print "Source images combined to form quality map in $out\n";

# Display the quality map using a temporary frame.
          my $tmpFrm = $Frm->new;
          $tmpFrm->file( $out );
          $Display->display_data( $tmpFrm ) if ( defined $Display );
       }

# Combine the images.
# ===================

# At present there's no sub-pixel registration.
       ( $in, $out ) = $mosFrm->inout( "_cab" );

# Mean is easy.
       if ( $method eq "mean" ) {
          $param = "exp='0.25*(IA-IB+IC-ID)' out=$out " .
                   "ia=$Ap_name ib=$An_name ic=$Bp_name id=$Bn_name"; 
          $Mon{ "kappa_mon" }->obeyw( "maths", "$param" );
          orac_print "Source images combined and averaged in $out\n";

# Other methods are for MAKEMOS.
       } else {

# First need to make two temporary frames change the polarity of the
# negative sources.
          my $tempAfile = new ORAC::TempFile;
          my $tempApos = $tempAfile->file;
          $param = "in=$An_name out=$tempApos scalar=-1";
          $Mon{ "kappa_mon" }->obeyw( "cmult", "$param" );

          my $tempBfile = new ORAC::TempFile;
          my $tempBpos = $tempBfile->file;
          $param = "in=$Bn_name out=$tempBpos scalar=-1";
          $Mon{ "kappa_mon" }->obeyw( "cmult", "$param" );

# Create text files to hold the list of input and output files, one per line.
# This is needed because expanded lists of files may make the command line
# too long for the ADAM message system.
          unlink( "combine.list$$" );
          my @names = ( $Ap_name,$tempApos,$Bp_name,$tempBpos );

          open( INLIST, ">combine.list$$" ) ||
            orac_throw "Unable to open combine.list$$ to create a list of frames to combine.  Error: $!.\n";
          print INLIST join( "\n", @names ), "\n";
          close( INLIST );

# Combine the now all positive frames using the chosen method.
# Assign other parameters.
          my $param1 = "in='^combine.list$$' title=!";
          $param = "out=$out zero optov=4 method=$method";

# Make the mosaic correcting for differences in offset.
          $Mon{ "ccdpack_reg" }->obeyw( "makemos", "$param1 $param" );
          unlink( "combine.list$$" );

          orac_print "Source images combined using the $method method in $out\n";
       }
    
# Update the frame.
       $mosFrm->file( $out );

# Display the combined frame.
       $Display->display_data( $mosFrm ) if ( defined $Display );

# Smooth the combined image.
# ==========================
       if ( $smoothbox > 1 ) {

# At present there's no sub-pixel registration.
          ( $in, $out ) = $mosFrm->inout( "_scab" );

# Block-averaged smooth using the supplied box size.
          $param = "in=$in out=$out box=$smoothbox accept";
          $Mon{ "kappa_mon" }->obeyw( "block", "$param" );

          orac_print "Combined image ${smoothbox}-pixel block smoothed in $out\n\n";

# Update the frame.
          $mosFrm->file( $out );

# Display the combined frame.
          $Display->display_data( $mosFrm ) if ( defined $Display );
       }
       
# Store the frame for other primitives (e.g. photometry, polarimetry)
# requiring it.
       $Grp->uhdr( "COMBINED_SOURCE_FRAME", $mosFrm );

       orac_print "\n";
    }

# Podule
# ======

=head1 NAME

_COMBINE_CHOPPED_SOURCE_ -- Combines chopped and nodded images for NOD_CHOP recipes.

=head1 DESCRIPTION

This primitive forms a combined source file from the current group
file.  It expects the group file to be an integrated chopped and
nodded image, in which the source appears as two positive and two
negative images.  The primitive optionally locates the centroid of
each source, and extracts a symmetric region about each source. These
regions are combined (see argument METHOD) to create an image of the
source of twice the signal-to-noise of a single image, but normalised
to yield the average signal of a single image.  This maintains the
scaling of flux per unit exposure time.

The primitive also forms a quality map indicating the contributions
from each image of the source to help interpret the final combined
frame.

=head1 ARGUMENTS

=over 4

=item CENTROID = LOGICAL (Given)

If true (1), centroid on the source in each sub-frame before
combining.  If successful, the resultant combined file has the
source centred.  Centroiding is not suitable for objects near
the detection limit.  Setting CENTROID to false (0), means
the combined file is centred about the expected position of
the source.  [1] 

=item CLEAN = LOGICAL (Given)

If true (1), column then row patterns, say due to pickup or
bias variations, are filtered out by subtracting the median
of each column or row from all the values in that column or
row.  It's useful to help see faint sources.  [0]

=item METHOD = CHARACTER (Given)

The method used to combine frames, once all have the same
polarity.  See parameter METHOD of CCDPACK/MAKEMOS (SUN/139) for
the options.  The main two in practice will be "Median" or
"Mean".  The former excludes outliers but has problems in good
seeing where the registration is poor, as it biases against the
peak values of the steepening profile near the core, and hence
underestimate the flux.  In this circumstance the mean blurs the
psf profile, making it more of a plateau than a sharp peak.
However, the mean preserves the flux, at the cost of the odd
rogue value affecting the result.  ["Mean"]

=item QMAP = LOGICAL (Given)

If true (1), a quality map is generated. [0]

=item SMOOTH = INTEGER (Given)

If greater than 1 apply block smoothing with a square block size
equal to SMOOTH to the combined image.  For all other values, 
there is no smoothing. [0]

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for Michelle in imaging mode.

=item *

Processing only occurs for object frames, and when the steering header
MAKE_MOSAIC is true.

=item *

The file to be combined may be specified through group user header
MOSAIC_FRAME, if $Grp->file is not the file from which to combine
images.

=item *

The centroid is found by first setting the initial positions to
the telescope offset in Cartesian co-ordinates for each nod position
from the centre of the mosaic, and using a search window equal
to the larger absolute telescope offset.  The telescope offsets are
derived from the first and second frames in the current-cycle group.

=item *

The average offsets of the centroid positions from the nominal
source locations are found; the nearest-integer offsets are stored
in $Cal-E<gt>baseshift.  When argument CENTROID is false,
$Cal-E<gt>>baseshift is accessed, and if there is a valid shift vector,
the script offsets the nominal position of each region by this
vector.  This is to allow for misplaced instrument apertures
whenever the weak flux prevents centroiding. 

=item *

The regions are made as large as possible such that there is no
duplication of pixels from the original group file.  In other words
the regions extend to the midpoints of the chop throw and nod offsets.
User header ORAC_CHOP_ANGLE is used to select one of two orientations
(0 or +/-90 degrees) to derive the x-y half-widths of the regions.

=item *

Before addition, the origins of each identically sized frame
are set to 0,0.

=item *

It determines for the current recipe cycle the two nod positions
from the first two frames (nod to beam A then beam B) of the current
cycle.  Those coupled with the chop throw and angle, and the mosaic
centre specify the approximate locations of the sources for the
centroid locating.

=item *

The quality map is derived from the four sub-frames, with
recommended smoothing if argument SMOOTH=1.  It is the sum of the 
pixel values divided by their abslute values, after changing sign
for the negative sources.  In the map +4 indicates that a pixel had 
negative sources.  In the map +4 indicates that a pixel had 
positive contributions from the positive images and negative signal
from the negative images.  Thus it helps to discriminate from sources
which have been chopped into view, for which there are no positive
or negative counterparts (values +/-2) or noise (0, +/-2).

=item *

The steering header CYCLE_NUMBER specifies the recipe cycle
number. 

=item *

The smoothed and raw combined images, and the quality map may be
displayed.

=item *

The name of the combined frame is stored is the group user
header called COMBINED_SOURCE_FRAME.

=back

=head1 OUTPUT DATA

=over 4

=item *

Combined source frame inheriting the group file's name but with the
_cab suffix.  The smoothed version has a _scab suffix.

=item *

The quality map inheriting the group file's name but with the
_qcab suffix.

=item *

The extracted sections about image within the mosaic, inheriting
the group file's name but with the suffices _Ap, _An, _Bp, _Bn for
the positive (p) and negative (n) images in the A and B beams.

=back

=head1 TASKS

CCDPACK: MAKEMOS; KAPPA: BLOCK, MATHS, NDFCOPY, SETORIGIN.

=head1 DEFICIENCIES

=over 4

=item

Assumes an ABBA pattern comprising two positive and two negative
images.  If the nodding and jitter are in the same direction it
is possible to have a double positive image and two negatives.

=item *

The group and frame management is tricky.   In part it's having
access to both steering and mosaic headers.  The created _cab frame
needs to be accessed within primitives directly rather than using
the current frame.

=back

=head1 AUTHORS

MJC: Malcolm J. Currie (JAC)

=head1 COPYRIGHT

Copyright (C) 2001--2002 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut
