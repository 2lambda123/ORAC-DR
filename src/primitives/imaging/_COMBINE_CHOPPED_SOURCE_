#+
# Name:
#    _COMBINE_CHOPPED_SOURCE_
#
# Purpose:
#    Combines chopped and nodded images for NOD_CHOP recipes.
#
# Language:
#    Perl5
#
# Description:
#    This primitive forms a combined source file from the current group
#    file.  It expects the group file to be an integrated chopped and
#    nodded image, in which the source appears as two positive and two
#    negative images.  The primitive locates the centroid of each source,
#    and extracts a symmetric region about each source.  These regions
#    are added or subtracted to create an image of the source of twice
#    the signal-to-noise of a single image, but normalised to yield the
#    average signal of a single image.  This maintains the scaling of
#    flux per unit exposure time.
#
# Notes:
#    -  This primitive is suitable for Michelle in imaging mode.
#    -  The regions are made as large as possible such that there is no
#    duplication of pixels from the original group file.  In other words
#    the regions extend to the midpoints of the chop throw and nod offsets. 
#    -  Before addition, the origins of each identically sized frame
#    are set to 0,0.
#    -  It determines for the current recipe cycle the two nod positions
#    from the first two frames (nod to beam A then beam B) of the current
#    cycle.  Those coupled with the chop throw and angle, and the mosaic
#    centre specify the approximate locations of the sources for the
#    centroid locating.
#    -  The steering header CYCLE_NUMBER specifies the recipe cycle
#    number. 
#    -  The name of the combined frame is stored is the group user
#    header called COMBINED_SOURCE_FRAME.
#
# Output Data:
#    -  Combined source frame inheriting the group file's name but with the
#    _cab suffix.
#    -  The extracted sections about image within the mosaic, inheriting
#    the group file's name but with the suffices _Ap, _An, _Bp, _Bn for
#    the positive (p) and negative (n) images in the A and B beams.
#
# Tasks:
#    KAPPA: MATHS, NDFCOPY, SETORIGIN.
#
# Deficiencies:
#    -  Assumes an ABBA pattern comprising two positive and two negative
#    images.  If the nodding and jitter are in the same direction it
#    is possible to have a double positive image and two negatives.
#    -  The group and frame management is tricky.   In part it's having
#    access to both steering and mosaic headers.  The created _cab frame
#    needs to be accessed within primitives directly rather than using
#    the current frame.
#
# Authors:
#    MJC: Malcolm J. Currie (JAC)
#
# Copyright:
#    Copyright (C) 2001 Particle Physics and Astronomy Research
#    Council.  All Rights Reserved.
#
#-

# Selection
# =========

# This should only be performed on OBJECT frames.
    if ( $Frm->uhdr( "ORAC_OBSERVATION_TYPE" ) =~ /OBJECT/ ) {

# Obtain the cycle number.  Default to zero if undefined, so that recipes
# which do not support this feature will continue to work.
       my $cycleno = $Frm->uhdr( "CYCLE_NUMBER" );
       $cycleno = defined( $cycleno ) ? $cycleno : 0;

# Select those members in the current cycle.
       my $cycleGrp = $Grp->subgrp( CYCLE_NUMBER => $cycleno );

# Specify the aperture.
       my $aperture = max( abs( $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET" ) ),
                      abs( $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET" ) ) );
       $aperture = min( $Frm->uhdr( "ORAC_CHOP_THROW" ), 2.0 * $aperture );

# Frame preliminaries.
# ====================

# Get the mosaic's name
       my $in = $Grp->file;

# Create a new frame.
       my $mosFrm = new $Frm;
       $mosFrm->file( $in );

# Propagate the headers.
       %{ $mosFrm->hdr } = %{ $Grp->hdr };
       %{ $mosFrm->uhdr } = %{ $Grp->uhdr };

# Record original telescope offsets.
       my $mos_raoff = $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET" );
       my $mos_decoff = $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET" );

# Find the nominal locations of the images.
# =========================================

# Find the bounds of the array, and hence its centre.
       my ( $xmid, $ymid );
       {
          my $Frm = $mosFrm;
          _GET_FRAME_CENTRE_
          $xmid = $_GET_FRAME_CENTRE_{XCENTRE};
          $ymid = $_GET_FRAME_CENTRE_{YCENTRE};
       }

# Find the limiting telescope offsets.  Obtain the telescope offsets
# and apply the rotation matrix to convert these to pixels.  Assume
# that the first two frames are at the A and B offsets.
       my ( $xpA, $xpB, $xnA, $xnB, $ypA, $ypB, $ynA, $ynB );
       my ( $x_chop_offset, $y_chop_offset, $x_nod_offset, $y_nod_offset );
       my ( $Ara_chop_offset, $Adec_chop_offset, $Bra_chop_offset, $Bdec_chop_offset );
       my ( $A_raoff, $A_decoff, $B_raoff, $B_decoff );
       my $first = 1;

# Form a new temporary group.
       my $tempGrp = new $Grp;
       $tempGrp->push( $cycleGrp->frame( 0 ) );
       $tempGrp->push( $cycleGrp->frame( 1 ) );
       
       foreach my $Frm ( $tempGrp->members ) {
          _GET_CARTESIAN_TELESCOPE_OFFSETS_
          $x_nod_offset = $_GET_CARTESIAN_TELESCOPE_OFFSETS_{XOFF};
          $y_nod_offset = $_GET_CARTESIAN_TELESCOPE_OFFSETS_{YOFF};

# Obtain the chop throw offsets.
          _GET_CHOP_OFFSETS_
          $x_chop_offset = $_GET_CHOP_OFFSETS_{XOFF};
          $y_chop_offset = $_GET_CHOP_OFFSETS_{YOFF};

          if ( $first ) {
             $Ara_chop_offset = $_GET_CHOP_OFFSETS_{RAOFF};
             $Adec_chop_offset = $_GET_CHOP_OFFSETS_{DECOFF};

# Since the sense of the chop throw is not provided, we assume the ABBA
# convention.  Note we have to subtract the offsets to obtain the
# positions.
             $xpA = $xmid + $x_nod_offset;
             $ypA = $ymid + $y_nod_offset;
             $xnA = $xpA - $x_chop_offset;
             $ynA = $ypA - $y_chop_offset;

# Record telescope offsets for centroiding.
             $A_raoff = $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET" );
             $A_decoff = $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET" );
             $first = 0;

          } else {

             $Bra_chop_offset = $_GET_CHOP_OFFSETS_{RAOFF};
             $Bdec_chop_offset = $_GET_CHOP_OFFSETS_{DECOFF};

             $xnB = $xmid + $x_nod_offset;
             $ynB = $ymid + $y_nod_offset;
             $xpB = $xnB - $x_chop_offset;
             $ypB = $ynB - $y_chop_offset;

# Record telescope offsets for centroiding.
             $B_raoff = $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET" );
             $B_decoff = $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET" );
          }
       }

# Use approximate positions to find the centroids.
# ================================================
       my ( $sectionAp, $sectionAn, $sectionBp, $sectionBn );

       {
          my $centre;

# Want to find centroids within the mosaic.
          my $Frm = $mosFrm;

# Locate the centroid of the A positive image.  This uses the telescope
# offsets to locate the source.  Hence first set the telescope offsets
# to those of the A beam.
          $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET", $A_raoff  );
          $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET", $A_decoff );

          _FIND_SOURCE_CENTROID_ POSITIVE=1 BOXSIZE=$aperture

# It is possible that no centroid was found.  Get a reference to the flag,
# test the status, and report an error where centroiding failed.
# In this case give a warning but carry on with nominal position.
# Update the position with the centroid's co-ordinates.
          my $found = $_FIND_SOURCE_CENTROID_{FOUND};
          if ( $$found ) {
             $centre = $_FIND_SOURCE_CENTROID_{CENTRE};
             $xpA = $$centre[ 0 ];
             $ypA = $$centre[ 1 ];
          } else {
             orac_err "Unable to locate positive A-beam source for " .
                      "aperture photometry.\n";
          }

# Locate the centroid of the negative A beam.  This is approximately
# displaced from the A positive by the chop throw.
          _FIND_SOURCE_CENTROID_ POSITIVE=0 BOXSIZE=$aperture RAOFF=-$Ara_chop_offset DECOFF=-$Adec_chop_offset

# It is possible that no centroid was found.  Get a reference to the flag,
# test the status, and report an error where centroiding failed.
# In this case give a warning but carry on with nominal position.
# Update the position with the centroid's co-ordinates.
          $found = $_FIND_SOURCE_CENTROID_{FOUND};
          if ( $$found ) {
             $centre = $_FIND_SOURCE_CENTROID_{CENTRE};
             $xnA = $$centre[ 0 ];
             $ynA = $$centre[ 1 ];

          } else {
             orac_err "Unable to locate negative A-beam source for " .
                      "aperture photometry.\n";
          }


# Locate the centroid of the B negative image.  This uses the telescope
# offsets to locate the source.  Hence first set the telescope offsets
# to those of the B beam.
          $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET", $B_raoff  );
          $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET", $B_decoff );

          _FIND_SOURCE_CENTROID_ POSITIVE=0 BOXSIZE=$aperture

# It is possible that no centroid was found.  Get a reference to the flag,
# test the status, and report an error where centroiding failed.
# In this case give a warning but carry on with nominal position.
# Update the position with the centroid's co-ordinates.
          $found = $_FIND_SOURCE_CENTROID_{FOUND};
          if ( $$found ) {
             $centre = $_FIND_SOURCE_CENTROID_{CENTRE};
             $xnB = $$centre[ 0 ];
             $ynB = $$centre[ 1 ];
          } else {
             orac_err "Unable to locate negative B-beam source for " .
                      "aperture photometry.\n";
          }

# Locate the centroid of the positive A beam.  This is approximately
# displaced from the B negative by the chop throw.
          _FIND_SOURCE_CENTROID_ POSITIVE=1 BOXSIZE=$aperture RAOFF=-$Bra_chop_offset DECOFF=-$Bdec_chop_offset

# It is possible that no centroid was found.  Get a reference to the flag,
# test the status, and report an error where centroiding failed.
# In this case give a warning but carry on with nominal position.
# Update the position with the centroid's co-ordinates.
          $found = $_FIND_SOURCE_CENTROID_{FOUND};
          if ( $$found ) {
             $centre = $_FIND_SOURCE_CENTROID_{CENTRE};
             $xpB = $$centre[ 0 ];
             $ypB = $$centre[ 1 ];
          } else {
             orac_err "Unable to locate positive B-beam source for " .
                      "aperture photometry.\n";
          }

# Find bounds of regions about images.
# ====================================

# Derive the bounds of four equal-sized rectangles centred on each
# positive and negative image.  We could access the chop rotation angle
# but it's simpler to decide on the position (quadrant) of the
# positive A signal. 
#
# This combination loses sub-pixel registration, but should be adequate
# for aperture photometry.  This is also somewhat smaller than the
# telescope pointing errors.  This makes an assumption re. orientation,
# and needs a header.
          my ( $halfx, $halfy );
          if ( $xpA > $xmid ) {
             $halfx = int( 0.5 * abs( $xpA - $xnA ) );
             $halfy = int( 0.5 * abs( $ypA - $ynB ) );
          } else {
             $halfx = int( 0.5 * abs( $xpA - $xnB ) );
             $halfy = int( 0.5 * abs( $ypA - $ynA ) );
          }

# Create an NDF bounds string for the positive A beam.
          my ( $x_lbnd, $y_lbnd, $x_ubnd, $y_ubnd );
          $x_lbnd = int( $xpA - $halfx );
          $y_lbnd = int( $ypA - $halfy );
          $x_ubnd = int( $xpA + $halfx );
          $y_ubnd = int( $ypA + $halfy );
          $sectionAp = "($x_lbnd:$x_ubnd,$y_lbnd:$y_ubnd)";

# Create an NDF bounds string for the negative A beam.
          $x_lbnd = int( $xnA - $halfx );
          $y_lbnd = int( $ynA - $halfy );
          $x_ubnd = int( $xnA + $halfx );
          $y_ubnd = int( $ynA + $halfy );
          $sectionAn = "($x_lbnd:$x_ubnd,$y_lbnd:$y_ubnd)";

# Create an NDF bounds string for the positive B beam.
          $x_lbnd = int( $xpB - $halfx );
          $y_lbnd = int( $ypB - $halfy );
          $x_ubnd = int( $xpB + $halfx );
          $y_ubnd = int( $ypB + $halfy );
          $sectionBp = "($x_lbnd:$x_ubnd,$y_lbnd:$y_ubnd)";

# Create an NDF bounds string for the negative B beam.
          $x_lbnd = int( $xnB - $halfx );
          $y_lbnd = int( $ynB - $halfy );
          $x_ubnd = int( $xnB + $halfx );
          $y_ubnd = int( $ynB + $halfy );
          $sectionBn = "($x_lbnd:$x_ubnd,$y_lbnd:$y_ubnd)";

# End of new $Frm context.
       }

# Restore the original telescope offsets for the mosaic.
       $mosFrm->uhdr( "ORAC_RA_TELESCOPE_OFFSET", $mos_raoff  );
       $mosFrm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET", $mos_decoff );

# Extract the four sections.
# ==========================

# There is a problem in that the $Grp user headers contain updated end
# time, end airmass, and integrated exposure time.  If we update
# $Frm->file with $in---the group file---that gives # the correct
# steering headers, but lacks the revised group headers.  On the other
# hand, using the $mosFrm gets the revised data but loses the steering
# headers.  The former while on the face of it is easier, it does have
# side effects, since the original mainline frame is lost (and is needed
# for things like tidying).  Choose the latter to preserve the steering
# operations.  Primitives requiring the combined frame should access it
# through the COMBINED_SOURCE_FRAME group user header, but steer using
# the mainline frame.

# Define the name for the positive A beam.  Create a new image
# which is the section approximately centred about that beam's
# nominal location.  Set the origin to 1,1 for the arithmetic
# later.
       my $Ap_name = $in . "_Ap";
       my $param = "in=$in$sectionAp out=$Ap_name";
       $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$param" );
       $param = "ndf=$Ap_name origin=[1,1]";
       $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "$param" );
       orac_print "Positive A-beam image extracted in $Ap_name\n";

# Repeat for the negative A beam.
       my $An_name = $in . "_An";
       $param = "in=$in$sectionAn out=$An_name";
       $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$param" );
       $param = "ndf=$An_name origin=[1,1]";
       $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "$param" );
       orac_print "Negative A-beam image extracted in $An_name\n";

# Repeat for the negative A beam.
       my $Bp_name = $in . "_Bp";
       $param = "in=$in$sectionBp out=$Bp_name";
       $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$param" );
       $param = "ndf=$Bp_name origin=[1,1]";
       $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "$param" );
       orac_print "Positive B-beam image extracted in $Bp_name\n";

# Repeat for the negative B beam.
       my $Bn_name = $in . "_Bn";
       $param = "in=$in$sectionBn out=$Bn_name";
       $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$param" );
       $param = "ndf=$Bn_name origin=[1,1]";
       $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "$param" );
       orac_print "Positive B-beam image extracted in $Bn_name\n";

# Combine the images.
# ===================

# At present there's no sub-pixel registration.
       ( $in, my $out ) = $mosFrm->inout( "_cab" );
       $param = "exp='0.25*(IA-IB+IC-ID)' out=$out " .
                "ia=$Ap_name ib=$An_name ic=$Bp_name id=$Bn_name"; 
       $Mon{ "kappa_mon" }->obeyw( "maths", "$param" );
       orac_print "Source images combined and averaged in $out\n\n";

# Update the frame.
       $mosFrm->file( $out );

# Store the frame for other primitives (e.g. photometry, polarimetry)
# requiring it.
       $Grp->uhdr( "COMBINED_SOURCE_FRAME", $mosFrm );
    }

# Podule
# ======

=head1 NAME

_COMBINE_CHOPPED_SOURCE_ -- Combines chopped and nodded images for NOD_CHOP recipes.

=head1 DESCRIPTION

This primitive forms a combined source file from the current group
file.  It expects the group file to be an integrated chopped and
nodded image, in which the source appears as two positive and two
negative images.  The primitive locates the centroid of each source,
and extracts a symmetric region about each source.  These regions
are added or subtracted to create an image of the source of twice
the signal-to-noise of a single image, but normalised to yield the
average signal of a single image.  This maintains the scaling of
flux per unit exposure time.

=head1 NOTES

=over 4

=item *

This primitive is suitable for Michelle in imaging mode.

=item *

The regions are made as large as possible such that there is no
duplication of pixels from the original group file.  In other words
the regions extend to the midpoints of the chop throw and nod offsets. 

=item *

Before addition, the origins of each identically sized frame
are set to 0,0.

=item *

It determines for the current recipe cycle the two nod positions
from the first two frames (nod to beam A then beam B) of the current
cycle.  Those coupled with the chop throw and angle, and the mosaic
centre specify the approximate locations of the sources for the
centroid locating.

=item *

The steering header CYCLE_NUMBER specifies the recipe cycle
number. 

=item *

The name of the combined frame is stored is the group user
header called COMBINED_SOURCE_FRAME.

=back

=head1 OUTPUT DATA

=over 4

=item *

Combined source frame inheriting the group file's name but with the
_cab suffix.

=item *

The extracted sections about image within the mosaic, inheriting
the group file's name but with the suffices _Ap, _An, _Bp, _Bn for
the positive (p) and negative (n) images in the A and B beams.

=back

=head1 TASKS

KAPPA: MATHS, NDFCOPY, SETORIGIN.

=head1 DEFICIENCIES

=over 4

=item

Assumes an ABBA pattern comprising two positive and two negative
images.  If the nodding and jitter are in the same direction it
is possible to have a double positive image and two negatives.

=item *

The group and frame management is tricky.   In part it's having
access to both steering and mosaic headers.  The created _cab frame
needs to be accessed within primitives directly rather than using
the current frame.

=back

=head1 AUTHORS

MJC: Malcolm J. Currie (JAC)

=head1 COPYRIGHT

Copyright (C) 2001 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut
