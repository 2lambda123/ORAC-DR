# _DIVIDE_BY_STANDARD_          -*- perl -*-
#
# divides a group file by a standard

=head1 NAME

DIVIDE_BY_STANDARD - divides a reduced group file by a calibration standard star

=head1 DESCRIPTION

This primitive queries the calibration database for a filed standard
star, then divides the group file by this standard.

=head1 PARAMETERS

=over 4

none

=back

=head1 ORAC

=head2 Engines referenced

KAPPA

=head2 Tasks called

=over 4

=item kappa_mon

div

=back

=head2 Objects addressed

$Grp

=head1 NOTES

This primitive ratios by exposure time. The resulting file will be
scaled to an exposure time of one second. For example, if the group
file exposure time was 10 seconds, and the standard star exposure time
was 2 seconds, the resulting file will be ((group / standard) * (2 /
10)).

=head1 REVISION

  $Id$

=head1 AUTHOR

b.cavanagh@jach.hawaii.edu

=cut

my $out = $Grp->raw . "_dbs";
my $group = $Grp->file;

my $dbsfile = $out . $Grp->filesuffix;
my $basefile = $group . $Grp->filesuffix;

# A file check that needs some explanation.  
#
# First check:
#
# If the base group file (i.e. rgYYYYMMDD_XXXX_YY) exists, and the
# divided-by-standard file doesn't exist, do the dividing by standard.
#
# Second check:
#
# If the first check fails (i.e. there's a base group file and a
# divided-by-standard file), and the following conditions are
# satisfied: 1. the divided-by-standard file exists 2. the
# modification time of the base group file is later than the
# modification time of the divided-by-standard file (i.e. base raw
# group file was created after the most recent dividing) then do the
# dividing by standard.  This check will fail to catch the
# possibility if there is a divided-by-standard file but no base group
# file.  I personally don't see how that could happen, so I haven't
# devised any other checks for that.  The check is already complex
# enough as it is.

if(((-e $basefile) && (!(-e $dbsfile))) || ((-e $dbsfile) && ((stat($basefile))[9] > (stat($dbsfile))[9]))) {

  # We need to make sure that we are comparing with a group rather than
  # a frame so we need to change the hash stored in the cal object
  my $thing = $Cal->thing;

  # Set up a new hash that we wish to compare with
  my %hdr = %{ $thing };

  # and copy in the NDIMS header
  $hdr{NDIMS} = $Grp->uhdr("NDIMS");

  # and store it in the Cal object
  $Cal->thing( \%hdr );

  # get standard information & exposure times

  my $standard = $Cal->standard;

  # Now reset the hash in the Cal object
  $Cal->thing( $thing );

#  my $stdexptimeref = $Cal->standardindex->indexentry($standard);
#  my $stdexptime = $$stdexptimeref{'DEXPTIME'};
#  my $grpexptime = $Frm->hdr->{'DEXPTIME'};
#  my $timeratio = $stdexptime / $grpexptime;

  # do division

  orac_print "Using standard $standard\n";
  orac_print "Dividing $group by $standard to give $out\n";
#  my $tmp = new ORAC::TempFile;
#  my $tmpname = $tmp->file;
  $Mon{'kappa_mon'}->obeyw("div","in1=$group in2=$standard out=$out");
#  $Mon{'kappa_mon'}->obeyw("cdiv","in=$tmpname out=$out scalar=$timeratio");

  $Grp->file($out);
  
  $Display->display_data($Grp) if (defined $Display);


}
