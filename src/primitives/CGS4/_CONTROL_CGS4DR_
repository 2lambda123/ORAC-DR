=head1 NAME

_CONTROL_CGS4DR_ - send a REDUCE command to CGS4DR

=head1 DESCRIPTION

Command CGS4DR/QMAN to reduce the current data. This should be
called after the _EXPORT_CGS4DR_FORMAT_ primitive.

=head1 NOTES

=over 4

=item *

Creates a new object in C<%Mon> which is attached to a
QMAN monolith. This will fail if QMAN is not running.

=item *

CGS4DR must already be running on the same machine as ORAC-DR.

=back

=cut


# Connect to the monolith
# This is made harder by the fact that CGS4DR uses PID-related
# ADAM names except when at UKIRT.
# QMAN is actually named  reverse($pid)_qman
# where $pid is the process ID of the parent CGS4DR_TCL task
# There are two ways to do this:
#   1. Search through the process table until I find CGS4DR_TCL
#       (Can do this with Proc::ProcessTable)
#   2. Search through ADAM_USER (or ~adam) for a pipe named
#      NNNN_qman_NNNN and extract the name from this. This is
#      okay except that we can not guarantee that ADAM_USER is
#      the same now as it was then (in fact $ENV{ADAM_USER} is
#      redefined when running ORAC-DR.

# At UKIRT the QMAN process is simply called QMAN so that tasks
# on other machines (including the VAX) know what it is called

unless (exists $Mon{QMAN}) {

  # We are going to search the PID list to make sure that CGS4DR is 
  # running
  require Proc::ProcessTable;
  my $procs = new Proc::ProcessTable;

  my $cgs4dr_proc;

  foreach my $proc ( @{$procs->table} ) {

    if ($proc->cmndline =~ /\/cgs4dr_tcl/ ) {

      # only get here if we have a valid process name
      $cgs4dr_proc = $proc;

      # Abort from the loop
      last;

    }

  }

  # Check that we have a value
  unless (defined $cgs4dr_proc) {
    orac_err "CGS4-DR does not seem to be running. Unable to talk to QMAN.\n";
    my $ORAC_STATUS = ORAC__ERROR;
  }

  # print some diagnostics
  my $uid = $cgs4dr_proc->uid;
  my $pid = $cgs4dr_proc->pid;
  my $name = scalar getpwuid($uid);
  orac_print "Found cgs4dr_tcl process running as PID $pid under user $name (UID $uid)\n";


  # name of qman in ADAM messaging system and password access
  my ($qmanaccess, $qman);

  # If we are at UKIRT this is fairly straightforward
  my $domain = `domainname`;

  if ($domain =~ /ukirt/i) {

    # It might be worth checking for CGS4DR in this case as well though...
    
    orac_print "Running pipeline at UKIRT. Name of qman task is easy!\n";

    $qman = "qman";

    $qmanaccess = '';

  } else {
    
    # Running elsewhere, need to know PID of CGS4DR

    # We are fine so calculate the name
    # Reverse the process id
    # Must be a more efficient way than reverse split???
    my $rpid = reverse split (//, $pid );
    $qman = $rpid . "_qman";

    # Password and lockword for the QMAN process are 
    # These are derived from the pid as well
    my $lockword = $rpid . "lock";
    my $password = $rpid . "pass";

    $qmanaccess = "password=$password lockword=$lockword";

  }

  # These need to be stored in a global somewhere so use
  # So make one up [dont tell any one that this works since
  # it is very naughty]. There is no global hash for the use of the 
  # pipeline -- this could well be a bug.
  $ORACDR::QMAN::TEMP::QmanAccess = "$qmanaccess";

  # Create the object
  $Mon{QMAN} = new ORAC::Msg::ADAM::Task("$qman");

  # Try to talk to it
  unless ($Mon{QMAN}->contact) {
    orac_err "Could not talk to QMAN ($qman). Aborting\n";
    delete $Mon{QMAN};
    my $ORAC_STATUS = ORAC__ERROR;
  }


}




# Get the observation number [see also _EXPORT_CGS4DR_FORMAT_
# since that uses exactly the same technique
my $num = $Frm->number;
my $ut  = $Frm->hdr('ORACUT');
my $out = substr($ut, 2) . '_' . $num;

# Send the command
$Mon{QMAN}->obeyw("WRITE","string='REDUCE O$out' qposition=oldest $ORACDR::QMAN::TEMP::QmanAccess");

# ..and the end
$Mon{QMAN}->obeyw("WRITE","string='END O$out' qposition=oldest $ORACDR::QMAN::TEMP::QmanAccess");
