=head1 NAME

_DETERMINE_ROW_ - determines the max and min rows

=head1 SYNOPSIS

_DETERMINE_ROW_
_DETERMINE_ROW_  POSROW=96 NEGROW=120

=head1 DESCRIPTION

Finds the most likely looking rows to use by collapsing the 
image to a 1-D spectrum and finding the brightest pixel.

If a row is specified, no action is taken by this primitive except
to store the information for use by subsequent primitives. This
is so that the extraction can be specified in a single location.

=head1 OPTIONS

The following options are supported:

=over 4

=item POSROW

Position of positive signal to use for extraction.
There is no default value.

=item NEGROW

Position of negative signal to use for extraction.
There is no default value.

=back

=head1 EXTERNAL TASKS

The following packages are used:

=over 4

=item Kappa

C<compave>, C<stats>

=back

=head1 OUTPUT FILES

There are no output files.

=head1 NOTES

This primitives processes a coadded pair. It makes sure that the
group file exists before proceeding.

Also, for very weak sources, it is possible that edge effects or the
presence of hot pixels will dominate. To overcome this the 10 pixels
around the edge of the array are removed before the rows are
determined. Hot pixels in the middle of the array can still throw off the
algorithm (would need to add some form of automatic deglitching).

This primitive should be run after the pairs have been coadded.  It is
best to include this primitive in _COADD_PAIRS_AND_GROUP_ so that it
is guaranteed to be run correctly.  The primitive does check that a
complete pair has been processed and that a group file exists.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

=cut


my $posrow = (exists $_DETERMINE_ROW_{'POSROW'} ? 
	      $_DETERMINE_ROW_{POSROW} : undef);

my $negrow = (exists $_DETERMINE_ROW_{'NEGROW'} ? 
	      $_DETERMINE_ROW_{NEGROW} : undef);

unless (defined $Frm->uhdr("PAIR_COMPLETE")) {
  orac_err "PAIR_COMPLETE not present, have you run the steering primitive??";
  my $ORAC_STATUS = ORAC__ERROR;
}


# Check that the group file exists and we have a pair

if ( $Grp->file_exists && $Frm->uhdr("PAIR_COMPLETE") ) {

  unless (defined $posrow && defined $negrow) {

    # Get the group
    my $group = $Grp->file;

    # Create a temporary name
    my $add = new ORAC::TempFile;
    my $addname = $add->file;

    # Need to find the size of the array so that we can caluclate the
    # compression ratio 
    # With kappa 0.15 we can simply choose a very large number.
    # for older kappa we have to find the size first

    $Mon{'ndfpack_mon'}->obeyw("ndftrace","ndf=$group quiet=true");
    my ($ORAC_STATUS, @dims) = $Mon{ndfpack_mon}->get("ndftrace","dims");

    # We also need to find the pixel bounds so that we can remove edge
    # pixels that sometimes contain hot pixels.
    ($ORAC_STATUS, my @ub) = $Mon{ndfpack_mon}->get("ndftrace","ubound");
    ($ORAC_STATUS, my @lb) = $Mon{ndfpack_mon}->get("ndftrace","lbound");

    # Correct the bounds for the edge effect by removing $offpix
    # pixels from the bounds (use aliases in a for loop)
    my $offpix = 10;
    for (@ub) { $_ -= $offpix }
    for (@lb) { $_ += $offpix }

    # Calculate the ndf section
    my $sect = "($lb[0]:$ub[0],$lb[1]:$ub[1])";
#    print "Section is $sect\n";
    # Now add up all the columns
    # In kappa15 we can add the ALIGN parameter - in fact this is a requirement
    # since with an NDF section the default of ALIGN=ORIGIN results in the
    # output containing all bad values since none of the data appear in
    # bin associated with the pixel origin. Without ALIGN all we can do is 
    # hope that hot pixels dont get us
    # Use default value of WLIM
    if (starversion_gt("kappa","0.15-0")) {
      # The compression ratio is slightly to high but it doesn't matter since
      # we get at least one pixel in the output
      $Mon{kappa_mon}->obeyw("compave","in=$group$sect out=$addname compress=[$dims[0],1] align=first");

    } else {

      orac_warn "Using entire array rather than section since kappa version is older than 0.15\n";
      orac_warn "This may lead to erroneous detections of extraction rows due to hot pixels\n";
      $Mon{kappa_mon}->obeyw("compave","in=$group out=$addname compress=[$dims[0],1]");

    }

    # Now find the brightest - should probably use a pixels in the middle
    # so as to avoid hot pixels at the edge
    $Mon{kappa_mon}->obeyw("stats","ndf=$addname");

    # Get the coordinate of the maximum value in pixel coordinates
    # (This may be a problem if we are expecting to use arcsec)

    ($ORAC_STATUS, my $xmax, my $ymax) = $Mon{kappa_mon}->get("stats","maxpos");
    ($ORAC_STATUS, my $xmin, my $ymin) = $Mon{kappa_mon}->get("stats","minpos");

    # Report that we have found the rows from the image
    $posrow = $ymax;
    orac_print "Determined positive extraction row from image...($posrow)\n";

    $negrow = $ymin;
    orac_print "Determined negative extraction row from image...($negrow)\n";
  }

  orac_print "Using detector rows (pos=$posrow, neg=$negrow)...";

  # Store the extraction row in the index
  $Cal->rowname( $Grp->file );

  my %hdr = %{$Frm->hdr};
  $hdr{POSROW} = $posrow; # need this for index
  $hdr{NEGROW} = $negrow;
  $Cal->rowindex->add( $Grp->file, \%hdr );

  orac_print "Stored in index file\n";

} else {

  orac_warn "Can not determine row yet (pair not yet completed)\n";

}
