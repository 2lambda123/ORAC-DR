# _COADD_PAIRS_AND_GROUP_  -*-perl-*-

=head1 NAME

COADD_PAIRS_AND_GROUP - coadd observations taken in OBJECT/SKY pairs into group file

=head1 DESCRIPTION

Coadds observations taken in the standard OBJECT/SKY pairs and adds the result to
a group file.

=head1 PARAMETERS

=over 4

none

=back

=head1 ORAC

=head2 Engines referenced

KAPPA

=head2 Tasks called

=over 4

=item kappa_mon

sub, cmult, add, cdiv

=item ndfpack_mon

erase

=back

=head2 Objects addressed

$Frm, $Grp

=head1 NOTES

This primitive is meant to act on observations taken in the standard OBJECT/SKY pairing.
It does not assume that the pairings come in any specific order, only that for each pair
of observations, one is OBJECT and one is SKY (i.e. observations taken in OSSOOSSO are
reduced properly, whereas observations taken in OSOOSO are not).

To determine whether an observation is OBJECT or SKY, this primitives relies on correct
telescope offset information being placed in the header.  More specifically, OBJECT
observations have R.A. and Dec. offsets of zero, and SKY observations have either R.A., 
Decl., or both set as non-zero.  If these offsets are set incorrectly, the primitive
will not work correctly.

Also note that the test on if the observation is either OBJECT or SKY relies on the offset
being exactly zero.  If the offset comes back as a floating point number, this equality
may not happen, even though the offset is technically zero (this is due to the way computers
handle floating point numbers -- 0.0 may not necessarily be equal to zero).  If, for some 
reason, the test fails, this strict equality check may need to be modified to check within
a range around zero.

=head2 REVISION

  $Id$

=head1 AUTHOR

b.cavanagh@jach.hawaii.edu

=cut

my $groupnum = $Frm->group;
my $obsnum = $Frm->number;

my $diff = $obsnum - $groupnum;

# We're using $Grp->raw so that the primitive will -always- coadd to the base
# group file. If some other steps were done after this (i.e. ratioing by a 
# standard), then $Grp->file would be the name of the file after the other
# steps, thus sending the entire primitive into a pit of despair from which
# it would be quite difficult to return

my $groupname = $Grp->raw;

if(($diff % 2) == 1) {
  my $prevobs = $obsnum - 1;
  my $raoff = $Frm->hdr("RAOFF");
  my $decoff = $Frm->hdr("DECOFF");
  my ($sky, $object);
  if(($raoff == 0) && ($decoff == 0)) {

    # RA and Decl. offsets are zero, so assume that the current
    # frame is the object frame, and the previous is sky.

    my @membernames = $Grp->membernames;
    $object = $membernames[$diff];
    $sky = $membernames[$diff-1];
  } else {

    # RA and/or Decl. offsets are nonzero, so assume that the
    # current frame is sky, and previous is object.

    my @membernames = $Grp->membernames;
    $object = $membernames[$diff-1];
    $sky = $membernames[$diff];
  }
  if(!(-e ($groupname . $Grp->filesuffix))) {

    # The group file doesn't exist, so copy the coadded pair into it.

    my $tmp = new ORAC::TempFile;
    my $tmpname = $tmp->file;
    $Mon{'kappa_mon'}->obeyw("sub","in1=$sky in2=$object out=$tmpname title=$groupname");
    $Mon{'kappa_mon'}->obeyw("cmult","in=$tmpname scalar=-1 out=$groupname");
    orac_print "Subtracting $sky (SKY) from $object (OBJECT) and adding to group $groupname\n";

# HUGE COMMENT -- If you're looking through this code and wondering why a sky-object is done,
# instead of object-sky, here's the reason.  When extracting the spectrum, the primitive that
# does that needs to calculate where the negative row is.  This calculation is done using the
# RAOFF and DECOFF (RA and Decl. offsets) header values.  These two values are zero for object
# observations, and non-zero for sky observations.  If the pair was added as object-sky, instead
# of -(sky-object), then the header for the object would be placed in the reduced group file.
# Remember how RAOFF and DECOFF are zero for object observations?  When the spectrum extraction
# primitive does its calculations, it would calculate that the negative row is zero rows away 
# from the positive row, and this is (generally) not the case.  Thus, if we copy in the headers
# from the sky observations, we preserve the RAOFF and DECOFF values, and can thus correctly
# calculate the position of the negative row for spectrum extraction.
#
# PLEASE DO NOT CHANGE THIS!  If you change this, then the spectrum extraction will be broken,
# much to the dismay of astronomers and support scientists and others who might like to get
# accurate spectra from their hard-earned observations at UKIRT.

    # Update the user header to reflect the addition of the two observations to the group file.

    $Grp->uhdr("AddedPairs" => join(",",$prevobs,$obsnum));
  } elsif($diff == 1) {

    # The group file does exist, and this is the first pair, so we'll 
    # erase the group file, and then copy the coadded pair into it.

    $Mon{'ndfpack_mon'}->obeyw("erase","object=$groupname ok=true");
    my $tmp = new ORAC::TempFile;
    my $tmpname = $tmp->file;
    $Mon{'kappa_mon'}->obeyw("sub","in1=$sky in2=$object out=$tmpname title=$groupname");
    $Mon{'kappa_mon'}->obeyw("cmult","in=$tmpname scalar=-1 out=$groupname");
    orac_print "Subtracting $sky (SKY) from $object (OBJECT) and adding to group $groupname\n";

    # Update the user header to reflect the addition of the two observations to the group file.

    $Grp->uhdr("AddedPairs" => join(",",$prevobs,$obsnum));
  } else {

    # The group file exists and this is not the first pair.  First we need to determine
    # how many pairs have been added to the group;

    my $added = $Grp->uhdr("AddedPairs");
    my @added = split(",", $added);
    my $numobsadded = $#added + 1;
    my $numpairadded = $numobsadded / 2;

    # Now we need to "unaverage" the group file. A temporary file is needed for this.

    my $unavg = new ORAC::TempFile;
    my $unavgname = $unavg->file;
    $Mon{'kappa_mon'}->obeyw("cmult","in=$groupname scalar=$numpairadded out=$unavgname");

    # Now subtract SKY from OBJECT to create the pair. A temp file is needed.

    my $pair = new ORAC::TempFile;
    my $pairname = $pair->file;
    my $tmp = new ORAC::TempFile;
    my $tmpname = $tmp->file;
    $Mon{'kappa_mon'}->obeyw("sub","in1=$sky in2=$object out=$tmpname");
    $Mon{'kappa_mon'}->obeyw("cmult","in=$tmpname scalar=-1 out=$pairname");

    # Now add the pair to the unaveraged group. A temp file is needed.

    my $addgroup = new ORAC::TempFile;
    my $addgroupname = $addgroup->file;
    $Mon{'kappa_mon'}->obeyw("add","in1=$unavgname in2=$pairname out=$addgroupname");

    # Now average the result. Erase the original group file first, because kappa will
    # complain if it tries to overwrite a file.

    $Mon{'ndfpack_mon'}->obeyw("erase","object=$groupname ok=true");
    my $avgscalar = $numpairadded + 1;
    $Mon{'kappa_mon'}->obeyw("cdiv","in=$addgroupname scalar=$avgscalar out=$groupname title=$groupname");
    orac_print "Subtracting $sky (SKY) from $object (OBJECT) and adding to group $groupname\n";

    # Update the user header to reflect the addition of the two observations to the group file.

    my $prevadded = $Grp->uhdr("AddedPairs");
    $Grp->uhdr("AddedPairs" => join(",",$prevadded,$prevobs,$obsnum));
  }
}

# update $Grp object

$Grp->file($groupname);
