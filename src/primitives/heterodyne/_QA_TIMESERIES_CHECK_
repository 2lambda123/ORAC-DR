# -*-perl-*-

=head1 NAME

=head1 DESCRIPTION

=head1 ARGUMENTS

=over 4

=back

=head1 NOTES

=over 4

=back

=head1 OUTPUT DATA

=over 4

=back

=head1 TASKS

=head1 REQUIRED PERL MODULES

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

my $survey = get_prim_arg( $_PRIM_ARGS_, "SURVEY", undef );

my @surveys = qw/ GBS SLS NGS Telescope /;

my $isok = eval { require JSA::QA; 1; };
if( ! $isok ) {
  orac_warn "Could not load the JSA::QA Perl module: $@\n";
  orac_warn "Continuing with data reduction.\n";
} else {

  my $tsys_values_href = $Frm->uhdr( "QA_TSYS_VALUES" );
  my $rms_values_href = $Frm->uhdr( "QA_RMS_VALUES" );

  my $qaparamfile = $Cal->qaparams;

  # Set up new QA object using this file.
  my $qa = new JSA::QA( file => $qaparamfile );

  foreach my $file ( sort keys %$tsys_values_href ) {

    my $tsys_values = $tsys_values_href->{$file};
    my $rms_values = $rms_values_href->{$file};

    if( ! defined( $tsys_values ) ) {
      orac_warn "Must run Tsys QA calculations before running Tsys QA checks for file $file.\n";
      orac_warn "Possible programming error.\n";
      next;
    }
    if( ! defined( $rms_values ) ) {
      orac_warn "Must run RMS QA calculations before running RMS QA checks for file $file.\n";
      orac_warn "Possible programming error.\n";
      next;
    }

    my ( $tsys_result, %result, %opts );

    # Set up a hash of options to pass to the QA object.
    _SETUP_QA_OPTIONS_
    my $opts = $_SETUP_QA_OPTIONS_{'OPTS'};
    %opts = %$opts;

    # Set up a list of surveys to analyse.
    my @analyse_surveys;
    if( defined( $survey ) ) {
      if( uc( $survey ) eq 'ALL' ) {
        @analyse_surveys = @surveys;
      } else {
        push @analyse_surveys, $survey;
      }
    } else {
      push @analyse_surveys, ( defined( $Frm->hdr( "SURVEY" ) ) ?
                               $Frm->hdr( "SURVEY" )            :
                               "Telescope" );
    }

    # Run QA analysis on each requested survey.
    foreach my $analyse_survey ( @analyse_surveys ) {

      $opts{'survey'} = $analyse_survey;
      $tsys_result = $qa->analyse_tsys( $tsys_values, %opts );

      # Now we need to filter out those flagged as bad. Then get the
      # RMS result for the rest.
      my %bad_receptors = map { $_, 1 } @{$tsys_result->bad_receptors};

      my %temp_rms;
      foreach my $receptor ( keys %$tsys_values ) {
        next if exists $bad_receptors{$receptor};
        $temp_rms{$receptor} = $rms_values->{$receptor};
      }

      # Now run the RMS test with the new "clean" RMS hash.
      my $rms_result = $qa->analyse_timeseries_rms( \%temp_rms,
                                                    %opts );

      # Merge the results. If any of the tests fail, then the whole
      # survey QA test fails.
      my $merged_result = $tsys_result->merge( $rms_result );

      $result{$analyse_survey} = $merged_result;
    }

    # Display the results.
    if( defined( $opts{'molecule'} ) ) {
      my $transition = $Frm->hdr( "TRANSITI" );
      $transition =~ s/\s+//g;
      orac_print "QA results for " . $Frm->hdr( "MOLECULE" ) . " $transition:\n";
    } else {
      orac_print sprintf( "QA results at %.4f GHz:\n", $Frm->hdr( "LOFREQS" ) );
    }
    foreach my $result_survey ( sort keys %result ) {
      my $pass = $result{$result_survey}->pass;
      my $rms_stats = $result{$result_survey}->rms_stats;
      my $tsys_stats = $result{$result_survey}->tsys_stats;
      my $notes = $result{$result_survey}->notes;
      my $fail_reasons = $result{$result_survey}->fail_reasons;
      orac_print " Time-series QA ";
      orac_print ( ( $pass ? " passed " : " failed " ),
                   ( $pass ? "bold white on_green" : "bold white on_red" ) );
      orac_say " for $result_survey.";
      if( defined( $rms_stats ) ) {
        orac_print "  RMS statistics: ";
        orac_say sprintf( "minimum: %.2f maximum: %.2f mean: %.2f",
                            $rms_stats->{min},
                            $rms_stats->{max},
                            $rms_stats->{mean} );
      }
      if( defined( $tsys_stats ) ) {
        orac_print "  Tsys statistics: ";
        orac_say sprintf( "minimum: %.2f maximum: %.2f mean: %.2f",
                            $tsys_stats->{min},
                            $tsys_stats->{max},
                            $tsys_stats->{mean} );
      }
      if( defined( $notes ) &&
          scalar @$notes >= 1 ) {
        orac_print "  QA note" . ( scalar @$notes > 1 ? "s" : "" ) . ":\n";
        orac_print "   " . join( "\n ", @$notes );
        orac_print "\n";
      }
      if( ! $pass ) {
        orac_print "  Failure reason" . ( scalar @$fail_reasons > 1 ?
                                         "s"                                                 :
                                         "" );
        orac_say ":";
        orac_print "   " . join( "\n ", @$fail_reasons );
        orac_say "";
      }
      orac_say "";
    }

    # Sort out bad receptors. They'll be added to the calibration system
    # for either the specific survey or for everything, and only for the
    # current LOFREQ +/- 1 GHz.
    my $lofreq = $Frm->hdr( "LOFREQS" );
    my $survey_br = $Frm->uhdr( "SURVEY_BR" );
    my @bad_receptors;
    if( defined( $survey_br ) ) {
      @bad_receptors = @{$result{$survey_br}->bad_receptors};
    } else {
      @bad_receptors = @{$result{'Telescope'}->bad_receptors};
    }
    if( $#bad_receptors > 0 ) {
      my %recep_hash = ( %{$Frm->hdr},
                         LOFREQ_MAX => $lofreq + 1,
                         LOFREQ_MIN => $lofreq - 1,
                         DETECTORS => ( join ',',@bad_receptors ),
                         SURVEY_BR => $survey_br,
                       );
      $Cal->bad_receptors_qa_index->add( $file, \%recep_hash );
    }
  }
}

