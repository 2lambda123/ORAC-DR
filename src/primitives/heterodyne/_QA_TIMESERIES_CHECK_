# -*-perl-*-

=head1 NAME

=head1 DESCRIPTION

=head1 ARGUMENTS

=over 4

=back

=head1 NOTES

=over 4

=back

=head1 OUTPUT DATA

=over 4

=back

=head1 TASKS

=head1 REQUIRED PERL MODULES

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

my $isok = eval { require JSA::QA; 1; };
if( ! $isok ) {
  orac_warn "Could not load the JSA::QA Perl module: $@\n";
  orac_warn "Continuing with data reduction.\n";
} else {

  my $tsys_values_href = $Frm->uhdr( "QA_TSYS_VALUES" );
  my $rms_values_href = $Frm->uhdr( "QA_RMS_VALUES" );

  foreach my $file ( sort keys %$tsys_values_href ) {

    my $tsys_values = $tsys_values_href->{$file};
    my $rms_values = $rms_values_href->{$file};

    my $survey = $Frm->hdr( "SURVEY" );

    my ( $tsys_result, %result );

    if( ! defined( $survey ) ) {
      $tsys_result = JSA::QA::analyse_tsys( $tsys_values );
    } else {
      $tsys_result = JSA::QA::analyse_tsys( $tsys_values,
                                            'survey' => $survey );
    }

    # Now for each survey in the Tsys results, we need to filter out
    # those flagged as bad. Then get the RMS result for the rest.
    foreach my $result_survey ( keys %$tsys_result ) {
      my %bad_receptors = map { $_, 1 } @{$tsys_result->{$result_survey}->bad_receptors};

      my %temp_rms;
      foreach my $receptor ( keys %$tsys_values ) {
        next if exists $bad_receptors{$receptor};
        $temp_rms{$receptor} = $rms_values->{$receptor};
      }

      # Now run the RMS test with the new "clean" RMS hash.
      my $rms_result = JSA::QA::analyse_timeseries_rms( \%temp_rms,
                                                      'survey' => $survey );

      # Merge the results. If any of the tests fail, then the whole
      # survey QA test fails.
      my $merged_result = new JSA::QA::Result;
      $merged_result->pass( $tsys_result->{$result_survey}->pass &&
                            $rms_result->{$result_survey}->pass );
      $merged_result->add_fail_reason( $tsys_result->{$result_survey}->fail_reasons );
      $merged_result->add_fail_reason( $rms_result->{$result_survey}->fail_reasons );
      $merged_result->add_bad_receptor( $tsys_result->{$result_survey}->bad_receptors );
      $merged_result->add_bad_receptor( $rms_result->{$result_survey}->bad_receptors );
      $merged_result->rms_stats( $rms_result->{$result_survey}->rms_stats );
      $merged_result->tsys_stats( $tsys_result->{$result_survey}->tsys_stats );

      $result{$result_survey} = $merged_result;
    }

    # Display the results.
    foreach my $result_survey ( sort keys %result ) {
      my $pass = $result{$result_survey}->pass;
      my $rms_stats = $result{$result_survey}->rms_stats;
      my $tsys_stats = $result{$result_survey}->tsys_stats;
      orac_print "Time-series QA ";
      orac_print ( ( $pass ? " passed " : " failed " ),
                   ( $pass ? "bold white on_green" : "bold white on_red" ) );
      orac_print " for $result_survey for $file.\n";
      if( defined( $rms_stats ) ) {
        orac_print " RMS statistics: ";
        orac_print sprintf( "minimum: %.2f maximum: %.2f mean: %.2f\n",
                            $rms_stats->{min},
                            $rms_stats->{max},
                            $rms_stats->{mean} );
      }
      if( defined( $tsys_stats ) ) {
        orac_print " Tsys statistics: ";
        orac_print sprintf( "minimum: %.2f maximum: %.2f mean: %.2f\n",
                            $tsys_stats->{min},
                            $tsys_stats->{max},
                            $tsys_stats->{mean} );
      }
      if( ! $pass ) {
        orac_print " Failure reason" . ( scalar @{$result{$result_survey}->fail_reasons} > 1 ?
                                         "s"                                                 :
                                         "" );
        orac_print ":\n";
        orac_print " " . join( "\n ", @{$result{$result_survey}->fail_reasons} );
        orac_print "\n";
      }
    }

    # Sort out bad receptors. They'll be added to the calibration system
    # for either the specific survey or for everything, and only for the
    # current LOFREQ +/- 1 GHz.
    my $lofreq = $Frm->hdr( "LOFREQS" );
    my $survey_br = $Frm->uhdr( "SURVEY_BR" );
    my @bad_receptors;
    if( defined( $survey ) ) {
      @bad_receptors = @{$result{$survey}->bad_receptors};
    } else {
      @bad_receptors = @{$result{'Telescope'}->bad_receptors};
    }
    if( $#bad_receptors > 0 ) {
      my %recep_hash = ( %{$Frm->hdr},
                         LOFREQ_MAX => $lofreq + 1,
                         LOFREQ_MIN => $lofreq - 1,
                         DETECTORS => ( join ',',@bad_receptors ),
                         SURVEY_BR => $survey_br,
                       );
      $Cal->bad_receptors_qa_index->add( $file, \%recep_hash );
    }
  }
}

