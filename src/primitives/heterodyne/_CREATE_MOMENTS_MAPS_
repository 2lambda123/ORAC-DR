# -*-perl-*-

=head1 NAME

_CREATE_MOMENTS_MAPS_ - Create moments maps by collapsing along
spectral axis.

=head1 DESCRIPTION

This primitive is used to create moments maps. The input cube is
simply collapsed along the spectral axis, using the requested
estimator.

=head1 ARGUMENTS

=over 4

=item GROUP = INTEGER (Given)

How to process group files. 0 means use the current Frame object. 1
means use the current Group object. 2 means use each Frame member of
the current Group object. [0]

=item MOMENTS = STRING (Given)

The moment maps to create. These are any of the values allowed for the
ESTIMATOR parameter to the COLLAPSE method, but in reality this should
probably be 'integ', 'iwc', and/or 'itd'. Any number of moments can be
given in a comma-separated string. ['integ']

=item TAG = STRING (Given)

Which moment map to tag as a representative image. ['integ']

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS cubes.

=back

=head1 OUTPUT DATA

=over 4

=item *

The moments map(s) with suffix equal to the given moment(s) by the
MOMENTS parameter.

=back

=head1 TASKS

=head1 REQUIRED PERL MODULES

None, but see _COMPONENT_EXISTS_.

=head1 SEE ALSO

_CREATE_MOMENTS_MAPS_THROUGH_SMOOTHING_

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

# Handle parameters.
my $group = get_prim_arg( $_PRIM_ARGS_, "GROUP", 0 );
my $moments = get_prim_arg( $_PRIM_ARGS_, "MOMENTS", 'integ' );
my $tag = uc( get_prim_arg( $_PRIM_ARGS_, "TAG", 'integ' ) );

my @moments = split /,/, $moments;
my $group2 = ( $group == 2 ? 0 : $group );

my @Objs;
if( $group == 0 ) {
  push @Objs, $Frm;
} elsif( $group == 1 ) {
  push @Objs, $Grp;
} elsif( $group == 2 ) {
  @Objs = $Grp->members;
}

# Only go on if we're not doing a Group, or if we are doing a Group
# and this Frame is the last member of the Group.
if( $group != 1 || ( $group == 1 && $Grp->lastmember( $Frm ) ) ) {

  foreach my $Obj ( @Objs ) {

    foreach my $moment ( @moments ) {

      orac_say "Creating $moment moment map.";

      my @paste_inputs;

      foreach my $i ( 1 .. $Obj->nfiles ) {

        if( $Obj->uhdr( "SPARSE" ) ) {
          orac_warn $Obj->file( $i ) . " is a sparse cube. Cannot create moments map for a sparse cube.\n";
        } else {

          my $in = $Obj->file( $i );

          # Only collapse if the cube isn't 1xMxN or Mx1xN.
          _GET_DIMENSIONS_ FILE=$in
          my $dims = $_GET_DIMENSIONS_{DIMS};
          my $lbound = $_GET_DIMENSIONS_{LBOUND};
          my $ubound = $_GET_DIMENSIONS_{UBOUND};

          if( $dims->[0] == 1 ||
              $dims->[1] == 1 ) {
            orac_warn "Cannot create moment map with a " . $dims->[0] . "x" . $dims->[1] . "x" . $dims->[2] . " cube.\n";

            # If both dimensions are 1, then copy this file into the _sp.
            if( $dims->[0] == 1 && $dims->[1] == 1 ) {

              {
                my $Frm = $Obj;
                $Frm->uhdr( "INTEG_MAX_POS", [ 1, 1 ] );
                _EXTRACT_MAXVALUE_SPECTRUM_ TAG=1 GROUP=0
              }

            }
          } else {

            # Create a temporary file.
            my $tempfile = new ORAC::TempFile;

            # Collapse the cube.
            orac_say " Collapsing $in along frequency axis.";
            my $params = "in=$in out=$tempfile estimator=$moment axis=spec wlim=0.0";
            $Mon{'kappa_mon'}->obeyw( "collapse", "$params" );

            push @paste_inputs, $tempfile;

          }
        }
      }

      my ( $in, $out ) = $Obj->inout( "_$moment" );
      if( scalar( @paste_inputs ) == 1 ) {

        # We only have one input file, so just copy it over.
        my $params = "in=$paste_inputs[0] out=$out";
        $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "$params" );

      } else {

        orac_say " Pasting together temporary maps to form $moment map.";
        _PASTE_FILES_ FILES=\@paste_inputs OUT=$out

      }

      orac_say "Created $moment map in $out.\n";

      if( uc( $moment ) eq $tag ) {

        if( $group == 2 ) {
          my $Frm = new $Obj;
          $Frm->file( $out );
          _TAG_AS_REPRESENTATIVE_ FILE=$out GROUP=$group2 SUFFIX=rimg UPDATE=0
        } else {
          _TAG_AS_REPRESENTATIVE_ FILE=$out GROUP=$group SUFFIX=rimg UPDATE=0
        }

      }

    }
  }
}
