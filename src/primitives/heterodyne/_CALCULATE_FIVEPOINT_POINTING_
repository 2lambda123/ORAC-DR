# -*-perl-*-

=head1 NAME

_CALCULATE_FIVEPOINT_POINTING_

=head1 DESCRIPTION

=head1 ARGUMENTS

=over 4

=item TYPE = STRING (Given)

The type of pointing being calculated. This is purely for bookkeeping
purposes, and should be either CONTINUUM or LINE. This argument is
case-insensitive. ['LINE']

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS pointing observations.

=back

=head1 OUTPUT DATA

=over 4

None.

=back

=head1 TASKS

FIGARO: FITPOLY.
KAPPA: NDFCOPY, SETAXIS, WCSATTRIB.

=head1 REQUIRED PERL MODULES

None.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2007-2008 Science and Technology Facilities Council. All
Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

=cut

# Find out what type of pointing we're doing, line or
# continuum. Default to line.
my $type = ( defined( $_CALCULATE_FIVEPOINT_POINTING_{TYPE} ) ?
             uc( $_CALCULATE_FIVEPOINT_POINTING_{TYPE} ) :
             'LINE' );

my $in = $Frm->file;

# Get the WCS for easy retrieval of attributes. Some are required to allow easy resetting
# of the object afterwards
my $wcs = $Frm->read_wcs( $in );

# Retrieve the rest frequency so we can figure out what the FWHM is
# for the FITGAUSS call later on. Even though we're dealing with an
# image, all collapsed images and spectra are 3D to retain spectral
# information.
my $restfreq = $wcs->Get("RestFreq");
my $fwhm = 0.024383119917 / $restfreq; # FWHM in radians.

# Original status of frameset
my $skyrefis = $wcs->Get("SkyRefIs");
my $format1 = $wcs->Get("Format(1)");
my $format2 = $wcs->Get("Format(2)");

# Set the offset coordinate system to Origin and the formatting of axes to arcseconds
# with 4 decimal places
my $newformat = "s.4";
$Mon{ndfpack_mon}->obeyw("wcsattrib", "ndf=$in mode=mset setting='SkyRefIs=Origin,Format(1)=$newformat,Format(2)=$newformat'");

# We need to take two cuts of the data, one horizontal and the other
# vertical. Then we'll fit a gaussian to both of these using
# FIGARO:FITGAUSS to determine the pointing offsets.
#
# First, the horizontal.
my $temp1 = new ORAC::TempFile;
my $temp1_file = $temp1->file;
my $temp2 = new ORAC::TempFile;
my $temp2_file = $temp2->file;

$Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$in(,1) out=$temp1_file trim trimwcs" );
$Mon{'ndfpack_mon'}->obeyw( "setaxis", "ndf=$temp1_file dim=1 mode=wcs" );

# Get stats on the cut so that we can set the peak and set the
# baseline to zero, but only if both the min and max are negative.
$Mon{'kappa_mon'}->obeyw( "stats", "ndf=$temp1_file" );
( my $ORAC_STATUS, my $max ) = $Mon{'kappa_mon'}->get( "stats", "maximum" );
( $ORAC_STATUS, my $min ) = $Mon{'kappa_mon'}->get( "stats", "minimum" );

my $peak = $max;
if( $min < 0 && $max < 0 ) {
  $Mon{'kappa_mon'}->obeyw( "csub", "in=$temp1_file out=$temp2_file scalar=$min" );
  $peak = $min - $max;
} else {
  $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp1_file out=$temp2_file" );
}

# Fit the gaussian.
my $params = "in=$temp2_file device=! dialog=f varuse=true mask1=[-10]";
$params   .= " mask2=[10] ncomp=1 centre=0 cont=0 peak=$peak fwhm=$fwhm";
$params   .= " cf=[0] pf=[0] wf=[1] logfil=! comp=1";
$Mon{'figaro4'}->obeyw( "fitgauss", "$params" );

# Retrieve the fit information.
( $ORAC_STATUS, my @horiz_centre ) = $Mon{'figaro4'}->get( "fitgauss", "fcentre" );
my $horiz_centre = $horiz_centre[0] * 206265;

$Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$in(1,) out=$temp1_file trim trimwcs" );
$Mon{'ndfpack_mon'}->obeyw( "setaxis", "ndf=$temp1_file dim=1 mode=wcs" );

# Again, get the stats.
$Mon{'kappa_mon'}->obeyw( "stats", "ndf=$temp1_file" );
( $ORAC_STATUS, $max ) = $Mon{'kappa_mon'}->get( "stats", "maximum" );
( $ORAC_STATUS, $min ) = $Mon{'kappa_mon'}->get( "stats", "minimum" );

$peak = $max;
if( $min < 0 && $max < 0 ) {
  $Mon{'kappa_mon'}->obeyw( "csub", "in=$temp1_file out=$temp2_file scalar=$min" );
  $peak = $min - $max;
} else {
  $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp1_file out=$temp2_file" );
}

# Fit the polynomial.
$params  = "in=$temp2_file device=! dialog=f varuse=true mask1=[-10]";
$params .= " mask2=[10] ncomp=1 centre=0 cont=0 peak=$peak fwhm=$fwhm";
$params .= " cf=[0] pf=[0] wf=[1] logfil=! comp=1";
$Mon{'figaro4'}->obeyw( "fitgauss", "$params" );

# Retrieve the fit information.
( $ORAC_STATUS, my @vert_centre ) = $Mon{'figaro4'}->get( "fitgauss", "fcentre" );
my $vert_centre = $vert_centre[0] * 206265;

# Display the results to the user.
my $p_horiz_centre = sprintf( "%.2f", $horiz_centre );
my $p_vert_centre = sprintf( "%.2f", $vert_centre );
orac_print( "Pointing results using Gaussian fit:\n", "blue" );
orac_print( " DAZ: $p_horiz_centre\n DEL: $p_vert_centre\n", "blue" );

# Store with the calibration system.
my %calhash = ( %{$Frm->hdr},
                DAZ => $horiz_centre,
                DEL => $vert_centre,
                DAZ_ERR => 0,
                DEL_ERR => 0,
                POINTING_TYPE => $type,
                METHOD => 'FIVEPOINT',
              );

# Display a warning if values are large.
if( abs( $horiz_centre ) > 10 ) {
  orac_err "Absolute DAZ pointing value greater than 10 arcseconds.\n";
} elsif( abs( $horiz_centre ) > 5 ) {
  orac_warn "Absolute DAZ pointing value greater than 5 arcseconds.\n";
}
if( abs( $vert_centre ) > 10 ) {
  orac_err "Absolute DEL pointing value greater than 10 arcseconds.\n";
} elsif( abs( $vert_centre ) > 5 ) {
  orac_warn "Absolute DEL pointing value greater than 5 arcseconds.\n";
}

$Cal->pointingindex->add( $Frm->file, \%calhash );

# Set SkyRefIs and Format back to what they were before.
$Mon{'ndfpack_mon'}->obeyw( "wcsattrib", "ndf=$in mode=mset setting='SkyRefIs=$skyrefis,Format(1)=$format1,Format(2)=$format2'" );

# Tidy-up output.
orac_print "\n";
