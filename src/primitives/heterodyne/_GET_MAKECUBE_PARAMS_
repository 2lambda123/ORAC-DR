# -*-perl-*-

=head1 NAME

=head1 DESCRIPTION

=head1 ARGUMENTS

=over 4

=item PARAMS = STRING (Returned)

The parameters that can be passed to MAKECUBE for the given
observation. The parameters do not include the IN or OUT parameters.

=item PASS = INTEGER (Given)

The MAKECUBE pass number. 1 for first pass, 2 for second pass. The
first pass is typically used to determine output bounds without
creating a cube in order to determine whether or not to create
tiles. [1]

=item TYPE = STRING (Given)

The type of observation done. This must be one of 'jiggle', 'raster',
'pointing', 'focus', or 'grid'. Case-insensitive. ['']

=back

=head1 NOTES

=over 4

=back

=head1 OUTPUT DATA

=over 4

=item *

None.

=back

=head1 TASKS

None.

=head1 REQUIRED PERL MODULES

None.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2007 Science and Technology Facilities
Council.  All Rights Reserved.

=cut

# Handle parameters.
my $type = $_GET_MAKECUBE_PARAMS_{TYPE};
if( ! defined( $type ) ) {
  orac_throw "Observation type not defined for _GET_MAKECUBE_PARAMS_. Programming error."
}
$type = uc( $type );

my $pass = defined( $_GET_MAKECUBE_PARAMS_{PASS} ) ?
           $_GET_MAKECUBE_PARAMS_{PASS}            :
           1;

my $params;

orac_print "Determining MAKECUBE parameters for $type.\n";

# Set up some defaults.
my %return_hash = ( 'system' => 'icrs',
                    'autogrid' => 'yes',
                  );

if( $type eq 'RASTER' ) {

  $params = "autogrid=yes";

  # We get the pixel scale by multiplying SCAN_VEL and STEPTIME
  # headers, and the position angle comes from the MAP_PA
  # header. Force the position angle to be between -45 and 45
  # degrees. Set the system to azel if the LOCL_CRD header is AZEL.
  my $pixsize = $Frm->hdr( "SCAN_VEL" ) * $Frm->hdr( "STEPTIME" );
  my $crota = 90 - $Frm->hdr( "MAP_PA" );
  while ( $crota < -45 || $crota > 45 ) {
    if( $crota < -45 ) {
      $crota += 90;
    } elsif( $crota > 45 ) {
      $crota -= 90;
    }
  }

  $params .= " pixsize=$pixsize crota=$crota";

  $return_hash{'autogrid'} = 'yes';
  $return_hash{'pixsize'} = $pixsize;
  $return_hash{'crota'} = $crota;

  if( uc( $Frm->uhdr( "LOCL_CRD" ) ) eq 'AZEL' ) {
    $params .= " system=azel";
    $return_hash{'system'} = 'azel';
  }

} elsif( $type eq 'JIGGLE' ) {

  # JIGGLEs always use autogrid.
  $params = "autogrid=yes";
  $return_hash{'autogrid'} = 'yes';

  # HARP4 and HARP5 jiggles get their pixel scale set to 7.5 or 6,
  # respectively.
  my $jiggle_name = ( defined( $Frm->hdr( "JIGL_NAM" ) ) ?
                      $Frm->hdr( "JIGL_NAM" )            :
                      "" );
  if( $jiggle_name =~ /harp([45])/i ) {
    my $pixsize = ( $1 == 4 ? 7.5 : 6 );
    $params .= " pixsize=$pixsize";
    $return_hash{'pixsize'} = $pixsize;
  }

} elsif( $type eq 'GRID' ) {

  # GRIDs just use autogrid.
  $params = "autogrid=yes";
  $return_hash{'autogrid'} = 'yes';

} elsif( $type eq 'POINTING' ) {

  # Check to see if a specific detector is to be used.
  my $instap = ( defined( $Frm->hdr( "INSTAP" ) ) ?
                 uc( $Frm->hdr( "INSTAP" ) )      :
                 '' );

  if( $pass == 1 ) {
    $params = "autogrid=yes ";
    $return_hash{'autogrid'} = 'yes';
  }
  if( $instap ne '' ) {
    $params .= " detectors=$instap";
    $return_hash{'detectors'} = $instap;
  }
  $params .= " system=azel";
  $return_hash{'system'} = 'azel';

} elsif( $type eq 'FOCUS' ) {

  # Just use autogrid for FOCUS observations.
  $params = "autogrid=yes";
  $return_hash{'autogrid'} = 'yes';

} else {
  orac_throw "Unable to determine MAKECUBE parameters for observation type $type."
}

# Wrap the parameters in spaces.
$params = " $params ";

# And set the return value.
$_GET_MAKECUBE_PARAMS_{PARAMS} = $params;
$_GET_MAKECUBE_PARAMS_{HASH} = \%return_hash;
