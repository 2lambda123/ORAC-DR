# -*-perl-*-

=head1 NAME

_QA_RMS_TSYS_CONSISTENCY_ - Compare Tsys-calculated RMS values with
measured RMS values and optionally mask out those that fail to meet a
given threshold.

=head1 DESCRIPTION

This primitive compares RMS values calculated from the Tsys with those
measured from the data. Each spectrum has two RMS values calculated
for it, and if these values differ by more than a given amount, then
the spectrum fails the test. If a given percentage of spectra out of
the entire observation fail the test, then the observation is flagged
as either questionable or bad.

Failed spectra can be optionally masked.

=head1 ARGUMENTS

=over 4

=item MASK = STRING (Given)

The name of the survey to use when masking spectra. The special
"telescope" survey can be used to mask spectra failing the
less-stringent telescope thresholds. If left undefined, then no
spectra will be masked. ['']

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS data.

=back

=head1 OUTPUT DATA

=over 4

=item *

If masking is done (see MASK argument), then the masked timeseries
data with suffix _tsmsk.

=back

=head1 TASKS

KAPPA: COLLAPSE, COPYBAD, DIV, MANIC, NDFCOPY, NUMB, POW, THRESH.

=head1 REQUIRED PERL MODULES

JCMT::ACSIS::Array, JSA::QA, Starlink::HDSPACK.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

# Determine if we're supposed to use this as a mask for a survey.
my $mask = get_prim_arg( $_PRIM_ARGS_, "MASK", undef );
my $survey = get_prim_arg( $_PRIM_ARGS_, "SURVEY", undef );

my @surveys = qw/ GBS NGS SLS Telescope /;

my %result; # Hash containing percentages per file per survey.

use Starlink::HDSPACK qw/ create_hdsobj copy_hdsobj /;
use JSA::QA;

# Retrieve the QA parameters file and set up a new JSA::QA object.
my $qaparamfile = $Cal->qaparams;
my $qa = new JSA::QA( file => $qaparamfile );

# Set up a hash of options to pass to the QA object.
_SETUP_QA_OPTIONS_
my $opts = $_SETUP_QA_OPTIONS_{'OPTS'};
my %opts = %$opts;

# Set up a list of surveys to analyse.
my @analyse_surveys;
if( defined( $survey ) ) {
  if( uc( $survey ) eq 'ALL' ) {
    @analyse_surveys = @surveys;
  } else {
    push @analyse_surveys, $survey;
  }
} else {
  push @analyse_surveys, ( defined( $Frm->hdr( "SURVEY" ) ) ?
                           $Frm->hdr( "SURVEY" )            :
                           "Telescope" );
}

# Retrieve the list of previously masked files.
my $masked_files = $Frm->uhdr( "QA_MASKED_FILES" );

foreach my $i ( 1 .. scalar( @$masked_files ) - 1 ) {

  my ( $infile, $outfile ) = $Frm->inout( "_tsmsk", $i );
  my $masked_file = $masked_files->[$i];

  my $temp1file = new ORAC::TempFile;
  my $temp2file = new ORAC::TempFile;
  my $temp3file = new ORAC::TempFile;
  my $temp4file = new ORAC::TempFile;
  my $temp5file = new ORAC::TempFile;

  # Make sure this file has a VARIANCE component.
  _COMPONENT_EXISTS_ FILE=$infile COMPONENT=VARIANCE
  my $exists = $_COMPONENT_EXISTS_{EXISTS};
  if( ! $exists ) {
    orac_throw "Cannot perform Tsys/RMS consistency checks on a file that has no VARIANCE component\n";
  }

  # We need to collapse down the masked file around the central 85%.
  _GET_DIMENSIONS_ FILE=$infile
  my $lbnd = $_GET_DIMENSIONS_{LBOUND};
  my $ubnd = $_GET_DIMENSIONS_{UBOUND};
  my $extent = int( ( $ubnd->[0] - $lbnd->[0] ) * 0.85 );

  # Collapse it using the sigma estimator to get the standard
  # deviation.
  my $params = "in=$masked_file(~$extent,,) out=$temp1file estimator=sigma axis=spec trim=true wlim=0.0 variance=false";
  $Mon{'kappa_mon'}->obeyw( "collapse", "$params" );

  # Check to see how many good pixels we have.
  $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$temp1file" );
  my ( $ORAC_STATUS, $numgood ) = $Mon{'kappa_mon'}->get( "stats", "numgood" );
  if( $numgood == 0 ) {
    orac_err "No good pixels were found in $masked_file. Cannot perform Tsys/RMS consistency checks.\n";
    $Frm->isgood(0);
    $ORAC_STATUS = ORAC__TERM;
  }

  # Now copy a frequency slice out of the input file. It doesn't
  # matter where, since we're interested in the variance component and
  # that doesn't vary with frequency.
  if( $lbnd->[2] == $ubnd->[2] ) {
    $params = "in=$infile(~1,,) out=$temp2file trim=false";
    $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "$params" );
    $params = "ndf=$temp2file origin=[1,1,1]";
    $Mon{'ndfpack_mon'}->obeyw( "setorigin", "$params" );
  } else {
    $params = "in=$infile(~1,,) out=$temp2file trim=true";
    $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "$params" );
  }

  # Create an HDS object into which we can copy the variance array.
  $ORAC_STATUS = ( create_hdsobj( $temp3file, 'NDF', [0] ) ? ORAC__OK : ORAC__ERROR );
  $ORAC_STATUS = ( copy_hdsobj( "$temp2file.VARIANCE", "$temp3file.DATA_ARRAY" ) ? ORAC__OK : ORAC__ERROR );

  # Add a provenance so it's tracked properly.
  $params = "ndf=$temp3file parent=$temp2file";
  $Mon{'ndfpack_mon'}->obeyw( "provadd", "$params" );

  # Square-root it.
  $params = "in=$temp3file out=$temp4file power=0.5";
  $Mon{'kappa_mon'}->obeyw( "pow", "$params" );

  # At this point, if we're doing an RxA sample the temp4file could be
  # 1D, so turn it into 2D.
  _GET_DIMENSIONS_ FILE=$temp4file
  my $temp4dims = $_GET_DIMENSIONS_{DIMS};
  if( scalar( @{$temp4dims} ) == 1 ) {

    my $temp6file = new ORAC::TempFile;
    $params = "in=$temp4file out=$temp6file axes=[0,1] lbound=1 ubound=1";
    $Mon{'kappa_mon'}->obeyw( "manic", "$params" );

    $temp4file = $temp6file;
  }

  # Divide the measured RMS by the calculated RMS.
  $params = "in1=$temp1file in2=$temp4file out=$temp5file";
  $Mon{'kappa_mon'}->obeyw( "div", "$params" );

  # Run QA analysis on each requested survey.
  foreach my $analyse_survey ( @analyse_surveys ) {

    $opts{'survey'} = $analyse_survey;

    # Retrieve the constant(s) for the difference tolerance and the
    # questionable/bad limits.
    my $rmstol_const      = 'RMSTSYSTOL';
    my $rmstolquest_const = 'RMSTSYSTOL_QUEST';
    my $rmstolfail_const  = 'RMSTSYSTOL_FAIL';
    my $rmstol = $qa->get_data( key => $rmstol_const, %opts );
    my $rmstolquest = $qa->get_data( key => $rmstolquest_const, %opts );
    my $rmstolfail = $qa->get_data( key => $rmstolfail_const, %opts );

    my $tol = $rmstol + 1;
    $params = "in=$temp5file value=$tol above";
    $Mon{'kappa_mon'}->obeyw( "numb", "$params" );
    ( $ORAC_STATUS, my $numb_above ) = $Mon{'kappa_mon'}->get( "numb", "number" );

    # Find out how many pixels are below the tolerance to get a ratio.
    $params = "in=$temp5file value=$tol noabove";
    $Mon{'kappa_mon'}->obeyw( "numb", "$params" );
    ( $ORAC_STATUS, my $numb_below ) = $Mon{'kappa_mon'}->get( "numb", "number" );

    # Calculate the percentage above the threshold, and store it in a
    # hash for future printing.
    my $percent = $numb_above / ( $numb_above + $numb_below );
    $result{$analyse_survey}{$infile} = $percent;

    # Mask out the bad pixels, if requested.
    if( defined( $mask ) && ( uc( $analyse_survey ) eq $mask ) ) {

      my $temp6file = new ORAC::TempFile;
      my $temp7file = new ORAC::TempFile;
      $params = "in=$temp5file out=$temp6file thrlo=-100000 newlo=bad thrhi=$tol newhi=bad";
      $Mon{'kappa_mon'}->obeyw( "thresh", "$params" );

      # Expand out to size of input cube.
      $params = "in=$temp6file out=$temp7file axes=[0,1,2] lbound=" . $lbnd->[0] . " ubound=" . $ubnd->[0];
      $Mon{'kappa_mon'}->obeyw( "manic", "$params" );

      # Copy bad pixels from this to output cube.
      $params = "in=$infile ref=$temp7file out=$outfile";
      $Mon{'kappa_mon'}->obeyw( "copybad", "$params" );

      orac_say "Masked out bad samples to form $outfile.";

      # Update the Frame object.
      $Frm->file( $i, $outfile );
    }
  }
}

foreach my $survey ( sort keys %result ) {
  my $sum = 0;
  foreach my $value ( values %{$result{$survey}} ) {
    $sum += $value;
  }
  my $avg = $sum / scalar( values %{$result{$survey}} );

  $opts{'survey'} = $survey;

  my $rmstol_const      = 'RMSTSYSTOL';
  my $rmstolquest_const = 'RMSTSYSTOL_QUEST';
  my $rmstolfail_const  = 'RMSTSYSTOL_FAIL';
  my $rmstol = $qa->get_data( key => $rmstol_const, %opts );
  my $rmstolquest = $qa->get_data( key => $rmstolquest_const, %opts );
  my $rmstolfail = $qa->get_data( key => $rmstolfail_const, %opts );

  orac_print "Tsys versus RMS consistency check ";

  if( $avg > $rmstolfail ) {
    orac_print( " failed ", "bold white on_red" );
  } elsif( $avg > $rmstolquest ) {
    orac_print( " is questionable ", "bold black on_yellow" );
  } else {
    orac_print( " passed ", "bold white on_green" );
  }

  orac_print " for $survey.\n";

  orac_print sprintf( " %.2f%% of the samples had a calculated RMS that differed by more than %d%% from the measured RMS.\n", $avg * 100, $rmstol * 100 );
}

# If we masked, test the first output file. If it's all bad, don't
# continue as we can't do anything with the data anyhow.
if( defined( $mask ) ) {

  my $test = $Frm->file( 1 );
  $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$test" );
  my ( $ORAC_STATUS, $numgood ) = $Mon{'kappa_mon'}->get( "stats", "numgood" );
  if( $numgood == 0 ) {
    orac_err "All samples were masked as bad. Continuing with next observation.\n";
    $Frm->isgood( 0 );
    $ORAC_STATUS = ORAC__TERM;
  }

}

# Tidy up output.
orac_say "";
