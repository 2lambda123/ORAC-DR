# -*-perl-*-

=head1 NAME

_CREATE_MOMENTS_MAPS_THROUGH_SMOOTHING_

=head1 DESCRIPTION

=head1 ARGUMENTS

=over 4

=back

=head1 NOTES

=over 4

=back

=head1 OUTPUT DATA

=over 4

=back

=head1 TASKS

=head1 REQUIRED PERL MODULES

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

# Handle parameters.
my $group = ( defined( $_PRIM_ARGS_->{GROUP} ) ?
              $_PRIM_ARGS_->{GROUP}            :
              0 );
my $moments = ( defined( $_PRIM_ARGS_->{MOMENTS} ) ?
                $_PRIM_ARGS_->{MOMENTS}            :
                'integ' );
my $freqsmooth = ( defined( $_PRIM_ARGS_->{FREQUENCY_SMOOTH} ) ?
                   $_PRIM_ARGS_->{FREQUENCY_SMOOTH}            :
                   25 );
my $spatsmooth = ( defined( $_PRIM_ARGS_->{SPATIAL_SMOOTH} ) ?
                   $_PRIM_ARGS_->{SPATIAL_SMOOTH}          :
                   3 );
my $order = ( defined( $_PRIM_ARGS_->{ORDER} ) ?
              $_PRIM_ARGS_->{ORDER}            :
              5 );

my @moments = split /,/, $moments;

my @objs;
if( $group == 0 ) {
  push @objs, $Frm;
} elsif( $group == 1 ) {
  push @objs, $Grp;
} elsif( $group == 2 ) {
  @objs = $Grp->members;
}

foreach my $Obj ( @objs ) {

  if( ! defined( $Obj->uhdr( "BASELINE_MASKS" ) ) ) {

    _CREATE_BASELINE_MASK_ GROUP=$group FREQUENCY_SMOOTH=$freqsmooth SPATIAL_SMOOTH=$spatsmooth ORDER=$order

  }

  foreach my $i ( 1 .. $Obj->nfiles ) {

    if( $Obj->uhdr( "SPARSE" ) ) {

      orac_warn $Obj->file( $i ) . " is a sparse cube. Cannot create moments mask for a sparse cube.\n";

    } else {

      ( my $in, undef ) = $Obj->inout( "_blah", $i );
      my $masks = $Obj->uhdr( "BASELINE_MASKS" );
      my $mask = $masks->[$i];

      # Only do this if the cube isn't 1xMxN or Mx1xN.
      _GET_DIMENSIONS_ FILE=$in
      my $dims = $_GET_DIMENSIONS_{DIMS};
      my $lbound = $_GET_DIMENSIONS_{LBOUND};
      my $ubound = $_GET_DIMENSIONS_{UBOUND};

      if( $dims->[0] == 1 ||
          $dims->[1] == 1 ) {
        orac_warn "Cannot create moment map with a " . $dims->[0] . "x" . $dims->[1] . "x" . $dims->[2] . " cube.\n";
      } else {

        # Smooth the cube.
        my $temp1 = new ORAC::TempFile;
        my $temp1file = $temp1->file;
        my $params = "in=$in out=$temp1file axes=[1,3] box=[1,$freqsmooth]";
        $Mon{'kappa_mon'}->obeyw( "block", "$params" );

        my $temp2 = new ORAC::TempFile;
        my $temp2file = $temp2->file;
        if( $dims->[0] < 3 || $dims->[1] < 3 ) {
          $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp1file out=$temp2file" );
        } else {
          $params = "in=$temp1file out=$temp2file axes=[1,2] box=[$spatsmooth,$spatsmooth]";
          $Mon{'kappa_mon'}->obeyw( "block", "$params" );
        }

        # Mask out lines.
        my $temp3 = new ORAC::TempFile;
        my $temp3file = $temp3->file;
        $params = "in1=$temp2file in2=$mask out=$temp3file";
        $Mon{'kappa_mon'}->obeyw( "add", "$params" );

        # Get stats on central-ish regions.
        my $xlow  = int( $lbound->[0] + 0.165 * $dims->[0] + 0.5 );
        my $xhigh = int( $ubound->[0] - 0.165 * $dims->[0] - 0.5 );
        my $ylow  = int( $lbound->[1] + 0.165 * $dims->[1] + 0.5 );
        my $yhigh = int( $ubound->[1] - 0.165 * $dims->[1] - 0.5 );
        my $zlow  = int( $lbound->[2] + 0.165 * $dims->[2] + 0.5 );
        my $zhigh = int( $ubound->[2] - 0.165 * $dims->[2] - 0.5 );
        my $section = "$xlow:$xhigh,$ylow:$yhigh,$zlow:$zhigh";
        $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$temp3file($section)" );
        my ( $ORAC_STATUS, $sigma ) = $Mon{'kappa_mon'}->get( "stats", "sigma" );

        # Create parameter file for FINDCLUMPS.
        my $fc_param = "findclumps$$.param";
        open my $fc_fh, ">", $fc_param;
        print $fc_fh "ClumpFind.Minpix=50\n";
        print $fc_fh "ClumpFind.AllowEdge=1\n";
        print $fc_fh "ClumpFind.FwhmBeam=0\n";
        print $fc_fh "ClumpFind.MaxBad=9999\n";
        print $fc_fh "ClumpFind.VeloRes=0\n";
        print $fc_fh "ClumpFind.Tlow=4.5*RMS\n";
        close $fc_fh;

        # Run FINDCLUMPS.
        my $temp4 = new ORAC::TempFile;
        my $temp4file = $temp4->file;
        $params = "in=$temp2file rms=$sigma config='^$fc_param' method=clumpfind out=$temp4file outcat=\! deconv=no";
        $Mon{'cupid_mon'}->obeyw( "findclumps", "$params" );
        unlink( $fc_param );

        # Check number of clumps using NCLUMPS.
        ( $ORAC_STATUS, my $nclumps ) = $Mon{'cupid_mon'}->get( "findclumps", "nclumps" );

        # If we have no clumps, we can't make a clump mask, so skip the
        # masking and just go straight to the moment map creation.
        my $temp6 = new ORAC::TempFile;
        my $temp6file = $temp6->file;
        if( $nclumps ) {

          # Set clumps to be 0 everywhere (i.e. "clump mask").
          my $temp5 = new ORAC::TempFile;
          my $temp5file = $temp5->file;
          $params = "in=$temp4file scalar=0 out=$temp5file";
          $Mon{'kappa_mon'}->obeyw( "cmult", "$params" );

          # Add clump mask to input cube.
          $params = "in1=$in in2=$temp5file out=$temp6file";
          $Mon{'kappa_mon'}->obeyw( "add", "$params" );

        } else {

          $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$in out=$temp6file" );

        }

        # For each moment, collapse the masked cube into a temporary file.
        foreach my $moment ( @moments ) {

          my $out = $Obj->inout( "_$moment", $i );
          $params = "in=$temp6file out=$out estimator=$moment axis=3 variance=false wlim=0.0";
          $Mon{'kappa_mon'}->obeyw( "collapse", "$params" );
          orac_print "$in to $out: $moment moment map created.\n";

        }
      }
    }

    # Paste together the files in @collapsed into $out.

    # And get the SMURF extensions as well.

    # If we've done an integrated intensity map, find the peak value
    # so we can subsequently get a spectrum from the position of the
    # strongest signal.

  }

}

# Tidy-up output.
orac_print "\n";
