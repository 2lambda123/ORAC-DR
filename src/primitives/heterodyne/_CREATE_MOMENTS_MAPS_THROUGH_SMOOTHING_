# -*-perl-*-

=head1 NAME

_CREATE_MOMENTS_MAPS_THROUGH_SMOOTHING_ - Create moments maps by
smoothing and detecting emission regions using various methods.

=head1 DESCRIPTION

This primitive is used to create moments maps. It first smooths the
cube along the frequency axis, then in the spatial axes. It then masks
out emission regions using a previously-determined mask (see
_CREATE_BASELINE_MASK_), and then calculates the RMS in the
emission-free regions. This RMS is used to set a threshold for the
various emission-selection methods. Selected regions are then turned
into an emission mask (masking out non-emission) to be applied to the
original resolution cube which is then collapsed to form the moment
maps.

Three emission selection methods are available:
  CUPID::Clumpfind: selects emission by walking down peaks to lower
        intensities.
  CUPID::Fellwalker: selects emission by walking up along line of
        steepest accent until a peak or a previous found clump is
        found.
  KAPPA:Thresh: selects emission by simply accepting all data 
        above a specified RMS threshold.

=head1 ARGUMENTS

=over 4

=item FREQUENCY_SMOOTH = INTEGER (Given)

The number of channels to smooth in the frequency axis when smoothing
to determine baselines. This number should be small (~10) for
narrow-line observations and large (~25) for broad-line
observations. [25]

=item GROUP = INTEGER (Given)

How to process group files. 0 means use the current Frame object. 1
means use the current Group object. 2 means use each Frame member of
the current Group object. [0]

=item MOMENTS = STRING (Given)

The moment maps to create. These are any of the values allowed for the
ESTIMATOR parameter to the COLLAPSE method, but in reality this should
probably be 'integ', 'iwc', and/or 'itd'. Any number of moments can be
given in a comma-separated string. ['integ']

=item ORDER = INTEGER (Given)

The polynomial order that will be used when estimating baselines. [1]

=item METHOD = STRING (Given)

Method to use to find emission in the data: 'clumpfind', 'fellwalker',
or 'thresh'. ['clumpfind']

=item RMS_THRESHOLD = REALS (Given)

The RMS threshold above which emission will be considered to be a
clump. A separate threshold can be specified for each moments map
requested. The last specified number will be applied to any further
moments requested. Typically 'integ' can tolerate a rms of 3-sigma,
but the higher order moments need a higher threshold. Comma-separated
string in the same order as the requested MOMENTS. [3.0,4.5]

=item SPATIAL_SMOOTH = INTEGER (Given)

The number of pixels to smooth in both spatial axes when smoothing to
determine baselines. [3]

=item TAG = STRING (Given)

Which moment map to tag as a representative image. ['']

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS cubes.

=back

=head1 OUTPUT DATA

=over 4

=item *

The moments map(s) with suffix equal to the given moment(s) by the
MOMENTS parameter.

=back

=head1 TASKS

CUPID: FINDCLUMPS
KAPPA: ADD, BLOCK, COLLAPSE, DIV, MULT, NDFCOPY, NDFTRACE, NOMAGIC,
       PASTE, PLUCK, SETBB, SETVAR, STATS, THRESH

=head1 REQUIRED PERL MODULES

None, but see _COMPONENT_EXISTS_.

=head1 SEE ALSO

_COMPONENT_EXISTS_, _CREATE_BASELINE_MASK_

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

# Handle parameters.
my $freqsmooth = get_prim_arg( $_PRIM_ARGS_, "FREQUENCY_SMOOTH", 25 );
my $group = get_prim_arg( $_PRIM_ARGS_, "GROUP", 0 );
my $moments = get_prim_arg( $_PRIM_ARGS_, "MOMENTS", 'integ' );
my $method = get_prim_arg( $_PRIM_ARGS_, "METHOD", 'clumpfind' );
my $order = get_prim_arg( $_PRIM_ARGS_, "ORDER", 1 );
my $rms_thrhlds = get_prim_arg( $_PRIM_ARGS_, "RMS_THRESHOLD", '3.0,4.5' );
my $spatsmooth = get_prim_arg( $_PRIM_ARGS_, "SPATIAL_SMOOTH", 3 );
my $tag = get_prim_arg( $_PRIM_ARGS_, "TAG", undef );

my $group2 = ( $group == 2 ? 0 : $group );

my @moments = split /,/, $moments;
my @rms_thrhlds = split /,/, $rms_thrhlds;

if( $method =~ /^t/i ) {
  $method = "thresh";
} elsif( $method =~ /^f/i ) {
  $method = "fellwalker";
} else {
  $method = "clumpfind";
}

my @objs;
if( $group == 0 ) {
  push @objs, $Frm;
} elsif( $group == 1 ) {
  push @objs, $Grp;
} elsif( $group == 2 ) {
  @objs = $Grp->members;
}

if( $group != 1 || ( $group == 1 && $Grp->lastallmembers( $Frm ) ) ) {

  if( ! ( $group == 1 && $Grp->uhdr( "COPY_FRAME_CUBE" ) ) ) {

    foreach my $Obj ( @objs ) {

      if( ! defined( $Obj->uhdr( "BASELINE_MASKS" ) ) ) {

        _CREATE_BASELINE_MASK_ GROUP=$group FREQUENCY_SMOOTH=$freqsmooth SPATIAL_SMOOTH=$spatsmooth ORDER=$order

      }

      # Collapse each of the files making up the current object.
      my @collapsed;
      my %paste_inputs;
      my @smoothed;
      my @smo_obj;
      my @masked;
      my @mask_obj;

      my $nomap = 0;

      foreach my $i ( 1 .. $Obj->nfiles ) {

        if( $Obj->uhdr( "SPARSE" ) ) {

          orac_warn $Obj->file( $i ) . " is a sparse cube. Cannot create moments map for a sparse cube.\n";

        } else {

          ( my $in, undef ) = $Obj->inout( "_blah", $i );

          orac_say "Creating moments maps for $in.";

          my $masks = $Obj->uhdr( "BASELINE_MASKS" );
          my $mask = $masks->[$i];

          # Only do this if the cube isn't 1xMxN or Mx1xN.
          _GET_DIMENSIONS_ FILE=$in
          my $dims = $_GET_DIMENSIONS_{DIMS};
          my $lbound = $_GET_DIMENSIONS_{LBOUND};
          my $ubound = $_GET_DIMENSIONS_{UBOUND};

          if( $dims->[0] == 1 ||
              $dims->[1] == 1 ) {
            orac_warn "Cannot create moment map with a " . $dims->[0] . "x" . $dims->[1] . "x" . $dims->[2] . " cube.\n";

            # If both dimensions are 1, then copy this file into the _sp.
            if( $dims->[0] == 1 && $dims->[1] == 1 ) {

              $nomap = 1;

              {
                my $Frm = $Obj;
                $Frm->uhdr( "INTEG_MAX_POS", [ 1, 1 ] );
                _EXTRACT_MAXVALUE_SPECTRUM_ TAG=1 GROUP=0
              }

            }

          } else {

            # Smooth the cube.
            orac_say " Smoothing cube in frequency with $freqsmooth-pixel tophat.";
            my $temp1 = new ORAC::TempFile;
            my $temp1file = $temp1->file;
            my $params = "in=$in out=$temp1file axes=[1,3] box=[1,$freqsmooth] estimator=mean";
            $Mon{'kappa_mon'}->obeyw( "block", "$params" );

            orac_say " Smoothing cube in spatial with $spatsmooth-pixel tophat.";
            my $temp2 = new ORAC::TempFile;
            my $temp2file = $temp2->file;
            if( $dims->[0] < 3 || $dims->[1] < 3 ) {
              $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp1file out=$temp2file" );
            } else {
              $params = "in=$temp1file out=$temp2file axes=[1,2] box=[$spatsmooth,$spatsmooth] estimator=mean";
              $Mon{'kappa_mon'}->obeyw( "block", "$params" );
            }

            push @smoothed, $temp2file;
            push @smo_obj, $temp2;

            # Mask out lines.
            orac_say " Masking out lines using $mask.";
            my $temp3 = new ORAC::TempFile;
            my $temp3file = $temp3->file;
            $params = "in1=$temp2file in2=$mask out=$temp3file";
            $Mon{'kappa_mon'}->obeyw( "add", "$params" );

            # Copy the variance across, but only if the input cube has
            # a variance.
            $params = "ndf=$temp2file";
            $Mon{'ndfpack_mon'}->obeyw( "ndftrace", "$params" );
            my ( $ORAC_STATUS, $var ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "variance" );
            if( uc( $var ) eq 'TRUE' ) {
              $params = "ndf=$temp3file from=$temp2file comp=VARIANCE";
              $Mon{'ndfpack_mon'}->obeyw( "setvar", "$params" );
            }

            push @masked, $temp3file;
            push @mask_obj, $temp3;

          }
        }
      }

      if( ! $nomap ) {

        # Get the RMS for the smoothed files.
        _CALCULATE_RMS_ FILES=\@masked BOX=1
        my $medianrms = $_CALCULATE_RMS_{RMS};
        orac_say "Median RMS in smoothed observation is " . sprintf( "%0.3f", $medianrms );

        for my $i ( 1 .. $Obj->nfiles ) {
          my $in = $Obj->file( $i );
          my $file = $smoothed[$i-1];

          my $colin = new ORAC::TempFile;

          # Do the emission selection and collapse for each moment
          my $mom = 0;
          foreach my $moment ( @moments ) {

            # Select appropriate threshold from user specification
            my $rms_thresh;
            if($mom <= $#rms_thrhlds) {
              $rms_thresh = $rms_thrhlds[$mom];
            } else {
              $rms_thresh = $rms_thrhlds[$#rms_thrhlds];
              orac_say " Warning: no threshold level for this moment, using previous: $rms_thresh*RMS";
            }

            # Only repeat if different threshold needed
            if( $mom == 0 || $rms_thresh != $rms_thrhlds[$mom-1] ) {

              # Initialize output file for masks
              my $temp4 = new ORAC::TempFile;
              my $temp4file = $temp4->file;
              my $nclumps = 0;
              my $ORAC_STATUS;

              # Find emission/clumps
              # --------------------
              # RPT: this section could go into a _FIND_EMISSION_ primitive
              # if there is an elegant way to handle the temp output file.

              # Method is Thresholding: run kappa::thresh
              if( $method eq 'thresh' ) {

                orac_say " Finding emission higher than $rms_thresh-sigma using $method.";
                my $clip = $medianrms*$rms_thresh;
                my $params = "in=$file out=$temp4file thrlo=$clip thrhi=-1.0e30 newlo=bad";
                $Mon{'kappa_mon'}->obeyw( "thresh", "$params" );

                $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$temp4file" );
                ( $ORAC_STATUS, $nclumps ) = $Mon{'kappa_mon'}->get( "stats", "numgood" );

              # Else use cupid::findclumps
              } else {

                # Create parameter file for FINDCLUMPS with both
                # parameters for clumpfind and fellwalker
                my $fc_param = "findclumps$$.param";
                open my $fc_fh, ">", $fc_param;
                print $fc_fh "ClumpFind.Minpix=50\n";
                print $fc_fh "ClumpFind.AllowEdge=1\n";
                print $fc_fh "ClumpFind.FwhmBeam=0\n";
                print $fc_fh "ClumpFind.MaxBad=9999\n";
                print $fc_fh "ClumpFind.VeloRes=0\n";
                print $fc_fh "ClumpFind.Tlow=$rms_thresh*RMS\n";
                print $fc_fh "FellWalker.Minpix=50\n";
                print $fc_fh "FellWalker.AllowEdge=1\n";
                print $fc_fh "FellWalker.FwhmBeam=0\n";
                print $fc_fh "FellWalker.MaxBad=9999\n";
                print $fc_fh "FellWalker.VeloRes=0\n";
                print $fc_fh "FellWalker.Noise=$rms_thresh*RMS\n";
                print $fc_fh "FellWalker.FlatSlope=1.0*RMS\n";
                print $fc_fh "FellWalker.MinHeight=$rms_thresh*RMS\n";
                close $fc_fh;

                # Run findclumps with clumpfind or fellwalker
                orac_say " Finding clumps higher than $rms_thresh-sigma using $method.";
                my $params = "in=$file rms=$medianrms config='^$fc_param' method=$method out=$temp4file outcat=\! deconv=no";
                $Mon{'cupid_mon'}->obeyw( "findclumps", "$params" );
                unlink( $fc_param );

                # Check number of clumps using NCLUMPS.
                ( $ORAC_STATUS, $nclumps ) = $Mon{'cupid_mon'}->get( "findclumps", "nclumps" );
	      }
              # --------------------

              # If we have no clumps, we can't make a clump mask, so skip
              # the masking and just go straight to the moment map
              # creation.
              if( $nclumps ) {

                # Set clumps to be 1 everywhere (i.e. "clump mask").
                my $temp6 = new ORAC::TempFile;
                my $params = "in1=$temp4file in2=$temp4file out=$temp6";
                $Mon{'kappa_mon'}->obeyw( "div", "$params" );

                # Set bad data to zero.
                my $temp7 = new ORAC::TempFile;
                $params = "in=$temp6 out=$temp7 repval=0";
                $Mon{'kappa_mon'}->obeyw( "nomagic", "$params" );

                # Multiply clump mask by input cube.
                orac_say " Masking non-clump data.";
                $params = "in1=$in in2=$temp7 out=$colin";
                $Mon{'kappa_mon'}->obeyw( "mult", "$params" );

              } else {

                orac_say " No clumps found, using full cube for map creation.";
                $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$in out=$colin" );

              }

            }

            # For the moment collapse the masked cube into a temporary
            # file.

            if( ! exists( $paste_inputs{$moment} ) ) {
              $paste_inputs{$moment} = ();
            }

            # Set any pixels with a BORDER QUALITY value to bad.
            my $params = "ndf=$colin bb=255";
            $Mon{'ndfpack_mon'}->obeyw( "setbb", "$params" );

            # Copy the variance from the input cube.
            $params = "ndf=$colin from=$in comp=VARIANCE";
            $Mon{'ndfpack_mon'}->obeyw( "setvar", "$params" );

            # Run the COLLAPSE.
            orac_say " Collapsing to form temporary $moment map.";
            my $temp8 = new ORAC::TempFile;
            my $temp8file = $temp8->file;
            $params = "in=$colin out=$temp8file estimator=$moment ";
            $params .= "axis=SPEC wlim=0.0 trim=false";
            if( uc( $moment ) eq 'IWC' ) {
              $params .= " variance=false";
            } else {
              $params .= " variance=true";
            }
            $Mon{'kappa_mon'}->obeyw( "collapse", "$params" );

            push @{$paste_inputs{$moment}}, $temp8file;
            push @collapsed, $temp8;
            $mom++;
          }
	}

        orac_say;

        # Paste together the files in @collapsed into $out.
        foreach my $moment ( @moments ) {

          my( $in, $out ) = $Obj->inout( "_$moment" );

          if( defined( $paste_inputs{$moment} ) ) {

            if( scalar( @{$paste_inputs{$moment}} ) == 1 ) {

              my $params = "in=${$paste_inputs{$moment}}[0] out=$out";
              $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "$params" );

            } else {

              orac_say " Pasting together temporary maps to form $moment map.";

              my $title = $Frm->uhdr( "ORAC_OBJECT" );
              _PASTE_FILES_ FILES=$paste_inputs{$moment} OUT=$out TITLE=$title

            }

            orac_say "Created $moment map in $out.";

            _SET_FILE_FITS_ITEM_ FILE=$out KEY=PRODUCT VALUE=$moment
            $Obj->sync_headers;

            # Copy the output to a group file if requested.
            if( $group != 1 && $Grp->uhdr( "COPY_FRAME_CUBE" ) ) {
              ( undef, my $groupout ) = $Grp->inout( "_$moment" );

              $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$out out=$groupout" );

              my $tGrp = new $Grp;
              $tGrp->groupid( $Grp->groupid );
              $tGrp->allow_header_sync(1);
              $tGrp->file( $groupout );

              orac_say "$out to $groupout:";
              orac_say " Copied to Group file.";

              if( defined( $tag ) && $tag eq $moment ) {
                _TAG_AS_REPRESENTATIVE_ FILE=$groupout UPDATE=0 GROUP=1 SUFFIX=rimg
              }

            }

            # Tag the moment map if the current moment is the
            # requested one.
            if( defined( $tag ) && $tag eq $moment ) {
              if( $group == 2 ) {
                my $Frm = new $Obj;
                $Frm->file( $out );
                _TAG_AS_REPRESENTATIVE_ FILE=$out UPDATE=0 GROUP=$group2 SUFFIX=rimg
              } else {
                _TAG_AS_REPRESENTATIVE_ FILE=$out UPDATE=0 GROUP=$group SUFFIX=rimg
              }
            }

            # Find the position of the peak, then extract a spectrum
            # from that position, but only if the moment is 'integ'.
            if( $moment eq 'integ' ) {

              $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$out" );
              my( $ORAC_STATUS, @maxpos ) = $Mon{'kappa_mon'}->get( "stats", "maxpos" );
              $Obj->uhdr( "INTEG_MAX_POS", \@maxpos );

              my $tagspec = defined( $tag );

              if( $group == 2 ) {
                my $Frm = new $Obj;
                $Frm->files( $Obj->files );
                $Frm->uhdr( "INTEG_MAX_POS", \@maxpos );
                _EXTRACT_MAXVALUE_SPECTRUM_ TAG=$tagspec GROUP=$group2
              } else {
                _EXTRACT_MAXVALUE_SPECTRUM_ TAG=$tagspec GROUP=$group
              }
            }
          }
        }

        # Tidy-up output.
        orac_say "";

      }
    }
  }
}
