# -*-perl-*-

=head1 NAME

_CREATE_MOMENTS_MAPS_THROUGH_SMOOTHING_

=head1 DESCRIPTION

=head1 ARGUMENTS

=over 4

=back

=head1 NOTES

=over 4

=back

=head1 OUTPUT DATA

=over 4

=back

=head1 TASKS

=head1 REQUIRED PERL MODULES

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

# Handle parameters.
my $group = ( defined( $_PRIM_ARGS_->{GROUP} ) ?
              $_PRIM_ARGS_->{GROUP}            :
              0 );
my $moments = ( defined( $_PRIM_ARGS_->{MOMENTS} ) ?
                lc( $_PRIM_ARGS_->{MOMENTS} )      :
                'integ' );
my $freqsmooth = ( defined( $_PRIM_ARGS_->{FREQUENCY_SMOOTH} ) ?
                   $_PRIM_ARGS_->{FREQUENCY_SMOOTH}            :
                   25 );
my $spatsmooth = ( defined( $_PRIM_ARGS_->{SPATIAL_SMOOTH} ) ?
                   $_PRIM_ARGS_->{SPATIAL_SMOOTH}          :
                   3 );
my $order = ( defined( $_PRIM_ARGS_->{ORDER} ) ?
              $_PRIM_ARGS_->{ORDER}            :
              5 );
my $tag = ( defined( $_PRIM_ARGS_->{TAG} ) ?
            lc( $_PRIM_ARGS_->{TAG} )      :
            'integ' );

my @moments = split /,/, $moments;

my @objs;
if( $group == 0 ) {
  push @objs, $Frm;
} elsif( $group == 1 ) {
  push @objs, $Grp;
} elsif( $group == 2 ) {
  @objs = $Grp->members;
}

foreach my $Obj ( @objs ) {

  if( ! defined( $Obj->uhdr( "BASELINE_MASKS" ) ) ) {

    _CREATE_BASELINE_MASK_ GROUP=$group FREQUENCY_SMOOTH=$freqsmooth SPATIAL_SMOOTH=$spatsmooth ORDER=$order

  }

  my @collapsed;
  my %paste_inputs;

  foreach my $i ( 1 .. $Obj->nfiles ) {

    if( $Obj->uhdr( "SPARSE" ) ) {

      orac_warn $Obj->file( $i ) . " is a sparse cube. Cannot create moments mask for a sparse cube.\n";

    } else {

      ( my $in, undef ) = $Obj->inout( "_blah", $i );
      my $masks = $Obj->uhdr( "BASELINE_MASKS" );
      my $mask = $masks->[$i];

      # Only do this if the cube isn't 1xMxN or Mx1xN.
      _GET_DIMENSIONS_ FILE=$in
      my $dims = $_GET_DIMENSIONS_{DIMS};
      my $lbound = $_GET_DIMENSIONS_{LBOUND};
      my $ubound = $_GET_DIMENSIONS_{UBOUND};

      if( $dims->[0] == 1 ||
          $dims->[1] == 1 ) {
        orac_warn "Cannot create moment map with a " . $dims->[0] . "x" . $dims->[1] . "x" . $dims->[2] . " cube.\n";
      } else {

        # Smooth the cube.
        my $temp1 = new ORAC::TempFile;
        my $temp1file = $temp1->file;
        my $params = "in=$in out=$temp1file axes=[1,3] box=[1,$freqsmooth] estimator=mean";
        $Mon{'kappa_mon'}->obeyw( "block", "$params" );

        my $temp2 = new ORAC::TempFile;
        my $temp2file = $temp2->file;
        if( $dims->[0] < 3 || $dims->[1] < 3 ) {
          $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp1file out=$temp2file" );
        } else {
          $params = "in=$temp1file out=$temp2file axes=[1,2] box=[$spatsmooth,$spatsmooth] estimator=mean";
          $Mon{'kappa_mon'}->obeyw( "block", "$params" );
        }

        # Mask out lines.
        my $temp3 = new ORAC::TempFile;
        my $temp3file = $temp3->file;
        $params = "in1=$temp2file in2=$mask out=$temp3file";
        $Mon{'kappa_mon'}->obeyw( "add", "$params" );

        # Copy the variance across.
        $params = "ndf=$temp3file from=$temp2file comp=VARIANCE";
        $Mon{'ndfpack_mon'}->obeyw( "setvar", "$params" );

        # Get stats on central-ish regions.
        my $xlow  = int( $lbound->[0] + 0.165 * $dims->[0] + 0.5 );
        my $xhigh = int( $ubound->[0] - 0.165 * $dims->[0] - 0.5 );
        my $ylow  = int( $lbound->[1] + 0.165 * $dims->[1] + 0.5 );
        my $yhigh = int( $ubound->[1] - 0.165 * $dims->[1] - 0.5 );
        my $zlow  = int( $lbound->[2] + 0.165 * $dims->[2] + 0.5 );
        my $zhigh = int( $ubound->[2] - 0.165 * $dims->[2] - 0.5 );
        my $section = "$xlow:$xhigh,$ylow:$yhigh,$zlow:$zhigh";
        $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$temp3file($section)" );
        my ( $ORAC_STATUS, $sigma ) = $Mon{'kappa_mon'}->get( "stats", "sigma" );

        # Create parameter file for FINDCLUMPS.
        my $fc_param = "findclumps$$.param";
        open my $fc_fh, ">", $fc_param;
        print $fc_fh "ClumpFind.Minpix=50\n";
        print $fc_fh "ClumpFind.AllowEdge=1\n";
        print $fc_fh "ClumpFind.FwhmBeam=0\n";
        print $fc_fh "ClumpFind.MaxBad=9999\n";
        print $fc_fh "ClumpFind.VeloRes=0\n";
        print $fc_fh "ClumpFind.Tlow=4.5*RMS\n";
        close $fc_fh;

        # Run FINDCLUMPS.
        my $temp4 = new ORAC::TempFile;
        my $temp4file = $temp4->file;
        $params = "in=$temp2file rms=$sigma config='^$fc_param' method=clumpfind out=$temp4file outcat=\! deconv=no";
        $Mon{'cupid_mon'}->obeyw( "findclumps", "$params" );
        unlink( $fc_param );

        # Check number of clumps using NCLUMPS.
        ( $ORAC_STATUS, my $nclumps ) = $Mon{'cupid_mon'}->get( "findclumps", "nclumps" );

        # If we have no clumps, we can't make a clump mask, so skip the
        # masking and just go straight to the moment map creation.
        my $temp6 = new ORAC::TempFile;
        my $temp6file = $temp6->file;
        if( $nclumps ) {

          # Set clumps to be 0 everywhere (i.e. "clump mask").
          my $temp5 = new ORAC::TempFile;
          my $temp5file = $temp5->file;
          $params = "in=$temp4file scalar=0 out=$temp5file";
          $Mon{'kappa_mon'}->obeyw( "cmult", "$params" );

          # Add clump mask to input cube.
          $params = "in1=$in in2=$temp5file out=$temp6file";
          $Mon{'kappa_mon'}->obeyw( "add", "$params" );

        } else {

          $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$in out=$temp6file" );

        }

        # For each moment, collapse the masked cube into a temporary file.
        foreach my $moment ( @moments ) {

          if( ! exists( $paste_inputs{$moment} ) ) {
            $paste_inputs{$moment} = ();
          }

          # Set any pixels with a non-zero QUALITY value to bad.
          $params = "ndf=$temp6file bb=255";
          $Mon{'ndfpack_mon'}->obeyw( "setbb", "$params" );

          # Run the COLLAPSE.
          my $temp7 = new ORAC::TempFile;
          my $temp7file = $temp7->file;
          $params = "in=$temp6file out=$temp7file estimator=$moment axis=3 variance=true wlim=0.0 trim=false";
          $Mon{'kappa_mon'}->obeyw( "collapse", "$params" );

          push @{$paste_inputs{$moment}}, $temp7file;
          push @collapsed, $temp7;

        }
      }
    }
  }

  # Paste together the files in @collapsed into $out.
  foreach my $moment ( @moments ) {

    my( $in, $out ) = $Obj->inout( "_$moment" );

    if( scalar( @{$paste_inputs{$moment}} ) == 1 ) {

      my $params = "in=${$paste_inputs{$moment}}[0] out=$out";
      $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "$params" );

      orac_print "Created $moment map in $out.\n";

    } else {

      # Write a file containing the input files to PASTE.
      open my $paste_fh, ">", "paste$$.in" or die "Could not open input file for PASTE: $!\n";
      open my $expt_fh, ">", "paste_expt$$.in" or die "Could not open input file for PASTE: $!\n";
      open my $efft_fh, ">", "paste_efft$$.in" or die "Could not open input file for PASTE: $!\n";
      open my $tsys_fh, ">", "paste_tsys$$.in" or die "Could not open input file for PASTE: $!\n";

      print $paste_fh join "\n", @{$paste_inputs{$moment}};
      print $expt_fh join "\n", map { "$_.MORE.SMURF.EXP_TIME" } @{$paste_inputs{$moment}};
      print $efft_fh join "\n", map { "$_.MORE.SMURF.EFF_TIME" } @{$paste_inputs{$moment}};
      print $tsys_fh join "\n", map { "$_.MORE.SMURF.TSYS" } @{$paste_inputs{$moment}};

      close $paste_fh;
      close $expt_fh;
      close $efft_fh;
      close $tsys_fh;

      # And paste them together.
      my $params = "in='^paste$$.in' out=$out confine=false transp=true title='$moment map'";
      $Mon{'kappa_mon'}->obeyw( "paste", "$params" );

      $params = "in='^paste_expt$$.in' out=$out.MORE.SMURF.EXP_TIME confine=false transp=true";
      $Mon{'kappa_mon'}->obeyw( "paste", "$params" );
      $params = "in='^paste_efft$$.in' out=$out.MORE.SMURF.EFF_TIME confine=false transp=true";
      $Mon{'kappa_mon'}->obeyw( "paste", "$params" );
      $params = "in='^paste_tsys$$.in' out=$out.MORE.SMURF.TSYS confine=false transp=true";
      $Mon{'kappa_mon'}->obeyw( "paste", "$params" );

      orac_print "Created $moment map in $out.\n";

      unlink "paste$$.in";
      unlink "paste_expt$$.in";
      unlink "paste_efft$$.in";
      unlink "paste_tsys$$.in";

    }

    # Tag the moment map if the current moment is the requested one.
    if( $tag eq $moment ) {
      {
        $Frm = $Obj;
        _TAG_AS_REPRESENTATIVE_IMAGE_ FILE=$out UPDATE=0
      }
    }

    # Find the position of the peak, then extract a spectrum from that
    # position, but only if the moment is 'integ'.
    if( $moment eq 'integ' ) {

      $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$out" );
      my( $ORAC_STATUS, $maxwcs ) = $Mon{'kappa_mon'}->get( "stats", "maxwcs" );
      $maxwcs =~ /^(.*),(.*),.*$/;
      my $ra = $1;
      my $dec = $2;
      $ra =~ s/\s//g;
      $dec =~ s/\s//g;

      my ( $pl_in, $pl_out ) = $Obj->inout( "_sp" );

      my $params = "in=$pl_in pos='$ra,$dec' axes=VRAD method=linear out=$pl_out";
      $Mon{'kappa_mon'}->obeyw( "pluck", "$params" );

      orac_print "$pl_in to $pl_out:\n Extracted spectrum at $ra, $dec.\n";

      {
        $Frm = $Obj;
        _TAG_AS_REPRESENTATIVE_SPECTRUM_ FILE=$pl_out UPDATE=0
      }

    }

  }
}

# Tidy-up output.
orac_print "\n";
