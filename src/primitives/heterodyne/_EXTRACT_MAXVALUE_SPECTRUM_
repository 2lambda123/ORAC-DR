# -*-perl-*-

=head1 NAME

_EXTRACT_MAXVALUE_SPECTRUM_ -- Extract a spectrum from a cube using
the maximum value in an image.

=head1 DESCRIPTION

This primitive extracts a spectrum from a cube. The position of the
spectrum is chosen from the peak value location in an integrated
intensity image, which is passed through the Frame class uhdr. See the
Notes section for further information.

=head1 ARGUMENTS

=over 4

=item TAG = LOGICAL (Given)

Whether or not to tag the resulting spectrum as representative. [0]

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS.

=item *

If the input Frame is 1x1xN, then the Frame is copied into the output
spectrum.

=item *

If the input Frame is not 1x1xN, then the position to extract is given
by the INTEG_MAX_POS uhdr. This must be an array reference in pixel
coordinates.

=back

=head1 OUTPUT DATA

=over 4

=item *

The spectrum with a suffix _spNNN, where NNN is a zero-padded number
starting from 001. Currently only one spectrum is extracted by this
primitive.

=back

=head1 TASKS

=head1 REQUIRED PERL MODULES

None.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2007 Science and Technology Facilities
Council.  All Rights Reserved.

=cut

# Deal with parameters.
my $tag = ( $_EXTRACT_MAXVALUE_SPECTRUM_{TAG} ?
            $_EXTRACT_MAXVALUE_SPECTRUM_{TAG} :
            0 );

my $out;

# Only extract a representative spectrum if we've created an
# integrated intensity image (and thus have the peak value), or if the
# cube is 1x1xN.
_GET_DIMENSIONS_
my $dims = $_GET_DIMENSIONS_{DIMS};

if( $dims->[0] == 1 &&
    $dims->[1] == 1 ) {

  # In this case the cube is the spectrum. Just copy the cube over.
  ( my $in, $out ) = $Frm->inout( "_sp001" );
  $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$in out=$out" );

  orac_print "Spectrum created in $out.\n";

  my $tmpFrm = $Frm->new( $out );
  $tmpFrm->sync_headers;

  # Fix up provenance.
  $Frm->readhdr( $out );
  my $hdr = $Frm->hdr;
  my $prvcnt = $hdr->{'PRVCNT'};
  foreach my $i ( 1 .. $prvcnt ) {
    my $header = sprintf( "PRV%05d", $i );
    my $params = "ndf=$out edit=delete keyword=$header mode=interface";
    $Mon{'ndfpack_mon'}->obeyw( "fitsmod", "$params" );
  }

  # Fix up headers.
  _SET_FILE_FITS_ITEM_ FILE=$out KEY=PRVCNT VALUE=1
  _SET_FILE_FITS_ITEM_ FILE=$out KEY=PRV00001 VALUE=$in
  _SET_FILE_FITS_ITEM_ FILE=$out KEY=PRODUCT VALUE=sp
  _DELETE_FILE_FITS_ITEM_ FILE=$out KEY=NUMTILES
  _DELETE_FILE_FITS_ITEM_ FILE=$out KEY=TILENUM

  # And display.
  _DISPLAY_FILE_ FILE=$out

} else {

  # We have a proper cube, so we have to retrieve the maximum flux
  # position from the integrated intensity image. If we don't have
  # that information, collapse the entire cube in spatial directions
  # to create a spectrum.
  if( defined( $Frm->uhdr( "INTEG_MAX_POS" ) ) ) {

    my $maxpos = $Frm->uhdr( "INTEG_MAX_POS" );

    # We need to find which frame contains this position. Go through
    # each one in turn, finding the dimensions.
    my $fileno = 0;
    foreach my $i ( 1 .. $Frm->nfiles ) {

      my $file = $Frm->file( $i );
      $Mon{'ndfpack_mon'}->obeyw( "ndftrace", "ndf=$file" );

      my ( $ORAC_STATUS, @lbound ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "lbound" );
      ( $ORAC_STATUS, my @ubound ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "ubound" );
      if( $maxpos->[0] >= $lbound[0] &&
          $maxpos->[0] <= $ubound[0] &&
          $maxpos->[1] >= $lbound[1] &&
          $maxpos->[1] <= $ubound[1] ) {

        $fileno = $i;
        last;
      }
    }

    # Copy out the spectrum from the given file.
    my $in = $Frm->file( $fileno );
    ( undef, $out ) = $Frm->inout( "_sp001" );
    my $params = "in=$in(" . $maxpos->[0] . "," . $maxpos->[1] . ",) out=$out trim=false";
    $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "$params" );

    orac_print "Spectrum created in $out.\n";

    my $tmpFrm = $Frm->new( $out );
    $tmpFrm->sync_headers;

    # Fix up provenance.
    $Frm->readhdr( $out );
    my $hdr = $Frm->hdr;
    my $prvcnt = $hdr->{'PRVCNT'};
    foreach my $i ( 1 .. $prvcnt ) {
      my $header = sprintf( "PRV%05d", $i );
      my $params = "ndf=$out edit=delete keyword=$header mode=interface";
      $Mon{'ndfpack_mon'}->obeyw( "fitsmod", "$params" );
    }

    # Fix up headers.
    _SET_FILE_FITS_ITEM_ FILE=$out KEY=PRVCNT VALUE=1
    _SET_FILE_FITS_ITEM_ FILE=$out KEY=PRV00001 VALUE=$in
    _SET_FILE_FITS_ITEM_ FILE=$out KEY=PRODUCT VALUE=sp
    _DELETE_FILE_FITS_ITEM_ FILE=$out KEY=NUMTILES
    _DELETE_FILE_FITS_ITEM_ FILE=$out KEY=TILENUM

    # And display.
    _DISPLAY_FILE_ FILE=$out
  }
}

if( $tag ) {
  _TAG_AS_REPRESENTATIVE_SPECTRUM_ FILE=$out
}
