# -*-perl-*-

=head1 NAME

_CREATE_TIMESERIES_MASK_

=head1 DESCRIPTION

This primitive creates a mask that masks out regions of emission in
time-series data. It does so by retrieving a baseline mask as created
in the _REMOVE_BASELINE_THROUGH_SMOOTHING_ primitive, then running it
through UNMAKECUBE using the original time-series data as references.

=head1 ARGUMENTS

=over 4

=item INTERP = STRING (Given)

The method to use when resampling the input sky cube pixel
values. ['nearest']

=item PARAMS = STRING (Given)

An array which consists of additional parameters required by the Sinc,
SincSinc, SincCos, SincGauss, Somb, and SombCos interpolation schemes
(see INTERP argument). ['']

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS data.

=item *

The input baseline masks are found in the Group uhdr BASELINE_MASKS,
which is an array reference.

=item *

The output baseline mask names are stored in the Group uhdr
TIMESERIES_MASKS, which is a hash reference. Keys are the raw
time-series data, values are the corresponding time-series baseline
mask.

=item *

This primitive creates output masks for every Frame member in the
current Group.

=item *

Neither the Frame nor Group object are updated.

=back

=head1 OUTPUT DATA

=over 4

=item *

Time-series masks with the suffix _tsmask.

=back

=head1 TASKS

SMURF: UNMAKECUBE.

=head1 REQUIRED PERL MODULES

None.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

# Handle parameters.
my $interp = ( defined( $_PRIM_ARGS_->{INTERP} ) ?
               $_PRIM_ARGS_->{INTERP}            :
               'nearest' );
my $interp_params = ( defined( $_PRIM_ARGS_->{PARAMS} ) ?
                      $_PRIM_ARGS_->{PARAMS}            :
                      "''" );

my @ref;
my @tsmask;
my %tsmask;
my @maskin;
foreach my $Frm ( $Grp->members ) {
  foreach my $i ( 1 .. $Frm->nfiles ) {
    my ( $in, $out ) = $Frm->inout( "_tsmask", $i );
    push @ref, $in;
    push @tsmask, $out;
    $tsmask{$Frm->file($i)} = $out;
  }
}

foreach my $i ( 1 .. $Grp->nfiles ) {
  push @maskin, $Grp->uhdr( "BASELINE_MASKS" )->[$i];
}

# Create input list files for the various parameters to UNMAKECUBE.
my $inlist = "inlist$$.lis";
my $reflist = "reflist$$.lis";
my $outlist = "outlist$$.lis";
open my $inlist_fh, ">", $inlist;
open my $reflist_fh, ">", $reflist;
open my $outlist_fh, ">", $outlist;
print $inlist_fh join "\n", @maskin;
print $reflist_fh join "\n", @ref;
print $outlist_fh join "\n", @tsmask;
close $inlist_fh;
close $reflist_fh;
close $outlist_fh;

# Set up parameters to UNMAKECUBE.
my $params = "in='^$inlist' ref='^$reflist' out='^$outlist' interp=$interp params=$interp_params";

# And run UNMAKECUBE.
$Mon{'smurf_mon'}->obeyw( "unmakecube", "$params" );

# We now have the timeseries masks. Don't update the Group object or
# the Frame object or anything, just stick their names in the Group
# uhdr.
$Grp->uhdr( "TIMESERIES_MASKS", \%tsmask );

# Report to the user.
orac_print "Created timeseries masks in " . ( join ", ", @tsmask ) . "\n";

# Remove list files.
unlink $inlist;
unlink $reflist;
unlink $outlist;

# Tidy-up output.
orac_print "\n";
