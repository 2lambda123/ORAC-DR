=head1 NAME                                     -*-perl-*-

_GROUP_MOSIAC_ - Examine files within a group - mosaic together those than need mosaicking.

=head1 DESCRIPTION

If the frame is the last in the group, and there is
more than one frame in the group, mosaic the frames together.  The
criterion for mosacing will depend on the frequency axes of the
constituent frames, but the mosaicing should cover both sky and
frequency cases.


=head1 ARGUMENTS

=over

=item 4

=item ENCODING

=back

=head1 AUTHOR

Jamie Leech E<lt>j.leech@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 1998-2002 Particle Physics and Astronomy Research
Council. All Rights Reserved.

=cut

#######################
# Check that we are processing the last frame of the group
# and that there are some frames to coadd.

orac_print "Group Name is ".$Grp->name."\n";

if ($Grp->lastmember($Frm)) {
  my $ORAC_STATUS;
  my $allowable_sparseness=2.0; # we can tolerate an output cubes which has twice as many zeros as data in z direction.
  my ($outfile,$infile,$inputlist,$outputlist,$fh_inlist,$fh_outlist,$key_align);
  my (@filename,@sorted_resolutions,@resolutions,@astart_freq,@aend_freq,@temp,@a,@b,@overlap);
  my ($i,$j,$key,$do_mosaic_flag,$my_frame);
  my (%count,%resolution_hash);
  my $factor=0.1;
  my $tally=0;

  # Get the filenames for each frame in the group. There will be one filename per frame at this stage. 
  my @frames = $Grp->members;
  my $no_frames_in_group =scalar (@frames);
  my $no_of_files_in_frame=0;

  orac_print "GROUP MOSAIC found $no_frames_in_group frame(s) in the group.\n"; 

  if ( $no_frames_in_group == 1 ) {
    $i=0;

    foreach $my_frame (@frames) {
      foreach my $infile ($my_frame->files) {
        #######
        # determine resolution for the ith file
        # store as $resolution[$i]
        $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$infile");
        ($ORAC_STATUS, my @lbound) = $Mon{ndfpack_mon}->get("ndftrace","lbound");
        ($ORAC_STATUS, my @ubound) = $Mon{ndfpack_mon}->get("ndftrace","ubound");
        ($ORAC_STATUS, my @astart) = $Mon{ndfpack_mon}->get("ndftrace","flbnd");
        ($ORAC_STATUS, my @aend) = $Mon{ndfpack_mon}->get("ndftrace","fubnd");
        ($ORAC_STATUS, my @dims) = $Mon{ndfpack_mon}->get("ndftrace","dims");

        orac_print "$lbound[0] $lbound[1]  $lbound[2]--- $ubound[0] $ubound[1]  $ubound[2]\n";

        $resolutions[$i] = ($aend[2] - $astart[2]) /$dims[2] ;
        $astart_freq[$i] =  $astart[2];
        $aend_freq[$i] =  $aend[2];
        $filename[$i] = $infile;
        orac_print " $aend[2] ---  $astart[2]) -- $dims[2] --- $resolutions[$i]\n";
        $i++;
      }
    }

    $no_of_files_in_frame = $i;
    orac_print "no_of_files_in_frame $no_of_files_in_frame no_frames_in_group $no_frames_in_group \n";

    #####################
    #
    # Determine No. of distinct "rough" resolutions in the group from the 
    # $resolution[$i] array.
    #
    # We want to treat every resolution which is "roughly" the same as the same.
    #
    # Numerically sorting the resolution list simplifies the algorithm.
    # I'm sure there is a cunning way of doing this without the sort
    # but this will do for now.
    #

    @sorted_resolutions = sort { $a <=> $b } (@resolutions);
    $i=0;
    $j=0;

    while( $i < $no_of_files_in_frame ) {

      while( ($sorted_resolutions[$i] >= ($sorted_resolutions[$j] * (1.0 - $factor))) && ($sorted_resolutions[$i] < ($sorted_resolutions[$j] *(1.0 + $factor)))) {
        if (defined $count{$sorted_resolutions[$i]}) {
          $count{$sorted_resolutions[$i]}++;
        } else {
          $count{$sorted_resolutions[$i]}=1;
        }
        $j++;
        if( $j >= $no_of_files_in_frame ) { last; }
      }

      print "\n";
      $i = $i + $count{$sorted_resolutions[$i]};
      $j = $i;
    }

    $tally=0;

    # Sanity check
    foreach $key (sort { $a <=> $b } keys %count) {
      orac_print "There are ".$count{$key}." instances of values within ".($factor*100.0)." percent of $key\n";;
      $tally+=$count{$key};
    }

    if( $tally != $no_of_files_in_frame ) {
      orac_print "WARNING -- we have not counted each resolution\n";
      # N.B complete this throw an orac error here. 
      # Should never happen if the algorithm above is okay.
    }

    # We now know how many files correspond to each "rough" resolution within the group
    ####

    ####################
    # For each "rough" resolution i.e. each key in %count
    foreach $key (sort { $a <=> $b } keys %count) {

      #### step through $resolution[$i] if resolution matches within factor, add the the file 
      # @{ $resolution_h{$key}{file}    }   is an array of filenames
      # @{ $resolution_h{$key}{astarts} }   is an array of corresponding astarts  
      # @{ $resolution_h{$key}{aend}    }   is an array of corresponding aends  
      # @{ $resolution_h{$key}{resolution} } is an array e.g. fully accurate

      for ($i=0;$i<$no_of_files_in_frame;$i++) {
        if( ($resolutions[$i] >= ($key * (1.0 - $factor))) && ($resolutions[$i] < ($key *(1.0 + $factor)))) {
          push @{ $resolution_hash{$key}{file}    },  $filename[$i];
          push @{ $resolution_hash{$key}{astarts} },  $astart_freq[$i];
          push @{ $resolution_hash{$key}{aends}    },  $aend_freq[$i];
          push @{ $resolution_hash{$key}{resolution} },  $resolutions[$i];
        }
      }
      #########
      # These arrays should now be sorted so that they are in astart order.
      # This is the standard Schwartzian transform technique.

      @temp = map { [ $resolution_hash{$key}{"astarts"}[$_],
                      $resolution_hash{$key}{"file"}[$_],
                      $resolution_hash{$key}{"aends"}[$_],
                      $resolution_hash{$key}{"aends"}[$_]]
                  } (0..($no_of_files_in_frame-1));

      @temp = sort { $a[0] <=> $b[0] } @temp;

      @{ $resolution_hash{$key}{file}    } = map{ $_->[1] } @temp;
      @{ $resolution_hash{$key}{astarts} } = map{ $_->[0] } @temp;
      @{ $resolution_hash{$key}{aends}    } = map{ $_->[2] } @temp;
      @{ $resolution_hash{$key}{resolution} } = map{ $_->[3] } @temp;

      orac_print "Resolution $key has ". ($#{$resolution_hash{$key}{astarts}}+1) ." files, with the following overlaps...\n";

      ###################
      # Now calculate the overlaps
      # NB. Strictly this isn't necessary, but it is useful for debugging
      for ($i=0;$i<=($#{$resolution_hash{$key}{astarts}} - 1);$i++) {
        if( $resolution_hash{$key}{aends}[$i+1] >= $resolution_hash{$key}{aends}[$i]) {
          $overlap[$i]=$resolution_hash{$key}{aends}[$i]-$resolution_hash{$key}{astarts}[$i+1];
        } elsif ( $resolution_hash{$key}{aends}[$i+1] < $resolution_hash{$key}{aends}[$i]) {
          $overlap[$i]=$resolution_hash{$key}{aends}[$i+1]-$resolution_hash{$key}{astarts}[$i+1];
        }
        orac_print "Overlap ".$i." is ", $overlap[$i]," Hz";
        # if the gap is +ve
      }

      # Now calculate the sparseness
      # by summing the gaps the output z direction of 
      # the final mosaiced cube i.e. the regions which will not contain data.
      my $depth=0.0;
      my $filled=0.0;
      my $gap_accumulator=0.0;

      for ( $i = 0; $i <= ($#{$resolution_hash{$key}{astarts}}-1); $i++ ) {
        # IF end of this line segment streches deeper along the range
        # i.e. it is the new maximum
        if( $resolution_hash{$key}{aends}[$i] >= $depth ) {
          #Set the new depth to the end of this line segment 
          $depth=$resolution_hash{$key}{aends}[$i];

          # If the start of the next ($i+1)th line segment is greater than depth
          # We have a genuine "gap"
          if(( $resolution_hash{$key}{astarts}[$i+1] - $depth ) > 0.0 ) {
            # Keep a tally of the gaps in the $gap_accumulator
            $gap_accumulator +=  $resolution_hash{$key}{astarts}[$i+1] - $depth;
          }
        }

        #print out debugging info
        orac_print $resolution_hash{$key}{astarts}[$i]." -- ".$resolution_hash{$key}{aends}[$i]."\n" ;
        orac_print "i=$i depth=$depth gap=".($resolution_hash{$key}{astarts}[$i+1] - $depth)." gap accumulator  $gap_accumulator \n";
      }

      orac_print "Last values (i=".$i.") ". $resolution_hash{$key}{astarts}[$i]." -- ".$resolution_hash{$key}{aends}[$i]."\n" ;

      orac_print "---------------\n";
      my $total_freq_range= $resolution_hash{$key}{aends}[$#{$resolution_hash{$key}{aends}}] - $resolution_hash{$key}{astarts}[0];
      my $total_gap=$gap_accumulator;
      my $frac_sparseness =   $total_gap/$total_freq_range;

      orac_print "Total range = ".$total_freq_range." Total gap= ".$total_gap."\n";
      orac_print "Total fractional sparseness = ".$frac_sparseness."\n";

     if ($frac_sparseness>$allowable_sparseness) {
       $do_mosaic_flag = 0;
     } else {
       $do_mosaic_flag = 1;
     }

      ##################################
      # Now we:
      # Finalise the list of files to be mosaiced.
      # Print a summary of the files to the user.
      # Perform alignment and mosaic.

      if( $do_mosaic_flag ) {
          orac_print "Preparing to mosaic...\n";

          for ($i = 0; $i <= ($#{$resolution_hash{$key}{astarts}}); $i++ ) {

          ###################
          # Prepare the input and output file lists for alignment
          # Create a list of input and output images.
          $inputlist = "inlist.list$$";
          $outputlist = "outlist.list$$";
          unlink( $inputlist, $outputlist );
          open($fh_inlist, ">$inputlist" ) ||
            orac_throw "Unable to open $inputlist to create a list of spectra to mosaic. Error: $!\n";
          open($fh_outlist, ">$outputlist" ) ||
            orac_throw "Unable to open $outputlist to create a list of spectra to align. Error: $!\n"; 

          ###################
          # Populate the input and output file lists from the filelist hash
          #
          $infile=$resolution_hash{$key}{file}[$i];
          orac_print "File is $infile\n";
          $_ = $key;
          orac_print "key is $_\n";
          (my $key_no_dot = $key) =~ s(\.)(d);
          orac_print "key is $key_no_dot\n";
          $outfile=$infile."_".$key_no_dot."_align";
          print $fh_inlist $infile, "\n";
          print $fh_outlist $outfile, "\n";
        }

        ###################
        # Do the WCSALIGN
        orac_print "Aligning...\n";
        orac_print "in $inputlist out $outputlist\n";
        my $param1 = "in='^$inputlist' out='^$outputlist' lbnd=! ubnd=! ref=! accept";
        $Mon{'kappa_mon'}->obeyw( "wcsalign", "$param1" );

        # Close the file lists
        close( $fh_inlist );
        close( $fh_outlist );
        unlink( $inputlist);
        orac_print "...done\n";

        ###################
        # Now Mosaic the aligned files
        orac_print "Mosaicking...\n";
        $outfile=$Grp->file;

        # Arguments
        my $args = "in=^$outputlist noscale nozero method=mean title='Full ACSIS cube'";
        orac_print "...done\n";

        # Run CCDPACK makemos
        $Mon{ccdpack_reg}->obeyw("makemos","$args out=$outfile");
        unlink( $outputlist);

      } else {

        # End of if ($do_mosiac_flag)
        orac_print "Cube sparseness is greater than a factor ".$allowable_sparseness.". No mosaic will required.";   
      }
    }# END OF foreach $key

  } else {
    orac_print "GROUP MOSIAC - Only 1 frame in group => No mosaic required \n"; 
  }
} #End of if lastmember
