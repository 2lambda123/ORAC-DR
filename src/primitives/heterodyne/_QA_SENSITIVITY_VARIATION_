# -*-perl-*-

=head1 NAME

_QA_SENSITIVITY_VARIATION_

=head1 AUTHORS

Brad Cavanagh <b.cavanagh@jach.hawaii.edu>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council. All
Rights Reserved.

=cut

use JCMT::ACSIS::Array;

my @masked_files;
my %rms;
my %receptor_rms;
my $key =  $Frm->uhdr( "ORAC_OBSERVATION_NUMBER" ) . $Frm->hdr( $Frm->uhdr( "ORAC_SUBSYSTEM_IDKEY" ) );

my $array_rms = 0;

foreach my $i ( 1 .. $Frm->nfiles ) {

  my ( $infile, $outfile ) = $Frm->inout( "_msk", $i );

  orac_print "Calculating RMS values for $infile.\n";

  my $temp1 = new ORAC::TempFile;
  my $temp2 = new ORAC::TempFile;
  my $temp3 = new ORAC::TempFile;

  # Retrieve the JCMT pointing catalogue and look up the current
  # object. If it is defined, then we use the line velocity and width
  # to mask out the line, then use the remaining (hopefully line-free)
  # regions to determine the RMS. If the object isn't defined, then
  # we'll mask out the central 25% and hope that takes out the line.
  use Astro::Catalog;
  my $object = $Frm->uhdr( "ORAC_OBJECT" );
  my $poicat = $Cal->find_file( "poi.dat" );
  my $jcmtcat = new Astro::Catalog( Format => 'JCMT',
                                    File => $poicat );
  my ( $result ) = $jcmtcat->popstarbyid( $object );
  if( defined( $result ) &&
      defined( $result->misc ) &&
      defined( $result->misc->{'velocity_range'} ) ) {

    my $range = $result->misc->{'velocity_range'};
    my $centre = $result->coords->rv;

    my $params = "in=$infile out=$outfile section='$centre~$range,,' newval=bad";
    $Mon{'kappa_mon'}->obeyw( "chpix", "$params" );

  } else {

    # Fit a background to the spectrum.
    my $params = "in=$infile out=$temp1 mask=$temp2 order=3 subtract=true";
    $params .= " modifyin=false rmsclip=! axis=spec auto=true method=single";
    $Mon{'kappa_mon'}->obeyw( "mfittrend", "$params" );

    # Mask out the baselined file.
    $Mon{'kappa_mon'}->obeyw( "add", "in1=$temp1 in2=$temp2 out=$outfile" );

  }

  # Find dimensions.
  _GET_DIMENSIONS_
  my @lbnd = @{$_GET_DIMENSIONS_{LBOUND}};
  my @ubnd = @{$_GET_DIMENSIONS_{UBOUND}};

  # Find the extent along the first axis (which for CALs is the
  # frequency axis)
  my $extent = $ubnd[0] - $lbnd[0];

  # Only use the central 85%. This avoids noisy ends.
  $extent = int( $extent * 0.85 );

  # Get stats for this extent across all detectors.
  $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$outfile(~$extent,,)" );
  my ( $ORAC_STATUS, $rmsmean ) = $Mon{'kappa_mon'}->get( "stats", "sigma" );

  $array_rms += $rmsmean;

  # Get stats for each receptor.
  my $array = new JCMT::ACSIS::Array( File => $infile );

  foreach my $receptor ( sort $array->receptors ) {

    my $pixel = $array->pixel( $receptor );
    $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$outfile(~$extent,$pixel,)" );
    ( $ORAC_STATUS, my $pixrms ) = $Mon{'kappa_mon'}->get( "stats", "sigma" );

    if( $pixrms > 0 ) {
      $receptor_rms{$receptor} += $pixrms;
    } else {
      $receptor_rms{$receptor} = "bad";
    }

  }

  # Store the name of the masked file. We can't update the frame
  # object because we want to continue on doing stats on the original
  # file.
  $masked_files[$i] = $outfile;

}

$array_rms /= $Frm->nfiles;
foreach my $receptor ( keys %receptor_rms ) {
  if( $receptor_rms{$receptor} ne 'bad' ) {
    $receptor_rms{$receptor} /= $Frm->nfiles;
  }
}

orac_say sprintf( " RMS for entire array:   %7.2f K", $array_rms );

_PRETTYPRINT_RECEPTOR_QA_ HASH=\%receptor_rms TYPE=RMS

$rms{$key} = \%receptor_rms;

# Store the hash of RMS hashes.
$Frm->uhdr( "QA_RMS_VALUES", \%rms );

# Store the array of masked files.
$Frm->uhdr( "QA_MASKED_FILES", \@masked_files );

# Tidy-up output.
orac_print "\n";
