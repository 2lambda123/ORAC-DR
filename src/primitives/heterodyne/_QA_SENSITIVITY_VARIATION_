# -*-perl-*-

=head1 NAME

_QA_SENSITIVITY_VARIATION_

=head1 AUTHORS

Brad Cavanagh <b.cavanagh@jach.hawaii.edu>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council. All
Rights Reserved.

=cut

use JCMT::ACSIS::Array;

my @masked_files;

foreach my $i ( 1 .. $Frm->nfiles ) {

  my ( $infile, $outfile ) = $Frm->inout( "_msk", $i );

  orac_print "Calculating RMS values for $infile.\n";

  my $temp1 = new ORAC::TempFile;
  my $temp2 = new ORAC::TempFile;
  my $temp3 = new ORAC::TempFile;

  # Retrieve the JCMT pointing catalogue and look up the current
  # object. If it is defined, then we use the line velocity and width
  # to mask out the line, then use the remaining (hopefully line-free)
  # regions to determine the RMS. If the object isn't defined, then
  # we'll mask out the central 25% and hope that takes out the line.
  use Astro::Catalog;
  my $object = $Frm->uhdr( "ORAC_OBJECT" );
  my $poicat = $Cal->find_file( "poi.dat" );
  my $jcmtcat = new Astro::Catalog( Format => 'JCMT',
                                    File => $poicat );
  my ( $result ) = $jcmtcat->popstarbyid( $object );
  if( defined( $result ) &&
      defined( $result->misc ) &&
      defined( $result->misc->{'velocity_range'} ) ) {

    my $range = $result->misc->{'velocity_range'};
    my $centre = $result->coords->rv;

    my $params = "in=$infile out=$outfile section='$centre~$range,,' newval=bad";
    $Mon{'kappa_mon'}->obeyw( "chpix", "$params" );

  } else {

    # Fit a background to the spectrum.
    my $params = "in=$infile out=$temp1 mask=$temp2 order=5 subtract=true";
    $params .= " modifyin=false rmsclip=! axis=spec auto=true method=single";
    $Mon{'kappa_mon'}->obeyw( "mfittrend", "$params" );

    # Mask out the baselined file.
    $Mon{'kappa_mon'}->obeyw( "add", "in1=$temp1 in2=$temp2 out=$outfile" );

  }

  # Find dimensions.
  _GET_DIMENSIONS_
  my @lbnd = @{$_GET_DIMENSIONS_{LBOUND}};
  my @ubnd = @{$_GET_DIMENSIONS_{UBOUND}};

  # Find the extent along the first axis (which for CALs is the
  # frequency axis)
  my $extent = $ubnd[0] - $lbnd[0];

  # Only use the central 85%. This avoids noisy ends.
  $extent = int( $extent * 0.85 );

  # Get stats for this extent across all detectors.
  $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$outfile(~$extent,,)" );
  my ( $ORAC_STATUS, $rmsmean ) = $Mon{'kappa_mon'}->get( "stats", "sigma" );

  orac_print sprintf( " Average RMS across all receptors: %6.3f\n", $rmsmean );

  # Get stats for each receptor.
  my $array = new JCMT::ACSIS::Array( File => $infile );

  my %rms;
  my $dstring = '';
  my $rstring = '';
  my @dstrings;
  my @rstrings;

  foreach my $receptor ( sort $array->receptors ) {

    my $pixel = $array->pixel( $receptor );
    $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$outfile(~$extent,$pixel,)" );
    ( $ORAC_STATUS, my $pixrms ) = $Mon{'kappa_mon'}->get( "stats", "sigma" );

    if( $pixrms > 0 ) {
      $rstring .= sprintf( " %6.3f", $pixrms );
      $rms{$receptor} = $pixrms;
    } else {
      $rstring .= "    bad";
      $rms{$receptor} = "bad";
    }

    $dstring .= "    $receptor";

    if( length( $dstring ) > 72 ) {
      push @dstrings, $dstring;
      push @rstrings, $rstring;
      $dstring = '';
      $rstring = '';
    }

  }

  push @dstrings, $dstring;
  push @rstrings, $rstring;

  orac_print " RMS values for each receptor:\n";
  foreach my $i ( 0 .. $#dstrings ) {
    orac_print "$dstrings[$i]\n$rstrings[$i]\n";
  }

  # Store the information on receptors in the uhdr.
  $Frm->uhdr( "QA_RMS_VALUES", \%rms );

  # Store the name of the masked file. We can't update the frame
  # object because we want to continue on doing stats on the original
  # file.
  $masked_files[$i] = $outfile;

}

# Store the array of masked files.
$Frm->uhdr( "QA_MASKED_FILES", \@masked_files );

# Tidy-up output.
orac_print "\n";
