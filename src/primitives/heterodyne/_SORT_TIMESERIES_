# -*-perl-*-

=head1 NAME

_SORT_TIMESERIES_ - Sort timeseries data in time order.

=head1 DESCRIPTION

This primitive takes a set of timeseries cubes and sorts the time
slices into increasing time order. This has the chief advantage of
ensuring that the data has a defined transformation from WCS
coordinates to pixel coordinates. A beneficial side-effect is that the
size of the data files is reduced by purging bad detectors.

=head1 ARGUMENTS

=over 4

=item MASK = LOGICAL (Given)

Whether or not to mask bad detectors. [1]

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS timeseries data.

=back

=head1 OUTPUT DATA

=over 4

=item *

The time-sorted timeseries data with _ts suffix.

=back

=head1 TASKS

SMURF: TIMESORT.

=head1 REQUIRED PERL MODULES

None.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

# Retrieve parameters.
my $mask = ( defined( $_PRIM_ARGS_->{MASK} ) ?
             $_PRIM_ARGS_->{MASK}            :
             1 );

orac_print "\nSorting time-series data in time order...\n";

# Form two files, one holding input filenames and one holding output
# filenames.
my $infile = new ORAC::TempFile;
my $infilename = $infile->file;
my $outfile = new ORAC::TempFile;
my $outfilename = $outfile->file;

foreach my $i ( 1 .. $Frm->nfiles ) {

  my ( $in, $out ) = $Frm->inout( "_ts", $i );

  print {$infile->handle} "$in\n";
  print {$outfile->handle} "$out\n";
}

# Set up parameters for TIMESORT.
my $params = "in='^$infilename' out='^$outfilename' outfiles=tsout$$.lis";
$params .= " sizelimit=! merge=true detpurge=true";

# Retrieve a list of detectors to not use, but only if we've been
# asked to mask bad detectors.
my $baddets;
if( $mask ) {
  $baddets = eval { $Cal->bad_detectors };
  if( defined( $baddets ) ) {
    $params .= " detectors='-$baddets'";
  }
}

# Run TIMESORT.
$Mon{'smurf_mon'}->obeyw( "timesort", "$params" );

# Find out how many output files there were.
my( $ORAC_STATUS, $nout ) = $Mon{'smurf_mon'}->get( "timesort", "nout" );

open my $out_fh, "<", "tsout$$.lis" or die "Could not find TIMESORT output file list tsout$$.lis: $!\n";
my @tsout_files = <$out_fh>;
close $out_fh;

# Update the Frm object.
foreach my $i ( 1 .. $nout ) {

  my ( $in, $out ) = $Frm->inout( "_ts", $i );

  $out =~ s/_\d{4}_/_/;

  # We need to rename the output files, as TIMESORT creates _N, and
  # we've already told it to create files with the correct suffix
  # (_tsNNN), so just remove the _N.
  my $timesort_output = $tsout_files[$i-1];
  chomp $timesort_output;
  $timesort_output .= ".sdf";
  my $outfile = "$out.sdf";
  rename( $timesort_output, $outfile );
  $outfile =~ s/\.sdf$//;

  $Frm->file( $i, $outfile );

  orac_print "$in to $out:\n Sorted time slices in increasing time.\n";

  if( defined( $baddets ) ) {
    orac_print " Masked detectors $baddets.\n";
  }
}

unlink "tsout$$.lis";

# Tidy-up output.
orac_print "\n";
