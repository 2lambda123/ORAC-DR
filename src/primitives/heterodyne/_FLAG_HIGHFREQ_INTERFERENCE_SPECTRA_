use JCMT::ACSIS::Array;

# Handle arguments.
# =================

my $edge_clip = get_prim_arg( $_PRIM_ARGS_, "EDGE_CLIP", "2.0,2.0,2.5,3.0" );
my $thresh_clip = get_prim_arg( $_PRIM_ARGS_, "THRESH_CLIP", "4.0" );

# Handle recipe parameter overrides.
$edge_clip = ( defined( $Frm->uhdr( "RECPAR_EDGE_CLIP" ) ) ?
             $Frm->uhdr( "RECPAR_EDGE_CLIP" )              :
             $edge_clip );
$thresh_clip = ( defined( $Frm->uhdr( "RECPAR_THRESH_CLIP" ) ) ?
             $Frm->uhdr( "RECPAR_THRESH_CLIP" )            :
             $thresh_clip );

# Convert list of standard-deviation clip levels to an array.
my @clips = split( ',', $edge_clip );

# Constrain parameters to allowed values.
# ---------------------------------------

# Sigma clipping levels should not decrease. Do not set the initial
# threshold too low lest we exclude acceptable but slightly deviant
# spectra in an otherwise good set.
my @clip_sigma = ();
my $last = 2.0;
foreach ( @clips ) {
   push @clip_sigma, max( $last, $_ );
}

$edge_clip = "[" . join( ",", @clip_sigma ) . "]";

# Specify output and temporary filenames.
# =======================================
my $params;
my $osuffix = "_nimasked";

foreach my $i ( 1 .. $Frm->nfiles ) {

# Set/get filenames.
   my ( $in, $out ) = $Frm->inout( $osuffix, $i );
   orac_say( "Determine spectra exhibiting transient noise interference in $in." );

   my $temp1file = new ORAC::TempFile( 0 );
   my $temp2file = new ORAC::TempFile( 0 );
   my $temp3file = new ORAC::TempFile( 0 );
   my $temp4file = new ORAC::TempFile( 0 );
   my $temp5file = new ORAC::TempFile( 0 );
   my $temp6file = new ORAC::TempFile( 0 );
   my $temp7file = new ORAC::TempFile( 0 );
   my $temp8file = new ORAC::TempFile( 0 );
   my $temp9file = new ORAC::TempFile( 0 );
   my $temp10file = new ORAC::TempFile( 0 );
   my $temp11file = new ORAC::TempFile( 0 );
   my $temp12file = new ORAC::TempFile( 0 );

# We need the dimensions of the input file for later.
   _GET_DIMENSIONS_ FILE=$in
   my $lbnd = $_GET_DIMENSIONS_{LBOUND};
   my $ubnd = $_GET_DIMENSIONS_{UBOUND};
   my $nel = $ubnd->[0] - $lbnd->[0] + 1;

# Form arrays of bad detectors.
# =============================

# Retrieve the list of bad detectors from the calibration system ONLY
# ignoring the ones set locally.  The reading of INDEXORMASTER is
# done to setup the survey (survey_br).
   $Cal->bad_receptors( "MASTER" );
   my @baddets = $Cal->bad_receptors_list;
   orac_say( " Receptors disabled by the calibration system: " . join( ",", sort @baddets ) );

# Still need to invoke the bad_receptors_list method although the
# resulting array is not used.
   $Cal->bad_receptors( "INDEXORMASTER" );
   my @tmpdets = $Cal->bad_receptors_list;
   orac_say( " Receptors indexed by the calibration system: " . join( ",", sort @tmpdets ) );

# Create a mask NDF.
# ==================
#
# As we shall be filling every receptor plane with a mask of any noisy
# spectra, it is adequate to merely copy the input NDF.
    $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$in out=$temp6file" );

# Find the interference.
# ======================

# The data thus appear noisy because of a 5-pixel frequency sinusoid
# in an envelope whose amplitude oscillates with at least one other
# frequency (around 60 pixels).
   my $spec_percent = "~85%";
   if ( defined( $Frm->uhdr( "SPECTRAL_TRIMMED" ) ) &&
        $Frm->uhdr( "SPECTRAL_TRIMMED" ) ) { $spec_percent = "" }

# Get average rms deviations for each receptor not in the bad_receptors list.
# ===========================================================================
   my $array = new JCMT::ACSIS::Array( File => $in );

# Form set of receptors that are not bad in the master list.
   my @receptors = grep{ my $x=$_; not grep { $x =~ /\Q$_/i} @baddets} $array->receptors;
   @receptors = sort @receptors;

   foreach my $receptor ( @receptors ) {
      orac_say( " Receptor $receptor." );
      my $pixel = $array->pixel( $receptor );

# Perform an apprixmate Difference of Gaussian filter along the spectral axis.
#
# Since the interference has lots of zero crossings an edge detector is
# one way to identify this inference signal.  Note as currently coded
# LAPLACE only operates on two-dimensional data and thus includes
# variation along the time series axis into the signal, rejecting more
# spectra than is necessary.
      orac_say( "   Computing squared Laplacian of spectra." );
      $params = "in=$in($spec_percent,$pixel,) out=$temp8file stype=absolute";
      $params .= " method=nearest abs=[-1,0,0]";
      $Mon{'kappa_mon'}->obeyw( "slide", "$params" );

      $params = "in=$in($spec_percent,$pixel,) out=$temp9file stype=absolute";
      $params .= " method=nearest abs=[1,0,0]";
      $Mon{'kappa_mon'}->obeyw( "slide", "$params" );

      $params = "ia=$in($spec_percent,$pixel,) ib=$temp8file ic=$temp9file";
      $params .= " exp=2*IA-IB-IC out=$temp1file";
      $Mon{'kappa_mon'}->obeyw( "maths", "$params" );

# Find the rms `edginess' i.e. a positive measure of the deviation from flatness.
# The normalisation is arbitrary so just approximate with the full spectral
# dimension.
      $params = "ia=$temp1file out=$temp2file exp='sqrt(IA*IA/$nel)'";
      $Mon{'kappa_mon'}->obeyw( "maths", "$params" );

# Collapse the spectral axis using a clipped mean to form average
# edginess for each spectrum for the current detector.
      orac_say( "   Collapsing spectra to form average edge detection per spectrum." );
      $params = "in=$temp2file out=$temp3file$receptor estimator=mean";
      $params .= " axis=spec trim=f wlim=0.0 variance=false";
      $Mon{'kappa_mon'}->obeyw( "collapse", "$params" );

# There may be glitches or drift in the levels.  Correct for these
# before thresholding. FIXSTEPS needs double-precision data.
      orac_say( "   Correcting for glitches or drift in the edginess profile." );
      $Mon{'ndfpack_mon'}->obeyw( "settype", "$temp3file$receptor type=_DOUBLE" );
      $params = "in=$temp3file$receptor out=$temp11file";
      $params .= " meanshift=no dcfitbox=50";
      $Mon{'smurf_mon'}->obeyw( "fixsteps", "$params" );
      my ( $ORAC_STATUS, $rejected ) = $Mon{'smurf_mon'}->get( "fixsteps", "nrejected" );
      orac_warn "Status from FIXSTEPS was $ORAC_STATUS, and number rejected $rejected\n";

# Check that FIXSTEPS has not rejected the receptor.  This seems to
# happen extremely rarely when there are no genuine steps and too few
# points in the profile.  In this case we can pass the original profile
# directly to FINDBACK.
      if ( $rejected > 0 ) {
         $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp3file$receptor out=$temp11file" );
      }

# Reset the data type.
      $Mon{'ndfpack_mon'}->obeyw( "settype", "$temp11file type=_REAL" );

# Need the median signal before continuum removal.
      $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$temp11file order" );
      ( $ORAC_STATUS, my $median ) = $Mon{'kappa_mon'}->get( "stats", "median" );

# Estimate and subtract the 'continuum' level.
      $params = "in=$temp11file out=$temp12file$receptor box=51 sub accept";
      $Mon{'cupid_mon'}->obeyw( "findback", "$params" );

# Estimate the normal level, and standard deviation excluding anomalous spectra.
# This assumes that most of the spectra are good and the drift is not
# significant compared with the noise.
      $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$temp12file$receptor clip=$edge_clip order" );
      ( $ORAC_STATUS, my $sigma ) = $Mon{'kappa_mon'}->get( "stats", "sigma" );
      ( $ORAC_STATUS, my $numgood ) = $Mon{'kappa_mon'}->get( "stats", "numgood" );

# Threshold spectra whose mean rms edginess exceeds an outlier limit.
# The median will give a reliable normal signal on which there are
# spikes or broader mountains caused by the oscillating noise in the
# time series for the detector.  In most cases there is no interference
# noise, so protect against drift and signal variations in the timeseries
# causing the dispersion; these should be small compared with the signal
# being detected.
      if ( $numgood > 0 ) {
         my $threshold = $thresh_clip * $sigma;
         orac_say( "   Turning off spectra with rms edginess above " . sprintf( "%.4f", $threshold ) );
         $params = "in=$temp12file$receptor out=$temp4file thrlo=-1 newlo=bad thrhi=$threshold newhi=bad";
         $Mon{'kappa_mon'}->obeyw( "thresh", "$params" );
         ( $ORAC_STATUS, my $eject ) = $Mon{'kappa_mon'}->get( "thresh", "numhi" );
         ( $ORAC_STATUS, my $kept ) = $Mon{'kappa_mon'}->get( "thresh", "numsame" );
         my $total = $eject + $kept;
         if ( $eject == 1 ) {
            orac_say( "    One spectrum removed out of $total." );
         } elsif ( $eject > 0 ) {
            orac_say("    $eject spectra removed out of $total." );
         }
  
# Expand the thresholded image to the size of the current receptor's
# plane in the initial cube.
         orac_say( "   Expand the masked profile." );
         $params = "in=$temp4file out=$temp5file axes=[0,2,3] lbound=" . $lbnd->[0] . " ubound=" . $ubnd->[0];
         $Mon{'kappa_mon'}->obeyw( "manic", "$params" );

# Paste the data to the mask file.
         orac_say( "   Paste the masked data into the cube mask." );
         my $params = "in=$temp6file p1=$temp5file out=$temp7file confine=false transp=false";
         $Mon{'kappa_mon'}->obeyw( "paste", "$params" );
         $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp7file out=$temp6file" );
      }
   }

# At this point $temp6file should have all the original receptors
# checked for noisy spectra and have bad values for those spectra.
# Copy the bad spectra to the output image.
   orac_say( " Apply the mask of noisy spectra to the input time series to form $out." );
   $params = "in=$in ref=$temp6file out=$out";
   $Mon{'kappa_mon'}->obeyw( "copybad", "$params" );

# Display if necessary.
   $Display->display_data( $Frm ) if defined $Display;

}

# Tidy-up output.
orac_print "\n";
