# -*-perl-*-

=head1 NAME

_CREATE_CUBE_FRAME_ -- Create a cube from a time-series ACSIS
observation and stuff it in the Frm object.

=head1 DESCRIPTION

This primitive takes a time-series ACSIS cube and, using
SMURF/MAKECUBE, transforms it into a spatial/spectral cube.

=head1 ARGUMENTS

=over 4

=item BYTES_PER_PIXEL = INTEGER (Given)

The number of bytes per pixel. [4]

=item DETECTORS = STRING (Given)

A comma-separated list of detectors to use when creating the cube. If
blank or undefined, all detectors will be used. ['']

=item MAXSIZE = INTEGER (Given)

The maximum size, in bytes, of the output cube. This value does not
include extra information such as variance or weight arrays, FITS
headers, or any other NDF extensions. [512000000]

=item PARAMS = STRING (Given)

An optional array which consists of additional parameters required by
the Sinc, SincSinc, SincCos, SincGauss, Somb, SombCos, and Gauss
spreading methods (see parameter SPREAD). See documentation for the
PARAMS parameter for MAKECUBE. ['']

=item SPREAD = STRING (Given)

The interpolation method to use when regridding the cube. This can be
any of those allowed by MAKECUBE, listed in the SPREAD
parameter. ['nearest']

=item SUFFIX = STRING (Given)

Override the default "_cube" suffix with a new value. This is useful
when processing an iterative result where we do not want to improve
the initial product (the whole point being to retain it).

=item PRODUCT = STRING (Given)

Override the default "cube" product designation.

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS.

=back

=head1 OUTPUT DATA

=over 4

=item *

A cube whose filename is of the form aYYYYMMDD_NNNNN_SS_cube.sdf,
where YYYYMMDD is the UT date, NNNN is the zero-padded observation
number, and SS is the zero-padded susbystem number.

=back

=head1 TASKS

SMURF: MAKECUBE.

=head1 REQUIRED PERL MODULES

None.

=head1 AUTHORS

Brad Cavanagh <b.cavanagh@jach.hawaii.edu>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.
Copyright (C) 2006-2007 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

=cut

orac_print "Creating cube.\n";

# Deal with parameters.
my $bytes_per_pixel = get_prim_arg( $_PRIM_ARGS_, "BYTES_PER_PIXEL", 4 );
my $maxsize = get_prim_arg( $_PRIM_ARGS_, "MAXSIZE", 512_000_000 );
my $spread = get_prim_arg( $_PRIM_ARGS_, "SPREAD", 'nearest' );
my $sp_params = get_prim_arg( $_PRIM_ARGS_, "PARAMS", "''" );
my $tileborder = get_prim_arg( $_PRIM_ARGS_, "TILEBORDER", 0 );

my $detectors = ( defined( $_PRIM_ARGS_->{DETECTORS} ) ?
                  "'$_PRIM_ARGS_->{DETECTORS}'"        :
                  "''" );
my $suffix = get_prim_arg( $_PRIM_ARGS_, "SUFFIX", "_cube" );
my $product = get_prim_arg( $_PRIM_ARGS_, "PRODUCT", "cube" );


my @files;

# Create a list of input images.
my $inlist = new ORAC::TempFile( OPEN => 1,
                                 SUFFIX => '.lis' );
my $inlist_fh = $inlist->handle;

my $out = $Frm->inout( $suffix );

foreach my $i ( 1..$Frm->nfiles ) {

  my ( $in, $tmp ) = $Frm->inout( $suffix, $i );

  print $inlist_fh "$in\n";
  push @files, $in;
}

$inlist->handle->close;

# Fix the output filename to remove the subscan number.
$out =~ s/_\d{4}_/_/;

my $params = '';

# Determine the MAKECUBE parameters based on the
# ORAC_OBSERVATION_TYPE header.
my $type = $Frm->uhdr( "ORAC_OBSERVATION_TYPE" );

_GET_MAKECUBE_PARAMS_ TYPE=$type
my $mc_params = $_GET_MAKECUBE_PARAMS_{PARAMS};
my $mc_hash = $_GET_MAKECUBE_PARAMS_{HASH};

my ( $pixsize, $crota );
my $autogrid = $mc_hash->{autogrid};
my $system = $mc_hash->{system};

if( lc( $type ) ne "raster" ) {

  my $inlist2 = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
  my $inlist2_fh = $inlist2->handle;
  foreach my $i ( 1 .. $Frm->nfiles ) {
    print $inlist2_fh $Frm->file( $i ) . "\n";
  }
  $inlist2->handle->close;

  orac_print "Determining parameters for output cube...";
  $Mon{'smurf_mon'}->obeyw( "makecube", "$mc_params in='^" . $inlist2->file . "' out=! spread=$spread params=$sp_params" );
  orac_print "done.\n";

  # Check to see if we have a sparse cube.
  $Frm->uhdr( "SPARSE", 0 );
  my ( $ORAC_STATUS, $sparse ) = $Mon{'smurf_mon'}->get( "makecube", "sparse" );
  if( uc( $sparse ) eq 'TRUE' ) {
    orac_warn "Resulting cube will be sparse.\n";
    $Frm->uhdr( "SPARSE", 1 );
  } else {

    # Get the returned pixsize and crota.
    ( $ORAC_STATUS, $pixsize ) = $Mon{'smurf_mon'}->get( "makecube", "pixsize" );
    ( $ORAC_STATUS, $crota ) = $Mon{'smurf_mon'}->get( "makecube", "crota" );
  }

} else {
  $pixsize = $mc_hash->{pixsize};
  $crota = $mc_hash->{crota};
}

if( ! $Frm->uhdr( "SPARSE" ) ) {
  $params  = "pixsize=$pixsize crota=$crota autogrid=$autogrid";
} else {
  $params = "autogrid=yes";
}
$params .= " system=$system spread=$spread params=$sp_params";

if( defined( $mc_hash->{detectors} ) ) {
  $params .= " detectors=" . $mc_hash->{detectors};
}

if( defined( $mc_hash->{usedetpos} ) ) {
  $params .= " usedetpos=" . $mc_hash->{usedetpos};
}

# Get the tiling dimensions, but only if we're not doing a pointing
# or focus.
if( lc( $type ) ne 'pointing' && lc( $type ) ne 'focus' ) {
  _GET_TILE_DIMENSIONS_ TILEBORDER=$tileborder
  my $tiledims = $_GET_TILE_DIMENSIONS_{TILEDIMS};
  $params .= " tiledims=$tiledims tileborder=$tileborder trimtiles=yes";
}

if ($Frm->uhdr("ISHYBRID")) {
  # As a quick hack until a proper fix is made. Still undecided
  # whether to merge in makecube after baseline normalising or to
  # merge after the cubes are created.  For now merge in makecube so
  # that something happens.  Hybrid mode should use a different
  # badmask.
  $params .= " badmask=AND specunion=YES";
}

# Store the parameters for later use, but only if we don't have a
# sparse cube.
if( ! $Frm->uhdr( "SPARSE" ) ) {
  $Grp->uhdr( "MAKECUBE_PARAMETERS", $params );
}

# Tell user what we're doing.
orac_print( " Creating cube from " . join( ", ", @files ) . "..." );

# Run MAKECUBE.
$Mon{'smurf_mon'}->obeyw( "makecube", "$params in='^" . $inlist->file . "' out=$out" );

orac_print( "done.\n" );

# Retrieve the number of tiles created.
my ( $ORAC_STATUS, $ntile ) = $Mon{'smurf_mon'}->get( "makecube", "ntile" );

if( $ntile > 1 ) {

  # We need to rename the output cubes, as MAKECUBE creates _cube_N
  # and we want _cubeNNN.
  my @files;
  my $numbad = 0;
  foreach my $j ( 1 .. $ntile ) {
    my $makecube_outfile = "${out}_$j.sdf";
    my $outfile = "${out}" . sprintf( "%03d", $j ) . ".sdf";

    if( -e $makecube_outfile ) {

      # Run STATS to find out if this tile is blank or not.
      $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$makecube_outfile" );
      ( $ORAC_STATUS, my $numgood ) = $Mon{'kappa_mon'}->get( "stats", "numgood" );
      if( $numgood == 0 ) {
        $numbad++;
        next;
      }

      rename( $makecube_outfile, $outfile );
      $outfile =~ s/\.sdf$//;
      push( @files, $outfile );
    }
  }

  $ntile -= $numbad;
  orac_print " $ntile cubes formed: ";

  $Frm->files( @files );
  my $filestring = join ", ", @files;
  orac_print( "$filestring\n" );

} else {

  # We want the output file to be named _cube001.
  my $makecube_outfile = "${out}.sdf";
  my $outfile = "${out}001.sdf";
  rename( $makecube_outfile, $outfile );
  $outfile =~ s/\.sdf$//;
  $Frm->files( $outfile );
  orac_print " 1 cube formed: $outfile\n";
}

# Set the product.
$Frm->product( $product );
$Frm->sync_headers;

# Retrieve and set the Group REFLAT/REFLON if they're not already set.
if( ! defined( $Grp->uhdr( "REFLAT" ) ) ) {
  my $ndf = $Frm->file( 1 );

  # Read the frameset from this file
  my $wcs = $Frm->read_wcs( $ndf );

  # Determine which axis is latitude and which is longitude. Subtract
  # 1 from these to turn them into Perl array indices.
  my $lataxis = $wcs->Get("LatAxis");
  my $lonaxis = $wcs->Get("LonAxis");
  my $plataxis = $lataxis - 1;
  my $plonaxis = $lonaxis - 1;

  # set the format to 'dms.4' for the latitude axis and 'dms.4' for the longitude
  # axis to get some decent precision.
  my $latformat = "dms.4";
  my $lonformat = "hms.4";
  $wcs->Set("Format($lataxis)=$latformat,Format($lonaxis)=$lonformat'");

  # Retrieve the SkyRef position and store it in the Grp uhdr. This is
  # of the form 'dd:mm:ss.ssss, dd:mm:ss.ssss', so split on commas.
  my $skyref = $wcs->Get("SkyRef");
  my @skyref = split /, /, $skyref;
  my $reflat = $skyref[$plataxis];
  $reflat =~ s/ /:/g;
  my $reflon = $skyref[$plonaxis];
  $reflon =~ s/ /:/g;
  $Grp->uhdr( "REFLAT", $reflat );
  $Grp->uhdr( "REFLON", $reflon );

}

# Set a tag on this one so we can retrieve it later if necessary.
_SET_TAG_ TAG=POST_CREATE_CUBE_FRAME

# Display.
$Display->display_data( $Frm ) if defined $Display;

# Tidy-up output.
orac_print "\n";

