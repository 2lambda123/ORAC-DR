# -*-perl-*-

=head1 NAME

_CREATE_CUBE_FRAME_ -- Create a cube from a time-series ACSIS
observation and stuff it in the Frm object.

=head1 DESCRIPTION

This primitive takes a time-series ACSIS cube and, using
SMURF/MAKECUBE, transforms it into a spatial/spectral cube.

=head1 ARGUMENTS

=over 4

=item BYTES_PER_PIXEL = INTEGER (Given)

The number of bytes per pixel. [4]

=item DETECTORS = STRING (Given)

A comma-separated list of detectors to use when creating the cube. If
blank or undefined, all detectors will be used. ['']

=item MAXSIZE = INTEGER (Given)

The maximum size, in bytes, of the output cube. This value does not
include extra information such as variance or weight arrays, FITS
headers, or any other NDF extensions. [512000000]

=item PARAMS = STRING (Given)

An optional array which consists of additional parameters required by
the Sinc, SincSinc, SincCos, SincGauss, Somb, SombCos, and Gauss
spreading methods (see parameter SPREAD). See documentation for the
PARAMS parameter for MAKECUBE. ['']

=item SPREAD = STRING (Given)

The interpolation method to use when regridding the cube. This can be
any of those allowed by MAKECUBE, listed in the SPREAD
parameter. ['nearest']

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS.

=back

=head1 OUTPUT DATA

=over 4

=item *

A cube whose filename is of the form aYYYYMMDD_NNNNN_SS_cube.sdf,
where YYYYMMDD is the UT date, NNNN is the zero-padded observation
number, and SS is the zero-padded susbystem number.

=back

=head1 TASKS

SMURF: MAKECUBE.

=head1 REQUIRED PERL MODULES

None.

=head1 AUTHORS

Brad Cavanagh <b.cavanagh@jach.hawaii.edu>

=head1 COPYRIGHT

Copyright (C) 2006 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut

orac_print "Creating cube.\n";

# Deal with parameters.
my $maxsize = ( defined( $_CREATE_CUBE_FRAME_{MAXSIZE} ) ?
                $_CREATE_CUBE_FRAME_{MAXSIZE}            :
                512000000 );

my $bytes_per_pixel = ( defined( $_CREATE_CUBE_FRAME_{BYTES_PER_PIXEL} ) ?
                        $_CREATE_CUBE_FRAME_{BYTES_PER_PIXEL}            :
                        4 );

my $spread = ( defined( $_CREATE_CUBE_FRAME_{SPREAD} ) ?
               $_CREATE_CUBE_FRAME_{SPREAD}            :
               'nearest' );
my $makecube_params = ( defined( $_CREATE_CUBE_FRAME_{PARAMS} ) ?
                        $_CREATE_CUBE_FRAME_{PARAMS}            :
                        '' );
my $detectors = ( defined( $_CREATE_CUBE_FRAME_{DETECTORS} ) ?
                  "'$_CREATE_CUBE_FRAME_{DETECTORS}'"        :
                  "''" );

my @files;

# Create a list of input images.
my $inlist = new ORAC::TempFile( OPEN => 1,
                                 SUFFIX => '.lis' );
my $inlist_fh = $inlist->handle;

my $out = $Frm->inout( "_cube" );

foreach my $i ( 1..$Frm->nfiles ) {

  my ( $in, $tmp ) = $Frm->inout( "_cube", $i );

  print $inlist_fh "$in\n";
  push @files, $in;
}

$inlist->handle->close;

# Fix the output filename to remove the subscan number.
$out =~ s/_\d{4}_/_/;

my $params = '';

# Check to see if we've already run MAKECUBE once for this group. If
# we have, don't bother the first MAKECUBE runthrough, just use the
# previously-determined parameters.
if( defined( $Grp->uhdr( "MAKECUBE_PARAMETERS" ) ) ) {

  $params = $Grp->uhdr( "MAKECUBE_PARAMETERS" );

  if( defined( $Grp->uhdr( "REFLAT" ) ) && defined( $Grp->uhdr( "REFLON" ) ) ) {
    $params .= " reflat='" . $Grp->uhdr( "REFLAT" ) . "'";
    $params .= " reflon='" . $Grp->uhdr( "REFLON" ) . "'";
  }

} else {

  # First we need to run MAKECUBE without output to find out what the
  # size of the output cube will be.
  $params = "autogrid spread=$spread";

  if( uc( $spread ) ne 'NEAREST' ) {
    $params .= " params=$makecube_params";
  }

  # If we have either a HARP4 or a HARP5 jiggle, we need to hardwire
  # the spread to SINCSINC and the params to [2,2].
  my $jiggle_name = "";
  if( defined( $Frm->hdr( "JIGL_NAM" ) ) ) {
    $jiggle_name = $Frm->hdr( "JIGL_NAM" );
    if( $jiggle_name =~ /harp([45])/i ) {
      $spread = "SINCSINC";
      $makecube_params = "[2,2]";
    }
  }

  # If we have either a HARP4 or a HARP5 jiggle, we need to set the
  # pixel scale to 7.5 or 6 arcseconds, respectively.
  if( $jiggle_name =~ /harp([45])/i ) {
    my $pixsize = ( $1 == 4 ? 7.5 : 6 );
    $params .= " pixsize=$pixsize";
  }

  # If we have a raster (SAM_MODE header), then we need to set the pixel
  # scale manually.
  my $raster = ($Frm->hdr("SAM_MODE") =~ /raster/i);
  if ($raster) {
    my $pixsize = $Frm->hdr( "SCAN_VEL" ) * $Frm->hdr( "STEPTIME" );
    $params .= " pixsize=$pixsize";
    my $crota = 90 - $Frm->hdr( "MAP_PA" );

    # Ensure that CROTA lies between -45 and 45.
    while ( $crota < -45 || $crota > 45 ) {
      if( $crota < -45 ) {
        $crota += 90;
      } elsif( $crota > 45 ) {
        $crota -= 90;
      }
    }
    $params .= " crota=$crota";
    if( $Frm->hdr( "LOCL_CRD" ) eq 'AZEL' ) {
      $params .= " system=azel";
    }
  }

  # If we're doing a pointing and the INSTAP header is defined, pass
  # that to MAKECUBE using the DETECTORS parameter.
  my $pointing = ( uc( $Frm->hdr( "OBS_TYPE" ) ) eq 'POINTING' );
  my $instap = ( defined( $Frm->hdr( "INSTAP" ) ) ?
                 $Frm->hdr( "INSTAP" ) :
                 '' );
  if( $pointing && $instap ne '' ) {
    $params .= " detectors=$instap";
  } elsif( $detectors ne "''" ) {
    $params .= " detectors=$detectors";
  }
  if( $pointing ) {
    $params .= " system=azel";
  }

  orac_print " Determining size of output cube...";

  $Mon{'smurf_mon'}->obeyw( "makecube", "$params in='^" . $inlist->file . "' out=!" );

  # Check to see if we would have a sparse cube. If so, we don't have
  # to go through this song and dance.
  my ( $ORAC_STATUS, $sparse ) = $Mon{'smurf_mon'}->get( "makecube", "sparse" );
  $Frm->uhdr( "SPARSE_CUBE", ( uc( $sparse ) eq 'TRUE' ) );

  # Get output bounds, but only if we don't have a sparse cube.
  if( ! $Frm->uhdr( "SPARSE_CUBE" ) ) {

    ( $ORAC_STATUS, my @lbnd ) = $Mon{'smurf_mon'}->get( "makecube", "lbound" );
    ( $ORAC_STATUS, my @ubnd ) = $Mon{'smurf_mon'}->get( "makecube", "ubound" );
    ( $ORAC_STATUS, my @flbnd ) = $Mon{'smurf_mon'}->get( "makecube", "flbnd" );
    ( $ORAC_STATUS, my @fubnd ) = $Mon{'smurf_mon'}->get( "makecube", "fubnd" );

    # And grid parameters to speed up next call
    ($ORAC_STATUS, my @pixsize ) = $Mon{'smurf_mon'}->get( "makecube", 'pixsize' );
    ($ORAC_STATUS, my $crota )   = $Mon{'smurf_mon'}->get( "makecube", 'crota' );

    orac_print "done.\n";

    my $x_length = abs( $ubnd[0] - $lbnd[0] + 1 );
    my $y_length = abs( $ubnd[1] - $lbnd[1] + 1 );
    my $f_length = abs( $ubnd[2] - $lbnd[2] + 1 );
    my $f_range = abs( $fubnd[2] - $flbnd[2] );

    my $total_pixels = $x_length * $y_length * $f_length;
    my $total_bytes = $total_pixels * $bytes_per_pixel;
    orac_print " Total size of output cube: $total_pixels pixels ($total_bytes bytes)\n";
    orac_print " This computer can handle $maxsize bytes.\n";

    if( $maxsize < $total_bytes ) {

      # We want square tiles. Find out how big the tiles would be if
      # they were rectangular, then convert that spatial pixel area
      # into a square.
      my $x_out; # Length of the x-axis for each tile.
      my $y_out; # Length of the y-axis for each tile.
      my $ntiles = int( $total_bytes / $maxsize ) + 1;
      if( $x_length > $y_length ) {
        $x_out = int ( $x_length / $ntiles ) + 1;
        $y_out = $y_length;
      } else {
        $x_out = $x_length;
        $y_out = int( $y_length / $ntiles ) + 1;
      }
      my $tiledim = int( sqrt( $x_out * $y_out ) );

      $params = "tiledims=$tiledim";
      orac_print " Output cubes will have dimensions [$tiledim,$tiledim,$f_length]\n";

      $Frm->uhdr( "SPECTRAL_TRIMMED", 0 );
      $Frm->uhdr( "TILED_CUBE", 1 );

    } else {

      $Frm->uhdr( "SPECTRAL_TRIMMED", 0 );
      $Frm->uhdr( "TILED_CUBE", 0 );

      $Grp->uhdr( "TILEDIMS", "!" );

      $params = "tiledims=!";
    }

    # Make sure CROTA is between -45 and 45.
    while ( $crota < -45 || $crota > 45 ) {
      if( $crota < -45 ) {
        $crota += 90;
      } elsif( $crota > 45 ) {
        $crota -= 90;
      }
    }

    # Set up the parameters to MAKECUBE. (use hints from previous
    # call) Autogrid is required because without it the pixel grid is
    # not positioned in an optimal way. (and the fractional pixel
    # shift is not stored in an output parameter at present).
    $params .= " crota=$crota spread=$spread";

    if (@pixsize > 1) {
      $params .= " pixsize=[".join(",",@pixsize) ."] ";
    } else {
      $params .= " pixsize=$pixsize[0] ";
    }

    # If the data units are Kelvin, then we can generate a variance
    # from TSYS. Otherwise, we can generate a variance from the spread
    # of the input data values contributing to each output pixel.
    $Mon{'ndfpack_mon'}->obeyw( "ndftrace", "ndf=$files[0] fullframe" );
    ( $ORAC_STATUS, my $units ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "units" );
    if( $units eq 'K' ) {
      $params .= " genvar=tsys inweight=true";
    } else {
      $params .= " genvar=spread inweight=false";
    }

  } else {

    # We have a sparse cube, so set up the parameters differently.
    $params = "autogrid spread=$spread";

    # Send a warning.
    orac_warn "Sparse cube will be created in $out.\n";

  }

  if( $pointing && $instap ne '' ) {
    $params .= " detectors=$instap";
  } elsif( $detectors ne "''" ) {
    $params .= " detectors=$detectors";
  }

  if( $pointing ) {
    $params .= " system=azel";
  }

  if( uc( $spread ) ne 'NEAREST' ) {
    $params .= " params=$makecube_params";
  }

  # If it's a raster and the LOCL_CRD header is AZEL, set the system
  # to azel.
  if( $raster && $Frm->hdr( "LOCL_CRD" ) eq 'AZEL' ) {
    $params .= " system=azel";
  }

  if ($Frm->uhdr("ISHYBRID")) {
  # As a quick hack until a proper fix is made. Still undecided whether to merge in
  # makecube after baseline normalising or to merge after the cubes are created.
  # For now merge in makecube so that something happens.
  # Hybrid mode should use a different badmask.
      $params .= " badmask=AND specunion=YES";
  }

  # Tell user what we're doing.
  orac_print( " Creating cube from " . join( ", ", @files ) . "..." );

  # Store the parameters for later use.
  $Grp->uhdr( "MAKECUBE_PARAMETERS", $params );

}

# Run MAKECUBE.
$Mon{'smurf_mon'}->obeyw( "makecube", "$params in='^" . $inlist->file . "' out=$out" );

orac_print( "done.\n" );

# Set the product.
$Frm->product( "cube" );

# Retrieve the number of tiles created.
my ( $ORAC_STATUS, $ntile ) = $Mon{'smurf_mon'}->get( "makecube", "ntile" );

if( $ntile > 1 ) {

  # We need to rename the output cubes, as MAKECUBE creates _cube_N
  # and we want _cubeNNN.
  my @files;
  foreach my $j ( 1 .. $ntile ) {
    my $makecube_outfile = "${out}_$j.sdf";
    my $outfile = "${out}" . sprintf( "%03d", $j ) . ".sdf";
    rename( $makecube_outfile, $outfile );
    $outfile =~ s/\.sdf$//;
    push( @files, $outfile );
  }

  orac_print " $ntile cubes formed: ";


  $Frm->files( @files );
  my $filestring = join ", ", @files;
  orac_print( "$filestring\n" );
} else {

  # We want the output file to be named _cube001.
  my $makecube_outfile = "${out}.sdf";
  my $outfile = "${out}001.sdf";
  rename( $makecube_outfile, $outfile );
  $Frm->files( $outfile );
  orac_print( "Cube formed in $outfile.\n" );
}

# Retrieve and set the Group REFLAT/REFLON if they're not already set.
if( ! defined( $Grp->uhdr( "REFLAT" ) ) ) {
  my $ndf = $Frm->file( 1 );

  # Determine which axis is latitude and which is longitude. Subtract
  # 1 from these to turn them into Perl array indices.
  $Mon{'ndfpack_mon'}->obeyw( "wcsattrib", "ndf=$ndf mode=get name=LatAxis" );
  ( $ORAC_STATUS, my $lataxis ) = $Mon{'ndfpack_mon'}->get( "wcsattrib", "value" );
  my $plataxis = $lataxis - 1;
  $Mon{'ndfpack_mon'}->obeyw( "wcsattrib", "ndf=$ndf mode=get name=LonAxis" );
  ( $ORAC_STATUS, my $lonaxis ) = $Mon{'ndfpack_mon'}->get( "wcsattrib", "value" );
  my $plonaxis = $lonaxis - 1;

  # Retrieve the current format for the two axes, then set the format
  # to 'dms.4' for the latitude axis and 'bdms.4' for the longitude
  # axis to get some decent precision.
  $Mon{'ndfpack_mon'}->obeyw( "wcsattrib", "ndf=$ndf mode=get name=Format(1)" );
  ( $ORAC_STATUS, my $format1 ) = $Mon{'ndfpack_mon'}->get( "wcsattrib", "value" );
  $Mon{'ndfpack_mon'}->obeyw( "wcsattrib", "ndf=$ndf mode=get name=Format(2)" );
  ( $ORAC_STATUS, my $format2 ) = $Mon{'ndfpack_mon'}->get( "wcsattrib", "value" );
  my $latformat = "dms.4";
  my $lonformat = "hms.4";
  $Mon{'ndfpack_mon'}->obeyw( "wcsattrib", "ndf=$ndf mode=set name=Format($lataxis) newval=$latformat" );
  $Mon{'ndfpack_mon'}->obeyw( "wcsattrib", "ndf=$ndf mode=set name=Format($lonaxis) newval=$lonformat" );

  # Retrieve the SkyRef position and store it in the Grp uhdr. This is
  # of the form 'dd:mm:ss.ssss, dd:mm:ss.ssss', so split on commas.
  $Mon{'ndfpack_mon'}->obeyw( "wcsattrib", "ndf=$ndf mode=get name=SkyRef" );
  ( $ORAC_STATUS, my $skyref ) = $Mon{'ndfpack_mon'}->get( "wcsattrib", "value" );
  my @skyref = split /, /, $skyref;
  my $reflat = $skyref[$plataxis];
  $reflat =~ s/ /:/g;
  my $reflon = $skyref[$plonaxis];
  $reflon =~ s/ /:/g;
  $Grp->uhdr( "REFLAT", $reflat );
  $Grp->uhdr( "REFLON", $reflon );

  # Set the axis formats back to what they were.
  $Mon{'ndfpack_mon'}->obeyw( "wcsattrib", "ndf=$ndf mode=set name=Format(1) newval=$format1" );
  $Mon{'ndfpack_mon'}->obeyw( "wcsattrib", "ndf=$ndf mode=set name=Format(2) newval=$format2" );

}

# Display.
$Display->display_data( $Frm ) if defined $Display;

# Tidy-up output.
orac_print "\n";

