    # Are we allowed to continue?

    my $cancombine = $Frm->uhdr("GOT_EM_ALL");
    my $masking = $_MAKE_FLAT_AND_DIVIDE_{MASK};
    my $divide = $_MAKE_FLAT_AND_DIVIDE_{DIVIDE};

    # Right we're allowed to continue.  Start by getting a subgroup with
    # the correct cycle number.  This is because a group may contain several
    # cycles.

    if ($cancombine) {
        my $current_cycle = $Frm->uhdr("CYCLE_NUMBER");
        my $subgrp = $Grp->subgrp(CYCLE_NUMBER=>$current_cycle);
        my $ref_run = $Frm->uhdr("ORAC_OBSERVATION_NUMBER");
        foreach my $fr ($subgrp->allmembers) {
            if ($fr->uhdr("REF_RUNNO")) {
                $ref_run = $fr->uhdr("ORAC_OBSERVATION_NUMBER");
                last;
            }
        }
        my $flatfile = sprintf("flat_%d.%s",$ref_run,$Frm->fitsextn);
        unlink $flatfile if (-e $flatfile);

        # Now make the flat...

        {
            my $Grp = $subgrp;
            _FLATCOMBINE_ OUT=$flatfile MASK=0
        }
        _FILE_FLAT_ NAME=$flatfile

        # If doing masking, then divide by this flat and make object masks.
        # Then remake the flat field using the object masks.

        if ($masking) {
            use File::Copy;
            foreach my $fr ($subgrp->allmembers) {
                my $tmpnam = "tmp_" . $fr->file;
                copy($fr->file,$tmpnam);
                my $Frm = $fr->new($tmpnam);
                _STAGE1_ FLATCOR=1 LINCOR=0 DARKCOR=0 RESETCOR=0
                _MAKE_OBJECT_MASK_ PNOP=15 THRESH=-1.5 GRID=64
                $fr->uhdr("OPM",$Frm->uhdr("OPM"));
                $fr->update_header("CIR_OPM",TSTRING,$fr->uhdr("OPM"),
                    "Object mask");
                unlink $tmpnam;
            }
            unlink $flatfile;
            {
                my $Grp = $subgrp;
                _FLATCOMBINE_ OUT=$flatfile MASK=1
            }
            foreach my $fr ($subgrp->allmembers) {
                my $opm = $fr->uhdr("OPM");
                unlink $opm;
            }
        }

        # Now make the confidence map...

        my $cpmfile = sprintf("cpm_%d.%s",$ref_run,$Frm->fitsextn);
        unlink $cpmfile if (-e $cpmfile);
        _MAKE_CONFIDENCE_MAP_ IN=$flatfile OUT=$cpmfile THRESH=5.0 NITER=2 WINDOW=1
      
        # Do stats on the flat

        my ($value,$retval,$errmsg);
        $errmsg = "";
        $retval = cir_imstat($flatfile,"",1,$value,$errmsg);
        if ($retval != CIR_OK) {
            orac_err("CIR_IMSTAT: failed in _MAKE_FLAT_\n$errmsg\n");
            return(ORAC__ERROR);
        }

        # Normalise the flat field and replace values of zero

        _FLAT_NORMAL_ IN=$flatfile NF=$value
        _ZERO_REPLACE_ IN=$flatfile
        my $tmpFrm = $Frm->new($flatfile);
        $tmpFrm->update_header("WFRTYPE",TSTRING,"FLAT",
            "Calibration frame type");        
        _FILE_FLAT_ NAME=$flatfile

        # Now for each of the frames in the subgroup, divide by the 
        # associated flat field.

        foreach my $frm ($subgrp->allmembers) {
            my $Frm = $frm;
            if ($divide) {
                _STAGE1_ FLATCOR=1 LINCOR=0 DARKCOR=0 RESETCOR=0
            }
            _CPM_HEDIT_
        }
    }
