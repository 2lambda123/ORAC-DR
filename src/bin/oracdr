#!/bin/perl -s
#
# Change log is at the end of this file
#
# Usage: orac.pl <recipe_name>
#------------------------------------------------------------------------
# check for starlink login
# 
&orac_exit_normally("No starlink login") unless exists $ENV{STAR_LOGIN};

# 
# modules
#
use Carp;				# perl -MCarp=verbose for backtrace
use NDF;				# to access NDF headers
use File::Path;				# rmtree
use Starlink::ADAMTASK;			# monolith access
use Starlink::NBS;			# noticeboard access
#
# command line arguments
#
# -quiet option supresses Starlink non-error messages
($quiet) && ($Starlink::ADAMTASK::msg_hide = 1);
#
# 
#
# signals and perl variables
$|=1;					# make unbuffered
#
$SIG{'INT'} = \&orac_exit_abnormally;
$SIG{'PIPE'} = \&orac_exit_abnormally;
#
# constants
#
$orac_dir = $ENV{ORAC_DIR};		# main orac directory (contains bin)
$recipe_dir = $orac_dir."recipes/";	# recipes
$dictionary_dir = $orac_dir."primitives/"; # primitives
$data_in = $ENV{ORAC_DATA_IN};		# source of data
$data_out = $ENV{ORAC_DATA_OUT};	# data output
$cal_dir = $ENV{ORAC_AUX};		# auxiliarry data (calibration etc)
chdir($data_out);
#
# various ADAM-related constants & parameters
#
# These will end up in the Orac::Messaging::ADAM module
#

$Starlink::ADAMTASK::TIMEOUT = 30;	# task timeout
$ENV{'HDS_SCRATCH'} = "/tmp";           # fix ndf2fits (etc ?)  "feature"
$ENV{'ADAM_USER'} = "/tmp/adam$$";      # process-specific adam dir
#
# launch display
print "Orac says: Launching display...";
&orac_launch_display;
sleep 10;
print "Done\n";
#

#

# start algorithm engines
#
print "ORAC says: Starting up monoliths...";
#
adamtask_init;
&orac_connect_display;
#$Orac{Mon_p4} = new Starlink::ADAMTASK("33672p4",$ENV{CGS4DR_ROOT}."/p4");
$Orac{Mon_ccdpack_red} = new Starlink::ADAMTASK("ccdpack_red_$$",$ENV{CCDPACK_DIR}."/ccdpack_red");
$Orac{Mon_ccdpack_res} = new Starlink::ADAMTASK("ccdpack_res_$$",$ENV{CCDPACK_DIR}."/ccdpack_res");
$Orac{Mon_ccdpack_reg} = new Starlink::ADAMTASK("ccdpack_reg_$$",$ENV{CCDPACK_DIR}."/ccdpack_reg");
$Orac{Mon_kappa_mon} = new Starlink::ADAMTASK("kappa_mon_$$",$ENV{KAPPA_DIR}."/kappa_mon");
$Orac{Mon_kappa_mon}->contactw;	# wait for last monolith
print "Done\n";
#
#------------------------------------------------------------------------
# Data detection loop goes here
#------------------------------------------------------------------------
#
$Orac{'Recipe'} = shift(@ARGV);
@objects=();
$isuffix = "";
$root = 'ro970815_';
foreach $obsno (9,26..30) {
#------------------------------------------------------------------------
#
# %Orac holds key=value pairs relevant to data reduction
#
# we expect to get these two from the header
$Orac{'File'} = $root.$obsno;
#
#  Read the FITS header of the file
#
$file  = $data_in.$Orac{'File'};
($headerref, $status) = fits_read_header($file);
%Header = %$headerref;

#
# Make sure that we successfully read a header
# In the future we will use the concept of good ORAC status rather than stealing from
# Starlink
#
# Once we are in a BIG LOOP this will probably print the warning and do a 'next'
#

if ($status != &NDF::SAI__OK) {

  print "Bad status from header extraction...exiting\n";
  &orac_exit_normally;
}

#
#
@recipe = ();
@recipe = orac_read_recipe($Orac{'Recipe'});	# read recipe

while (grep /^_/,@recipe) {		# while it contains other recipes
  @recipe = orac_parse_recipe(@recipe);	# keep parsing recipes
};

$oracref = orac_execute_recipe(\@recipe,\%Orac);	# execute parsed recipe

};				# end data loop


&orac_exit_normally;

# exit 

#------------------------------------------------------------------------
# THE END(s)
#------------------------------------------------------------------------

sub orac_exit_normally {

    $message = shift(@_);
    print "Orac says: $message - Exiting...\n";

    adamtask_exit;		# Shut down the messaging system
    &orac_kill_display;		# Destroy display

    print "\nOrac says: Goodbye\n";
    exit;
};

sub orac_exit_abnormally {

my $signal = shift;
$Starlink::ADAMTASK::message_hide = 1; # turn off messages

adamtask_exit;                        # Shut down the messaging system
rmtree $ENV{'ADAM_USER'};             # delete process-specific adam dir
&orac_kill_display;		# Destroy display
die;
# die "\n --Signal $signal received--\n";	

};

#------------------------------------------------------------------------
# subs (to be moduled)
#
#  Once this is stuff is in an ORAC module it becomes far more flexible
#
#   - The same code can be used for the data reduction pipeline (with an auto-detection
#      component) and for off-line reduction (where the script is simply given a directory 
#      to process)
#
#------------------------------------------------------------------------
sub orac_launch_display {


# launch display, classic fork trick
    unless ($toolpid = fork) {
	unless (fork) {
    $ENV{PID} = "$$";
print "DEBUG $orac_dir/p4/p4_tcl $data_out 970815 ndf";
	    exec "$orac_dir/p4/p4_tcl $data_out 970815 ndf";
	    die "no exec: $!";
	    exit 0;
	}
	exit 0;
    }
    waitpid($toolpid,0);
};
#------------------------------------------------------------------------

sub orac_connect_display {

#    chomp($toolpid = <>);
    $toolpid = scalar reverse ($toolpid+1);
    $toolname = $toolpid."_p4";
    $toolnbname = "p".$toolpid."_plotnb";
    $Display = new Starlink::ADAMTASK($toolname);
    $Display->contactw;		# ensure contact is made
    $Nbs = new Starlink::NBS ($toolnbname);
};

#------------------------------------------------------------------------

sub orac_kill_display {
#    kill(9,$toolpid+1);
#    system("$orac_dir/bin/cgs4dr_nuke");
};
#------------------------------------------------------------------------

sub nbspeek {
    local($item) = shift(@_);
    $what = $Nbs->find($item);
    ($ok,$value) = $where->get;
    return $value;
};

#------------------------------------------------------------------------

sub nbspoke {
    local($item,$value) = @_;
    $what = $Nbs->find($item);
    $ok = $what->put($value);
};

#------------------------------------------------------------------------
sub orac_execute_recipe {

local($reciperef,$argsref) = @_;
local(@recipe) = @$reciperef;		# dereference recipe
local(%args) = %$argsref;		# dereference arguments

$block = join("",@recipe);
eval $block;
print "Orac says: RECIPE ERROR: $@" if ($@);
return \%args;

};


#------------------------------------------------------------------------
sub orac_read_recipe {

local $recipe = shift(@_);
local (@arguments) = @_;

open(RECIPE,$recipe_dir.$recipe) || croak "No such recipe $recipe\n";;

my (@recipe) = <RECIPE>;

close(RECIPE);

return(@recipe);

};


#------------------------------------------------------------------------

sub orac_parse_recipe {
  
  local(@recipe) = @_;
  my(@parsed);
  
  foreach $line (@recipe) {

    if ($line =~ /^_/) {
      ($macro,@arguments)=split(/\s+/,$line);
      # read in primitive
      open(DICTIONARY,$dictionary_dir.$macro) || croak "No translation for $line\n";    
      @lines = <DICTIONARY>;
      close(DICTIONARY);
      push(@parsed,@lines);
      # store arguments
      %$macro = ();
      foreach $argument (@arguments) {
	  ($key,$value)=split("=",$argument);
	  $$macro{$key}=$value;
      };
      
    } else {
      
      push(@parsed,$line);

  }

};

return(@parsed);
};


#------------------------------------------------------------------------



#------------------------------------------------------------------------

# $Log$
# Revision 1.2  1998/02/20 04:22:13  frossie
# Static variables pulled out as shell ENVs.
#
# Revision 1.1.1.1  1998/02/04 00:51:01  frossie
# Original version
#
# Revision 1.5  1997/11/25 06:46:57  frossie
# actually runs tasks. adam stuff not transparent.
#
# Revision 1.4  1997/11/22 01:04:35  frossie
# Variables passed down and back up
#
# Revision 1.3  1997/11/22 00:28:23  frossie
# Arguments propagate down
#
# Revision 1.2  1997/11/21 21:30:43  frossie
# Very simple version. Deals with recipes calling recipes.
#
# Revision 1.1  1997/11/21 21:29:43  frossie
# Initial revision
#

