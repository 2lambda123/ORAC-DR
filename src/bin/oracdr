#!/usr/local/bin/perl
#
# Change log is at the end of this file
# POD documentation is at end of file
#
# Usage: oracdr <recipe_name>
#------------------------------------------------------------------------

use 5.006;

use strict;
use warnings;
use vars qw/$VERSION/;

# Version number - do this before anything else so that we dont have to 
# wait for all the modules to load - very quick
BEGIN {
  $VERSION = sprintf "%d.%03d", q$Revision$ =~ /(\d+)\.(\d+)/;
  #
  # Check for version number request
  # - do this before real options handling...
  foreach (@ARGV) {
    if (/^-vers/) {
      print "ORAC-DR: Data reduction pipeline version $VERSION\n";
      exit;
    }
  }
}

# Make sure we catch as many signals as possible
# so that the END{} blocks work correctly and tidy up

# add a stack-trace for debugging
use sigtrap qw/die normal-signals error-signals/;

################# L O A D  M O D U L E S #################################### 

#
#  ORAC modules
#
use lib $ENV{"ORAC_PERL5LIB"};
use ORAC::Basic;     # Helper routines
use ORAC::General;   # parse_* routines
use ORAC::Print;     # Printing messages or errors
use ORAC::Core;      # Core pipeline routines
use ORAC::Constants; # ORAC__OK et al
use ORAC::Event;     # Tk events
use ORAC::Error qw/:try/;
use ORAC::Inst::Defn qw/ orac_determine_inst_classes /;

#
#  General modules
#
use Pod::Usage;
use Getopt::Long;                       # command line arguments
eval{ require Starlink::AST; };

# check for starlink login
orac_exit_normally("No starlink login") unless exists $ENV{"STAR_LOGIN"}; 

####### C H E C K  E N V I R O N M E N T  V A R I A B L E S ################

# Need to determine module list from the ORAC_INSTRUMENT
# environment variable before we can include certain modules.

# Simply exit if the environment variable is not set.
unless (exists $ENV{ORAC_INSTRUMENT}) {
  orac_err("No intrument specified in \$ORAC_INSTRUMENT. Please set to one of IRCAM, UFTI, SCUBA\n");
  exit;
}

my $instrument = uc($ENV{ORAC_INSTRUMENT});

# Get class definitions for this instrument
my ($frameclass, $groupclass, $calclass, $instclass) =
  orac_determine_inst_classes( $instrument );
die "Could not translate $instrument to class hierarchy"
  unless defined $frameclass;

# Create a new instrument object
my $InstObj = new $instclass;

############# C O M M A N D  L I N E  A R G U M E N T S ###################

# Store them first so that we can print out the log message
my @ORAC_ARGS = @ARGV;

# Now parse the args

# Pass @_ directly to GetOpt::Long::GetOptions, no need to process
# an argument list as it would just complicate things. 

my ( %opt );
$opt{calib} = []; # Want to support --calib a=b --calib c=d

my $status = GetOptions("nodisplay" => \$opt{nodisplay},
	  		"debug!"    => \$opt{debug},
		 	"verbose!"  => \$opt{verbose},
			"calib=s"   =>  $opt{calib},
		        "from=i"    => \$opt{from},
			"to=i"      => \$opt{to},
			"ut=i"      => \$opt{ut},
			"list=s"    => \$opt{list},
			"loop=s"    => \$opt{loop},
			"help"      => \$opt{help},
			"batch!"    => \$opt{batch},
			"skip!"     => \$opt{skip},
			"noeng"     => \$opt{noeng},
			"nomsgtmp"  => \$opt{nomsgtmp},
			"log=s"     => \$opt{log},
			"resume!"   => \$opt{resume},
			"warn!"     => \$opt{warn},
			"beep!"     => \$opt{beep},
			"showcurrent!" => \$opt{showcurrent},
			"files=s"   => \$opt{files},
			"man"       => \$opt{man},
		       );

pod2usage(1) if $opt{help};
pod2usage(-exitstatus => 0, -verbose => 2) if $opt{man};

# Turn on -w support
# This will twiddle with the warnings pragma
if ($opt{warn}) {
  $^W=1;
  if ($opt{verbose}) {
    eval "use diagnostics;";
  }
}

############### S I G N A L  H A N D L E R S ##############################

# signals and perl variables
$|=1;					# make unbuffered

$SIG{'INT'} = \&orac_exit_abnormally;
#$SIG{'PIPE'} = \&orac_exit_abnormally;
$SIG{'PIPE'} = 'IGNORE';

########## O R A C - D R  C O N F I G U R A T I O N ########################

# constants - for the module

# Check for ORAC_DIR
unless (exists $ENV{ORAC_DIR}) {
  orac_err("ORAC_DIR environment variable not defined. Aborting.");
  orac_exit_normally();
}

######## C H A N G E   T O   O U T P U T   D I R E C TO R Y  ###############

# Force absolute path
orac_force_abspath();

if (exists $ENV{ORAC_DATA_OUT}) {

  # change to output  dir
  chdir($ENV{ORAC_DATA_OUT}) ||
    do { 
      orac_err("Could not change directory to ORAC_DATA_OUT: $!");
      orac_exit_normally();
    };

} else {
  orac_err("ORAC_DATA_OUT environment variable not set. Aborting\n");
  orac_exit_normally();
}

############### C H E C K  I N P U T  D I R E C T O R Y ####################

if (exists $ENV{ORAC_DATA_IN}) {

  unless (-d $ENV{ORAC_DATA_IN}) {

    orac_err("ORAC_DATA_IN directory ($ENV{ORAC_DATA_IN}) does not exist. Aborting\n");
    orac_exit_normally();
  }
  
} else {
  orac_err("ORAC_DATA_IN environment variable not set. Aborting\n");
  orac_exit_normally();
}

######### O R A C  P R I N T  C O N F I G U R A T I O N #####################

# $CURRENT_RECIPE is used in Xoracdr and for the recipe progress window
my ( $CURRENT_RECIPE );

# declare variables
my ($log_options, $MW, $win_str);

# check for log options, we need to start the Tk early if using X Windows
if (defined $opt{log}) 
{
   # User is overriding logging options, lower case the options
   $log_options = lc($opt{log});
} 
else 
{
   # fx is default if we have a DISPLAY variable
   if (defined $ENV{DISPLAY}) 
   {
      $log_options = 'fx';     # We use X Windows
   } 
   else 
   {
     $log_options = 'sf';      # We use the console (icky!)
   }
}

if ( $log_options =~ /x/ )
{
   eval "use Tk; use Tk::TextANSIColor;";
   unless( $@ ) {
      $MW = MainWindow->new();
      ORAC::Event->register("Tk"=>$MW); 
      $win_str = "Tk";
   } else {
      $log_options = 'sf';
   }     
}

# start print system, pass $win_str since we want orac_print_confiuration to
# be generic and useable from Xoracdr (where we pass $TOPLEVEL instead).
my ( $orac_prt, $msg_prt, $msgerr_prt, $ORAC_MESSAGE, 
     $PRIMITIVE_LIST, $CURRENT_PRIMITIVE );
 
try 
{
   ( $orac_prt, $msg_prt, $msgerr_prt, $ORAC_MESSAGE, 
     $PRIMITIVE_LIST, $CURRENT_PRIMITIVE ) = 
         orac_print_configuration( $log_options, 
				   $win_str, 
				   \$CURRENT_RECIPE,
				   \@ORAC_ARGS,
				   %opt
				 );
}
catch ORAC::Error::FatalError with 
{
   my $Error = shift;
   orac_exit_normally( "$Error" );
}
catch ORAC::Error::UserAbort with
{
   my $Error = shift;
   orac_exit_normally();
}
otherwise
{
   # this should sucessfully catch croaks
   my $Error = shift;
   orac_exit_normally( "$Error" );
};
$CURRENT_RECIPE = "Starting pipeline";

#########################   U  T    D A T E #################################

# if no UT date has been provided, default to current.
!($opt{ut}) && do {

  $opt{ut} = utdate;
  orac_print ("Orac says: No UT date supplied, using $opt{ut}\n","blue");

};

######################## M E S S A G E  S Y S T E M S #######################

# pre-launch message system
try {
   orac_message_launch( $opt{nomsgtmp}, $opt{verbose} );
}
catch ORAC::Error::FatalError with 
{
   my $Error = shift;
   orac_print("Error launching the Message System", "red");
   orac_exit_normally("$Error");
}
catch ORAC::Error::UserAbort with 
{
   my $Error = shift;
   orac_print("Abort from launching the Message System", "red");
   orac_exit_normally();
}
otherwise
{
   # this should sucessfully catch croaks
   my $Error = shift;
   orac_exit_normally( "$Error" );
};

######################## A L G.   E N G I N E S #############################

# start algorithim engines
my $Mon;
try {
   $Mon = orac_start_algorithm_engines( $opt{noeng}, $InstObj );
}
catch ORAC::Error::FatalError with 
{
   my $Error = shift;
   orac_exit_normally( "$Error" );
}
catch ORAC::Error::UserAbort with
{
   my $Error = shift;
   orac_exit_normally();
}
otherwise
{
   # this should sucessfully catch croaks
   my $Error = shift;
   orac_exit_normally( "$Error" );
};

####################### B E E P I N G #######################################

# Beeping
if ($opt{beep}) {
  $orac_prt->errbeep(1);
  # Beep is for orac_exit_normally so must set global in the correct class
  $ORAC::Basic::Beep = 1;
}

######################## I N I T  D I S P L A Y #############################

# start the display
my $Display = orac_start_display( $opt{nodisplay} );

######################## C A L I B R A T I O N ##############################

# Calibration frame overrides
my $Cal = orac_calib_override( $calclass, @{$opt{calib}} );

################## P R O C E S S  A R G U M E N T  L I S T ##################

# declare observations array
my @obs;

# Process the -files file1 file2 file3 command line option into
if ( defined $opt{files} ) {
   try {
      @obs = orac_parse_files( $opt{files} );
   }
   catch ORAC::Error::FatalError with 
   {
      my $Error = shift;

      ORAC::Error->flush if defined $Error; 
      orac_exit_normally( "$Error" );
   }
   catch ORAC::Error::UserAbort with
   {
      my $Error = shift;

      ORAC::Error->flush if defined $Error; 
      orac_exit_normally();
   }
   otherwise
   {
      # this should sucessfully catch croaks
      my $Error = shift;
      orac_exit_normally( "$Error" );
   };
}

##################### L O O P I N G  S C H E M E ############################

# Generate list of observation numbers if @obs isn't defined to be processed
# This is related to looping scheme
my $loop =  
    orac_process_argument_list($frameclass,\@obs, %opt);

die "Unable to determine looping scheme. Please specify -loop or -list/from/to"
  unless defined $loop;


# Read recipe name, this will default to the RECIPE File method
my $Override_Recipe = shift(@ARGV);

########################## D A T A   L O O P ################################

# Call the main data processing loop
try {
  # Might want to consider simply passing all of %opt into this function
  orac_main_data_loop( $opt{batch}, $opt{ut}, $opt{resume}, $opt{skip}, 
		       $opt{debug}, $loop, $frameclass, $groupclass, 
		       $instrument, $Mon, $Cal, \@obs, $Display, 
		       $orac_prt, $ORAC_MESSAGE,
		       \$CURRENT_RECIPE, $PRIMITIVE_LIST, $CURRENT_PRIMITIVE,
		       $Override_Recipe );
}
catch ORAC::Error::FatalError with
{
   my $Error = shift;
   ORAC::Error->flush;
   orac_err( "$Error" );
   ORAC::Event->mainloop("Tk");
   orac_exit_normally();
}
catch ORAC::Error::UserAbort with
{
   my $Error = shift;
   ORAC::Error->flush;
   orac_exit_normally();
}
otherwise
{
   # this should sucessfully catch croaks
   my $Error = shift;
   orac_exit_normally( "$Error" );
};

########################## T I D Y  U P #####################################

orac_print ("Pipeline processing complete\n", "green");
$CURRENT_RECIPE = "Pipeline processing complete";

# If $MW is defined, enter the Tk MainLoop
# So that the session can be examined before exiting
ORAC::Event->mainloop("Tk");

# Cleanup
orac_exit_normally();

# exit

#------------------------------------------------------------------------


=head1 Name

oracdr - ORAC Data Reduction pipeline

=head1 Synopsis

  oracdr [-options] [RECIPE]
  oracdr -from 5
  oracdr -ut 19990523 -list 15:35,40,44 -batch

=head1 DESCRIPTION

C<oracdr> is the actual ORAC-DR data reduction pipeline. 
This document describes the command line options that
can be used to modify the pipeline operation.

=head1 Arguments

The following argument  is  supported:

=over 4

=item * RECIPE

By default, ORAC-DR looks in the file header for the name of the
recipe to be used on the data. If you specify the name of a recipe on
the command line, it will override the one specified in the
header. This override recipe is used for all data files regardless of
header contents or observation mode, so make sure you only only apply
it to appropriate data frames.

=back

=head1 Options

All ORAC-DR behaviour is controlled by the option
switches. These options may be abbreviated to a unique substring. It
is via command line switches that you (for example) control the range
of file numbers to be reduced, force the system to use a particular
calibration file when reducing (e.g. to try a different flat
exposure). This list needs to be read thoroughly by anyone wanting to
use the system.

=head2 General Options

=over 4

=item B<-help>

List help text. This prints a summary of this document.

=item B<-version>

Print the version number.

=item B<-verbose>

Print messages from the Starlink engines (rather than just ORAC-DR
messages).

=item B<-man>

Print the full documentation.

=item B<-debug>

Log debug messages to file C<ORACDR.DEBUG> in C<$ORAC_DATA_OUT>.

=item B<-warn>

Turn on perl level warning messages (C<perl -w>). This should be
used for debugging only. If C<-verbose> is also true then full 
perl diagnostics are turned on (see L<diagnostics> for more information
on this perl pragma).

=item B<-beep>

Make as much noise as possible over errors and pipeline exit.
Default is not to beep.

=back

=head2 Windows and output

=over 4

=item B<-nodisplay>

Do not launch the display system. No data will be displayed and GWM,
GAIA etc. windows will not be launched.

=item B<-showcurrent>

Launch a recipe viewer window along with the log Xwindow

=item B<-log s>

Log to terminal screen (standard out)

=item B<-log f>

Log to a file. The logfile is called C<.oracdr_NNNN.log> where NNNN 
is the current process ID. It is written to C<$ORAC_DATA_OUT> and is 
a hidden file.

=item B<-log x>

Log to an Xwindow. Has the advantage that warnings and errors are
written to different, independently scrollable windows.

=back

The three log options can be combined. The default is C<-log sx>

To run ORAC-DR using output only within the xterm that you used
to invoke it in, use C<-nodisplay -log s>. This is the fastest way
to run the pipeline if you are not interested in visually
inspecting the data as it is being reduced.

=head2 Observations

=over 4

=item B<-from>

Number of first observation.

=item B<-to>

Number of last observation.

=item B<-list>

Comma separated list of observation I<numbers>. Colons indicate a range.
For example, `1,2,4:6,10' means 1,2,4,5,6,10.

=item B<-file>

File name (relative to current directory) of a flat ASCII text file containing
a list of observation I<files> to be reduced, one file per line.

=back

=head2 UT date

=over 4

=item B<-ut>

UT date of observations (defaults to current yyyymmdd). When the
instrument specific setup scripts are run, oracdr is automatically
aliased to use the correct C<-ut> option. The UT is required for
UKIRT and JCMT instruments as it forms part of the file naming
convention for data files.

=back

=head2 Calibration options.

=over 4

=item B<-calib>

Used to specify calibration overrides. Accepts comma separated key=value
pairs. (e.g. `C<-cal dark=file1>' or `C<-cal dark=file1,bias=file2>'). The
allowed options depends on the instrument that is in use.

=back

See L<Calibrating> for more information on how the pipeline deals
with calibrations.


=head2 Looping options


The C<-loop> option specifies the type of data detection loop. Allowed
values are `list', `inf', `wait', `flag' or 'file'. In almost all cases of
offline use, `inf' is most appropriate.

=over 4

=item  B<-loop list>

Default when using the C<-list> option. The pipeline will stop
once the observations in the list have been reduced.

=item  B<-loop wait>

Waits for data to appear before timing out. Data is reduced and the pipeline
waits for the next file.

=item  B<-loop inf>

Do not wait for data. Simply reduce data starting with observation
specified by C<-from> and continuing until no more files are present.
Implicitly used when C<-from> is specified. This is the fastest way
of reducing data offline.

=item  B<-loop flag>

Waits for completion files to appear (flags) before processing the data.
Data is reduced and the pipeline waits for more data by checking the
presence of a flag.

=item B<-loop file>

Works much like C<-loop list> except that looping is carried out over a
list of arbitarly named files input from the C<-files> command line option.

=back

See L<DataLoops> for more
information on looping schemes.


=head2 Group processing options

=over 4

=item B<-batch>

Run in batch mode. Precalculate groups before processing
data. `wait' loop mode should not be used with this option.
B<NOTE> only SCUBA recipes support this option.

=item B<-skip>

Allow the data detection loop to skip missing observations.
Default is to stop the loop when an expected file can not be found.

=item B<-resume>

Allow the pipeline to resume midway through the processing
of a group. (so long as the recipe/instrument supports
this behaviour). Default is for the group file to be deleted
when a new group is created. When C<-resume> is set, the group
file is retained. B<NOTE> this option is not currently supported by
IRCAM, UFTI and SCUBA recipes.

=back

=head2 Engine Options

=over 4

=item B<-noeng>

Do not start algorithm engines. B<NOTE> this will cause
the vast majority of recipes to fail.

=item B<-nomsgtmp>

Do not create an invocation specific temporary directory for the
messaging systems but use whatever directory is the usual default. For
ADAM tasks this would mean that ~/adam or $ADAM_USER will be used
rather than a private ORAC-DR directory. This should only be used when
it is required for ORAC-DR to talk to tasks that were not started by
the pipeline and could lead to possible confusion if multiple
pipelines are running using this flag.

=back

=head1 REVISION

$Id$

=head1 AUTHORS

Frossie Economou (frossie@jach.hawaii.edu),
Tim Jenness (t.jenness@jach.hawaii.edu),
Alasdair Allan (aa@astro.ex.ac.uk)

=head1 COPYRIGHT

Copyright (C) 1998-2001 Particle Physics and Astronomy Research Council.
All Rights Reserved.

=cut
