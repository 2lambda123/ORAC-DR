#!/usr/local/bin/perl
#
# Change log is at the end of this file
#
# Usage: oracdr <recipe_name>
#------------------------------------------------------------------------
# check for starlink login
# 

# Predeclare subroutines that are read in after 
# the standard perl pre-processing (ie modules included
# via an eval)
use subs qw(start_msg_sys start_algorithm_engines wait_for_algorithm_engines);

use lib $ENV{ORAC_PERL5LIB};
use ORAC::Basic;
use ORAC::General;

&orac_exit_normally("No starlink login") unless exists $ENV{STAR_LOGIN};

# 
# general modules
#
use Carp;				# perl -MCarp=verbose for backtrace
use Term::ANSIColor;			# color output
use File::Copy;
use Getopt::Long;                       # command line arguments

# Need to determine module list from the ORAC_INSTRUMENT
# environment variable before we can include certain modules.

# Simply exit if the environment variable is not set.
unless (exists $ENV{ORAC_INSTRUMENT}) {
  print colored("No intrument specified in \$ORAC_INSTRUMENT. Please set to one of IRCAM, CGS4, SCUBA\n",'red');
  exit;
}

$instrument = uc($ENV{ORAC_INSTRUMENT});

if ($instrument eq 'IRCAM') {
  $groupobject = "ORAC::Group::UKIRT";
  $frameobject = "ORAC::Frame::UKIRT";
  $calobject   = "ORAC::Calib::IRCAM";
  $instmodule  = "ORAC::Inst::IRCAM";
} elsif ($instrument eq 'UFTI') {
  $groupobject = "ORAC::Group::UKIRT";
  $frameobject = "ORAC::Frame::UKIRT";
  $calobject   = "ORAC::Calib::IRCAM";
  $instmodule  = "ORAC::Inst::IRCAM";
} elsif ($instrument eq 'SCUBA') {
  $groupobject = "ORAC::Group::JCMT";
  $frameobject = "ORAC::Frame::JCMT";
  $calobject   = "ORAC::Calib::SCUBA";
  $instmodule  = "ORAC::Inst::SCUBA";
} else {
  print colored("Instrument $instrument is not currently supported in ORACDR\n",'red');
  exit;
}


# Read in the instrument specific modules
eval "use $groupobject;";
die "Error importing $groupobject:\n$@\n" if ($@);
eval "use $frameobject;";
die "Error importing $frameobject:\n$@\n" if ($@);
eval "use $calobject;";
die "Error importing $calobject:\n$@\n" if ($@);
eval "use $instmodule;";
die "Error importing $instmodule:\n$@\n" if ($@);




#
# command line arguments
#

GetOptions("nodisplay","quiet!","calib=s","from=i","to=i","ut=i","list=s","h");

($opt_h) && do {
print qq|

Usage:
  oracdr [-options] <recipe_name>

Arguments:
  <recipe_name>  a recipe to be executed

Options:

  These options may be abbreviated to a unique substring.

  -h         this help text
  -quiet     suppress engine messages
  -nodisplay do not launch display

  -from      number of first observation
  -to        number of last observation
  -list      comma separated list of object *numbers*
             Colons indicate a range (1,2,3:5,10 means 1,2,3,4,5,10)


  -ut        UT date of observations (defaults to current yyyymmdd)
  -calib     comma seperated key=value pairs (eg. -cal dark=file1 or
             -cal dark=file1,bias=file2) of calibration *files*
  |;
exit;
}
;


# -nodisplay suppresses display,
#
print colored ("Orac says: No display will be used\n","blue") if ($opt_nodisplay);

#
# signals and perl variables
$|=1;					# make unbuffered
#
$SIG{'INT'} = \&orac_exit_abnormally;
#$SIG{'PIPE'} = \&orac_exit_abnormally;
$SIG{'PIPE'} = sub {};

#
# constants - for the module
#
$orac_dir = $ENV{ORAC_DIR} . "/";	# main orac directory (contains bin)
$recipe_dir = $orac_dir."recipes/";	# recipes
$dictionary_dir = $orac_dir . "primitives/$instrument/"; # primitives

#
# constants - for the pipeline
#
$In = $ENV{ORAC_DATA_IN} . '/';	# source of data
$Out = $ENV{ORAC_DATA_OUT};	# data output
$CalDir = $ENV{ORAC_DATA_CAL};	# auxiliarry data (calibration etc)

# if no UT date has been provided, default to current.
#
!($opt_ut) && do {

  $opt_ut = utdate;

  print colored ("Orac says: No UT date supplied, using $opt_ut\n","blue");

};



chdir($Out);				# change to output  dir

# Start the messaging system(s) and initialise them
# This routine creates and initialies the message systems.
# Also allows us to store the message objects since on
# undef everything goes away
(@messys) = start_msg_sys;


#
# launch display
do {
  print colored ("Orac says: Launching display...","blue");
  &orac_launch_display;
  print colored ("Orac says: Done\n","blue");
} unless $opt_nodisplay;

#


# start algorithm engines
#
print colored ("ORAC says: Starting up monoliths...","blue");
#

%Mon = start_algorithm_engines;
$status = wait_for_algorithm_engines;

if ($status != ORAC__OK) {
  print colored("Error contacting monoliths. Aborting.\n",'red');
  orac_exit_normally;
}

print colored ("Done\n","blue");

# Now see if we can talk to the display
&orac_connect_display unless ($opt_nodisplay);


# Messaging system seems to be working okay so configure it.
# Now we set our overrides to the messaging systems.

foreach my $msg (@messys) {

  # -quiet option supresses Starlink non-error messages
  ($opt_quiet) && ($msg->messages(0));
  $msg->timeout(600);	# task timeout

}



#
#------------------------------------------------------------------------
# Data detection loop goes here
#------------------------------------------------------------------------
#
$Override_Recipe = shift(@ARGV); # this will default to the RECIPE File method


# Create calibration object
$Cal = new $calobject;

# temporary fudge
#$Cal->dark("ro970815_9_bp_db") if $instrument eq 'IRCAM';

#
# Calibration frame overrides
#
  
if (defined $opt_calib) {
  
  %calibs = parse_keyvalues($opt_calib);

  foreach $key (keys %calibs) {

    if ($Cal->can($key)) {		# set appropriate method

      $Cal->$key($calibs{$key});

      print colored ("ORAC says: Calibration $key set to $calibs{$key}\n","blue");

    } else {				# complain but continue

      print colored ("ORAC says: Calibration $key unknown by this instrument. Ignored\n","red");

    };
  };

};


 


# Generate list of observation numbers to be processed
 
if (defined $opt_from) {
 
  @obs = $opt_from .. $opt_to;
 
} elsif (defined $opt_list) {

  @obs = parse_obslist($opt_list);

}

foreach $obsno (@obs) {
  #------------------------------------------------------------------------
  #
  # Create frame object
  $Frm = new $frameobject;


  # Find the filename from the number
  #
  $File = $Frm->file_from_bits($opt_ut,$obsno);
  
  # temporary solution ? Create symbolic link in output directory
  # pointing to raw data file this or a similar strategy is needed to
  # preserve order-stupidity on the part of the primitives

  symlink($In.$File,$File);

  # 
  # Now that the file exists in cwd we can configure the object
  # 
  $Frm->configure($File);

  print colored ("REDUCING: ".$Frm->raw."\n","yellow");
  
  # query Frame for its group
  
  $grpname = $Frm->group;
  
  # create a new group object and remove the previous file
  # unless such an object already exists
  # note that the "existence" of this group is only meaningful
  # over the lifetime of the pipeline
  
  do {
    
    $Grp = new $groupobject($grpname);
    $Grp->file($Grp->file_from_bits($opt_ut, $obsno));
    unlink($Grp->file);
    $Groups{$grpname} = $Grp;		# store group object
    print colored ("A new group ".$Grp->file." has been created\n","blue");

  } unless (exists $Groups{$grpname});

  # Select current group
  $Grp = $Groups{$grpname};

  # push current Frame onto Group

  $Grp->push($Frm);
  print colored ("This observation is part of group ".$Grp->file."\n","blue");

  # let the calibration object know what thing it is using (to determine
  # suitability etc. In this case we do it on a frame-by-frame basis, so
  # we pass it the header hash of the current frame

  $Cal->thing($Frm->header);

  #
  # at this point the recipe method should be queried if it hasn't
  # been explicitly set
  # Query frame for a recipe
  my $frmrecipe = $Frm->recipe;

  # KLUDGE: If recipe is not defined take the one specified on the command
  # Line. Else use the one instructed by the frame.
  # This needs to be changed such that we override all recipes except for
  # calibrators
  if ($frmrecipe !~ /./) {
    $Recipe = $Override_Recipe;
  } else {
    $Recipe = $frmrecipe;
  }


  # Read in the selected recipe  
  @recipe = orac_read_recipe($Recipe);	# read recipe
  
  while (grep /^\s*_/,@recipe) {	# while it contains other recipes
    @recipe = orac_parse_recipe(@recipe); # keep parsing recipes
  };
  

  $oracref = orac_execute_recipe(\@recipe,$Frm,$Grp,$Cal); # execute parsed recipe

  # delete symlink to raw data file
  unlink($Frm->raw) if (-l $Frm->raw);


};				# end data loop




&orac_exit_normally;

# exit 


#------------------------------------------------------------------------

# $Log$
# Revision 1.27  1998/07/07 06:11:50  frossie
# Set current frame to calibration 'thing', against which to determine
# calibration suitability.
#
# Revision 1.26  1998/06/29 05:37:36  timj
# Add wait_for_algorithm_engines (reorganise to accomodate status checking).
#
# Revision 1.25  1998/06/29 05:25:16  frossie
# Use wait_for_algorithm_engines
#
# Revision 1.24  1998/06/29 03:56:09  frossie
# Bugfix: Make sure ORAC_PERL5LIB is really used.
#
# Revision 1.23  1998/06/29 03:21:11  frossie
# remove -dark and add general -calib option
#
# Revision 1.22  1998/06/28 01:10:46  frossie
# -ut option defaults to current UT date if unspecified
#
# Revision 1.21  1998/05/23 08:05:54  timj
# Read recipe from frame (or at least try to)
#
# Revision 1.20  1998/05/21 18:32:31  timj
# Left over 'exit' from my debugging efforts....
#
# Revision 1.19  1998/05/21 06:26:38  timj
# Add support for ranges in -list
#
# Revision 1.18  1998/05/19 01:45:41  timj
# Support file_from_bits() methods.
#
# Revision 1.17  1998/05/18 21:17:10  timj
# Add support for new organization of primitives directories.
#
# Revision 1.16  1998/05/08 18:41:13  timj
# Remove instrument specific definitions.
# Display is still hard-wired.
#
# Revision 1.15  1998/04/15 02:41:28  frossie
# Move ams_init to appropriate place
#
# Revision 1.14  1998/04/14 21:39:12  frossie
# Move data dir chdir prior to display launch
#
# Revision 1.13  1998/04/14 21:10:48  frossie
# Change explicit use of ADAMTASK modules to new ORAC::Msg classes.
#
# No longer need explicit exits from the messaging system as these are
# now performed when message objects are destroyed.
#
# Revision 1.12  1998/04/09 02:48:06  frossie
# Group filename changed to "rg" from "g"
#
# Revision 1.11  1998/04/04 06:45:31  frossie
# Introduce Frm Grp and Cal objects
#
# Revision 1.10  1998/04/01 23:09:12  frossie
# *** empty log message ***
#
# Revision 1.9  1998/03/17 18:54:23  frossie
# *** empty log message ***
#
# Revision 1.8  1998/03/16 19:07:28  frossie
# File::Copy and group filename prototype handling
#
# Revision 1.7  1998/03/16 04:07:57  frossie
# Add use of ANSI colour
#
# Revision 1.6  1998/02/25 11:25:50  frossie
# * oracdr: introduced Getopt for option handling
#
# Revision 1.5  1998/02/24 11:39:58  frossie
# More namespace fixing - Hdr and Mon now generally accessible. Risk of
# clobbering is probably worth the pain of enforcing ${main::Blah} to
# long-suffering primitive writers.
#
# Revision 1.4  1998/02/24 09:13:34  frossie
# Pipeline now does only basic control
#
# Revision 1.3  1998/02/20 06:43:55  frossie
# Static variables pulled out as shell ENVs.
#
# -nodisplay option supported
#
# Revision 1.2  1998/02/20 04:22:13  frossie
# Static variables pulled out as shell ENVs.
#
# Revision 1.1.1.1  1998/02/04 00:51:01  frossie
# Original version
#
# Revision 1.5  1997/11/25 06:46:57  frossie
# actually runs tasks. adam stuff not transparent.
#
# Revision 1.4  1997/11/22 01:04:35  frossie
# Variables passed down and back up
#
# Revision 1.3  1997/11/22 00:28:23  frossie
# Arguments propagate down
#
# Revision 1.2  1997/11/21 21:30:43  frossie
# Very simple version. Deals with recipes calling recipes.
#
# Revision 1.1  1997/11/21 21:29:43  frossie
# Initial revision
#
