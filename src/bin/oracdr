#!/usr/local/bin/perl
#
# Change log is at the end of this file
#
# Usage: oracdr <recipe_name>
#------------------------------------------------------------------------
# check for starlink login
# 

# Predeclare subroutines that are read in after 
# the standard perl pre-processing (ie modules included
# via an eval)
use subs qw(start_msg_sys start_algorithm_engines wait_for_algorithm_engines);

use lib $ENV{ORAC_PERL5LIB};
use ORAC::Basic;
use ORAC::General;
use ORAC::Loop;     # Loop control
use ORAC::Print;    # Printing messages or errors

&orac_exit_normally("No starlink login") unless exists $ENV{STAR_LOGIN};

# 
# general modules
#
use Carp;				# perl -MCarp=verbose for backtrace
use Term::ANSIColor;			# color output
use File::Copy;
use Getopt::Long;                       # command line arguments

# Need to determine module list from the ORAC_INSTRUMENT
# environment variable before we can include certain modules.

# Simply exit if the environment variable is not set.
unless (exists $ENV{ORAC_INSTRUMENT}) {
  orac_err("No intrument specified in \$ORAC_INSTRUMENT. Please set to one of IRCAM, UFTI, SCUBA\n");
  exit;
}

$instrument = uc($ENV{ORAC_INSTRUMENT});

if ($instrument eq 'IRCAM') {
  $groupobject = "ORAC::Group::UKIRT";
  $frameobject = "ORAC::Frame::UKIRT";
  $calobject   = "ORAC::Calib::IRCAM";
  $instmodule  = "ORAC::Inst::IRCAM";
} elsif ($instrument eq 'UFTI') {
  $groupobject = "ORAC::Group::UFTI";
  $frameobject = "ORAC::Frame::UFTI";
  $calobject   = "ORAC::Calib::IRCAM";
  $instmodule  = "ORAC::Inst::IRCAM";
} elsif ($instrument eq 'CGS4') {
  $groupobject = "ORAC::Group::UKIRT";
  $frameobject = "ORAC::Frame::UKIRT";
  $calobject   = "ORAC::Calib::CGS4";
  $instmodule  = "ORAC::Inst::CGS4";
} elsif ($instrument eq 'SCUBA') {
  $groupobject = "ORAC::Group::JCMT";
  $frameobject = "ORAC::Frame::JCMT";
  $calobject   = "ORAC::Calib::SCUBA";
  $instmodule  = "ORAC::Inst::SCUBA";
} else {
  orac_err("Instrument $instrument is not currently supported in ORACDR\n");
  exit;
}


# Read in the instrument specific modules
eval "use $groupobject;";
die "Error importing $groupobject:\n$@\n" if ($@);
eval "use $frameobject;";
die "Error importing $frameobject:\n$@\n" if ($@);
eval "use $calobject;";
die "Error importing $calobject:\n$@\n" if ($@);
eval "use $instmodule;";
die "Error importing $instmodule:\n$@\n" if ($@);




#
# command line arguments
#

my $status = GetOptions("nodisplay","debug!","quiet!","calib=s","from=i","to=i","ut=i","list=s","loop=s","h");

($opt_h) && do {
print qq|

Usage:
  oracdr [-options] <recipe_name>

Arguments:
  <recipe_name>  a recipe to be executed

Options:

  These options may be abbreviated to a unique substring.

  -h         this help text
  -quiet     suppress engine messages
  -debug     log debug messages to ORACDR.DEBUG
  -nodisplay do not launch display

  -from      number of first observation
  -to        number of last observation
  -list      comma separated list of object *numbers*
             Colons indicate a range (1,2,3:5,10 means 1,2,3,4,5,10)


  -ut        UT date of observations (defaults to current yyyymmdd)
  -calib     comma seperated key=value pairs (eg. -cal dark=file1 or
             -cal dark=file1,bias=file2) of calibration *files*
  -loop      Type of data detection loop: list, inf, or wait
             -loop list is equivalent to not using a loop at all
              (only data specified is reduced)
             -loop wait waits for data to appear before timing out
	      (data is reduced and we wait for new data)
             -loop inf does not wait for data 
	      (data is reduced and new data is assumed to be available)
              
  |;
exit;
}
;

############### S I G N A L  H A N D L E R S ###########################
#
# signals and perl variables
$|=1;					# make unbuffered
#
$SIG{'INT'} = \&orac_exit_abnormally;
#$SIG{'PIPE'} = \&orac_exit_abnormally;
$SIG{'PIPE'} = sub {};

#########################  ORAC DR Configuration #######################
#
# constants - for the module
#
# Check for ORAC_DIR
unless (exists $ENV{ORAC_DIR}) {
  orac_err("ORAC_DIR environment variable not defined. Aborting.");
  &orac_exit_normally;
}

$orac_dir = $ENV{ORAC_DIR} . "/";	# main orac directory (contains bin)
$recipe_dir = $orac_dir."recipes/$instrument/";	# recipes
$dictionary_dir = $orac_dir . "primitives/$instrument/"; # primitives

######################## Change to Output directory ####################

if (exists $ENV{ORAC_DATA_OUT}) {

  # change to output  dir
  chdir($ENV{ORAC_DATA_OUT}) || 
    do { 
      orac_err("Could not change directory to ORAC_DATA_OUT: $!");
      &orac_exit_normally;
    };

} else {
  orac_err("ORAC_DATA_OUT environment variable not set. Aborting");
  &orac_exit_normally;
}

#########################   U  T    D A T E #############################
# if no UT date has been provided, default to current.
#
!($opt_ut) && do {

  $opt_ut = utdate;

  orac_print ("Orac says: No UT date supplied, using $opt_ut\n","blue");

};


######################## M E S S A G E  SYSTEMS #############################

# Start the messaging system(s) and initialise them
# This routine creates and initialies the message systems.
# Also allows us to store the message objects since on
# undef everything goes away
(@messys) = start_msg_sys;


######################## A L G.   E N G I N E S #############################

# start algorithm engines
#
orac_print("ORAC says: Starting up monoliths...","blue");
#

%Mon = start_algorithm_engines;
$status = wait_for_algorithm_engines;

if ($status != ORAC__OK) {
  orac_err("Error contacting monoliths. Aborting.\n");
  orac_exit_normally;
}

orac_print ("Done\n","blue");




######################## I N I T  D I S P L A Y #############################
#
# launch display
# -nodisplay suppresses display,
#
if ($opt_nodisplay) {
  orac_print("Orac says: No display will be used\n","blue");
} else {

  orac_print ("Setting up display infrastructure (display tools will not be started until necessary)...", 'blue');
  &orac_setup_display;
  orac_print ("Done\n","blue");

}


######################## MESSYS CONFIG #############################
# Messaging system seems to be working okay so configure it.
# Now we set our overrides to the messaging systems.
# Dont do this earlier since we dont want to wait 600 seconds for
# a timeout to find that we couldn't even talk to a monolith

foreach my $msg (@messys) {

  # -quiet option supresses Starlink non-error messages
  ($opt_quiet) && ($msg->messages(0));
  $msg->timeout(600);	# task timeout
  $msg->paramrep(sub {print "xxx";return "!!"});

}

######################## ORAC PRINT #############################

if ($opt_debug) {
  $print = new ORAC::Print;
  $print->debugmsg(1);
  $fh = new IO::File(">ORACDR.DEBUG");
  $print->debughdl($fh);
};


######################## C A L I B R A T I O N #############################

# Create calibration object
$Cal = new $calobject;

#
# Calibration frame overrides
#
  
if (defined $opt_calib) {
  
  %calibs = parse_keyvalues($opt_calib);

  foreach $key (keys %calibs) {

    if ($Cal->can($key)) {		# set appropriate method

      $Cal->$key($calibs{$key});

# if we have a noupdate method to enforce overrides, use it.
      my $noupdate = $key."noupdate";
      $Cal->$noupdate(1) if $Cal->can($noupdate);

      orac_print("ORAC says: Calibration $key set to $calibs{$key}\n","blue");

    } else {				# complain but continue

      orac_err ("Calibration $key unknown by this instrument. Ignored\n");

    };
  };

};

############################# L O O P I N G  S C H E M E ###############
# Decide on a looping scheme

$loop = "orac_loop_list"; # Default is too use list to cycle through obs
if (defined $opt_loop) {
  $loop = "orac_loop_" . $opt_loop;
}

# Read recipe name
$Override_Recipe = shift(@ARGV); # this will default to the RECIPE File method



############## Process argument list ###############################3
# Generate list of observation numbers to be processed
 
if (defined $opt_from) {

  if (defined $opt_to) {
    @obs = $opt_from .. $opt_to
  } else {
    @obs = ($opt_from);  # Used for data detection loops etc
  }
 
} elsif (defined $opt_list) {

  @obs = parse_obslist($opt_list);

}


################# D A T A   L O O P ###############################
# Loop forever

while (1) {

# foreach $obsno (@obs) {
  #------------------------------------------------------------------------
  #

  # Return back the current frame
  # This will also configure the frame object
  $Frm = &{$loop}($frameobject, $opt_ut, \@obs);

  # If frame is undefined then we assume that the data loop
  # should be stopped
  last unless defined $Frm;

  orac_print ("REDUCING: ".$Frm->raw."\n","yellow");
  
  # query Frame for its group
  
  $grpname = $Frm->group;
  
  # create a new group object and remove the previous file
  # unless such an object already exists
  # note that the "existence" of this group is only meaningful
  # over the lifetime of the pipeline
  
  do {
    
    $Grp = new $groupobject($grpname);
    $Grp->file($Grp->file_from_bits($opt_ut, $Frm->number));
    unlink($Grp->file); # wont work since .sdf is not included
    $Groups{$grpname} = $Grp;		# store group object
    orac_print ("A new group ".$Grp->file." has been created\n","blue");

  } unless (exists $Groups{$grpname});

  # Select current group
  $Grp = $Groups{$grpname};

  # push current Frame onto Group

  $Grp->push($Frm);
  orac_print ("This observation is part of group ".$Grp->file."\n","blue");

  # let the calibration object know what thing it is using (to determine
  # suitability etc. In this case we do it on a frame-by-frame basis, so
  # we pass it the header hash of the current frame

  $Cal->thing($Frm->header);

  #
  # at this point the recipe method should be queried if it hasn't
  # been explicitly set
  # Query frame for a recipe
  my $frmrecipe = $Frm->recipe;

  # KLUDGE: If recipe is not defined take the one specified on the command
  # Line. Else use the one instructed by the frame.
  # This needs to be changed such that we override all recipes except for
  # calibrators
  if ($frmrecipe !~ /./) {
    $Recipe = $Override_Recipe;
  } else {
    $Recipe = $frmrecipe;
  }


  # Read in the selected recipe  
  @recipe = orac_read_recipe($Recipe);	# read recipe
  
  while (grep /^\s*_/,@recipe) {	# while it contains other recipes
    @recipe = orac_parse_recipe(@recipe); # keep parsing recipes
  };

  # Now that the recipe is parsed, insert code for automatic error
  # checking, etc

  @recipe = orac_add_code_to_recipe(@recipe);
  
  $oracref = orac_execute_recipe(\@recipe,$Frm,$Grp,$Cal); # execute parsed recipe

  # delete symlink to raw data file
  unlink($Frm->raw) if (-l $Frm->raw);


};				# end data loop




&orac_exit_normally;

# exit 


#------------------------------------------------------------------------

# $Log$
# Revision 1.37  1998/09/16 03:21:14  frossie
# Pick up recipes form inst-specific dirs
#
# Revision 1.36  1998/09/15 12:27:31  frossie
# Add CGS4 specific class modules
#
# Revision 1.35  1998/08/07 02:19:06  frossie
# Add -debug option
#
# Add orac_add_code_to_recipe call
#
# Revision 1.34  1998/07/10 02:43:55  frossie
# For UFTI, use UFTI Group subclass
#
# Revision 1.33  1998/07/09 03:52:03  timj
# Use new Display commands
#
# Revision 1.32  1998/07/08 23:21:05  timj
# Tidy up.
# Use orac_print
#
# Revision 1.31  1998/07/08 05:08:18  frossie
# Change UFTI section to use UFTI Frame subclass
#
# Revision 1.30  1998/07/08 04:39:23  frossie
# -h the loop option
#
# Revision 1.29  1998/07/08 03:49:32  timj
# Use different data detection loops
#
# Revision 1.28  1998/07/07 06:28:55  frossie
# Call noupdate method when a calibration has been specified in the
# command line
#
# Revision 1.27  1998/07/07 06:11:50  frossie
# Set current frame to calibration 'thing', against which to determine
# calibration suitability.
#
# Revision 1.26  1998/06/29 05:37:36  timj
# Add wait_for_algorithm_engines (reorganise to accomodate status checking).
#
# Revision 1.25  1998/06/29 05:25:16  frossie
# Use wait_for_algorithm_engines
#
# Revision 1.24  1998/06/29 03:56:09  frossie
# Bugfix: Make sure ORAC_PERL5LIB is really used.
#
# Revision 1.23  1998/06/29 03:21:11  frossie
# remove -dark and add general -calib option
#
# Revision 1.22  1998/06/28 01:10:46  frossie
# -ut option defaults to current UT date if unspecified
#
# Revision 1.21  1998/05/23 08:05:54  timj
# Read recipe from frame (or at least try to)
#
# Revision 1.20  1998/05/21 18:32:31  timj
# Left over 'exit' from my debugging efforts....
#
# Revision 1.19  1998/05/21 06:26:38  timj
# Add support for ranges in -list
#
# Revision 1.18  1998/05/19 01:45:41  timj
# Support file_from_bits() methods.
#
# Revision 1.17  1998/05/18 21:17:10  timj
# Add support for new organization of primitives directories.
#
# Revision 1.16  1998/05/08 18:41:13  timj
# Remove instrument specific definitions.
# Display is still hard-wired.
#
# Revision 1.15  1998/04/15 02:41:28  frossie
# Move ams_init to appropriate place
#
# Revision 1.14  1998/04/14 21:39:12  frossie
# Move data dir chdir prior to display launch
#
# Revision 1.13  1998/04/14 21:10:48  frossie
# Change explicit use of ADAMTASK modules to new ORAC::Msg classes.
#
# No longer need explicit exits from the messaging system as these are
# now performed when message objects are destroyed.
#
# Revision 1.12  1998/04/09 02:48:06  frossie
# Group filename changed to "rg" from "g"
#
# Revision 1.11  1998/04/04 06:45:31  frossie
# Introduce Frm Grp and Cal objects
#
# Revision 1.10  1998/04/01 23:09:12  frossie
# *** empty log message ***
#
# Revision 1.9  1998/03/17 18:54:23  frossie
# *** empty log message ***
#
# Revision 1.8  1998/03/16 19:07:28  frossie
# File::Copy and group filename prototype handling
#
# Revision 1.7  1998/03/16 04:07:57  frossie
# Add use of ANSI colour
#
# Revision 1.6  1998/02/25 11:25:50  frossie
# * oracdr: introduced Getopt for option handling
#
# Revision 1.5  1998/02/24 11:39:58  frossie
# More namespace fixing - Hdr and Mon now generally accessible. Risk of
# clobbering is probably worth the pain of enforcing ${main::Blah} to
# long-suffering primitive writers.
#
# Revision 1.4  1998/02/24 09:13:34  frossie
# Pipeline now does only basic control
#
# Revision 1.3  1998/02/20 06:43:55  frossie
# Static variables pulled out as shell ENVs.
#
# -nodisplay option supported
#
# Revision 1.2  1998/02/20 04:22:13  frossie
# Static variables pulled out as shell ENVs.
#
# Revision 1.1.1.1  1998/02/04 00:51:01  frossie
# Original version
#
# Revision 1.5  1997/11/25 06:46:57  frossie
# actually runs tasks. adam stuff not transparent.
#
# Revision 1.4  1997/11/22 01:04:35  frossie
# Variables passed down and back up
#
# Revision 1.3  1997/11/22 00:28:23  frossie
# Arguments propagate down
#
# Revision 1.2  1997/11/21 21:30:43  frossie
# Very simple version. Deals with recipes calling recipes.
#
# Revision 1.1  1997/11/21 21:29:43  frossie
# Initial revision
#


