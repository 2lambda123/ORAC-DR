#!/usr/local/bin/perl
#
# Change log is at the end of this file
#
# Usage: orac.pl <recipe_name>
#------------------------------------------------------------------------
# check for starlink login
# 

use ORAC::Basic;

&orac_exit_normally("No starlink login") unless exists $ENV{STAR_LOGIN};

# 
# general modules
#
use Carp;				# perl -MCarp=verbose for backtrace
use Term::ANSIColor;			# color output
use File::Copy;

# JAC and ORAC related modules
use NDF;				# to access NDF headers
use ORAC::Msg::ADAM::Control;		# messaging control for ADAM
use ORAC::Msg::ADAM::Task;		# monolith control for ADAM
use ORAC::Frame::UKIRT;			# Frame object methods
use ORAC::Group::UKIRT;			# Group object methods
use ORAC::Calib;			# Calibration object
#
# command line arguments
#

use Getopt::Long;

GetOptions("nodisplay","quiet!","dark=i","from=i","to=i","-ut=i","h");

($opt_h) && do {
print qq|

Usage:
  oracdr [-options] <recipe_name>

Arguments:
  <recipe_name>  a recipe to be executed

Options:

  -h         this help text
  -from      number of first observation
  -to        number of last observation
  -dark      number of dark observation
  -ut        UT date of observations
  -quiet     suppress engine messages
  -nodisplay do not launch display
  |;
exit;
}
;

#
# create message system object

$adam = new ORAC::Msg::ADAM::Control;

# -quiet option supresses Starlink non-error messages
($opt_quiet) && ($adam->messages(0));

# -nodisplay suppresses display,
#
print colored ("Orac says: No display will be used\n","blue") if ($opt_nodisplay);

#
# signals and perl variables
$|=1;					# make unbuffered
#
$SIG{'INT'} = \&orac_exit_abnormally;
$SIG{'PIPE'} = \&orac_exit_abnormally;
#
# constants - for the module
#
$orac_dir = $ENV{ORAC_DIR};		# main orac directory (contains bin)
$recipe_dir = $orac_dir."recipes/";	# recipes
$dictionary_dir = $orac_dir."primitives/"; # primitives
#
# constants - for the pipeline
#
$In = $ENV{ORAC_DATA_IN};		# source of data
$Out = $ENV{ORAC_DATA_OUT};	# data output
$Cal = $ENV{ORAC_AUX};		# auxiliarry data (calibration etc)
#
#
# various ADAM-related constants & parameters
#
# These will end up in the Orac::Messaging::ADAM module
#

$adam->timeout(30);	# task timeout
$ENV{'HDS_SCRATCH'} = "/tmp";           # fix ndf2fits (etc ?)  "feature"
$ENV{'ADAM_USER'} = "/tmp/adam$$";      # process-specific adam dir
#
# launch display
do {
print colored ("Orac says: Launching display...","blue");
&orac_launch_display;
sleep 10;
print colored ("Orac says: Done\n","blue");
} unless $opt_nodisplay;

#
  chdir($Out);				# change to output  dir
#

# start algorithm engines
#
print colored ("ORAC says: Starting up monoliths...","blue");
#
$adam->init;
&orac_connect_display unless ($opt_nodisplay);
#$Orac{Mon_p4} = new Starlink::ADAMTASK("33672p4",$ENV{CGS4DR_ROOT}."/p4");
#$Mon{red4} = new Starlink::ADAMTASK("red4_$$",$ENV{CGS4DR_ROOT}."/red4");
$Mon{photom_mon} = new ORAC::Msg::ADAM::Task("photom_mon_$$",$ENV{PHOTOM_DIR}."/photom_mon");
$Mon{figaro1} = new ORAC::Msg::ADAM::Task("figaro1_$$",$ENV{FIG_DIR}."/figaro1");
$Mon{ccdpack_red} = new ORAC::Msg::ADAM::Task("ccdpack_red_$$",$ENV{CCDPACK_DIR}."/ccdpack_red");
$Mon{ccdpack_res} = new ORAC::Msg::ADAM::Task("ccdpack_res_$$",$ENV{CCDPACK_DIR}."/ccdpack_res");
$Mon{ccdpack_reg} = new ORAC::Msg::ADAM::Task("ccdpack_reg_$$",$ENV{CCDPACK_DIR}."/ccdpack_reg");
$Mon{kappa_mon} = new ORAC::Msg::ADAM::Task("kappa_mon_$$",$ENV{KAPPA_DIR}."/kappa_mon");
$Mon{kappa_mon}->contactw;	# wait for last monolith
#$Mon{red4}->obeyw("set_verbose","verbose=TRUE");

print colored ("Done\n","blue");
#
#------------------------------------------------------------------------
# Data detection loop goes here
#------------------------------------------------------------------------
#
$Recipe = shift(@ARGV);			# this will default to the RECIPE File method
#@objects=();
#$isuffix = "";
$Root = "ro".$opt_ut.'_';
$Tail = ".sdf";
$Groot = "rg".$opt_ut.'_';
#$GFile = $Groot.$opt_from;
#unlink ($GFile);

$Cal = new ORAC::Calib;

# temprary fudge
$Cal->dark("ro970815_9_bp_db");

foreach $obsno ($opt_dark,$opt_from..$opt_to) {
  #------------------------------------------------------------------------
  #
  # %Orac holds key=value pairs relevant to data reduction
  #
  
  $File = $Root.$obsno.$Tail;		# temporary fudge
  
  # temporary solution ? Create symbolic link in output directory
  # pointing to raw data file this or a similar strategy is needed to
  # preserve order-stupidity on the part of the primitives

  symlink($In.$File,$File);

  # create Frame object (this also populates the header and so on)
  # file must be accessible from current directory by now

  $Frm = new ORAC::Frame::UKIRT($File);
  
  print colored ("REDUCING: ".$Frm->raw."\n","yellow");
  
  # query Frame for its group
  
  $grpnum = $Frm->group;
  
  # create a new group object and remove the previous file
  # unless such an object already exists
  # note that the "existence" of this group is only meaningful
  # over the lifetime of the pipeline
  
  do {
    

    $Grp = new ORAC::Group::UKIRT($grpnum);
    $gfile = $Groot.$grpnum;		# temprary fudge
    $Grp->file($gfile);
    unlink($Grp->file);
    $Groups{$grpnum} = $Grp;		# store group object
    print colored ("A new group ".$Grp->file." has been created\n","blue");

  } unless (exists $Groups{$grpnum});

  # push current Frame onto Group

  $Grp->push($Frm);
  print colored ("This observation is part of group ".$Grp->file."\n","blue");



  #
  # at this point the recipe method should be queried if it hasn't
  # been explicitly set
  
  @recipe = orac_read_recipe($Recipe);	# read recipe
  
  while (grep /^\s*_/,@recipe) {	# while it contains other recipes
    @recipe = orac_parse_recipe(@recipe); # keep parsing recipes
  };
  

  $oracref = orac_execute_recipe(\@recipe,$Frm,$Grp,$Cal); # execute parsed recipe

  # delete symlink to raw data file
  unlink($Frm->raw) if (-l $Frm->raw);


};				# end data loop




&orac_exit_normally;

# exit 


#------------------------------------------------------------------------

# $Log$
# Revision 1.13  1998/04/14 21:10:48  frossie
# Change explicit use of ADAMTASK modules to new ORAC::Msg classes.
#
# No longer need explicit exits from the messaging system as these are
# now performed when message objects are destroyed.
#
# Revision 1.12  1998/04/09 02:48:06  frossie
# Group filename changed to "rg" from "g"
#
# Revision 1.11  1998/04/04 06:45:31  frossie
# Introduce Frm Grp and Cal objects
#
# Revision 1.10  1998/04/01 23:09:12  frossie
# *** empty log message ***
#
# Revision 1.9  1998/03/17 18:54:23  frossie
# *** empty log message ***
#
# Revision 1.8  1998/03/16 19:07:28  frossie
# File::Copy and group filename prototype handling
#
# Revision 1.7  1998/03/16 04:07:57  frossie
# Add use of ANSI colour
#
# Revision 1.6  1998/02/25 11:25:50  frossie
# * oracdr: introduced Getopt for option handling
#
# Revision 1.5  1998/02/24 11:39:58  frossie
# More namespace fixing - Hdr and Mon now generally accessible. Risk of
# clobbering is probably worth the pain of enforcing ${main::Blah} to
# long-suffering primitive writers.
#
# Revision 1.4  1998/02/24 09:13:34  frossie
# Pipeline now does only basic control
#
# Revision 1.3  1998/02/20 06:43:55  frossie
# Static variables pulled out as shell ENVs.
#
# -nodisplay option supported
#
# Revision 1.2  1998/02/20 04:22:13  frossie
# Static variables pulled out as shell ENVs.
#
# Revision 1.1.1.1  1998/02/04 00:51:01  frossie
# Original version
#
# Revision 1.5  1997/11/25 06:46:57  frossie
# actually runs tasks. adam stuff not transparent.
#
# Revision 1.4  1997/11/22 01:04:35  frossie
# Variables passed down and back up
#
# Revision 1.3  1997/11/22 00:28:23  frossie
# Arguments propagate down
#
# Revision 1.2  1997/11/21 21:30:43  frossie
# Very simple version. Deals with recipes calling recipes.
#
# Revision 1.1  1997/11/21 21:29:43  frossie
# Initial revision
#
