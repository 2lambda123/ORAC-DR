#!/usr/local/bin/perl
#
# Change log is at the end of this file
#
# Usage: oracdr <recipe_name>
#------------------------------------------------------------------------
# check for starlink login
# 

# Predeclare subroutines that are read in after 
# the standard perl pre-processing (ie modules included
# via an eval)
use subs qw(start_msg_sys start_algorithm_engines wait_for_algorithm_engines);

# Make sure we catch as many signals as possible
# so that the END{} blocks work correctly and tidy up
use sigtrap qw/die normal-signals error-signals/;


use lib $ENV{ORAC_PERL5LIB};
use ORAC::Basic;    # Recipe parsing/execution routines
use ORAC::General;
use ORAC::Loop;     # Loop control
use ORAC::Print;    # Printing messages or errors
use ORAC::Core;     # Core pipeline routines

&orac_exit_normally("No starlink login") unless exists $ENV{STAR_LOGIN};

# 
# general modules
#
use Carp;				# perl -MCarp=verbose for backtrace
use Term::ANSIColor;			# color output
use File::Copy;
use Getopt::Long;                       # command line arguments

# Need to determine module list from the ORAC_INSTRUMENT
# environment variable before we can include certain modules.

# Simply exit if the environment variable is not set.
unless (exists $ENV{ORAC_INSTRUMENT}) {
  orac_err("No intrument specified in \$ORAC_INSTRUMENT. Please set to one of IRCAM, UFTI, SCUBA\n");
  exit;
}

$instrument = uc($ENV{ORAC_INSTRUMENT});

if ($instrument eq 'IRCAM') {
  $groupobject = "ORAC::Group::UKIRT";
  $frameobject = "ORAC::Frame::UKIRT";
  $calobject   = "ORAC::Calib::IRCAM";
  $instmodule  = "ORAC::Inst::IRCAM";
} elsif ($instrument eq 'UFTI') {
  $groupobject = "ORAC::Group::UFTI";
  $frameobject = "ORAC::Frame::UFTI";
  $calobject   = "ORAC::Calib::IRCAM";
  $instmodule  = "ORAC::Inst::IRCAM";
} elsif ($instrument eq 'CGS4') {
  $groupobject = "ORAC::Group::UKIRT";
  $frameobject = "ORAC::Frame::CGS4";
  $calobject   = "ORAC::Calib::CGS4";
  $instmodule  = "ORAC::Inst::CGS4";
} elsif ($instrument eq 'SCUBA') {
  $groupobject = "ORAC::Group::JCMT";
  $frameobject = "ORAC::Frame::JCMT";
  $calobject   = "ORAC::Calib::SCUBA";
  $instmodule  = "ORAC::Inst::SCUBA";
} else {
  orac_err("Instrument $instrument is not currently supported in ORACDR\n");
  exit;
}


# Read in the instrument specific modules
eval "use $groupobject;";
die "Error importing $groupobject:\n$@\n" if ($@);
eval "use $frameobject;";
die "Error importing $frameobject:\n$@\n" if ($@);
eval "use $calobject;";
die "Error importing $calobject:\n$@\n" if ($@);
eval "use $instmodule;";
die "Error importing $instmodule:\n$@\n" if ($@);




#
# command line arguments
#

my $status = GetOptions("nodisplay","debug!","quiet!","calib=s","from=i","to=i","ut=i","list=s","loop=s","h","batch","skip","noeng");

($opt_h) && do {
print qq|

Usage:
  oracdr [-options] <recipe_name>

Arguments:
  <recipe_name>  a recipe to be executed

Options:

  These options may be abbreviated to a unique substring.

  -h         this help text
  -quiet     suppress engine messages
  -debug     log debug messages to ORACDR.DEBUG
  -nodisplay do not launch display

  -from      number of first observation
  -to        number of last observation
  -list      comma separated list of object *numbers*
             Colons indicate a range (1,2,3:5,10 means 1,2,3,4,5,10)


  -ut        UT date of observations (defaults to current yyyymmdd)
  -calib     comma seperated key=value pairs (eg. -cal dark=file1 or
             -cal dark=file1,bias=file2) of calibration *files*
  -loop      Type of data detection loop: list, inf, or wait
             -loop list is equivalent to not using a loop at all
              (only data specified is reduced)
             -loop wait waits for data to appear before timing out
	      (data is reduced and we wait for new data)
             -loop inf does not wait for data 
	      (data is reduced and new data is assumed to be available)
             -loop flag waits for completion files to appear before
              procesing (data is reduced and we wait for new data
	      via the flag)
  -batch     Run in batch mode. Precalculate groups before proceesing
             data. 'wait' loop mode should not be used with this option.
  -skip      Allow the data detection loop to skip missing observations.
             Default is to stop the loop when a expected file
	     can not be found.
  -noeng     Do not start algorithm engines. Note: this will cause 
             the vast majority of recipes to fail.

  |;
exit;
}
;

############### S I G N A L  H A N D L E R S ###########################
#
# signals and perl variables
$|=1;					# make unbuffered
#
$SIG{'INT'} = \&orac_exit_abnormally;
#$SIG{'PIPE'} = \&orac_exit_abnormally;
$SIG{'PIPE'} = 'IGNORE';

#########################  ORAC DR Configuration #######################
#
# constants - for the module
#
# Check for ORAC_DIR
unless (exists $ENV{ORAC_DIR}) {
  orac_err("ORAC_DIR environment variable not defined. Aborting.");
  &orac_exit_normally;
}

$orac_dir = $ENV{ORAC_DIR} . "/";	# main orac directory (contains bin)

######################## Change to Output directory ####################

if (exists $ENV{ORAC_DATA_OUT}) {

  # change to output  dir
  chdir($ENV{ORAC_DATA_OUT}) || 
    do { 
      orac_err("Could not change directory to ORAC_DATA_OUT: $!");
      &orac_exit_normally;
    };

} else {
  orac_err("ORAC_DATA_OUT environment variable not set. Aborting");
  &orac_exit_normally;
}

#########################   U  T    D A T E #############################
# if no UT date has been provided, default to current.
#
!($opt_ut) && do {

  $opt_ut = utdate;

  orac_print ("Orac says: No UT date supplied, using $opt_ut\n","blue");

};


######################## M E S S A G E  SYSTEMS #############################

# Start the messaging system(s) and initialise them
# This routine creates and initialies the message systems.
# Also allows us to store the message objects since on
# undef everything goes away
(@messys) = start_msg_sys;


######################## A L G.   E N G I N E S #############################


unless ($opt_noeng) {
  
  # start algorithm engines
  #
  orac_print("ORAC says: Starting up monoliths...","blue");
  #
  
  %Mon = start_algorithm_engines;
  $status = wait_for_algorithm_engines;
  
  if ($status != ORAC__OK) {
    orac_err("Error contacting monoliths. Aborting.\n");
    orac_exit_normally;
  }
  
  orac_print ("Done\n","blue");
  
} else {
  
  orac_print("Orac says: No algorithm engines will be started (-noeng option)\n","blue");

}



######################## I N I T  D I S P L A Y #############################
#
# launch display
# -nodisplay suppresses display,
#
if ($opt_nodisplay) {
  orac_print("Orac says: No display will be used\n","blue");
} else {

  orac_print ("Setting up display infrastructure (display tools will not be started until necessary)...", 'blue');
  &orac_setup_display;
  orac_print ("Done\n","blue");

}


######################## MESSYS CONFIG #############################
# Messaging system seems to be working okay so configure it.
# Now we set our overrides to the messaging systems.
# Dont do this earlier since we dont want to wait 600 seconds for
# a timeout to find that we couldn't even talk to a monolith

foreach my $msg (@messys) {

  # -quiet option supresses Starlink non-error messages
  ($opt_quiet) && ($msg->messages(0));
  $msg->timeout(600);	# task timeout
  $msg->paramrep(sub {print "xxx";return "!!"});

}

######################## ORAC PRINT #############################

if ($opt_debug) {
  $print = new ORAC::Print;
  $print->debugmsg(1);
  $fh = new IO::File(">ORACDR.DEBUG");
  $print->debughdl($fh);
};


######################## C A L I B R A T I O N #############################

# Create calibration object
$Cal = new $calobject;

#
# Calibration frame overrides
#
  
if (defined $opt_calib) {
  
  %calibs = parse_keyvalues($opt_calib);

  foreach $key (keys %calibs) {

    if ($Cal->can($key)) {		# set appropriate method

      $Cal->$key($calibs{$key});

# if we have a noupdate method to enforce overrides, use it.
      my $noupdate = $key."noupdate";
      $Cal->$noupdate(1) if $Cal->can($noupdate);

      orac_print("ORAC says: Calibration $key set to $calibs{$key}\n","blue");

    } else {				# complain but continue

      orac_err ("Calibration $key unknown by this instrument. Ignored\n");

    };
  };

};


############## Process argument list ###############################3
# Generate list of observation numbers to be processed
# This is related to looping scheme

$loop = 'orac_loop_list'; # Default loop scheme unless -from 

if (defined $opt_from) {

  if (defined $opt_to) {
    @obs = $opt_from .. $opt_to
  } else {

    # If the skip flag is set to true we can turn the -from..end 
    # loop into 'list' loop by determining the last observation number.
    # For historical reasons, the inf loop should be used if the -skip
    # option is false.

    if ($opt_skip) {
      my ($next, $high) = orac_check_data_dir($frameobject, $opt_from, 0);
      if (defined $high) {
	@obs = ($opt_from..$high);
      } else {
	# High not defined -- a problem has occured.
	# Probably should abort
	orac_err("The -from option was used even though no data exists above the selected observation number [$opt_from].");
	orac_exit_normally;
      }

    } else {

      @obs = ($opt_from);  # Used for data detection loops etc

      # Set default loop scheme to 'inf'
      # if there is no 'to' and 'skip' is false.
      $loop = 'orac_loop_inf';

    }

    orac_print "Starting at observation $opt_from and looping until no files available\n"
  }
 
} elsif (defined $opt_list) {

  @obs = parse_obslist($opt_list);

} elsif (defined $opt_to) {
  # This catches the case where -to is defined but no -from or -list
  # Start counting at 1
  orac_print "Processing observations 1 to $opt_to\n";
  @obs = (1..$opt_to);

} else {
  # Okay - none of -from, -list or -to were defined
  # We default to 1 in this case and set the loop to wait
  # Note that loop will be overriden if -loop is supplied
  orac_print "No observation numbers supplied - starting from obs 1\n";
  $loop = 'orac_loop_wait';
  @obs = (1);

}

############################# L O O P I N G  S C H E M E ###############
# Decide on a looping scheme

$loop = "orac_loop_" . $opt_loop if defined $opt_loop;


# Read recipe name
$Override_Recipe = shift(@ARGV); # this will default to the RECIPE File method





################# D A T A   L O O P ###############################
# 
# There are two approaches to the data processing:
#
# 1 - The default processing method where data are read in 
#     and processed as it arrives and Groups are extended as needed.
#     This has the advantage that the data is processed as it is
#     taken, has very good feedback to the user in real time. The down
#     side is that Groups are processed as soon as possible and in an
#     off-line batch processing envrionment this is very wasteful
#     (why work out the flatfield every time a frame arrives when you
#     simply want to work out the flatfield from the entire group).
# 2 - The 'batch' method where the data are analysed in two passes.
#     First the groups are setup, secondly the frames are processed in
#     each group in turn. This has the advantage that frames can be coadded
#     into a group only once and is the most efficient way of processing
#     data off-line. Note that this presupposes that the primitives are
#     written in such a way that they can spot the last member of the group
#     (via the lastmember method). Grp Primitives without this check will
#     probably fail since the some of the members will not have been 
#     processed even though the group contains many members.
#     One other issue is
#     calibration -- in principal all calibration groups should be processed
#     before observation groups and currently this is not supported.
#     (only important when calibrations are taken after the observation).
#
#     Batch mode can be summarised as
#       - Read in all frames and allocate groups
#       - Loop over all groups
#            Loop over all frames in group
#               process frames
#
#    Default mode is
#      - Loop over all frames
#         - Allocate groups
#            - process frames

#   Batch mode can be turned on with the -batch switch.
#   


# Default is to process data in order of arrival
unless ($opt_batch) {

  # Loop forever
  %Groups = ();

  while (1) {

    # Return back the current frame
    # This will also configure the frame object
    $Frm = &{$loop}($frameobject, $opt_ut, \@obs, $opt_skip);

    # If frame is undefined then we assume that the data loop
    # should be stopped
    last unless defined $Frm;

    orac_print ("REDUCING: ".$Frm->raw."\n","yellow");
  
    # Store the Frame in the Group
    $Grp = orac_store_frm_in_correct_grp($Frm, $groupobject, \%Groups, undef, 
				      $opt_ut);

    # Actually process the observation
    orac_process_frame($Frm, $Grp, $Cal, $Override_Recipe, $instrument);


  }

} else {
  # Batch mode

  # Set the flag in the namespace used by the recipes
  # so that the recipes know we are in batch mode.
  $ORAC::Basic::Batch = 1;

  # First loop over frames
  @Groups = ();
  %Groups = ();

  while (1) {
    # Return back the current frame
    # This will also configure the frame object
    $Frm = &{$loop}($frameobject, $opt_ut, \@obs, $opt_skip);

    # If frame is undefined then we assume that the data loop
    # should be stopped
    last unless defined $Frm;

    orac_print ("Storing: ".$Frm->raw."\n","yellow");
  
    # Store the Frame in the Group
    orac_store_frm_in_correct_grp($Frm, $groupobject, \%Groups, \@Groups, 
				  $opt_ut);

  }

  # Now loop over groups and frames
  foreach $Grp (@Groups) {
    foreach $Frm ($Grp->members) {
      # Actually process the observation
      orac_print ("REDUCING: ".$Frm->raw."\n","yellow");
      orac_process_frame($Frm, $Grp, $Cal, $Override_Recipe, $instrument);
    }
  }


}

&orac_exit_normally;

# exit 

#------------------------------------------------------------------------

# $Log$
# Revision 1.46  1999/02/23 00:32:48  frossie
# Change in instrument imported methods
#
# Revision 1.45  1999/02/18 03:10:44  timj
# Set Batch variable in ORAC::Basic
#
# Revision 1.44  1998/12/12 04:00:24  frossie
# Added -noeng option (does not start algorthm engines)
#
# Revision 1.43  1998/10/01 22:55:10  timj
# Add the -skip option
#
# Revision 1.42  1998/09/25 03:35:31  timj
# Add -batch option.
# Remove data processing routines to ORAC::Core
#
# Revision 1.41  1998/09/23 23:42:48  frossie
# Take out some print debug lines.
#
# Revision 1.40  1998/09/17 19:00:27  timj
# - Add support for just using -to option.
# - Set default behaviour when neither -list, -from nor -to are specified.
#
# Revision 1.39  1998/09/17 04:06:51  timj
# Ignore SIGPIPE rather than assigning a null sub
#
# Revision 1.38  1998/09/17 03:32:05  timj
# - Change recipe parsing so that it handles array references
# - Fix -from behaviour looping
# - use sigtrap so that we can try to trap most signals
#
# Revision 1.37  1998/09/16 03:21:14  frossie
# Pick up recipes form inst-specific dirs
#
# Revision 1.36  1998/09/15 12:27:31  frossie
# Add CGS4 specific class modules
#
# Revision 1.35  1998/08/07 02:19:06  frossie
# Add -debug option
#
# Add orac_add_code_to_recipe call
#
# Revision 1.34  1998/07/10 02:43:55  frossie
# For UFTI, use UFTI Group subclass
#
# Revision 1.33  1998/07/09 03:52:03  timj
# Use new Display commands
#
# Revision 1.32  1998/07/08 23:21:05  timj
# Tidy up.
# Use orac_print
#
# Revision 1.31  1998/07/08 05:08:18  frossie
# Change UFTI section to use UFTI Frame subclass
#
# Revision 1.30  1998/07/08 04:39:23  frossie
# -h the loop option
#
# Revision 1.29  1998/07/08 03:49:32  timj
# Use different data detection loops
#
# Revision 1.28  1998/07/07 06:28:55  frossie
# Call noupdate method when a calibration has been specified in the
# command line
#
# Revision 1.27  1998/07/07 06:11:50  frossie
# Set current frame to calibration 'thing', against which to determine
# calibration suitability.
#
# Revision 1.26  1998/06/29 05:37:36  timj
# Add wait_for_algorithm_engines (reorganise to accomodate status checking).
#
# Revision 1.25  1998/06/29 05:25:16  frossie
# Use wait_for_algorithm_engines
#
# Revision 1.24  1998/06/29 03:56:09  frossie
# Bugfix: Make sure ORAC_PERL5LIB is really used.
#
# Revision 1.23  1998/06/29 03:21:11  frossie
# remove -dark and add general -calib option
#
# Revision 1.22  1998/06/28 01:10:46  frossie
# -ut option defaults to current UT date if unspecified
#
# Revision 1.21  1998/05/23 08:05:54  timj
# Read recipe from frame (or at least try to)
#
# Revision 1.20  1998/05/21 18:32:31  timj
# Left over 'exit' from my debugging efforts....
#
# Revision 1.19  1998/05/21 06:26:38  timj
# Add support for ranges in -list
#
# Revision 1.18  1998/05/19 01:45:41  timj
# Support file_from_bits() methods.
#
# Revision 1.17  1998/05/18 21:17:10  timj
# Add support for new organization of primitives directories.
#
# Revision 1.16  1998/05/08 18:41:13  timj
# Remove instrument specific definitions.
# Display is still hard-wired.
#
# Revision 1.15  1998/04/15 02:41:28  frossie
# Move ams_init to appropriate place
#
# Revision 1.14  1998/04/14 21:39:12  frossie
# Move data dir chdir prior to display launch
#
# Revision 1.13  1998/04/14 21:10:48  frossie
# Change explicit use of ADAMTASK modules to new ORAC::Msg classes.
#
# No longer need explicit exits from the messaging system as these are
# now performed when message objects are destroyed.
#
# Revision 1.12  1998/04/09 02:48:06  frossie
# Group filename changed to "rg" from "g"
#
# Revision 1.11  1998/04/04 06:45:31  frossie
# Introduce Frm Grp and Cal objects
#
# Revision 1.10  1998/04/01 23:09:12  frossie
# *** empty log message ***
#
# Revision 1.9  1998/03/17 18:54:23  frossie
# *** empty log message ***
#
# Revision 1.8  1998/03/16 19:07:28  frossie
# File::Copy and group filename prototype handling
#
# Revision 1.7  1998/03/16 04:07:57  frossie
# Add use of ANSI colour
#
# Revision 1.6  1998/02/25 11:25:50  frossie
# * oracdr: introduced Getopt for option handling
#
# Revision 1.5  1998/02/24 11:39:58  frossie
# More namespace fixing - Hdr and Mon now generally accessible. Risk of
# clobbering is probably worth the pain of enforcing ${main::Blah} to
# long-suffering primitive writers.
#
# Revision 1.4  1998/02/24 09:13:34  frossie
# Pipeline now does only basic control
#
# Revision 1.3  1998/02/20 06:43:55  frossie
# Static variables pulled out as shell ENVs.
#
# -nodisplay option supported
#
# Revision 1.2  1998/02/20 04:22:13  frossie
# Static variables pulled out as shell ENVs.
#
# Revision 1.1.1.1  1998/02/04 00:51:01  frossie
# Original version
#
# Revision 1.5  1997/11/25 06:46:57  frossie
# actually runs tasks. adam stuff not transparent.
#
# Revision 1.4  1997/11/22 01:04:35  frossie
# Variables passed down and back up
#
# Revision 1.3  1997/11/22 00:28:23  frossie
# Arguments propagate down
#
# Revision 1.2  1997/11/21 21:30:43  frossie
# Very simple version. Deals with recipes calling recipes.
#
# Revision 1.1  1997/11/21 21:29:43  frossie
# Initial revision
#


