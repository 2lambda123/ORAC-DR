#!/usr/local/bin/perl
#
# Change log is at the end of this file
#
# Usage: orac.pl <recipe_name>
#------------------------------------------------------------------------
# check for starlink login
# 

use ORAC::Basic;

&orac_exit_normally("No starlink login") unless exists $ENV{STAR_LOGIN};

# 
# modules
#
use Carp;				# perl -MCarp=verbose for backtrace
use NDF;				# to access NDF headers
use Starlink::ADAMTASK;			# monolith access
use Term::ANSIColor;			# color output

#
# command line arguments
#

use Getopt::Long;

GetOptions("nodisplay","quiet!","dark=i","from=i","to=i","-ut=i","h");

($opt_h) && do {
print qq|

Usage:
  oracdr [-options] <recipe_name>

Arguments:
  <recipe_name>  a recipe to be executed

Options:

  -h         this help text
  -from      number of first observation
  -to        number of last observation
  -dark      number of dark observation
  -ut        UT date of observations
  -quiet     suppress engine messages
  -nodisplay do not launch display
  |;
exit;
}
;


# -quiet option supresses Starlink non-error messages
($opt_quiet) && ($Starlink::ADAMTASK::msg_hide = 1);

# -nodisplay suppresses display,
#
print colored ("Orac says: No display will be used\n","blue") if ($opt_nodisplay);

#
# signals and perl variables
$|=1;					# make unbuffered
#
$SIG{'INT'} = \&orac_exit_abnormally;
$SIG{'PIPE'} = \&orac_exit_abnormally;
#
# constants - for the module
#
$orac_dir = $ENV{ORAC_DIR};		# main orac directory (contains bin)
$recipe_dir = $orac_dir."recipes/";	# recipes
$dictionary_dir = $orac_dir."primitives/"; # primitives
#
# constants - for the pipeline
#
$In = $ENV{ORAC_DATA_IN};		# source of data
$Out = $ENV{ORAC_DATA_OUT};	# data output
$Cal = $ENV{ORAC_AUX};		# auxiliarry data (calibration etc)
#
chdir($Out);
#
# various ADAM-related constants & parameters
#
# These will end up in the Orac::Messaging::ADAM module
#

$Starlink::ADAMTASK::TIMEOUT = 30;	# task timeout
$ENV{'HDS_SCRATCH'} = "/tmp";           # fix ndf2fits (etc ?)  "feature"
$ENV{'ADAM_USER'} = "/tmp/adam$$";      # process-specific adam dir
#
# launch display
do {
print colored ("Orac says: Launching display...","blue");
&orac_launch_display;
sleep 10;
print colored ("Orac says: Done\n","blue");
} unless $opt_nodisplay;

#

#

# start algorithm engines
#
print colored ("ORAC says: Starting up monoliths...","blue");
#
adamtask_init;
&orac_connect_display unless ($opt_nodisplay);
#$Orac{Mon_p4} = new Starlink::ADAMTASK("33672p4",$ENV{CGS4DR_ROOT}."/p4");
$Mon{ccdpack_red} = new Starlink::ADAMTASK("ccdpack_red_$$",$ENV{CCDPACK_DIR}."/ccdpack_red");
$Mon{ccdpack_res} = new Starlink::ADAMTASK("ccdpack_res_$$",$ENV{CCDPACK_DIR}."/ccdpack_res");
$Mon{ccdpack_reg} = new Starlink::ADAMTASK("ccdpack_reg_$$",$ENV{CCDPACK_DIR}."/ccdpack_reg");
$Mon{kappa_mon} = new Starlink::ADAMTASK("kappa_mon_$$",$ENV{KAPPA_DIR}."/kappa_mon");
$Mon{kappa_mon}->contactw;	# wait for last monolith
print "Done\n";
#
#------------------------------------------------------------------------
# Data detection loop goes here
#------------------------------------------------------------------------
#
$Recipe = shift(@ARGV);
@objects=();
$isuffix = "";
$Root = "ro".$opt_ut.'_';
foreach $obsno ($opt_dark,$opt_from..$opt_to) {
#------------------------------------------------------------------------
#
# %Orac holds key=value pairs relevant to data reduction
#
# we expect to get these two from the header
$File = $Root.$obsno;
#
#  Read the FITS header of the file and take a copy
#
$file = $In.$File;
($headerref, $status) = fits_read_header($file);
%Header = %$headerref;

#
# Make sure that we successfully read a header
# In the future we will use the concept of good ORAC status rather than stealing from
# Starlink
#
# Once we are in a BIG LOOP this will probably print the warning and do a 'next'
#

if ($status != &NDF::SAI__OK) {

  print "Bad status from header extraction...exiting\n";
  &orac_exit_normally;
}

#
#
@recipe = ();
@recipe = orac_read_recipe($Recipe);	# read recipe

while (grep /^\s*_/,@recipe) {		# while it contains other recipes
  @recipe = orac_parse_recipe(@recipe);	# keep parsing recipes
};

$oracref = orac_execute_recipe(\@recipe,\%Orac);	# execute parsed recipe

};				# end data loop


&orac_exit_normally;

# exit 


#------------------------------------------------------------------------

# $Log$
# Revision 1.7  1998/03/16 04:07:57  frossie
# Add use of ANSI colour
#
# Revision 1.6  1998/02/25 11:25:50  frossie
# * oracdr: introduced Getopt for option handling
#
# Revision 1.5  1998/02/24 11:39:58  frossie
# More namespace fixing - Hdr and Mon now generally accessible. Risk of
# clobbering is probably worth the pain of enforcing ${main::Blah} to
# long-suffering primitive writers.
#
# Revision 1.4  1998/02/24 09:13:34  frossie
# Pipeline now does only basic control
#
# Revision 1.3  1998/02/20 06:43:55  frossie
# Static variables pulled out as shell ENVs.
#
# -nodisplay option supported
#
# Revision 1.2  1998/02/20 04:22:13  frossie
# Static variables pulled out as shell ENVs.
#
# Revision 1.1.1.1  1998/02/04 00:51:01  frossie
# Original version
#
# Revision 1.5  1997/11/25 06:46:57  frossie
# actually runs tasks. adam stuff not transparent.
#
# Revision 1.4  1997/11/22 01:04:35  frossie
# Variables passed down and back up
#
# Revision 1.3  1997/11/22 00:28:23  frossie
# Arguments propagate down
#
# Revision 1.2  1997/11/21 21:30:43  frossie
# Very simple version. Deals with recipes calling recipes.
#
# Revision 1.1  1997/11/21 21:29:43  frossie
# Initial revision
#
