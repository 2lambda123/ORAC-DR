#!/usr/local/bin/perl
#
# Change log is at the end of this file
#
# Usage: oracdr <recipe_name>
#------------------------------------------------------------------------

# Version number - do this before anything else
# so that we dont have to wait for all the modules to load
# - very quick
BEGIN {
  $VERSION = sprintf "%d.%03d", q$Revision$ =~ /(\d+)\.(\d+)/;
  #
  # Check for version number request
  # - do this before real options handling...
  foreach (@ARGV) {
    if (/^-v/) {
      print "ORAC-DR: Data reduction pipeline version $VERSION\n";
      exit;
    }
  }
}


# Predeclare subroutines that are read in after 
# the standard perl pre-processing (ie modules included
# via an eval)
use subs qw(start_msg_sys start_algorithm_engines wait_for_algorithm_engines);

# Make sure we catch as many signals as possible
# so that the END{} blocks work correctly and tidy up
use sigtrap qw/stack-trace normal-signals error-signals/;

#
#  ORAC modules
#
use lib $ENV{ORAC_PERL5LIB};
use ORAC::Basic;    # Recipe parsing/execution routines
use ORAC::General;
use ORAC::Loop;     # Loop control
use ORAC::Print;    # Printing messages or errors
use ORAC::Core;     # Core pipeline routines
use ORAC::Constants; # ORAC__OK et al

# 
# general modules
#
use Carp;				# perl -MCarp=verbose for backtrace
use Term::ANSIColor;			# color output
use Getopt::Long;                       # command line arguments
use Sys::Hostname;                      # For logfile

# check for starlink login
# 
&orac_exit_normally("No starlink login") unless exists $ENV{STAR_LOGIN};


# First thing we need to do is create an ORAC::Print object
# that we can fiddle with to adjust the output filehandles
my $msg_prt  = new ORAC::Print; # For message system
my $msgerr_prt = new ORAC::Print; # For errors from message system
my $orac_prt = new ORAC::Print; # For general orac_print

# Need to determine module list from the ORAC_INSTRUMENT
# environment variable before we can include certain modules.

# Simply exit if the environment variable is not set.
unless (exists $ENV{ORAC_INSTRUMENT}) {
  orac_err("No intrument specified in \$ORAC_INSTRUMENT. Please set to one of IRCAM, UFTI, SCUBA\n");
  exit;
}

$instrument = uc($ENV{ORAC_INSTRUMENT});

if ($instrument eq 'IRCAM') {
  $groupobject = "ORAC::Group::UKIRT";
  $frameobject = "ORAC::Frame::UKIRT";
  $calobject   = "ORAC::Calib::IRCAM";
  $instmodule  = "ORAC::Inst::IRCAM";
} elsif ($instrument eq 'UFTI') {
  $groupobject = "ORAC::Group::UFTI";
  $frameobject = "ORAC::Frame::UFTI";
  $calobject   = "ORAC::Calib::IRCAM";
  $instmodule  = "ORAC::Inst::IRCAM";
} elsif ($instrument eq 'CGS4') {
  $groupobject = "ORAC::Group::UKIRT";
  $frameobject = "ORAC::Frame::CGS4";
  $calobject   = "ORAC::Calib::CGS4";
  $instmodule  = "ORAC::Inst::CGS4";
} elsif ($instrument eq 'SCUBA') {
  $groupobject = "ORAC::Group::JCMT";
  $frameobject = "ORAC::Frame::JCMT";
  $calobject   = "ORAC::Calib::SCUBA";
  $instmodule  = "ORAC::Inst::SCUBA";
} elsif ($instrument eq 'MICHTEMP') {
  $groupobject = "ORAC::Group::UKIRT";
  $frameobject = "ORAC::Frame::MichTemp";
  $calobject = "ORAC::Calib::CGS4";
  $instmodule = "ORAC::Inst::CGS4";
} elsif ($instrument eq 'MICHELLE') {
  $groupobject = "ORAC::Group::UKIRT";
  $frameobject = "ORAC::Frame::Michelle";
  $calobject = "ORAC::Calib::CGS4";
  $instmodule = "ORAC::Inst::CGS4";
} else {
  orac_err("Instrument $instrument is not currently supported in ORACDR\n");
  exit;
}


# Read in the instrument specific modules
eval "use $groupobject;";
die "Error importing $groupobject:\n$@\n" if ($@);
eval "use $frameobject;";
die "Error importing $frameobject:\n$@\n" if ($@);
eval "use $calobject;";
die "Error importing $calobject:\n$@\n" if ($@);
eval "use $instmodule;";
die "Error importing $instmodule:\n$@\n" if ($@);




#
# command line arguments
#

# Store them first so that we can print out the log message
@ORAC_ARGS = @ARGV;

# Now parse the args
my $status = GetOptions("nodisplay","debug!","quiet!","calib=s","from=i","to=i","ut=i","list=s","loop=s","help","batch","skip","noeng","log=s");

($opt_help) && do {
print qq|

Usage:
  oracdr [-options] <recipe_name>

Arguments:
  <recipe_name>  a recipe to be executed

Options:

  These options may be abbreviated to a unique substring.

  -help      this help text
  -quiet     suppress engine messages
  -debug     log debug messages to ORACDR.DEBUG
  -nodisplay do not launch display

  -from      number of first observation
  -to        number of last observation
  -list      comma separated list of object *numbers*
             Colons indicate a range (1,2,3:5,10 means 1,2,3,4,5,10)


  -ut        UT date of observations (defaults to current yyyymmdd)
  -calib     comma seperated key=value pairs (eg. -cal dark=file1 or
             -cal dark=file1,bias=file2) of calibration *files*
  -loop      Type of data detection loop: list, inf, or wait
             -loop list is equivalent to not using a loop at all
              (only data specified is reduced)
             -loop wait waits for data to appear before timing out
	      (data is reduced and we wait for new data)
             -loop inf does not wait for data 
	      (data is reduced and new data is assumed to be available)
             -loop flag waits for completion files to appear before
              procesing (data is reduced and we wait for new data
	      via the flag)
  -batch     Run in batch mode. Precalculate groups before proceesing
             data. 'wait' loop mode should not be used with this option.
  -skip      Allow the data detection loop to skip missing observations.
             Default is to stop the loop when a expected file
	     can not be found.
  -noeng     Do not start algorithm engines. Note: this will cause 
             the vast majority of recipes to fail.
  -log       Control the location of the session logging. Default
             is to log messages to the screen and file (log=sf).
             Options are:
               s - log to screen (Xterm=STDOUT)
               f - log to file. The logfile is called .oracdr_$$.log
                   where $$ is the current process ID - it is written
                   to ORAC_DATA_OUT (it is a hidden file)
               x - log to an X widget. Has the advantage that warnings
                   and errors don't scroll of the screen
             The options can be combined (ie  log=sf will write log
             messages to screen and to a file).
  |;
exit;
}
;

############### S I G N A L  H A N D L E R S ###########################
#
# signals and perl variables
$|=1;					# make unbuffered
#
$SIG{'INT'} = \&orac_exit_abnormally;
#$SIG{'PIPE'} = \&orac_exit_abnormally;
$SIG{'PIPE'} = 'IGNORE';

#########################  ORAC DR Configuration #######################
#
# constants - for the module
#
# Check for ORAC_DIR
unless (exists $ENV{ORAC_DIR}) {
  orac_err("ORAC_DIR environment variable not defined. Aborting.");
  &orac_exit_normally;
}

$orac_dir = $ENV{ORAC_DIR} . "/";	# main orac directory (contains bin)

######################## Change to Output directory ####################

if (exists $ENV{ORAC_DATA_OUT}) {

  # change to output  dir
  chdir($ENV{ORAC_DATA_OUT}) || 
    do { 
      orac_err("Could not change directory to ORAC_DATA_OUT: $!");
      &orac_exit_normally;
    };

} else {
  orac_err("ORAC_DATA_OUT environment variable not set. Aborting");
  &orac_exit_normally;
}

######################## ORAC PRINT #############################
#                       CONFIGURATION                           #

# Debug info
if ($opt_debug) {
  $orac_prt->debugmsg(1);
  my $fh = new IO::File(">ORACDR.DEBUG");
  $orac_prt->debughdl($fh);
};

# Logging messages to a file
# If log is not defined, we are defaulting to STDOUT
# Log can be:
#  s - xterm screen  (STDOUT)
#  f - file          (ORACDR_$$.LOG)
#  x - Xwindow       (experimental)
# or combination (eg sf).
# Can keep STDOUT default if not set at all
# Always print error messages to STDERR  + optionally, the logfile
# Default is to use 'sf'

if (defined $opt_log) {
  # User is overriding logging options
  # Lower case the options
  $log_options = lc($opt_log);
} else {
  $log_options = 'sf'; # The default
}

# If it only matches 's' then we dont bother with this block
if ($log_options ne 's') {

  # Initialise file handle arrays
  @out_hdl = ();
  @err_hdl = (\*STDERR);
  @war_hdl = ();

  # Request for an X-window (experimental)
  # Put this first so that we can fall back to 
  # using the screen if Tk is not found
  if ($log_options =~ /x/) {
    # Delay X-loading until now
    eval "use Tk; use Tk::TextANSIColor;";
    if ($@) {
      print STDERR "Error loading Tk modules - X logging not available\n";
      print STDERR "Using screen instead\n";
      print STDERR "Error was: $@\n";
      $log_options .= 's'; # Make sure we print to screen now
    } else {
      $MW = MainWindow->new();
      # ORAC_PRINT messages
      $ORAC_MESSAGE = 'ORAC-DR reducing observation --';
      $msg1   = $MW->Label(-width=>60,-textvariable=>\$ORAC_MESSAGE)->pack();
      $lab1   = $MW->Label(-text=>'Normal Status')->pack;
      $textw1 = $MW->Scrolled('TextANSIColor',
			      -scrollbars=>'w',
			      -background=>'#555555',
			      -foreground=>'white',
			      -height => 30,
			      -width  => 90
			     )->pack;
      $textw1->tagConfigure('ANSIfgmagenta', -foreground => '#ccccff');
      $textw1->tagConfigure('ANSIfgblue', -foreground => '#33ff33');
      $textw1->tagConfigure('ANSIfgred', -foreground => '#ffcccc');
      $textw1->insert('end',"ORAC-DR status log\n");
      tie *TEXT1,  "Tk::TextANSIColor", $textw1;

      # ORAC_WARN messages
      $lab2   = $MW->Label(-text=>'Warnings')->pack;
      $textw2 = $MW->Scrolled('TextANSIColor',
			      -scrollbars=>'w',
			      -background=>'#555555',
			      -foreground=>'white',
			      -height => 5,
			      -width  => 90,
			     )->pack;
      $textw2->insert('end',"ORAC-DR warning messages\n");
      tie *TEXT2,  "Tk::TextANSIColor", $textw2;

      # ORAC Error messages
      $lab1   = $MW->Label(-text=>'Errors')->pack;
      $textw3 = $MW->Scrolled('TextANSIColor',
			      -scrollbars=>'w',
			      -background=>'#555555',
			      -foreground=>'white',
			      -height => 5,
			      -width  => 90,
			     )->pack;
      $textw3->insert('end',"ORAC-DR error messages\n");
      tie *TEXT3,  "Tk::TextANSIColor", $textw3;


      # Update and draw the screen and tell the ORAC::Print
      # system that we have a Tk window
      $MW->update;
      $ORAC::Print::TKMW = $MW;

      # Store the filehandles
      push (@out_hdl, \*TEXT1);
      push (@err_hdl, \*TEXT3);
      push (@war_hdl, \*TEXT2, \*TEXT1); # Display warnings with messages 
    }

  }
  # Request for SCREEN
  if ($log_options =~ /s/) {
    push (@out_hdl, \*STDOUT);
    push (@war_hdl, \*STDOUT);
  }
  # Request for file - must have already chdir'ed to ORAC_DATA_OUT
  if ($log_options =~ /f/) {
    $logfh = new IO::File(">.oracdr_$$.log") || 
      do { orac_err "Error opening logfile: $!"; orac_exit_normally;};
    $logfh->autoflush(1);

    # Write a header
    print $logfh "ORAC-DR logfile - created on " . scalar(gmtime) ." UT\n";
    print $logfh "\nORAC Environment:\n\n";
    print $logfh "\tInstrument : $ENV{ORAC_INSTRUMENT}\n";
    print $logfh "\tInput  Dir : $ENV{ORAC_DATA_IN}\n";
    print $logfh "\tOutput Dir : $ENV{ORAC_DATA_OUT}\n";
    print $logfh "\tCalibration: $ENV{ORAC_DATA_CAL}\n";
    print $logfh "\tORAC   Dir : $ENV{ORAC_DIR}\n";
    print $logfh "\tORAC   Lib : $ENV{ORAC_PERL5LIB}\n";
    my $rdir = ($ENV{ORAC_RECIPE_DIR} || '<undefined>');
    my $pdir = ($ENV{ORAC_PRIMITIVES_DIR} || '<undefined>');
    print $logfh "\tAdditional Recipe Dir   : $rdir\n";
    print $logfh "\tAdditional Primitve Dir : $pdir\n";


    print $logfh "\nSystem environment:\n\n";
    print $logfh "\tHostname        : ". hostname . "\n";
    print $logfh "\tUser name       : $ENV{USER}\n";
    print $logfh "\tPerl version    : $]\n";
    print $logfh "\tOperating System: $^O\n";
    
    print $logfh "\nORAC-DR Arguments: ".join(" ",@ORAC_ARGS)."\n";

    print $logfh "\nSession:\n\n";

    # Store the filehandle
    push (@out_hdl, $logfh);
    push (@err_hdl, $logfh);
    push (@war_hdl, $logfh);
  }

  # Configure ORAC::Print
  $orac_prt->outhdl(@out_hdl);
  $orac_prt->warhdl(@war_hdl);
  $orac_prt->errhdl(@err_hdl);

}

#########################   U  T    D A T E #############################
# if no UT date has been provided, default to current.
#
!($opt_ut) && do {

  $opt_ut = utdate;

  orac_print ("Orac says: No UT date supplied, using $opt_ut\n","blue");

};


######################## M E S S A G E  SYSTEMS #############################

# Start the messaging system(s) and initialise them
# This routine creates and initialies the message systems.
# Also allows us to store the message objects since on
# undef everything goes away
(@messys) = start_msg_sys;


######################## A L G.   E N G I N E S #############################


unless ($opt_noeng) {
  
  # start algorithm engines
  #
  orac_print("ORAC says: Starting up monoliths...","blue");
  #
  
  %Mon = start_algorithm_engines;
  $status = wait_for_algorithm_engines;
  
  if ($status != ORAC__OK) {
    orac_err("Error contacting monoliths. Aborting.\n");
    orac_exit_normally;
  }
  
  orac_print ("Done\n","blue");
  
} else {
  
  orac_print("Orac says: No algorithm engines will be started (-noeng option)\n","blue");

}



######################## I N I T  D I S P L A Y #############################
#
# launch display
# -nodisplay suppresses display,
#
if ($opt_nodisplay) {
  orac_print("Orac says: No display will be used\n","blue");
} else {

  orac_print ("Setting up display infrastructure (display tools will not be started until necessary)...", 'blue');
  &orac_setup_display;
  orac_print ("Done\n","blue");

}


######################## MESSYS CONFIG #############################
# Messaging system seems to be working okay so configure it.
# Now we set our overrides to the messaging systems.
# Dont do this earlier since we dont want to wait 600 seconds for
# a timeout to find that we couldn't even talk to a monolith

# First generate a filehandle tied to the orac_print system
tie *MSG, 'ORAC::Print', $msg_prt;
$msg_prt->outcol('clear'); # Cyan color for all messages

# Tie a filehandle to the error messages from the alogrithm
# engines and redirect to orac_err
tie *MSGERR, 'ORAC::Print', $msgerr_prt, 'err';

# Now loop over each message system and configure it
foreach my $msg (@messys) {

  # -quiet option supresses Starlink non-error messages
  ($opt_quiet) && ($msg->messages(0));
  $msg->timeout(600);	# task timeout
  $msg->paramrep(sub {orac_warn "Sending auto abort in response to parameter request\n";return "!!"});

  # Filehandle
  $msg->stdout(\*MSG);
  $msg->stderr(\*MSGERR);

}

######################## C A L I B R A T I O N #############################

# Create calibration object
$Cal = new $calobject;

#
# Calibration frame overrides
#
  
if (defined $opt_calib) {
  
  %calibs = parse_keyvalues($opt_calib);

  foreach $key (keys %calibs) {

    if ($Cal->can($key)) {		# set appropriate method

      $Cal->$key($calibs{$key});

# if we have a noupdate method to enforce overrides, use it.
      my $noupdate = $key."noupdate";
      $Cal->$noupdate(1) if $Cal->can($noupdate);

      orac_print("ORAC says: Calibration $key set to $calibs{$key}\n","blue");

    } else {				# complain but continue

      orac_err ("Calibration $key unknown by this instrument. Ignored\n");

    };
  };

};


############## Process argument list ###############################3
# Generate list of observation numbers to be processed
# This is related to looping scheme

$loop = 'orac_loop_list'; # Default loop scheme unless -from 

if (defined $opt_from) {

  if (defined $opt_to) {
    @obs = $opt_from .. $opt_to
  } else {

    # If the skip flag is set to true we can turn the -from..end 
    # loop into 'list' loop by determining the last observation number.
    # For historical reasons, the inf loop should be used if the -skip
    # option is false.

    if ($opt_skip) {
      my ($next, $high) = orac_check_data_dir($frameobject, $opt_from, 0);
      if (defined $high) {
	@obs = ($opt_from..$high);
      } else {
	# High not defined -- a problem has occured.
	# Probably should abort
	orac_err("The -from option was used even though no data exists above the selected observation number [$opt_from].");
	orac_exit_normally;
      }

    } else {

      @obs = ($opt_from);  # Used for data detection loops etc

      # Set default loop scheme to 'inf'
      # if there is no 'to' and 'skip' is false.
      $loop = 'orac_loop_inf';

    }

    orac_print "Starting at observation $opt_from and looping until no files available\n"
  }
 
} elsif (defined $opt_list) {

  @obs = parse_obslist($opt_list);

} elsif (defined $opt_to) {
  # This catches the case where -to is defined but no -from or -list
  # Start counting at 1
  orac_print "Processing observations 1 to $opt_to\n";
  @obs = (1..$opt_to);

} else {
  # Okay - none of -from, -list or -to were defined
  # We default to 1 in this case and set the loop to wait
  # Note that loop will be overriden if -loop is supplied
  orac_print "No observation numbers supplied - starting from obs 1\n";
  $loop = 'orac_loop_wait';
  @obs = (1);

}

############################# L O O P I N G  S C H E M E ###############
# Decide on a looping scheme

$loop = "orac_loop_" . $opt_loop if defined $opt_loop;


# Read recipe name
$Override_Recipe = shift(@ARGV); # this will default to the RECIPE File method





################# D A T A   L O O P ###############################
# 
# There are two approaches to the data processing:
#
# 1 - The default processing method where data are read in 
#     and processed as it arrives and Groups are extended as needed.
#     This has the advantage that the data is processed as it is
#     taken, has very good feedback to the user in real time. The down
#     side is that Groups are processed as soon as possible and in an
#     off-line batch processing envrionment this is very wasteful
#     (why work out the flatfield every time a frame arrives when you
#     simply want to work out the flatfield from the entire group).
# 2 - The 'batch' method where the data are analysed in two passes.
#     First the groups are setup, secondly the frames are processed in
#     each group in turn. This has the advantage that frames can be coadded
#     into a group only once and is the most efficient way of processing
#     data off-line. Note that this presupposes that the primitives are
#     written in such a way that they can spot the last member of the group
#     (via the lastmember method). Grp Primitives without this check will
#     probably fail since the some of the members will not have been 
#     processed even though the group contains many members.
#     One other issue is
#     calibration -- in principal all calibration groups should be processed
#     before observation groups and currently this is not supported.
#     (only important when calibrations are taken after the observation).
#
#     Batch mode can be summarised as
#       - Read in all frames and allocate groups
#       - Loop over all groups
#            Loop over all frames in group
#               process frames
#
#    Default mode is
#      - Loop over all frames
#         - Allocate groups
#            - process frames

#   Batch mode can be turned on with the -batch switch.
#   


# Default is to process data in order of arrival
unless ($opt_batch) {

  # Loop forever
  %Groups = ();

  while (1) {

    # Return back the current frame
    # This will also configure the frame object
    my $Frm = &{$loop}($frameobject, $opt_ut, \@obs, $opt_skip);

    # If frame is undefined then we assume that the data loop
    # should be stopped
    last unless defined $Frm;

    orac_print ("REDUCING: ".$Frm->raw."\n","yellow");

    # Set the ORAC::Print prefix
    my $fnumber = $Frm->number;
    $ORAC_MESSAGE = 'ORAC-DR reducing observation number ' . $fnumber;
    $orac_prt->errpre("#$fnumber Err: ");
    $orac_prt->warpre("#$fnumber Warning: ");
  
    # Store the Frame in the Group
    my $Grp = orac_store_frm_in_correct_grp($Frm, $groupobject, \%Groups, 
					    undef, $opt_ut);

    # Actually process the observation
    orac_process_frame($Frm, $Grp, $Cal, $Override_Recipe, $instrument);

    # Reset the obs number labels
    $orac_prt->errpre('Error: ');
    $orac_prt->warpre('Warning: ');
    $ORAC_MESSAGE = 'ORAC-DR reducing observation --';


  }

} else {
  # Batch mode

  # Set the flag in the namespace used by the recipes
  # so that the recipes know we are in batch mode.
  $ORAC::Basic::Batch = 1;

  # First loop over frames
  @Groups = ();
  %Groups = ();

  while (1) {
    # Return back the current frame
    # This will also configure the frame object
    $Frm = &{$loop}($frameobject, $opt_ut, \@obs, $opt_skip);

    # If frame is undefined then we assume that the data loop
    # should be stopped
    last unless defined $Frm;

    orac_print ("Storing: ".$Frm->raw."\n","yellow");
  
    # Store the Frame in the Group
    orac_store_frm_in_correct_grp($Frm, $groupobject, \%Groups, \@Groups, 
				  $opt_ut);

  }

  # Now loop over groups and frames
  foreach $Grp (@Groups) {
    foreach $Frm ($Grp->members) {
      orac_print ("REDUCING: ".$Frm->raw."\n","yellow");
      # Set the ORAC::Print prefix
      my $fnumber = $Frm->number;
      $ORAC_MESSAGE = 'ORAC-DR reducing observation ' . $fnumber;
      $orac_prt->errpre("#$fnumber Err: ");
      $orac_prt->warpre("#$fnumber Warning: ");
      # Actually process the observation
      orac_process_frame($Frm, $Grp, $Cal, $Override_Recipe, $instrument);

      # Reset the obs number labels
      $orac_prt->errpre('Error: ');
      $orac_prt->warpre('Warning: ');
      $ORAC_MESSAGE = 'ORAC-DR reducing observation --';
    }
  }


}

# Reset the ORAC::Print prefix
orac_print "Pipeline processing complete\n";


# If $MW is defined, enter the Tk MainLoop
# So that the session can be examined before exiting
# Add a button to allow the pipeline to exit.
if (defined $MW) {
  $MW->Button(-text=>'Press to Exit ORAC-DR', 
	      -command => sub {destroy $MW})->pack;
  &MainLoop;
  # Need to remove the tie
  untie *TEXT1;
  untie *TEXT2;
  untie *TEXT3;
  $ORAC::Print::TKMW = undef;
}


&orac_exit_normally;

# exit 

#------------------------------------------------------------------------

# $Log$
# Revision 1.53  1999/03/27 00:40:43  frossie
# Change red colour to pink
#
# Revision 1.52  1999/03/26 02:55:46  frossie
# Added -log x option to -h output
#
# Revision 1.51  1999/03/26 02:43:34  timj
# Make sure that the log file location matches the -help info
# (.oracdr_$$.log)
#
# Revision 1.50  1999/03/26 02:42:34  timj
# Add version -v option.
# Add -log option to screen, log file and Tk window
#
# Revision 1.49  1999/03/23 23:54:18  frossie
# Add Michelle temporary intrument type (MichTemp)
#
# Revision 1.48  1999/02/27 02:31:29  frossie
# Changed -h option to -help
#
# Revision 1.47  1999/02/25 04:55:09  frossie
# Michelle module loading
#
# Revision 1.46  1999/02/23 00:32:48  frossie
# Change in instrument imported methods
#
# Revision 1.45  1999/02/18 03:10:44  timj
# Set Batch variable in ORAC::Basic
#
# Revision 1.44  1998/12/12 04:00:24  frossie
# Added -noeng option (does not start algorthm engines)
#
# Revision 1.43  1998/10/01 22:55:10  timj
# Add the -skip option
#
# Revision 1.42  1998/09/25 03:35:31  timj
# Add -batch option.
# Remove data processing routines to ORAC::Core
#
# Revision 1.41  1998/09/23 23:42:48  frossie
# Take out some print debug lines.
#
# Revision 1.40  1998/09/17 19:00:27  timj
# - Add support for just using -to option.
# - Set default behaviour when neither -list, -from nor -to are specified.
#
# Revision 1.39  1998/09/17 04:06:51  timj
# Ignore SIGPIPE rather than assigning a null sub
#
# Revision 1.38  1998/09/17 03:32:05  timj
# - Change recipe parsing so that it handles array references
# - Fix -from behaviour looping
# - use sigtrap so that we can try to trap most signals
#
# Revision 1.37  1998/09/16 03:21:14  frossie
# Pick up recipes form inst-specific dirs
#
# Revision 1.36  1998/09/15 12:27:31  frossie
# Add CGS4 specific class modules
#
# Revision 1.35  1998/08/07 02:19:06  frossie
# Add -debug option
#
# Add orac_add_code_to_recipe call
#
# Revision 1.34  1998/07/10 02:43:55  frossie
# For UFTI, use UFTI Group subclass
#
# Revision 1.33  1998/07/09 03:52:03  timj
# Use new Display commands
#
# Revision 1.32  1998/07/08 23:21:05  timj
# Tidy up.
# Use orac_print
#
# Revision 1.31  1998/07/08 05:08:18  frossie
# Change UFTI section to use UFTI Frame subclass
#
# Revision 1.30  1998/07/08 04:39:23  frossie
# -h the loop option
#
# Revision 1.29  1998/07/08 03:49:32  timj
# Use different data detection loops
#
# Revision 1.28  1998/07/07 06:28:55  frossie
# Call noupdate method when a calibration has been specified in the
# command line
#
# Revision 1.27  1998/07/07 06:11:50  frossie
# Set current frame to calibration 'thing', against which to determine
# calibration suitability.
#
# Revision 1.26  1998/06/29 05:37:36  timj
# Add wait_for_algorithm_engines (reorganise to accomodate status checking).
#
# Revision 1.25  1998/06/29 05:25:16  frossie
# Use wait_for_algorithm_engines
#
# Revision 1.24  1998/06/29 03:56:09  frossie
# Bugfix: Make sure ORAC_PERL5LIB is really used.
#
# Revision 1.23  1998/06/29 03:21:11  frossie
# remove -dark and add general -calib option
#
# Revision 1.22  1998/06/28 01:10:46  frossie
# -ut option defaults to current UT date if unspecified
#
# Revision 1.21  1998/05/23 08:05:54  timj
# Read recipe from frame (or at least try to)
#
# Revision 1.20  1998/05/21 18:32:31  timj
# Left over 'exit' from my debugging efforts....
#
# Revision 1.19  1998/05/21 06:26:38  timj
# Add support for ranges in -list
#
# Revision 1.18  1998/05/19 01:45:41  timj
# Support file_from_bits() methods.
#
# Revision 1.17  1998/05/18 21:17:10  timj
# Add support for new organization of primitives directories.
#
# Revision 1.16  1998/05/08 18:41:13  timj
# Remove instrument specific definitions.
# Display is still hard-wired.
#
# Revision 1.15  1998/04/15 02:41:28  frossie
# Move ams_init to appropriate place
#
# Revision 1.14  1998/04/14 21:39:12  frossie
# Move data dir chdir prior to display launch
#
# Revision 1.13  1998/04/14 21:10:48  frossie
# Change explicit use of ADAMTASK modules to new ORAC::Msg classes.
#
# No longer need explicit exits from the messaging system as these are
# now performed when message objects are destroyed.
#
# Revision 1.12  1998/04/09 02:48:06  frossie
# Group filename changed to "rg" from "g"
#
# Revision 1.11  1998/04/04 06:45:31  frossie
# Introduce Frm Grp and Cal objects
#
# Revision 1.10  1998/04/01 23:09:12  frossie
# *** empty log message ***
#
# Revision 1.9  1998/03/17 18:54:23  frossie
# *** empty log message ***
#
# Revision 1.8  1998/03/16 19:07:28  frossie
# File::Copy and group filename prototype handling
#
# Revision 1.7  1998/03/16 04:07:57  frossie
# Add use of ANSI colour
#
# Revision 1.6  1998/02/25 11:25:50  frossie
# * oracdr: introduced Getopt for option handling
#
# Revision 1.5  1998/02/24 11:39:58  frossie
# More namespace fixing - Hdr and Mon now generally accessible. Risk of
# clobbering is probably worth the pain of enforcing ${main::Blah} to
# long-suffering primitive writers.
#
# Revision 1.4  1998/02/24 09:13:34  frossie
# Pipeline now does only basic control
#
# Revision 1.3  1998/02/20 06:43:55  frossie
# Static variables pulled out as shell ENVs.
#
# -nodisplay option supported
#
# Revision 1.2  1998/02/20 04:22:13  frossie
# Static variables pulled out as shell ENVs.
#
# Revision 1.1.1.1  1998/02/04 00:51:01  frossie
# Original version
#
# Revision 1.5  1997/11/25 06:46:57  frossie
# actually runs tasks. adam stuff not transparent.
#
# Revision 1.4  1997/11/22 01:04:35  frossie
# Variables passed down and back up
#
# Revision 1.3  1997/11/22 00:28:23  frossie
# Arguments propagate down
#
# Revision 1.2  1997/11/21 21:30:43  frossie
# Very simple version. Deals with recipes calling recipes.
#
# Revision 1.1  1997/11/21 21:29:43  frossie
# Initial revision
#


