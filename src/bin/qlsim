#!perl

=head1 NAME

qlsim - Simulated DRAMA task for -loop task option

=head1 SYNOPSIS

   qlsim -name SCU2 -flagfile sa.ok

=head1 DESCRIPTION

When testing the ORAC-DR pipeline in "Quick Look" mode (aka the "task"
looping option) data are made available to the DR via DRAMA parameters.
This simulator provides a surrogate acquisition task using the standard
QL parameter interface.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<-name>

This is the name that the task will use in the DRAMA message system.
If not specified, it will use the name QLSIM.

=item B<-flagfile>

The name of a standard ORAC-DR multi-frame flag file. The flag file
will contain the names of input data files relative to ORAC_DATA_IN.
These files will be stored into the QL parameter at at the specified
rate (see the C<-refresh> option). This is a mandatory option.

=item B<-raw>

Do not try to read data file contents from the flagfile. Simply publish
the filename in the FILENAME parameter.

=item B<-refresh>

The rate at which data will be presented to the pipeline (in seconds).
Defaults to 2 seconds.

=item B<-loop>

By default, the task will exit when it runs out of files. When this
option is enabled the task will start from the beginning again when
it gets to the end.

=item B<-help>

Provide simple help information.

=item B<-man>

Provides the manual page.

=item B<-version>

The version of the simulator.

=back

=head1 ACTIONS

This is a DRAMA task with the following actions (in addition to the
core actions that all perl DRAMA tasks have):

=over 4

=item B<UPDATE>

This is the internal action that reschedules itself at the refresh
rate, updating the internal parameters. It should not be called
from an external source.

=back

=head1 PARAMETERS

This is a DRAMA task with parameters matching those expected by ORAC-DR:

=over 4

=item B<QL>

This is the SDS parameter monitored by ORAC-DR. It consists of the following
SDS components:

=over 8

=item B<TIMESTAMP>

The Unix epoch seconds for when the parameter was written

=item B<FILENAME>

The name of the file to be read by ORAC-DR. This component is mandatory
unless the IMAGE component is present. It takes priority over IMAGE
if both are present.

=item B<IMAGE>

A structure containing the processed image. Must be present if FILENAME
is not present. This structure contains DATA_ARRAY (a 2-d image) 
and FITS (character array) components.

=back

=back

=cut

use warnings;
use strict;
use Carp;
use Getopt::Long;
use Pod::Usage;

use Astro::FITS::Header::NDF;
use Time::HiRes;
#use Jit;
use DRAMA;
use Sds::Tie;

# ORAC-DR library path
use lib $ENV{ORAC_PERL5LIB};
use ORAC::Inst::Defn qw/ orac_determine_inst_classes /;

# Buffer sizes
# Override the outgoing message size
$DRAMA::BUFSIZE = 300000;
$DRAMA::MESSAGEBYTES = 80000;
$DRAMA::MAXMESSAGES  = 1;

# Options
my ($help, $man, $version, $refresh, $name, $flagfile, $loop, $rawmode);
my $opt_status = GetOptions("help" => \$help,
			    "man" => \$man,
			    "flagfile=s" => \$flagfile,
			    "version" => \$version,
			    "refresh=s" => \$refresh,
			    "name=s" => \$name,
			    "loop" => \$loop,
			    "raw" => \$rawmode,
			   );

pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose => 2) if $man;

if ($version) {
  my $id = '$Id$ ';
  print "QuickLook simulator data source for ORAC-DR pipeline\n";
  print " CVS revision: $id\n";
  exit;
}

# handle defaults
$refresh ||= 2.0;
$name    ||= "QLSIM";

# error checks
die "-flagfile option is mandatory\n"
  unless defined $flagfile;

die "Supplied flagfile ($flagfile) does not exist\n"
  unless -e $flagfile;

# ORAC_DATA_IN is required for us to read the file
if (!exists $ENV{ORAC_DATA_IN}) {
  warn "\$ORAC_DATA_IN is required when serving the IMAGE data. Falling back to FILENAME\n";
}

# if we do not have ORAC_INSTRUMENT defined we will default
# to simply serving the files without attempting to handle
# subframes. If FRM_CLASS is defined we will ask the frame itself
# for details of all the components.
my $FRM_CLASS;
if (!exists $ENV{ORAC_INSTRUMENT}) {
  warn "\$ORAC_INSTRUMENT not defined. Falling back to safe mode.";
} else {
  my @classes = orac_determine_inst_classes( $ENV{ORAC_INSTRUMENT} );
  $FRM_CLASS = $classes[0] if @classes;
}

# Cache of filenames that are waiting to be sent
# Only used if $FRM_CLASS is defined
my @FILECACHE;

# The format of the files stored in the filecache. Assume
# it is the same for all files in the cache (it should be)
my $IMAGE_FORMAT;

# open the flagfile so that we can start reading files from it
# and to make sure we can before we start DRAMA
# This is a global for simplicity
open my $FH, "< $flagfile"
  or die "Error opening file $flagfile: $!";

# Initialise DRAMA
DPerlInit( $name );
#Jit::Init( $name );

# Register the actions
my $status = new DRAMA::Status;
Dits::DperlPutActions("UPDATE",\&update_param,undef,0,undef,$status);

# Get the parameter object
my $sdp = Dits::GetParId();

# Create the QL structure
my $qlsds = Sds->Create("QL", undef, Sds::STRUCT, 0, $status );
$qlsds->Create( "TIMESTAMP", undef,Sds::DOUBLE, 0.0, $status );

# Store it in the parameter system
$sdp->Create('', 'SDS', $qlsds);

# Create the rescheduling timescale
my $DELAY = Dits::DeltaTime( int($refresh), ($refresh - int($refresh)));

# call ourselves
DRAMA::obey $name, "UPDATE";

# event loop
Dits::MainLoop( $status );

exit;

# actions

# UPDATE Action

sub update_param {
  my $status = shift;
  return $status unless $status->Ok;
  print "Enter UPDATE action...\n";

  # first we need to see whether there is a file pending in the
  # file cache
  my $nextfile = shift(@FILECACHE);

  # if we are in multi-frame mode we will be publishing the
  # data in "IMAGE"-mode. Else we will use FILENAME-mode
  my $image_mode;

  # check whether we need to read from the flagfile
  if (defined $nextfile) {
    $image_mode = 1;
    print "Retrieved file from cache...\n";

  } elsif (!defined $nextfile) {
    # no name, look on disk in the flagfile
    $nextfile = <$FH>;
    chomp($nextfile) if defined $nextfile;

    # if we have a frame class defined we should use it now
    # to find whether we have multiple components.
    # else we just pass ths filename onto the system
    # and publish it as a filename
    if (defined $nextfile && defined $FRM_CLASS && !$rawmode) {

      # first see if the file exists in ORAC_DATA_IN or relative
      # to the current directory
      my $filepath;
      if (-e $nextfile) {
	$filepath = $nextfile;
      } else {
	if (exists $ENV{ORAC_DATA_IN} &&
	    -e File::Spec->catfile( $ENV{ORAC_DATA_IN}, $nextfile)) {
	  $filepath = File::Spec->catfile( $ENV{ORAC_DATA_IN}, $nextfile);
	}
      }

      # now we know whether the file exists and where it is located
      # if we have not located the file we simply go to FILENAME
      # mode and assume that the monitoring ORAC-DR will find it.
      if (defined $filepath) {
	# canonicalize
	$filepath = mycanonpath( $filepath );
	print "Retrieved file from file: $filepath with $FRM_CLASS\n";



	# create the relevant frame object
	my $Frm = $FRM_CLASS->new( $filepath );

	if (defined $Frm) {
	  print "Got frame $Frm\n";

	  # Ask it for the files
	  my @files = $Frm->files;

	  # and store the format
	  $IMAGE_FORMAT = $Frm->rawformat;

	  use Data::Dumper;
	  print Dumper(\@files);

	  # the next file will be the first file in this list
	  $nextfile = shift(@files);

	  # IMAGE-mode?
	  if (scalar(@files) > 0) {
	    # if we have files remaining, then we enter IMAGE mode
	    # and store the rest in the file cach
	    $image_mode = 1;
	    @FILECACHE = @files;
	  } else {
	    # make sure the rawsuffix is appended to the file
	    # if we have a single file
	    $nextfile .= $Frm->rawsuffix
	      if (defined $Frm->rawsuffix && $nextfile !~ /\./);
	  }

	}

      }

    }

  }

  # do we have something? Else finish up or reopen the file
  if (defined $nextfile && $nextfile =~ /\w/) {
    print "Processing file: $nextfile\n";

    # We have global access to the QL structure
    # Lazy, so use a tie for exploration
    tie my %QL, "Sds::Tie", $qlsds;
#    $QL{FILENAME} = $nextfile;
#    $QL{TIMESTAMP} = Time::HiRes::time();

    # Find the timestamp
    my $t = $qlsds->Find( "TIMESTAMP", $status );
    print Time::HiRes::time() ."\n";
    $t->PutPdl( PDL::Core::pdl( Time::HiRes::time() ) )
      if (defined $t && $status->Ok);

    # Find the FILENAME (or create it)
    if ($status->Ok) {
      if ($image_mode) {
	# read the image
	croak "Fatal error: IMAGE mode requested without associated format defined\n" unless defined $IMAGE_FORMAT;
	if ($IMAGE_FORMAT eq 'HDS' ||
	    $IMAGE_FORMAT eq 'NDF') {

	  require PDL::IO::NDF;
	  my $image = PDL::IO::NDF::rndf( $nextfile );

	  if (defined $image) {

	    my %STRUCT;
	    $STRUCT{DATA_ARRAY} = $image;

	    # reread the FITS header since we do not have the Frm
	    # object
	    my $fits;
	    eval {
	      $fits = new Astro::FITS::Header::NDF( File => $nextfile );
	    };
	    $fits = new Astro::FITS::Header() if (!defined $fits);
	    $STRUCT{FITS} = [ split ("\n","$fits") ];

	    # Need to remove previous IMAGE structures
	    DRAMA::ErsPush();
	    my $lstat = new DRAMA::Status;
	    {
	      my $imsds = $qlsds->Find( "IMAGE", $lstat );
	      if ($imsds) {
		# force out-of-scope destroy
		$imsds->flags(1,1,1);
	      }
	    }
	    $lstat->Annul() unless $lstat->Ok;
	    DRAMA::ErsPop;

	    # write the data to the structure
	    $qlsds->PutHash( \%STRUCT, "IMAGE", $status );

	  } else {

	    croak "Error reading $nextfile into a PDL\n";

	  }

	} else {
	  croak "Do not know (yet) how to read files of format $IMAGE_FORMAT\n";
	}

      } else {
	if (exists $QL{FILENAME}) {
	  my $fil = $qlsds->Find("FILENAME", $status);
	  $fil->PutStringArrayExists( [ $nextfile ], $status, 1 );
	} else {
	  $qlsds->PutStringArray( [ $nextfile ], "FILENAME" );
	}
      }
    }

    $qlsds->List( $status );
    # trigger parameter update
    $sdp->Update($qlsds, $status);

    # reschedule
    Dits::PutDelay( $DELAY, $status );
    Dits::PutRequest( Dits::REQ_WAIT, $status );
  } else {
    # nothing else in the file
    # do we start from the start?
    if ($loop) {
      # reopen the file
      close($FH);
      open $FH, "< $flagfile" or die "Error reopening flagfile $flagfile: $!";

      # reschedule immediately so we serve the next file without an obvious delay
      DRAMA::MsgOut( $status, "Loop switch enabled. Restarting from the top");
      Dits::PutRequest( Dits::REQ_STAGE, $status );
    } else {
      # abort
      Dits::PutRequest( Dits::REQ_EXIT(), $status );
      close($FH);
    }
  }

  return $status;
}

# canonicalize path

sub mycanonpath {
  my $path = shift;
  croak "Only works on absolute paths: not $path\n"
    unless File::Spec->file_name_is_absolute( $path );

  my ($vol, $dir, $file) = File::Spec->splitpath( $path );

  my @dirs = File::Spec->splitdir( $dir );

  my @newdirs;
  for my $d (@dirs) {
    if ( $d eq File::Spec->updir ) {
      pop(@newdirs);
    } elsif ($d eq File::Spec->curdir) {
      # no action
    } else {
      push(@newdirs, $d );
    }
  }

  return File::Spec->catpath( $vol, File::Spec->catdir(@newdirs), $file );
}


=head1 SEE ALSO

L<DRAMA>, L<ORAC::Loop>.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2005 Particle Physics and Astronomy Research Council.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

=cut
