#!/usr/local/bin/perl

=head1 NAME

oracdr_nuke - kill all ORAC-DR related processes and shared memory

=head1 SYNOPSIS

  oracdr_nuke

=head1 DESCRIPTION

Attempt to kill all ORAC-DR related processes and shared memory that
can be found and that are associated with the current user.

=head1 NOTES

=over 4

=item *

All shared memory owned by the current user is removed even if
it is not directly associated with an ORAC-DR process.

=item * 

Will not attempt to remove shared memory owned by another user.

=item *

Will attempt to kill processes owned by other users even though
this will not succeed unless the user has special privilege.

=item *

Does not attempt to clear out ADAM_USER directories. This is not
normally a problem for ORAC-DR since each ORAC-DR process works
in a different ADAM_USER directory.

=back

=head1 AUTHORS

Frossie Economou (frossie@jach.hawaii.edu),
Tim Jenness (t.jenness@jach.hawaii.edu)

=head1 REVISION

$Id$

=head1 COPYRIGHT

Copyright (C) 1996-2000 Particle Physics and Astronomy Research Council.
All Rights Reserved.

=cut

use strict;

use Sys::Hostname;

$| = 1;

# Get date and time
my $date = scalar(localtime);
my $host = hostname;


# Open log in $ORAC_DATA_OUT
if (exists $ENV{ORAC_DATA_OUT}) {

  open ( LOG, ">> $ENV{ORAC_DATA_OUT}/oracdr_nuke.log")
    || warn 'Could not open log file in ORAC_DATA_OUT';

  print LOG "$date by $ENV{'USER'} on $host (perl $]) OS $^O\n";

  close(LOG);
}


# Attempt to kill oracdr processes

print "Killing ORAC-DR processes...";
&proc_kill('oracdr|MessageRelay', 'oracdr_nuke');
print "Done\n";

# Starlink processes

print "Killing Starlink processes...";
&proc_kill('\/star', 'oracdr_nuke');
print "Done\n";


# Shared memory
print "Removing shared memory...";
&ipcs_kill;
print "Done\n";


#
print "\n\t\toracdr_nuke- Nuke complete for user $ENV{'USER'}.\n\n";

exit;
 

# Subroutine to remove named pipes from directories.
# called by find routine. Not required for ORAC-DR since
# each process uses a different ORAC-DR tree.

sub wanted {
#    (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) &&
#    -p _ &&
#    (unlink($_) || warn "$name: $!\n");
}

# Subroutine to kill all processes that match the supplied 
# pattern

#   Arguments:  Pattern   - pattern used to match the string
#               Exclusion - pattern that should be ignored

# The exlusion pattern is optional and is only required when
# certain processes that match the more general pattern should
# be excluded. The classic example is where the pattern matches
# the name of the process doing the killing!

# Relies on knowing the format and location of the standard
# ps for all supported OSs. This is a pain -- Should
# be using Proc::ProcessTable instead

sub proc_kill {

  my $pat = shift;

  my $exclude = '____NOTHING_TO_EXCLUDE___';
  if (@_) { $exclude = shift; }

  # The command to use for ps
  my $cmd; 
  # this is the position of the pid in the ps output
  my $pos;
  if ($^O eq 'linux') {
    $cmd = '/bin/ps auxw';
    $pos = 0;
  } elsif ($^O eq 'solaris') {
    $cmd = '/usr/bin/ps -ef';
    $pos = 1;
  } else {
    # Digital Unix PS
    $cmd = '/bin/ps -ef';
    $pos = 1;      
  }

  my @processes = `$cmd`;

  foreach my $line (@processes) {

    # Check to see if any part of the line matches the supplied pattern
    # Check the whole string -- only clash would be user id
    if ($line =~ /$pat/) {

      # Check the exclusion pattern
      if ($line !~ /$exclude/) {

	# Split on space to extract the pid
	$line =~ s/^\s+//;  # Strip leading blanks
	my @a = split(/\s+/, $line);

	# Now kill the relevant PID
	kill 'KILL', $a[$pos];

      }

    }
    
  }

}


# Kill the shared memory segments owned by user.
# no arguments.

sub ipcs_kill {

  # Set up ipcrm command
  my $ipcrm;
  if ($^O eq 'linux') {
    $ipcrm = "ipcrm shm";
  } elsif ($^O eq 'solaris') {
    $ipcrm = "ipcrm -m";
  } else {
    # Assume ipcrm -m -- this is valid for an Alpha
    # but I don't know the value for $^O in a modern alpha installation
    $ipcrm = "ipcrm -m";
  }

  # Read all shared memory segment IDs
  my @ipcs = `ipcs -m`;

  foreach my $line (@ipcs) {

    # Check to see if the line matches the current user name

    # Split on space
    my @a = split(/\s+/, $line);

    # The position of the USER name is different on solaris
    # and linux but we can ignore this if we are only trying to match

    if ($line =~ $ENV{'USER'}) {
      # Note that SHMID is in position 1 on both linux and solaris
      # and alpha
      system "$ipcrm $a[1]";
    }

  }


}

				 

