#!/usr/bin/perl -w
#
#  oracdisp
#
#     - Controls the ORACDR display environment
#     - This program is run from the ORACDR pipeline
#     
#
#  Authors:
#     Frossie Economou (JAC)
#     Tim Jenness (JAC)
#
#  History:
#     $Log$
#     Revision 1.4  1998/07/20 06:47:29  timj
#     Turn off red bar when moving cursor in text widget
#
#     Revision 1.3  1998/07/19 00:02:30  timj
#     Up date oracdisp so that it recognises command line options for the
#     input and output files.
#
#     The menus have been changed so that the TOOL can not be selected
#     with incompatible REGIONs or WINDOWs. The UIs have been updated
#     to relfect the required change.
#
#     Section has been renamed Region in the UIs.
#
#     Revision 1.2  1998/07/15 03:10:13  timj
#     Now works with four display types.
#     Can add and delete display entries.
#     Can write to disk.
#
#     Revision 1.1  1998/07/14 21:24:44  timj
#     First demo release
#
#

BEGIN {
  unless (exists $ENV{ORAC_DIR}) {
    print "Warning: The ORAC_DIR environment variable is not defined.\n";
    print "         This may cause problems. (setting to /tmp)\n";
    $ENV{ORAC_DIR} = "/tmp"; # Turn of -w warnings
  }
}

	  

# Make sure that UI files can be read
use lib "$ENV{ORAC_DIR}/gui";


use strict;

use subs qw/update_status image_ui spectrum_ui datamodel_ui sigma_ui/;

# Generic variables
use vars qw/$MW $VERSION $BAR $TKSTATUS $TOPLEVEL/;

# Menus
use vars qw/ %TOOL_TYPES %TOOLS /;

# Variables related to global state of sytem
use vars qw/%STATUS %DEFAULTS @SELECT_LIST @UNDOBUFFER $CURRENT/;

# Widgets
use vars qw/ $UNDO_but /;

# Variables related to definition file
use vars qw/ $InDefnFile $OutDefnFile $DefaultDefnFile/;


# Start up Tk early and put up a status bar

BEGIN {

  use Tk;
  use Tk::ProgressBar;
  '$Revision$ ' =~ /.*:\s(.*)\s\$/ && ($VERSION = $1);

  # Create a new main window
  $MW = MainWindow->new;
  $MW->positionfrom('user');
  $MW->geometry('+40+40');
  $MW->title('ORACDR display configuration utility');
  $MW->iconname('ORACdisp');

  $TKSTATUS = $MW->Label(qw(-width 40 -anchor w -foreground blue),
		       -text => "Obslog $VERSION ...");
  $TKSTATUS->grid(-row => 0, -column => 0, -sticky => 'w'); 
  $BAR = $MW->ProgressBar->grid(-sticky => 's');
  $BAR->configure(-step => 0, -max => 100);
  $MW->update;
}

# Read file reader
use IO::File;

# Options handling
use Getopt::Long;



# Tool options
%TOOLS = (
	  KAPVIEW => {
		      WINDOW => [ 0..4 ],
		      REGION => [ 0..8 ]
		     },
	  P4 => {
		 WINDOW => [ 0..4 ],
		 REGION => [ 0..8 ]
		},
	  GAIA => {
		   WINDOW => [ 0..3 ],
		   REGION => [ 0 ]
		  }
	 );


# Allows tools per type

%TOOL_TYPES = (
	       IMAGE => [ qw / KAPVIEW P4 GAIA/],
	       GRAPH => [ qw /KAPVIEW P4/],
	       SIGMA => [ qw /KAPVIEW/],
	       DATAMODEL => [ qw / KAPVIEW / ]
	      );


# Default Name of definition file
# this can also be read from the command line
# as an option in order to override this default.
$DefaultDefnFile = "$ENV{ORAC_DIR}/disp.dat";

# This is the actual display definition as stored in memory
# It is an array of hashes
# The ID entry in each hash is 'suffix'
# use &update_defn to update the status widget
# use &write_defn to write the defn to a file
# could treat this as an object....(cf ORAC::Index)
my @DispDefn = ();


# Configure the default behaviour
%DEFAULTS = (
	     'IMAGE' => {
			 TOOL => 'KAPVIEW',
			 REGION => 0,
			 WINDOW => 0,
			 SUFFIX => 'RAW',
			 XAUTOSCALE => 1,
			 YAUTOSCALE => 1,
			 ZAUTOSCALE => 1,
			 XMIN => 0,
			 YMIN => 0,
			 ZMIN => 0,
			 XMAX => 100,
			 YMAX => 100,
			 ZMAX => 100
			},
	     'GRAPH' => {
			 TOOL => 'KAPVIEW',
			 REGION => 0,
			 WINDOW => 0,
			 SUFFIX => 'RAW',
			 XAUTOSCALE => 1,
			 YAUTOSCALE => 1,
			 XMIN => 0,
			 YMIN => 0,
			 XMAX => 100,
			 YMAX => 100
			},
	     'DATAMODEL' => {
			     TOOL => 'KAPVIEW',
			     REGION => 0,
			     WINDOW => 0,
			     SUFFIX => 'RAW',
			     XAUTOSCALE => 1,
			     YAUTOSCALE => 1,
			     XMIN => 0,
			     YMIN => 0,
			     XMAX => 100,
			     YMAX => 100
			    },
	     'SIGMA' => {
			 TOOL => 'KAPVIEW',
			 REGION => 0,
			 WINDOW => 0,
			 SUFFIX => 'RAW',
			 RANGE  => 5,
			 DASHED => 3	   
			}
	     );

# Now configure the widget default values
&set_default_status(keys %DEFAULTS);


# Okay now we are really starting

update_status('Reading NoteBook module..', 10);
require Tk::NoteBook;
update_status('Reading Tk::Menu module..', 20);
require Tk::Menu;

update_status('Reading DialogBox module..', 25);
require Tk::DialogBox;

update_status('Reading notebook definitions..', 40);
require 'image.ui.pl';
require 'spectrum.ui.pl';
require 'datamodel.ui.pl';
require 'sigma.ui.pl';


# Before we start packing frames we should examine the options
# First thing to do is read command line options so that
# the input and output files can be set up
update_status('Processing command line options..', 45);
use vars qw/$help $version $optin $optout/;

my $result = GetOptions("help" => \$help,
			"version" => \$version,
			"in=s" => \$optin,
			"out=s" => \$optout
		       );

$help = 1 unless $result == 1; # Print help if unknown option

# Version reporting
# Put up aboutwindow and exit
if ($version) {
  &aboutwin;
  exit;
}

# Help window
# DO i make a window for this or just dump some text?
if ($help) {
  print qq/
 Usage:
\toracdisp [-h] [-v] [-in=file] [-out=file]
 Options:
   -h[elp]\tThis message
   -v[ersion]\tVersion number
   -in=f\tName of input display definition file
   -out=f\tName of output display definition file
/;
  exit;
}

# Configure the input and output display definition files
if (defined $optin) {
  $InDefnFile = $optin;
} else {
  $InDefnFile = $DefaultDefnFile;
}

if (defined $optout) {
  $OutDefnFile = $optout;
} else {
  $OutDefnFile = $InDefnFile;
}



# 1 - Create frames in top window
# 2 - Create frames inside these and pack
# 3 - Pack all the toplevel frames into the MainWindow
# 4 - Start event loop

update_status('Configure toplevel frames...', 60);

# Declare all the frame variables
my $MBar_f; # The Top row of menu buttons
my $NB_f;   # The notebook frame
my $State_f; # The listbox containing the current state

# Global widgets
my $CurrDefn; # The listbox widget that contains the current definitions
my $NB;       # The notebook widget
my $NB_image; # The image notebook widget
my $NB_graph; # The graph notebook widget
my $NB_datamodel; # The DataModel notebook widget
my $NB_sigma; # The Sigma notebook widget



# Actually create the frame objects
$MBar_f = $MW->Frame(-relief =>'flat', -borderwidth => 2);
$NB_f   = $MW->Frame( -relief => 'groove', -borderwidth => 2);
$State_f = $MW->Frame(-relief => 'groove', -borderwidth => 2);

# Now create the top level menu bar
update_status 'Creating menubar...', 60;
&create_topmenu($MBar_f);

# Now create the notebook widget
update_status 'Creating notebook entries...', 70;
&create_notebook($NB_f);

# Now create the lower window containing the current state
# of the settings
update_status 'Creating lower window...', 80;
&create_state($State_f);

# Update the bar to show that we have finished loading (No startup time!)
update_status 'Complete', 99;

# Now that we have created all the widgets we can pack them into the
# main window

# Remove the STATUS and BAR
$TKSTATUS->destroy if defined $TKSTATUS;
$BAR->destroy if defined $BAR;

# Pack the frames into the mainwindow
$MBar_f->grid(-sticky => 'nswe');
$NB_f->grid(-sticky => 'nsew');
$State_f->grid(-sticky => 'nsew');

# Start the event loop
MainLoop;


############################# S U B S ################################

# Subroutines abound....

# create_topmenu
#  This routine creates the row of buttons along the top
# of the main window.
# contains things such as Exit and About buttons

sub create_topmenu {
  my $frame = shift;

  my $about;
  $about = $frame->Button(-text=>'About',
			    -relief=>'raised',
			    -command=>sub{&aboutwin($about)})->pack(-side=>'right');

  my $quit = $frame->Button(-text=>'Exit',
			     -relief=>'raised',
			     -command=>sub{&close_oracdisp})->pack(-side=>'left');

}

# This routine formats and packs the NoteBook
# Argument is the frame in which it should be packed
# Assumes that the UI frame code has been 'required' earlier

sub create_notebook {
  my $frame = shift;

  # Create the notebook
  $NB = $frame->NoteBook(-ipadx => 6, -ipady => 6);
  
  # Now declare the entries
  # and set up a raise command
  $NB_image = $NB->add("image", -label => "Image", -underline => 0,
		       -raisecmd => \&onNBraise);
  $NB_graph = $NB->add("graph", -label => "Graph", -underline => 0,
		       -raisecmd => \&onNBraise);
  $NB_sigma = $NB->add("sigma", -label => "Sigma", -underline => 0,
		       -raisecmd => \&onNBraise);
  $NB_datamodel = $NB->add("datamodel", -label => "DataModel", 
			   -underline => 0,
			   -raisecmd => \&onNBraise);

  # Now fill the entries with 'stuff'
  image_ui $NB_image;
  spectrum_ui $NB_graph;
  sigma_ui $NB_sigma;
  datamodel_ui $NB_datamodel;

  # And pack the pages into the required frame
  $NB->pack(-expand => 'yes',
	    -fill => 'both',
	    -padx => 5, -pady => 5,
	    -side => 'top');
}

# Sub to create the list widget at the bottom of the screen that 
# contains the current display configuration

sub create_state {
  my $frame = shift;

  # Create a text widget for the data with an attached Scroll bar
  # This becomes a Global variable so that
  # we can always access the widget for updating entired
  $CurrDefn = $frame->Scrolled('Text',
			       -scrollbars => 'se',
			       -wrap => 'none',
			       -setgrid => 1,
			       -height=>5,
			       -width =>30
			      )->pack(-side =>'top',-fill => 'both');
  $CurrDefn->bindtags(qw/widget_demo/); # Remove all bindings except dummy

  # Add a button that will write the state to file
  my $configure_but = $frame->Button(-text => 'Configure',
				     -relief => 'raised',
				     -command => \&write_defn
				    )->pack(-side=>'left');

  # A button to delete highlighted entries
  # Looks in the global variable @SELECT_LIST for a list of indices to
  # remove
  my $delete_but = $frame->Button(-text => 'Delete',
				  -relief => 'raised',
				  -command => \&delete_entry_from_defn
				 )->pack(-side=>'left');

  # An undo button. Uses @UNDOBUFFER
  # Global so that we can change the state
  $UNDO_but = $frame->Button(-text => 'Undo',
			     -relief => 'raised',
			     -state  => 'disabled',
			     -command => \&undo_delete
			    )->pack(-side => 'left');
  
  # Now fill the widget with the contents of the default state
  # Read in the default configuration from file
  # This sets the state in the defn array
  &read_defn;

  # Now run the task that fills the text widget with entries
  &update_defn;

}
  
# This sub is invoked every time the NoteBook entry is raised
# to the front. It makes sure that the 'update' button is disabled
# and that the current selection is unset.
# This is necessary so that a selection can be updated only when
# it is current (ie when an entry is selected in the listbox 
# we keep track of the update unless another image type is selected.
# this means that everything can be configured except the display type.
# This may not be good. Will need to discuss

sub onNBraise {
  undef $CURRENT;
}



# This sub inserts text into a widget and sets a tag
# Carriage returns are not appended.
#
# args:  Window object, text, list of tags to associate with line

sub insert_text {

  my $w = shift;
  my $text = shift;

  # Get the start position from the current state of the object
  my $start = $w->index('insert');

  # Insert the text
  $w->insert('insert', $text);

  # Remove all tags on this position
  foreach my $tag ($w->tag('names', $start)) {
    # Im not sure this does anything at all :-)
    $w->tag('remove', $tag, $start, 'insert');
  }

  # If a list has been supplied then set the tags
  if (@_) {
    my @tags = @_;
    foreach my $tag (@tags) {
      $w->tag('add', $tag, $start, 'insert');
    }
  }

}


# This routine closes down the GUI
sub close_oracdisp {
  $MW->destroy if defined $MW;
}

# This routine pops up a window telling us all abour oracdisp

sub aboutwin {
  my $aboutbut = shift;

  # Turn off the button that called this
  $aboutbut->configure(-state=>'disabled') if defined $aboutbut;

  my $f = $MW->DialogBox(-title => 'About oracdisp', -buttons => ["OK"]);

  $f->Label(-text =>"ORACDISP\n\nBy: Frossie Economou and Tim Jenness\n\nVersion: $VERSION")->pack;

  # One problem with using a dialog box is that the window
  # grabs focus. If this is a pain I will rewrite using my own
  # widgets
  my $result = $f->Show;

  if ($result && defined $aboutbut) {
    $aboutbut->configure(-state=>'normal');
  }
  

}


# This subroutine updates the display widget on startup

sub update_status {
 
    my($status_text, $something) = @_;
 
    $TKSTATUS->configure(-text => "$status_text ...");
    $BAR->configure(-step=>$something);
    if (defined $TOPLEVEL) {
      $TOPLEVEL->update;
    } else {
      $MW->update;
    }
 
}

# Subroutine to read the current definition from disk
# The name of the file is stored in the global variable $InDefnFile
# This routine is almost exactly the same as the reader in
# ORAC::Display::parse_file_defn

sub read_defn {

  # Reset the current definition
  @DispDefn = ();

  # Open the file
  my $file = new IO::File("< $InDefnFile");

  # If the file is okay....
  if (defined $file) {
    
    # Probably want to skip all lines containing comments
    foreach my $line (<$file>) {

      chop $line;  # Get rid of carriage return

      next unless defined $line;
      next unless $line =~ /./;

      # Parse the line and convert to hash
      my $href = Disp_TextToH($line);

      next unless defined $href;
      # Now store the hash on the stack
      push(@DispDefn, $href);

    }

  } else {
    warn ("Definition file ($InDefnFile) could not be opened");
  }

  return;
}

# update_defn 
#   This routine takes the definition array and copies it into
#   the status widget
# The global defintion is stored in @DispDefn

sub update_defn {

  # This routine simply runs through @DispDefn and constructs a 
  # string that is then displayed 

  # Allow modification in the widget
  $CurrDefn->configure(-state => 'normal');

  # Clear the widget
  $CurrDefn->delete('1.0', 'end');

  # Clear all tags
#  foreach my $tag ($CurrDefn->tag('names')) {
#    $CurrDefn->tag('delete', $tag);
#  }
    $CurrDefn->tag('delete', $CurrDefn->tag('names'));

  # Now loop through @DispDefn
  for (my $i =0; $i <= $#DispDefn; $i++) {

    my $defn = $DispDefn[$i];
    
    # Tag name
    my $tag = "d$i";
    
    # Convert to a string
    my $text = Disp_HtoText($defn);

    next unless defined $text;

    # And insert this text into the widget and tag it with $i
    &insert_text($CurrDefn, "$text\n", $tag, 'normal', 'selected');

    # Now configure this tag so that it recongises when 
    # the mouse arrives and leaves
    $CurrDefn->tag('bind', $tag, '<Any-Enter>' => 
		   sub {shift->tag('configure', $tag,
				   -relief => 'raised',
				   -borderwidth => 2
				  )}
		  );

    $CurrDefn->tag('bind', $tag, '<Any-Leave>' => 
		   sub {shift->tag('configure', $tag,
				   -relief => 'flat',
				  )}
		  );

    # Now we should configure it so that something happens when 
    # we double click
    # All we really need to do is associate the command with
    # the 
    $CurrDefn->tag('bind', $tag, 
		   '<Double-1>' => sub {&reflect_defn($defn);}
		  );

    # Configure the Single Button release such that it can
    # turn on or off selection
    $CurrDefn->tag('bind', $tag,
		   '<ButtonRelease-1>' =>
		   sub { my $index = substr($tag, 1);
			 my $widg = shift;

			 # Check to see whether the index is
			 # already stored
			 if (grep(/^$index$/,@SELECT_LIST) > 0) {
			   # Already in so remove it
			   @SELECT_LIST = grep(!/^$index$/,@SELECT_LIST);
			   $widg->tag('configure',$tag,
				     -foreground => undef);
			 } else {
			   push(@SELECT_LIST, $index);
			   $widg->tag('configure',$tag,
				     -foreground => 'blue');
			 }

		       }
		  );

  }

  # Disable the box so that people cant write in it
  $CurrDefn->configure(-state => 'disabled');


}

# WRITE_DEFN
#   Write a display definition to disk
#   More or less the sames as update_defn
#   except we write to a file

sub write_defn {

  # Open the file for writing
  # Open the file
  my $file = new IO::File("> $OutDefnFile");

  # If the file is okay....
  if (defined $file) {
    
    # Now loop through @DispDefn
    for (my $i =0; $i <= $#DispDefn; $i++) {

      my $defn = $DispDefn[$i];
    
      # Convert to a string
      my $text = Disp_HtoText($defn);
      
      next unless defined $text;

      # Print to the file
      print $file $text . "\n";

    }

    # Dialog box
    my $f = $MW->DialogBox(-title => 'Update', -buttons => ["OK"]);
    $f->Label(-bitmap => 'info')->pack;
    $f->Label(-text => "Display configuration written to disk")->pack;
    $f->Show;

  } else {

    # Dialog box
    my $f = $MW->DialogBox(-title => 'Update', -buttons => ["OK"]);
    $f->Label(-bitmap => 'error')->pack;
    $f->Label(-text => "Error writing configuration to disk\nFile: $OutDefnFile\n$!\n")->pack;
    $f->Show;

  }

}


# Routine to take an entry in @DispDefn and convert it to a string
# suitable for display or writing to a file
# Expects a hash reference as input

sub Disp_HtoText {
  # First arg is the hash reference
  my $href = shift;

  die 'Not a hash reference' unless ref($href) eq 'HASH';

  my %hash = %{$href};

  # Now the first bit of the string is just the ID
  my $string;
  if (exists $hash{'ID'}) {
    $string = $hash{'ID'};
  } else {
    print "GUI_Error::: ID key is missing\n";
    return undef;
  }
  
  foreach my $key (keys %hash) {
    next if $key eq 'ID';
    $string .= " " . $key . "=$hash{$key}";
  }

  # Return the string
  return $string;
}

# Routine to convert a text line (as stored on the text widget or
# in a Definition File and convert it to a hash

sub Disp_TextToH {
  my $text = shift;

  # Return immediately if there was nothing there
  return undef unless defined $text;

  # Strip leading spaces
  $text =~ s/^\s+//;

  # Skip  blank lines
  return undef  unless defined $text;
  
  # Skip comments 
  return if $text =~ /^\#/;
      
  # Now we need to split up the line
  my @bits = split(/\s+/, $text);

  # We are generating a hash
  my %hash = ();

  # We know the first key
  $hash{'ID'} = shift(@bits);

  return unless defined $text;

  # Now loop through the remainder and split on equals
  foreach my $key (@bits) {
    my ($hkey, $value) = split(/=/,$key);
    $hkey = uc($hkey);
    $hash{$hkey} = $value;
  }

  return \%hash;

}


# Routine to update the NoteBook item so that it reflects the
# selected Defintion entry.
# Args:  Hash reference (might change this to a number since that would
#           be the obvious OO interface)

sub reflect_defn {
  my $href = shift;

#  print "Process: ". Disp_HtoText($href) . "\n";

  # Now we need to process the line to decide on the required
  # NoteBook entry and then set the variables

  # Take a copy of the entry hash
  my %defn = %$href;

  # First display type
  # If TYPE does not exist then we are in trouble
  if (exists $defn{TYPE}) {

    my $type = $defn{TYPE};
    
    # Raise it
    $NB->raise(lc($type));

    # TYPE is upper case in the STATUS hash
    $type = uc($type);

    # Do it the long way first
    $STATUS{$type}{SUFFIX} = $defn{ID} if exists $defn{ID};
    $STATUS{$type}{XAUTOSCALE} = $defn{XAUTOSCALE} if exists $defn{XAUTOSCALE};
    $STATUS{$type}{YAUTOSCALE} = $defn{YAUTOSCALE} if exists $defn{YAUTOSCALE};
    $STATUS{$type}{ZAUTOSCALE} = $defn{ZAUTOSCALE} if exists $defn{ZAUTOSCALE};
    $STATUS{$type}{TOOL} = uc($defn{TOOL}) if exists $defn{TOOL};
    $STATUS{$type}{REGION} = $defn{REGION} if exists $defn{REGION};
    $STATUS{$type}{WINDOW} = $defn{WINDOW} if exists $defn{WINDOW};
    $STATUS{$type}{XMIN} = $defn{XMIN} if exists $defn{XMIN};
    $STATUS{$type}{XMAX} = $defn{XMAX} if exists $defn{XMAX};
    $STATUS{$type}{YMIN} = $defn{YMIN} if exists $defn{YMIN};
    $STATUS{$type}{YMAX} = $defn{YMAX} if exists $defn{YMAX};
    $STATUS{$type}{ZMIN} = $defn{ZMIN} if exists $defn{ZMIN};
    $STATUS{$type}{ZMAX} = $defn{ZMAX} if exists $defn{ZMAX};
    $STATUS{$type}{RANGE} = $defn{RANGE} if exists $defn{RANGE};
    $STATUS{$type}{DASHED} = $defn{DASHED} if exists $defn{DASHED};


  } else {
    print "Display type is not available.....:\n";
    print Disp_HtoText($href) . "\n";
  }

}


# Create menus. The TOOL is a special menu since the contents
# of window and region depend on tool.
#
#  Args: display type (IMAGE, GRAPH, etc), tool menu button, remainder
#   The menubutton widgets are for the TOOL (the main one), window
#   and section

sub create_menus {
  my ($type, $toolw, $winw, $regw) = @_;

  $type = uc($type);
  
  
  foreach my $entry (@{$TOOL_TYPES{$type}}) {
    
    # Create tool menu
    # When the command is exectued, the variable is updated and
    # the WINDOW and REGION windows are updated.
    $toolw->command(-label => $entry,
		    -command => sub {
		      $STATUS{$type}{TOOL} = $entry;
		      &reconfig_menu($winw, $type, $entry, 'WINDOW');
		      &reconfig_menu($regw, $type, $entry, 'REGION');
		    } );

    # Special case - disable the GAIA item
    $toolw->menu->entryconfigure('end', -state => 'disabled')
       if $entry eq 'GAIA';
    
  }

  # Now setup the WINDOW menu using the current state of type
  &reconfig_menu($winw, $type, $STATUS{$type}{TOOL}, 'WINDOW');
  &reconfig_menu($regw, $type, $STATUS{$type}{TOOL}, 'REGION');

}


# reconfig_menu($w, $type, $tool, $menu)
#   Configures menu $w (name $menu - WINDOW,REGION...), 
#   in type $type (IMAGE,GRAPH..) so that it is oncistent
#   with tool $tool (could use the global variable for this)
#  If the current state of the menubutton does not match any 
#  of the menu entries the value is changed to the first menu
#  entry.

sub reconfig_menu {

  my ($w, $type, $tool, $menu) = @_;
  
  $type = uc($type);
  $tool = uc($tool);
  $menu = uc($menu);
  

  # Need to clear the menu
  $w->menu->delete(0,'end');

  my $okay = 0;
  
  # Now create a new one
  foreach my $item (@{$TOOLS{$tool}{$menu}}) {

    $w->command( -label   => $item,
		 -command => sub { $STATUS{$type}{$menu} = $item }
	       );

    # Compare current state with each item
    $okay = 1 if $item eq $STATUS{$type}{$menu};
  }

  # If nothing matched the current state, change the current state
  $STATUS{$type}{$menu} = $ {$TOOLS{$tool}{$menu}}[0]
     unless $okay;
 
}


# Sub to create and entry in the definition table from 
# the GUI

sub add_image_entry {

  my $href = &read_image;

  # Now store this in the array
  push(@DispDefn, $href);

  # Now update the list box
  update_defn;

}

sub add_graph_entry {

  my $href = &read_graph;

  # Now store this in the array
  push(@DispDefn, $href);

  # Now update the list box
  update_defn;

}

sub add_datamodel_entry {

  my $href = &read_datamodel;

  # Now store this in the array
  push(@DispDefn, $href);

  # Now update the list box
  update_defn;

}

sub add_sigma_entry {

  my $href = &read_sigma;

  # Now store this in the array
  push(@DispDefn, $href);

  # Now update the list box
  update_defn;

}




# Sub to read the image widget and store the information in a hash
# A hash reference is returned.

sub read_image {

  # Create the hash to store all this in
  my %values = ();

  $values{TYPE} = 'IMAGE';

  # Now read the widget state into the hash
  $values{ID} = $STATUS{IMAGE}{SUFFIX};
  $values{TOOL} = $STATUS{IMAGE}{TOOL};
  $values{WINDOW} = $STATUS{IMAGE}{WINDOW};
  $values{REGION} = $STATUS{IMAGE}{REGION};

  $values{XAUTOSCALE} = $STATUS{IMAGE}{XAUTOSCALE};  
  $values{YAUTOSCALE} = $STATUS{IMAGE}{YAUTOSCALE};  
  $values{ZAUTOSCALE} = $STATUS{IMAGE}{ZAUTOSCALE};  

  $values{XMIN} = $STATUS{IMAGE}{XMIN};
  $values{XMAX} = $STATUS{IMAGE}{XMAX};
  $values{YMIN} = $STATUS{IMAGE}{YMIN};
  $values{YMAX} = $STATUS{IMAGE}{YMAX};
  $values{ZMIN} = $STATUS{IMAGE}{ZMIN};
  $values{ZMAX} = $STATUS{IMAGE}{ZMAX};

  return \%values;

}

# Sub to read the graph widget and store the information in a hash
# A hash reference is returned.

sub read_graph {

  # Create the hash to store all this in
  my %values = ();

  $values{TYPE} = 'GRAPH';

  # Now read the widget state into the hash
  $values{ID} = $STATUS{GRAPH}{SUFFIX};
  $values{TOOL} = $STATUS{GRAPH}{TOOL};
  $values{WINDOW} = $STATUS{GRAPH}{WINDOW};
  $values{REGION} = $STATUS{GRAPH}{REGION};

  $values{XAUTOSCALE} = $STATUS{GRAPH}{XAUTOSCALE};  
  $values{YAUTOSCALE} = $STATUS{GRAPH}{YAUTOSCALE};  

  $values{XMIN} = $STATUS{GRAPH}{XMIN};
  $values{XMAX} = $STATUS{GRAPH}{XMAX};
  $values{YMIN} = $STATUS{GRAPH}{YMIN};
  $values{YMAX} = $STATUS{GRAPH}{YMAX};

  return \%values;

}

# Sub to read the datamodel widget and store the information in a hash
# A hash reference is returned.

sub read_datamodel {

  # Create the hash to store all this in
  my %values = ();

  $values{TYPE} = 'DATAMODEL';

  # Now read the widget state into the hash
  $values{ID} = $STATUS{DATAMODEL}{SUFFIX};
  $values{TOOL} = $STATUS{DATAMODEL}{TOOL};
  $values{WINDOW} = $STATUS{DATAMODEL}{WINDOW};
  $values{REGION} = $STATUS{DATAMODEL}{REGION};

  $values{XAUTOSCALE} = $STATUS{DATAMODEL}{XAUTOSCALE};  
  $values{YAUTOSCALE} = $STATUS{DATAMODEL}{YAUTOSCALE};  

  $values{XMIN} = $STATUS{DATAMODEL}{XMIN};
  $values{XMAX} = $STATUS{DATAMODEL}{XMAX};
  $values{YMIN} = $STATUS{DATAMODEL}{YMIN};
  $values{YMAX} = $STATUS{DATAMODEL}{YMAX};

  return \%values;

}

# Sub to read the sigma widget and store the information in a hash
# A hash reference is returned.

sub read_sigma {

  # Create the hash to store all this in
  my %values = ();

  $values{TYPE} = 'SIGMA';

  # Now read the widget state into the hash
  $values{ID} = $STATUS{SIGMA}{SUFFIX};
  $values{TOOL} = $STATUS{SIGMA}{TOOL};
  $values{WINDOW} = $STATUS{SIGMA}{WINDOW};
  $values{REGION} = $STATUS{SIGMA}{REGION};

  $values{RANGE} = $STATUS{SIGMA}{RANGE};
  $values{DASHED} = $STATUS{SIGMA}{DASHED};

  return \%values;

}

# This subroutine copies the default values to the STATUS array
# It is run during initialisation and whenever the REVERT button is
# pushed
#
#  Arguments is TYPE {GRAPH|IMAGE|SIGMA|etc}

sub set_default_status {

  my @types = @_;

  # Cant just copy the new hashref in since this would change the
  # scalar references inside the hash that are linked to the widgets
  # Do it long hand setting each in turn

  foreach my $type (@types) {
    foreach my $key (keys %{$DEFAULTS{$type}}) {
      $STATUS{$type}{$key} = $DEFAULTS{$type}{$key};
    }
  }

}


# Sub to delete the specified entries from DispDefn
# Uses the contents of @SELECT_LIST to provide the indices

sub delete_entry_from_defn {

  # Set up a local copy
  my @local = ();

  # Reset the UNDO buffer
  @UNDOBUFFER = ();

  # Need to work out which indices ARE allowed
  # ie those that are not in @SELECT_LIST
  for (my $i=0; $i <= $#DispDefn; $i++) {
    # Copy it across if the index is not in the selected list
    if (grep(/^$i$/,@SELECT_LIST) == 0) {
      push(@local, $DispDefn[$i]);
    } else {
      # Store in the UNDO buffer
      push(@UNDOBUFFER, $DispDefn[$i]);
      
      # Enable the undo button
      $UNDO_but->configure(-state => 'normal');
    }
  }

  # Copy back to DispDefn
  @DispDefn = @local;

  # The selection list should be reset after a deletion
  @SELECT_LIST = ();

  # Redraw the listbox
  &update_defn;

}


# UNDO a delete from the list box

sub undo_delete {
  # Now need to copy the contents of the UNDO buffer back onto
  # the DispDefn
  push(@DispDefn, @UNDOBUFFER);

  # Disable the button
  $UNDO_but->configure(-state => 'disabled');

  # Update the window
  &update_defn;
}
