\subsection{ORAC::Basic\label{ORAC::Basic}\index{ORAC::Basic}}


Some implementation subroutines

\subsubsection*{SYNOPSIS\label{ORAC::Basic_SYNOPSIS}\index{ORAC::Basic!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Basic;
\end{verbatim}
\begin{verbatim}
  $Display = orac_setup_display;
  orac_exit_normally($message);
  orac_exit_abnormally($message);
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Basic_DESCRIPTION}\index{ORAC::Basic!DESCRIPTION}}


Routines that do not have a home elsewhere.

\subsubsection*{FUNCTIONS\label{ORAC::Basic_FUNCTIONS}\index{ORAC::Basic!FUNCTIONS}}


The following functions are provided:

\begin{description}

\item[{\textbf{orac\_force\_abspath}}] \mbox{}

Force ORAC\_DATA\_IN and ORAC\_DATA\_OUT to use an absolute path
rather than a relative path. Must be called before pipeline
does the first chdir.

\begin{verbatim}
 orac_force_abspath();
\end{verbatim}


Does not canonicalize.


\item[{\textbf{orac\_setup\_display}}] \mbox{}

Create a new Display object for use by the recipes. This includes
the association of this object with a specific display configuration
file (\emph{disp.dat}). If a configuration file is not in \$ORAC\_DATA\_OUT
one will be copied there from \$ORAC\_DATA\_CAL (or \$ORAC\_DIR
if no file exists in \$ORAC\_DATA\_CAL).



If the \$DISPLAY environment variable is not set, the display
subsystem will be started but only for use by monitor programs.



The display object is returned.

\begin{verbatim}
  $Display = orac_setup_display;
\end{verbatim}


Hash arguments can control behaviour to indicate master vs monitor
behaviour. Options are:

\begin{verbatim}
  - monitor =>  configure as a monitor (default is to be master) (false)
  - nolocal =>  disable master display, monitor files only.
                Default is to display locally (false)
\end{verbatim}


Monitor files are always written if a master.


\item[{\textbf{orac\_exit\_normally}}] \mbox{}

Standard exit handler for oracdr. Should be called instead of \texttt{exit()}
when the pipeline is complete.



Hash arguments control the behaviour. Allowed keys are:

\begin{verbatim}
  quiet - Do not print any informational messages to stdout (default is false)
  message - Any string to be printed
  err   - true if the supplied message is an error message
          or if the process should exit with bad status (default is false
          unless error stack is populated)
\end{verbatim}


If called with a single argument, it is assumed to be an informational
message and is equivalent to using the "message" argument. "err" will
default to true if we are called when there are messages in the
ORAC::Error stack.



Message is printed using orac\_err if we know it is an error message.
It will be printed even if "quiet" is true.


\item[{\textbf{orac\_exit\_abnormally}}] \mbox{}

Exit handler when a problem has been encountered. Normally
used a signal handler for SIGINT.


\item[{\textbf{orac\_chdir\_output\_dir}}] \mbox{}

Change to the output directory. If that fails, exit the pipeline.

\begin{verbatim}
  orac_chdir_output_dir();
\end{verbatim}


Default output directory is controlled by ORAC\_DATA\_OUT environment
variable.



Takes one argument, a boolean dictating whether or not a check that
the data is on an NFS disk should be done. By default this check is
done, and if ORAC\_DATA\_OUT is on an NFS-mounted disk, then the
pipeline will exit.

\end{description}
\subsubsection*{REVISION\label{ORAC::Basic_REVISION}\index{ORAC::Basic!REVISION}}


\$Id\$

\subsubsection*{SEE ALSO\label{ORAC::Basic_SEE_ALSO}\index{ORAC::Basic!SEE ALSO}}


\emph{ORAC::Core}, \emph{ORAC::General}

\subsubsection*{COPYRIGHT\label{ORAC::Basic_COPYRIGHT}\index{ORAC::Basic!COPYRIGHT}}


Copyright (C) 1998-2004 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Convert\label{ORAC::Convert}\index{ORAC::Convert}}


Methods for converting data formats

\subsubsection*{SYNOPSIS\label{ORAC::Convert_SYNOPSIS}\index{ORAC::Convert!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Convert
\end{verbatim}
\begin{verbatim}
  $conv = new ORAC::Convert;
  $outfile = $conv->convert($infile, {IN => 'FITS', OUT => 'NDF'});
\end{verbatim}
\begin{verbatim}
  $outfile = $conv->convert($infile, { OUT => 'NDF'});
\end{verbatim}
\begin{verbatim}
  $outfile = $conv->fits2ndf($infile);
\end{verbatim}
\begin{verbatim}
  $conv->infile($infile);
  $outfile = $conv->convert;  # uses infile()
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Convert_DESCRIPTION}\index{ORAC::Convert!DESCRIPTION}}


Provide a system for converting data formats. Currently the
only output format supported are:

\begin{verbatim}
  NDF     - simple NDF files
  HDS     - HDS containers with .HEADER and .Inn NDFs
  FITS    - Simple FITS files
\end{verbatim}


The only input formats supported are:

\begin{verbatim}
  NDF     - simple NDF files
  FITS    - FITS file
  UKIRTIO - UKIRT I/O file
  HDS     - HDS containers with .HEADER and .Inn NDFs
            In general this can only be converted to a NDF or FITS
            output file if there is only one data frame in the container.
  GMEF    - Gemini Multi-Extension FITS.
  INGMEF  - Isaac Newton Group Multi-Extension FITS.
\end{verbatim}


In many cases the NDF format is used as the intermediate format for
all conversions (should probably use PDLs as the intermediate
format....)



Uses the Starlink CONVERT package (via monoliths) where necessary.



Can be used to convert from instrument specific NDF files (eg
multi-frame CGS4 data or I- and O- frames for IRCAM) to HDS formats
usable by the pipeline (either as HDS containers or NDFs with combined
I and O information).



The output filename is always related to the input filename
(usually simply with a change of suffix).

\subsubsection*{METHODS\label{ORAC::Convert_METHODS}\index{ORAC::Convert!METHODS}}


The following methods are provided:

\paragraph*{Constructors\label{ORAC::Convert_Constructors}\index{ORAC::Convert!Constructors}}
\begin{description}

\item[{\textbf{new}}] \mbox{}

Object constructor. Should always be used before initiating a conversion.

\begin{verbatim}
  $Cvt = new ORAC::Convert;
\end{verbatim}


Returns undef if there was an error creating the object. No arguments
are required.

\end{description}
\paragraph*{Accessor Methods\label{ORAC::Convert_Accessor_Methods}\index{ORAC::Convert!Accessor Methods}}


The following methods are available for accessing the
'instance' data.

\begin{description}

\item[{\textbf{engine\_launch\_object}}] \mbox{}

Returns the \texttt{ORAC::Msg::EngineLaunch} object that can be used
to launch algorithm engines as required by the particular
conversion.

\begin{verbatim}
 $messys = $self->messys_launch_object;
\end{verbatim}

\item[{\textbf{infile}}] \mbox{}

Method for storing or retreiving the current input filename.
Used by default if omitted from convert() methods.

\begin{verbatim}
  $infile = $Cvt->infile;
\end{verbatim}

\item[{\textbf{overwrite}}] \mbox{}

Method for storing or retreiving the flag governing whether
a file should be overwritten if it already exists.



If false, the file will be converted regardless.

\end{description}
\paragraph*{General Methods\label{ORAC::Convert_General_Methods}\index{ORAC::Convert!General Methods}}
\begin{description}

\item[{\textbf{convert}}] \mbox{}

Convert a file to the format specified by options.

\begin{verbatim}
  ($infile, $outfile) = $Cvt->convert;
  @files = $Cvt->convert($oldfile, { IN => 'FITS', OUT => 'NDF' });
\end{verbatim}


File is optional - uses infile() to retrieve the name if not specified.
The options hash is optional (assumed to be last argument). If not
specified the input format will be guessed and the output format
will be set to NDF.



Recogised keywords in the hash are:

\begin{verbatim}
  IN  => input format (NDF, UKIRTio or FITS)
  OUT => desired output format (NDF or HDS)
\end{verbatim}


If 'IN' is not specified it will try to derive the format from
name.



The output format is set to NDF if non-specified.



Returns a list containing the input filename and output filename.
Neither of these filenames has any directory structure removed.



Output filename is written to the current working directory of the
CONVERT monoliths (defaults to the CWD of the program when the
monoliths were launched - no attempt is made to correct the
CWD of the monoliths before conversion).



Will return an undefined output file if the conversion failed.


\item[{\textbf{guessformat}}] \mbox{}

Given 'name' try to guess data format.

\begin{verbatim}
  $format = $Cvt->guessformat("test.sdf");
\end{verbatim}


If no name is supplied, infile() is used to retrieve the current
filename.


\item[{\textbf{mon}}] \mbox{}

Returns the algorithm engine object, launching it if required.

\begin{verbatim}
  $object = $Cvt->mon($name);
\end{verbatim}


Returns undef if a monolith can not be contacted or fails to start.
This is launched using \texttt{ORAC::Msg::LaunchEngine}.

\end{description}
\paragraph*{Data Conversion Methods\label{ORAC::Convert_Data_Conversion_Methods}\index{ORAC::Convert!Data Conversion Methods}}
\begin{description}

\item[{\textbf{fits2ndf}}] \mbox{}

Convert a fits file to an NDF.
Returns the output name.

\begin{verbatim}
  $newfile = $Cvt->fits2ndf;
\end{verbatim}


Retrieves the input filename from the object via the infile()
method.


\item[{\textbf{ndf2fits}}] \mbox{}

Convert an NDF file to a FITS file.


\item[{\textbf{hds2mef}}] \mbox{}

Convert a HDS file into a multi-extension FITS file


\item[{\textbf{gmef2hds}}] \mbox{}

Convert a GEMINI multi-extension FITS file to an HDS container


\item[{\textbf{ingmef2hds}}] \mbox{}

Convert an ING format Multi-Extension FITS file into an HDS container.


\item[{\textbf{UKIRTio2hds}}] \mbox{}

Converts observations that are taken as a header file plus multiple
NDFs into a single HDS container that contains a .HEADER NDF and
.Inn NDFs for each of the nn data files. This is the scheme used for
IRCAM and CGS4 data at UKIRT.

\begin{verbatim}
  $hdsfile = $Cvt->UKIRTio2hds;
\end{verbatim}


This routine assumes the old UKIRT data acquisition system (at least for
IRCAM and CGS4) is generating the data files. The name of the header
file (aka the O-file) must be stored in the object (via the infile()
method) before running this method. The I files are assumed to be in
the directory \texttt{../idir} relative to the header file with a starting
character of 'i' rather than 'o' and are multiple files with
suffixes of '\_1', '\_2' etc. The new output file
is named 'cYYYYMMDD\_NNNNN' where the date is retrieved from the IDATE header
keyword and observation number from the OBSNUM header keyword.



Returns undef on error.


\item[{\textbf{hds2ndf}}] \mbox{}

Converts frames taken as HDS container files (container file with
.HEADER and .I1) to a simple NDF file. This method only works
for the first frame (.I1).

\begin{verbatim}
  $ndf = $Cvt->hds2ndf;
\end{verbatim}


If the input HDS has a .I1 component with FITS headers, then the
resulting NDF file has the FITS headers from both the .HEADER and
the .I1 components merged. Otherwise, the resulting NDF has the
FITS headers from just the .HEADER component. No warning is given
if more than one component exists (all higher numbers are ignored).

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Convert_SEE_ALSO}\index{ORAC::Convert!SEE ALSO}}


The Starlink CONVERT package.

\subsubsection*{REVISION\label{ORAC::Convert_REVISION}\index{ORAC::Convert!REVISION}}


\$Id\$

\subsubsection*{COPYRIGHT\label{ORAC::Convert_COPYRIGHT}\index{ORAC::Convert!COPYRIGHT}}


Copyright (C) 1998-2005 Particle Physics and Astronomy Research
Council. All Rights Reserved.



This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.



This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.



You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

\subsection{ORAC::Core\label{ORAC::Core}\index{ORAC::Core}}


Core routines for data pipelining

\subsubsection*{SYNOPSIS\label{ORAC::Core_SYNOPSIS}\index{ORAC::Core!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Core;
\end{verbatim}
\begin{verbatim}
  orac_process_frame($CURRENT_RECIPE, $PRIMITIVE_LIST, $opt_showcurrent,
                     $Frm, $Grp, $Cal,\%Mon,$OverRecipe, $instrument);
\end{verbatim}
\begin{verbatim}
  orac_store_frm_in_correct_grp($Frm, $GrpType, $GrpHash, $GrpArr, $ut);
\end{verbatim}
\begin{verbatim}
  orac_print_configuration( $opt_debug, $opt_showcurrent, $log_options,
                            $win_str, \$STATUS_TEXT  );
\end{verbatim}
\begin{verbatim}
  orac_message_launch( $opt_nomsgtmp, $opt_verbose );
\end{verbatim}
\begin{verbatim}
  orac_start_algorithm_engines( $opt_noeng, $InstObj );
\end{verbatim}
\begin{verbatim}
  orac_start_display( $nodisplay );
\end{verbatim}
\begin{verbatim}
  orac_calib_override( $opt_calib, $calclass );
\end{verbatim}
\begin{verbatim}
  orac_parse_files( $opt_files );
\end{verbatim}
\begin{verbatim}
  orac_process_argument_list( $opt_from, $opt_to, $opt_skip, $opt_list,
                               $frameclass );
\end{verbatim}
\begin{verbatim}
  orac_main_data_loop( $opt_batch, $opt_ut, $opt_resume, $opt_skip,
                       $opt_debug, $recsuffix, $grptrans,
                       $loop, $frameclass, $groupclass,
                       $instrument, $Mon, $Cal, \@obs, $Display, $orac_prt,
                       $ORAC_MESSAGE, \$STATUS_TEXT, $PRIMITIVE_LIST,
                       $Override_Recipe );
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Core_DESCRIPTION}\index{ORAC::Core!DESCRIPTION}}


This module contains the core routines that actually handle the
data processing. Routines are provided for constructing groups
and for processing those groups, along with routines to do the
inital pipeline configuration and algorithm engine startup.

\subsubsection*{SUBROUTINES\label{ORAC::Core_SUBROUTINES}\index{ORAC::Core!SUBROUTINES}}


The following subroutines are available:

\begin{description}

\item[{\textbf{orac\_store\_frm\_in\_correct\_grp}}] \mbox{}

Stores the supplied frame into a Grp (usually specified in the Frame),
creating a new Group object if necessary. The Group objects are stored
in a hash (reference supplied) and, optionally, an array (unless undef).
This is so that Groups can be retrieved in the order in which they
were created. The GrpType specifies the type of Group that should be
created (eg \textbf{ORAC::Group::UFTI}, \textbf{ORAC::Group::JCMT} etc). The UT
is supplied purely so that the Group can be named (using the
file\_from\_bits() method).

\begin{verbatim}
  orac_store_frm_in_correct_grp($Frm, $GrpType, \%Groups, \@Groups,
        $ut, $resume, $transient);
  orac_store_frm_in_correct_grp($Frm, $GrpType, \%Groups, undef,
        $ut, $resume, $transient);
\end{verbatim}


The resume flag is used to determine the behaviour of the group when
it is first created. If resume is false, any existing Group file is
removed before proceeding; if it is true, the Group file is retained
and any coadd information is read using the coaddsread() Group
method.



The transient argument controls whether more than one group can be
created. If transient is 1 only a single group is stored in \%Groups,
although multiple may be created during processing. If transient is -1
then only one group is ever created, and every Frame object goes into
that group.



The current Grp (ie the Group associated with the supplied Frm)
is returned.


\item[{\textbf{orac\_process\_frame}}] \mbox{}

This is the core \textbf{ORAC-DR} pipeline processing routine.
It processes the supplied frame object that belongs to the group object,
using the supplied calibration object. The instrument name and default
recipe are required for recipe/primitive reading since recipes and
primitives are stored in instrument specific directories.
The \%Mon hash is supplied so that a recipe has full access to
all the monoliths launched for this instrument.

\begin{verbatim}
  orac_process_frame( CurrentRecipe => $STATUS_TEXT,
                      PrimitiveList => $PRIMITIVE_LIST,
                      Frame => $Frm,
                      Group => $Grp,
                      Calibration => $Cal,
                      Engines =>\%Mon,
                      Display => $Display,
                      Beep => $opt_beep,
                      Debug => $opt_debug,
                      CmdLineRecipe => $Override_Recipe,
                      Instrument => $instrument,
                      Batch => 0,
                      RecSuffix => "A,B,C",
                      RecPars => $parameterfile,
                     );
\end{verbatim}


Additional parameters are provided to configure the recipe
environment. Defaults are provided for Debug and Batch.
(both false). Those options relate to the \texttt{-debug} and \texttt{-batch}
command line options.


\item[{\textbf{orac\_print\_config\_with\_defaults}}] \mbox{}

Wrapper for the \texttt{orac\_print\_configuration} function, but including
code to configure default logging switches before configuring the
print system.

\begin{verbatim}
  my ($orac_prt, $msg_prt, $err_prt, $ORAC_MESSAGE,
      $PRIMITIVE_LIST, $CURRENT_PRIMITIVE) =
        orac_print_config_with_defaults( \$CURRENT_RECIPE,
                                         \@ARGV, %cloptions );
\end{verbatim}


@ARGV contains the command line arguments for the log file. \%cloptions
are the command line switches. \texttt{-debug}, \texttt{-showcurrent} and \texttt{-log}
are used by this routine. \texttt{-log} will be read and modified to provide
default behaviour.


\item[{\textbf{orac\_launch\_tk}}] \mbox{}

Attempt to load Tk and create a main window indexed by the identifying
string.

\begin{verbatim}
  $w = orac_launch_tk($win_str);
\end{verbatim}


This routine can safely be called multiple times.



Returns the top level MainWindow object.


\item[{\textbf{orac\_declare\_location}}] \mbox{}

Write a file indicating where the pipeline is going to be writing
any output data (ie ORAC\_DATA\_OUT). This file will be written into
a directory obtained from the ORAC\_LOCATION\_DIR or else fall back
to the default JAC location of "/jac\_sw/oracdr-locations".



The file will be named for the ORAC\_INSTRUMENT environment variable
and any recipe suffices that are in use. For example "scuba2\_450-ql".
The file will contain one line with the value of \$ORAC\_DATA\_OUT.



A file is only written if the UT date being used is the current
UT date.

\begin{verbatim}
  orac_declare_location( %options );
\end{verbatim}


where \%options is the command line options hash.


\item[{\textbf{orac\_print\_configuration}}] \mbox{}

This routine setups the orac print system, it takes the \$opt\_debug and
\$log\_options and the \$MW variable and determines which file handles to return

\begin{verbatim}
  my($orac_prt, $msg_prt, $msgerr_prt, $ORAC_MESSAGE,
     $PRIMITIVE_LIST, $CURRENT_PRIMITIVE)
     = orac_print_configuration(
                                 $log_options, $win_str, \$CURRENT_RECIPE
                                 \@ORAC_ARGS, %options
                                );
\end{verbatim}


The ORAC\_ARGS are assumed to be the command line options. \texttt{\%options}
is the options hash. \texttt{-debug} and \texttt{-showcurrent} are used by this
routine.



The tied file handles \$orac\_prt, \$msg\_prt and \$msgerr\_prt are
returned, along with the Tk packed variable \$ORAC\_MESSAGE and
a reference to arrays containing the primitive information.


\item[{\textbf{orac\_message\_launch}}] \mbox{}

This routine creates a message launch system object and configures it,
we pass \$opt\_nomsgtmp and \$opt\_verbose to the routine to configure the
object.

\begin{verbatim}
  orac_message_launch( $opt_nomsgtmp, $opt_verbose );
\end{verbatim}


The message system itself will be initialised when it is required
rather than at the start. If we know there is one messsys and we know
that it will always be the same one then we can configure it here
explicitly. The main reason for doing that is to make sure that it
works before starting recipe processing.


\item[{\textbf{orac\_start\_algorithm\_engines}}] \mbox{}

This routine pre-launches the relevant algorithm engines which are always required by the instrument

\begin{verbatim}
   my ( $Mon )  = orac_start_algorithm_engines( $opt_noeng, $InstObj );
\end{verbatim}


it returns a reference to the algorithm engine hash, \$Mon.


\item[{\textbf{orac\_start\_display}}] \mbox{}

This routine is a wrapper for the orac\_setup\_display() subroutine in
ORAC::Basic. It starts the ORAC display unless \$nodisplay is
set.

\begin{verbatim}
   my $Display = orac_start_display( $nodisplay );
\end{verbatim}


the routine returns the display object \$Display.



Note that an object is returned in all cases, but if display
is disabled the display is created in monitor mode.


\item[{\textbf{orac\_calib\_override}}] \mbox{}

This routine creates a calibration object of the specified class and
overrides methods as specified in the \texttt{--calib} option string.

\begin{verbatim}
   my $Cal = orac_calib_override( $calclass, @opt_calib, );
\end{verbatim}


Multiple calibrations specifications can be supplied.
The calibrations are specified as comma separated keyword=value strings
or as hash references.


\item[{\textbf{orac\_parse\_files}}] \mbox{}

This routine parses the text file which has a list of the files to be
processed, this should have one filename per line, filenames are
assumed to be relative to ORAC\_DATA\_IN.

\begin{verbatim}
   my @obs = orac_parse_files( $opt_files );
\end{verbatim}


it returns an array of files to be read.



"\#" is a comment character.


\item[{\textbf{orac\_parse\_recparams}}] \mbox{}

Parse the command line argument specifying recipe parameters and return
either a ORAC::Recipe::Parameters object or undef.

\begin{verbatim}
 $params = orac_parse_recparams( $params );
\end{verbatim}

\item[{\textbf{orac\_process\_argument\_list}}] \mbox{}

This routine checks that your data exists and decides which data
loop approach to use.

\begin{verbatim}
 my $loop =
     orac_process_argument_list( $frameclass, \@obs, %opt );
\end{verbatim}


it returns the looping scheme and a list of observations if one does not
already exist.



This routine is fairly complex since there are many combinations of
\texttt{-from}, \texttt{-to}, \texttt{-skip}, \texttt{-loop} and \texttt{-list} that interact with
each other.



The options hash may contain the following keys: from, to, skip,
list and loop. All these are optional as the values may or may
not be defined or supplied by the user.


\item[{\textbf{orac\_main\_data\_loop}}] \mbox{}

This routine handles the main data processing

\begin{verbatim}
  orac_main_data_loop( $opt_batch, $opt_ut, $opt_resume,
                       $opt_skip, $opt_debug, $recsuffix, $recpars,
                       $grptrans, $loop, $frameclass, $groupclass,
                       $instrument, $Mon, $Cal, \@obs,
                       $Display, $orac_prt,
                       $ORAC_MESSAGE, $CURRENT_RECIPE, \@PRIMITIVE_LIST,
                       $CURRENT_PRIMITIVE, $Override_Recipe );
\end{verbatim}


There are two approaches to the data processing

\begin{enumerate}

\item

The default processing method where data are read in and processed as
it arrives and Groups are extended as needed. This has the advantage
that the data is processed as it is taken, has very good feedback to
the user in real time. The down side is that Groups are processed as
soon as possible and in an off-line batch processing envrionment this
is very wasteful (why work out the flatfield every time a frame
arrives when you simply want to work out the flatfield from the entire
group).


\item

The "batch" method where the data are analysed in two passes.  First
the groups are setup, secondly the frames are processed in each group
in turn. This has the advantage that frames can be coadded into a
group only once and is the most efficient way of processing data
off-line. Note that this presupposes that the primitives are written
in such a way that they can spot the last member of the group (via the
lastmember method). Grp Primitives without this check will probably
fail since the some of the members will not have been processed even
though the group contains many members.



One other issue is calibration -- in principal all calibration groups
should be processed before observation groups and currently this is
not supported (only important when calibrations are taken after the
observation).



Batch mode can be summarised as

\begin{verbatim}
    - Read in all frames and allocate groups
    - Loop over all groups Loop over all frames in
      group process frames
\end{verbatim}


Default mode is

\begin{verbatim}
    - Loop over all frames
    - Allocate groups
    - process frames
\end{verbatim}


Batch mode can be turned on with the -batch switch.

\end{enumerate}
\end{description}
\subsubsection*{REVISION\label{ORAC::Core_REVISION}\index{ORAC::Core!REVISION}}


\$Id\$

\subsubsection*{COPYRIGHT\label{ORAC::Core_COPYRIGHT}\index{ORAC::Core!COPYRIGHT}}


Copyright (C) 2008 Science and Technology Facilities Council.
Copyright (C) 1998-2007 Particle Physics and Astronomy Research
Council. All Rights Reserved.



This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.



This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.



You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

\subsection{ORAC::Display::Base\label{ORAC::Display::Base}\index{ORAC::Display::Base}}


Base class for ORAC display interface

\subsubsection*{SYNOPSIS\label{ORAC::Display::Base_SYNOPSIS}\index{ORAC::Display::Base!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Display::Base;
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Display::Base_DESCRIPTION}\index{ORAC::Display::Base!DESCRIPTION}}


Provides the generic methods for handling ORAC Display devices.
The generic routines (those worth inheriting) deal with display
device name allocation (eg mapping a device number to a real device).

\subsubsection*{PUBLIC METHODS\label{ORAC::Display::Base_PUBLIC_METHODS}\index{ORAC::Display::Base!PUBLIC METHODS}}
\paragraph*{Constructor\label{ORAC::Display::Base_Constructor}\index{ORAC::Display::Base!Constructor}}
\begin{description}

\item[{\textbf{new}}] \mbox{}

Base class constructor. Can be called as SUPER::new() from
sub-classes. Accepts a configuration hash as input in order to
initialise extra instance data components of the class that are
required by sub-classes.

\begin{verbatim}
  $a = new ORAC::Display(a => 'b', c => 'd');
\end{verbatim}


This constructor does not attempt to launch a display device.
That is up to the sub-classes.

\end{description}
\paragraph*{Accessor Methods\label{ORAC::Display::Base_Accessor_Methods}\index{ORAC::Display::Base!Accessor Methods}}
\begin{description}

\item[{\textbf{dev}}] \mbox{}

Method for handling the hash of device name mapping. ie Which
device name (as required for each Display interface, eg '.rtd0',
'xwindows;\$\$') is associated with the ORAC name (eg '0','1','default').



The hash reference is returned when called with no arguments:

\begin{verbatim}
  $href = $self->dev;
\end{verbatim}


The value associated with the supplied key is returned if one
argument is provided:

\begin{verbatim}
  $value = $self->dev('key');
\end{verbatim}


The supplied value is stored in key if two arguments are supplied:

\begin{verbatim}
  $self->dev('key','value');
\end{verbatim}


Undefined values are accepted.

\end{description}
\paragraph*{General Methods\label{ORAC::Display::Base_General_Methods}\index{ORAC::Display::Base!General Methods}}
\begin{description}

\item[{\textbf{window\_dev}}] \mbox{}

Returns the device id (eg GWM device name or RTD window name)
associated with window 'win'. If 'win' is undefined a new
window is launched, the id stored in the hash and the
new id returned. (see the launch\_dev() method). If this
is the first time the routine is called (ie the only window
name present is 'default', the name of the default window
is associated with window win.). We go through this hoop
so that devices will open a window before the user has associated
their user-defined name with the actual window name.

\begin{verbatim}
  $name = $self->window_dev('win');
\end{verbatim}


If the windows were launched with bad status we should
set the device name to something recognisable as bad
since status is not returned.

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Display::Base_SEE_ALSO}\index{ORAC::Display::Base!SEE ALSO}}


\emph{ORAC::Display::GAIA}, \emph{ORAC::Display::KAPVIEW}

\subsubsection*{REVISION\label{ORAC::Display::Base_REVISION}\index{ORAC::Display::Base!REVISION}}


\$Id\$

\subsubsection*{COPYRIGHT\label{ORAC::Display::Base_COPYRIGHT}\index{ORAC::Display::Base!COPYRIGHT}}


Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Display::GAIA\label{ORAC::Display::GAIA}\index{ORAC::Display::GAIA}}


ORAC interface to GAIA

\subsubsection*{SYNOPSIS\label{ORAC::Display::GAIA_SYNOPSIS}\index{ORAC::Display::GAIA!SYNOPSIS}}
\begin{verbatim}
  $disp = new ORAC::Display::GAIA;
\end{verbatim}
\begin{verbatim}
  $disp->image($file);
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Display::GAIA_DESCRIPTION}\index{ORAC::Display::GAIA!DESCRIPTION}}


ORAC interface to the the GAIA (ESO Skycat) display tool. Provides methods
for displaying images.



Available options are:



IMAGE - display image in GAIA window

\subsubsection*{PUBLIC METHODS\label{ORAC::Display::GAIA_PUBLIC_METHODS}\index{ORAC::Display::GAIA!PUBLIC METHODS}}
\paragraph*{Constructor\label{ORAC::Display::GAIA_Constructor}\index{ORAC::Display::GAIA!Constructor}}
\begin{description}

\item[{\textbf{new}}] \mbox{}

Object constructor. The constructor starts up a new version of
GAIA (if one is not running) and connects via a socket.



The program aborts if there is an error launching or contacting
gaia.

\end{description}
\paragraph*{Accessor Methods\label{ORAC::Display::GAIA_Accessor_Methods}\index{ORAC::Display::GAIA!Accessor Methods}}
\begin{description}

\item[{\textbf{launchable}}] \mbox{}

Whether or not GAIA can be automatically launched.

\begin{verbatim}
  $gaia->launchable( 0 );
\end{verbatim}


Defaults to true. If this is set to false (0), then a new GAIA will
never be started.


\item[{\textbf{sock}}] \mbox{}

Returns or sets the socket to Gaia. Private to this class.

\begin{verbatim}
  $sock = $gaia->sock();
\end{verbatim}


This is usually IO::Socket object. This socket is automatically
added to the IO::Select object returned by the \texttt{sel} method.
(and all previous sockets registered with the IO::Select object
are removed).


\item[{\textbf{sel}}] \mbox{}

Returns the IO::Select object associated associated with the
current socket.

\begin{verbatim}
  $select = $gaia->sel();
\end{verbatim}


This object is used to determine whether the GAIA process can be
contacted through the established socket connection.


\item[{\textbf{use\_remote\_gaia}}] \mbox{}

Controls whether we are allowed to connect to a GAIA process that
is already running on a remote machine. By default this is allowed
(true) but in some cases you may not want to connect to a remote
GAIA. For example, at UKIRT, the display must be sent to the machine
running the pipeline and not one of the other GAIAs that are running
on separate machines for QuickLook and general data inspection.

\end{description}
\paragraph*{General Methods\label{ORAC::Display::GAIA_General_Methods}\index{ORAC::Display::GAIA!General Methods}}
\begin{description}

\item[{\textbf{create\_dev}}] \mbox{}

Clone a new GAIA window and associate it with 'win'. This is different
to launching a new display device (ie running up GAIA itself).

\begin{verbatim}
  $status = $Display->create_dev($win, $name);
\end{verbatim}


For GAIA (V $<$= 2.3-2) the device name (\$name) must be an integer.
(enforced if the newdev() method is used).



ORAC status is returned.


\item[{\textbf{launch}}] \mbox{}

Connect to a pre-existing Gaia process or launch a new Gaia process.
If the first connection attempt fails, launches a new gaia process.
After this, attempts to connect to a new gaia process every 3 seconds
and attempts to launch a new gaia process every 60 seconds.
A maximum of 5 attempts are made (5 minutes) to launch a new Gaia
process before giving up.



There is no return status -- the program croaks if it can not
get a connection to GAIA !!



Whilst it is waiting, does not attempt to keep a \textsf{Tk} event loop
running.


\item[{\textbf{configure}}] \mbox{}

Load the startup image into GAIA. Essentially used to test that
GAIA can display images correctly.



Returns ORAC status.


\item[{\textbf{send\_to\_gaia}}] \mbox{}

Sends the supplied command to gaia. Any response from Gaia is returned.

\begin{verbatim}
  ($status, $return_string) = $obj->send_to_gaia('command');
  ($status, @return_strings) = $obj->send_to_gaia(@commands);
\end{verbatim}


The returned status is translated into an ORAC status (either ORAC\_\_OK
or ORAC\_\_ERROR). On error, the return\_string contains the error message.
The status returned is the status of the last command processed by GAIA.


\item[{\textbf{newdev}}] \mbox{}

Returns the name to be used for the new GAIA window based on the supplied
window name.

\begin{verbatim}
   $name = $obj->newdev($win);
\end{verbatim}


Currently, for gaia, the argument is ignored. The name is simply returned
as an integer calculated from the number of devices already stored
in the object.

\end{description}
\subsubsection*{DISPLAY METHODS\label{ORAC::Display::GAIA_DISPLAY_METHODS}\index{ORAC::Display::GAIA!DISPLAY METHODS}}
\begin{description}

\item[{\textbf{image}}] \mbox{}

Routine to display images in Gaia. Note that the full file name is required.
If an image name does not include an extension then '.sdf' is appended.
(ie NDF is assumed).



Takes a file name and arguments stored in a hash.

\begin{verbatim}
  $disp->image("filename", \%options)
  $disp->image("filename", { WINDOW => 2 });
\end{verbatim}


Currently no image sectioning is supported.
Display range can be adjusted with ZAUTOSCALE, ZMIN and ZMAX.



Component can be selected with COMP option. DATA is the default.
QUALITY and VARIANCE are supported.



Note that for GAIA, ZAUTOSCALE implies a 95 percent cut level and
not 100 percent.



Will attempt to relaunch GAIA if it can not be contacted.
Will attempt to create a new clone window if a clone can not be
contacted even though it has been used previously.



ORAC status is returned.

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Display::GAIA_SEE_ALSO}\index{ORAC::Display::GAIA!SEE ALSO}}


\emph{ORAC::Display::Base}, \emph{ORAC::Display::KAPVIEW}, \emph{ORAC::Display},
\emph{IO::Socket}

\subsubsection*{REVISION\label{ORAC::Display::GAIA_REVISION}\index{ORAC::Display::GAIA!REVISION}}


\$Id\$

\subsubsection*{COPYRIGHT\label{ORAC::Display::GAIA_COPYRIGHT}\index{ORAC::Display::GAIA!COPYRIGHT}}


Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Display::KAPVIEW\label{ORAC::Display::KAPVIEW}\index{ORAC::Display::KAPVIEW}}


ORACDR interface to Kapview (Kappa)

\subsubsection*{SYNOPSIS\label{ORAC::Display::KAPVIEW_SYNOPSIS}\index{ORAC::Display::KAPVIEW!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Display::KAPVIEW;
  $disp = new ORAC::Display::KAPVIEW;
\end{verbatim}
\begin{verbatim}
  $disp->image($file, { XAUTOSCALE => 1});
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Display::KAPVIEW_DESCRIPTION}\index{ORAC::Display::KAPVIEW!DESCRIPTION}}


ORAC interface to Kappa Kapview. Provides methods for displaying images
and spectrum with Kapview.



Available options are:

\begin{verbatim}
 IMAGE - display image using DISPLAY
 GRAPH - display graph using LINPLOT
 SIGMA - display scatter plot with a Y-range of +/- N sigma.
 DATAMODEL - Display data (as points) with a model overlaid
 HISTOGRAM - Histogram of values in data array
 VECTOR - Display image + vectors
\end{verbatim}
\subsubsection*{PUBLIC METHODS\label{ORAC::Display::KAPVIEW_PUBLIC_METHODS}\index{ORAC::Display::KAPVIEW!PUBLIC METHODS}}
\paragraph*{Constructor\label{ORAC::Display::KAPVIEW_Constructor}\index{ORAC::Display::KAPVIEW!Constructor}}
\begin{description}

\item[{\textbf{new}}] \mbox{}

Object constructor. The constructor starts up a new version of kapview,
starts a GWM window and displays the startup logo.



The program aborts if there is an error launching kapview.



The message system must be running so that Kapview can be configured.
(AMS is started if needed)

\end{description}
\paragraph*{Accessor Methods\label{ORAC::Display::KAPVIEW_Accessor_Methods}\index{ORAC::Display::KAPVIEW!Accessor Methods}}
\begin{description}

\item[{\textbf{engine\_launch\_object}}] \mbox{}

Returns the \texttt{ORAC::Msg::EngineLaunch} object that can be used
to launch algorithm engines as required by the particular
conversion.

\begin{verbatim}
 $messys = $self->messys_launch_object;
\end{verbatim}

\item[{\textbf{kappa}}] \mbox{}

Messaging object associated with the kappa\_mon monolith.
This is used by some of the modes in order to determine
display related values (eg statistics to determine plotting
ranges for SIGMA, dimension compression with COMPAVE).



A kappa messaging object is created if the object is undefined.



Note also that the HISTOGRAM task is present in the kappa monolith
rather than in the KAPVIEW monolith.


\item[{\textbf{ndfpack}}] \mbox{}

Messaging object associated with the ndfpack\_mon monolith.
This is used by some of the modes in order to reshape
date arrays (eg in SIGMA mode - reshape is run to convert
to 1-d)



A NdfPack messaging object is created if the object is undefined.


\item[{\textbf{polpack}}] \mbox{}

Messaging object associated with the polpack\_mon monolith.
This is used by the VECTOR mode to plot vectors from catalogues.



Note that this is technically not part of the KAPVIEW system.
It is here for convenience since in all cases POLPLOT is better
than VECPLOT for vector plotting.



A Polpack messaging object is created if the object is undefined.



Returns undef if polpack\_mon is not available.


\item[{\textbf{regions}}] \mbox{}

A hash containing the mapping of region name (number) to
AGI picture label.



Returns hash reference in scalar context, full hash in array context.
Contents can be modified by directly using the hash reference
(in order to modify specific entries) or completely rewritten by
supplying a hash as argument.

\begin{verbatim}
  $hashref = $self->regions;
  %hash = $self->regions;
  $self->regions(%hash);
  $self->regions->{Key} = "value";
\end{verbatim}

\item[{\textbf{obj}}] \mbox{}

Messaging object associated with the Kapview display object.

\end{description}
\paragraph*{General Methods\label{ORAC::Display::KAPVIEW_General_Methods}\index{ORAC::Display::KAPVIEW!General Methods}}
\begin{description}

\item[{\textbf{newdev}}] \mbox{}

Given 'win', calculates a new device name that should be unique for
each 'win'.

\begin{verbatim}
 $dev = $Display->newdev($win);
\end{verbatim}

\item[{\textbf{calc\_centre\_region}}] \mbox{}
\item[{\textbf{create\_dev}}] \mbox{}

Start the GWM window associated with the supplied window.
In general this is used by the startup configuration.
The lookup table is configured by this routine (so that
this routine really does start the GWM window).



Currently the GWM window itself is not started directly
by this routine (since KAPVIEW will automatically open
the specified device if one is not running).



The only reason to use this routine to actually START a window
is that it will give us some control over the colour allocation
and allow us to set the window name.



ORAC status is returned.

\begin{verbatim}
  $status = $Display->create_dev($win);
\end{verbatim}


Currently, the method dies if the device can not be successfully
created.


\item[{\textbf{launch}}] \mbox{}

This method starts the kapview monolith and stores the associated
Task object.


\item[{\textbf{configure}}] \mbox{}

Load a startup image. This tests the system to make sure that images
can be displayed and that the colour map is loaded.



Returns ORAC status.


\item[{\textbf{config\_regions}}] \mbox{}

This method configures the display regions so that they can be
selected later by select\_region.

\begin{verbatim}
  $status = $self->config_regions($window);
\end{verbatim}


A window name must be supplied.



The regions are defined as follows:

\begin{verbatim}
  0 - full screen
  1 - top left
  2 - top right
  3 - bottom left
  4 - bottom right
  5 - left
  6 - right
  7 - top
  8 - bottom
  17:32 - position in 4x4 grid (starting top left)
\end{verbatim}


The picture labels are stored in the regions() array.


\item[{\textbf{select\_region}}] \mbox{}

Selects the requested region as the current region in the display
system by using a supplied hash.

\begin{verbatim}
  $device = $Display->select_region(%options);
\end{verbatim}


Returns undef without action if the REGION keyword is not available
(since have no idea where to put it) or if REGION is not in the
allowed range.  Otherwise the name of the device containing the selected
region is returned. undef is returned if no arguments are supplied.



If the window name is not supplied (WINDOW) then 'default' is assumed.


\item[{\textbf{select\_section}}] \mbox{}

This method converts a file name and options hash into
a filename with an attached NDF section.

\begin{verbatim}
  $newfile = $Display->select_section($file, \%options, $dimensionality);
\end{verbatim}


An optional 3rd argument can be used to specify the required
dimensionality. If the number of dimensions in the data file is
greater than that requested, sections in higher dimensions
are set to 1 by compressing the undesired dimension
(with the assumption that KAPPA will discard axes
with 1 pixel). The desired dimension is specified with the CUT
option. For example, a graph can be displayed from a 2-D image
by displaying a cut in the X direction (averaging over the Ys).



If the number of dimensions in the data file
is fewer than that requested, a warning message is printed
but we continue in the hope that KAPPA will work something out....



The return value is the original filename with the
NDF section attached.



Relevant keywords in options hash:

\begin{verbatim}
  CUT  - Specify the significant dimension[s] (X,Y,3,4,5)
         Should be a comma-separated list specifying
         dimensionality - number of entries should equal the
         requested dimensionality. For a graph only 1 value
         is required since a graph is 1-D
  XMIN/XMAX - X pixel max and min values
  YMIN/YMAX - Y pixel max and min values
  XAUTOSCALE - Use autoscaling for X?
  YAUTOSCALE - Use autoscaling for Y?
\end{verbatim}


If Xautoscale and Yautoscale are true, no section command is appended.
If the XAUTOSCALE/YAUTOSCALE/nAUTOSCALE keywords can not be found they are
assumed to be true. If CUT is not specified  the first slice is
selected (eg a NDF section of N,1,1,1)



For data arrays with N$>$2, the leading letter is dropped and replaced
by the dimension number. eg:

\begin{verbatim}
  3MIN/3MAX - pixel range of the 3rd dimension
  4AUTOSCALE - autoscale the 4th dimension?
\end{verbatim}


For NDFs the maximum dimensionality is 7.



The bounds of the input file are compared to the supplied bounds.
If any of the requested bounds are exceeded, the maximum value
will be used instead.



Returns undef on error.
The unmodified file name is returned if no options hash can be found.



Returns the following:

\begin{verbatim}
  No CUT requested + auto-scaling:
    returns the original filename
  No CUT requested + some dimension ranges specified
    returns the original filename with an NDF section
    Dimensions above the requested dimensionality are set to the
    min value in the section (1 if not specified)
  CUT requested but dimensionality of data matches requested
    dimensionality.
    Just return the file + any relevant section
  CUT + auto-scaling + image too large
    data file is collapsed down to required size keeping the specified
    dimensions and averaging over the rest. A new temporary filename
    is returned
  CUT + some ranges specified + image too large
    NDF section constructed and then the data file is collapsed
    down to the required size. A new temporary file is generated.
  CUT + range + image + one pixel selected
    If the non-cut dimensions have min=max a section is
    sufficient and no averaging required
\end{verbatim}


The temporary files themselves are added to a global class
array and removed by the destructor.



Note that this routine does not remove the temporary filename.
This is probably a bug. Should probably create some kind of
object that will have a destructor that removes the file rather
than using a simple file name. (an ORAC::TempFile)?

\end{description}
\subsubsection*{DISPLAY METHODS\label{ORAC::Display::KAPVIEW_DISPLAY_METHODS}\index{ORAC::Display::KAPVIEW!DISPLAY METHODS}}
\begin{description}

\item[{\textbf{image}}] \mbox{}

Display an image.
Takes a file name and arguments stored in a hash.
Note that currently it does not take a format argument
and NDF is assumed.



Recognised options:

\begin{verbatim}
  XMIN/XMAX - X pixel max and min values
  YMIN/YMAX - Y pixel max and min values
  XAUTOSCALE - Use autoscaling for X?
  YAUTOSCALE - Use autoscaling for Y?
  ZMIN/ZMAX  - Z-range of greyscale (data units)
  ZAUTOSCALE - Autoscale Z?
  KEY        - Display key to colour table?
  COMP       - Component to display (Data (default), Variance or Error)
\end{verbatim}


Default is to autoscale.



ORAC Status is returned.


\item[{\textbf{graph}}] \mbox{}

Display a 1-D plot.



If the data are not 1-D, a section is taken that assures
1-D (eg NDF section= :,1,1,1 for 4D data)



Takes a file name and arguments stored in a hash.
Note that currently it does not take a format argument
and NDF is assumed.



Display keywords:

\begin{verbatim}
  XMIN/XMAX  - X-pixel range of graph
  XAUTOSCALE - Autoscale pixel range?
  YMIN/YMAX  - Y-pixel range of graph (in pixels)
  YAUTOSCALE - Autoscale Y-axis
  YMIN/YMAX  - Z-range of graph (in data units)
  YAUTOSCALE - Autoscale Z-axis
  CUT        - Decide which direction is the primary axis
               Can be X,Y,3,4,5 (for higher-dimensional data sets)
               For a 1-D data set (or section), this value is ignored
  COMP       - Component to display (Data (default), Variance or Error)
  ERRBAR     - Plot error bars or not (if variance information is
               present)
\end{verbatim}


Default is to autoscale. Note that the X/Y cuts are converted
to a 1-D slice before displaying by averaging over the section.



For example:

\begin{verbatim}
   XMIN=5 XMAX=5 YAUTOSCALE=YES
\end{verbatim}


would display column 5 (ie the whole of Y for X=5).
[CUT is irrelevant since the resulting image section is 1-D]

\begin{verbatim}
   XAUTOSCALE=YES YMIN=20 YMAX=30 CUT=X
\end{verbatim}


would display the average of rows 20 to 30 for each X.



Need to add way of controlling line style (e.g. replace with symbols)



ORAC status is returned.


\item[{\textbf{chanmap}}] \mbox{}

Displays a channel map of a central region of a cube.



Recognized options:

\begin{verbatim}
  XMIN/XMAX  - X pixel min and max values.
  YMIN/YMAX  - Y pixel min and max values.
  ZMIN/ZMAX  - Z-range of greyscale (data units)
  XAUTOSCALE - Use autoscaling for X?
  YAUTOSCALE - Use autoscaling for Y?
  ZAUTOSCALE - Use autoscaling for Z?
  WIDTH      - Width of central region to use, in percent.
  AXIS       - Axis to collapse over.
  NCHAN      - Total number of channels to display.
  SHAPE      - Number of channels to display along X-axis.
\end{verbatim}


WIDTH defaults to 100. AXIS defaults to 3. NCHAN defaults to 9. SHAPE
defaults to 3.



ORAC status is returned.


\item[{\textbf{cubecentre}}] \mbox{}

Collapse the central region of a cube along one axis, and display an
image of the collapse region.



Recognised options:

\begin{verbatim}
  XMIN/XMAX  - X pixel min and max values.
  YMIN/YMAX  - Y pixel min and max values.
  ZMIN/ZMAX  - Z-range of greyscale (data units)
  XAUTOSCALE - Use autoscaling for X?
  YAUTOSCALE - Use autoscaling for Y?
  ZAUTOSCALE - Use autoscaling for Z?
  WIDTH      - Width of central region to use, in percent.
  AXIS       - Axis to collapse over.
\end{verbatim}


WIDTH defaults to 100. AXIS defaults to 3.



ORAC status is returned.


\item[{\textbf{contour}}] \mbox{}

Display contours of a 2-D data set.



Recognised options:

\begin{verbatim}
  XMIN/XMAX - X pixel max and min values
  YMIN/YMAX - Y pixel max and min values
  XAUTOSCALE - Use autoscaling for X?
  YAUTOSCALE - Use autoscaling for Y?
  ZMIN/ZMAX  - Z-range of greyscale (data units)
  ZAUTOSCALE - Autoscale Z?
  NCONT      - Number of contours
  COMP       - Component to display (Data (default), Variance or Error)
\end{verbatim}


Default is to autoscale.



ORAC status is returned.


\item[{\textbf{sigma}}] \mbox{}

Display a scatter plot of the data with Y range of N-sigma (sigma
is derived from the data) with dashed lines overlaid at the X-sigma
points.



By default a range of +/-5 sigma with dashed lines at +/-3 sigma
are used.



These values can be overriden by using the RANGE and DASHED
keywords.



Takes a file name and arguments stored in a hash.
Note that currently it does not take a format argument
and NDF is assumed.



If we are running KAPPA 0.13, the NDF is converted
to 1-DIM with the kappa RESHAPE command before
displaying.



ORAC status is returned.


\item[{\textbf{datamodel}}] \mbox{}

Display mode where the supplied filename is plotted as individual
points and a model is overlaid as a solid line. This can be used
to determine the goodness of fit of data and model.



The model filename is derived from the input filename (a \_model
extension is expected). The data is displayed if the model
file can not be found.



Takes a file name and arguments stored in a hash.
Note that currently it does not take a format argument
and NDF is assumed.



Option keywords:

\begin{verbatim}
  XMIN/XMAX  - X-pixel range of graph
  XAUTOSCALE - Autoscale pixel range?
  ZMIN/ZMAX  - Y-range of graph (in data units)
  ZAUTOSCALE - Autoscale Y-axis
  COMP       - Component to display (Data (default), Variance or Error)
\end{verbatim}


Default is to autoscale on the data (the model may not be visible).



If the input file is greater than 1-D, the section is automatically
converted to 1-D by selecting the ?MIN slice from each of the
higher axes (eg the value specified in YMIN, 3min...)



ORAC status is returned.


\item[{\textbf{histogram}}] \mbox{}

Display a histogram of the data values present in the data array.



Takes a file name and arguments stored in a hash. Note that currently
it does not take a format argument and NDF is assumed.



Arguments:

\begin{verbatim}
  XMIN/MAX   - minimum/maximum x-pixel value
  XAUTOSCALE - Use full X-range
  YMIN/YMAX  - minimum/maximum x-pixel value
  YAUTOSCALE - use full Y-range
  ZMIN/ZMAX  - Z range of histogram (data units)
  ZAUTOSCALE - use full Z-range
  NBINS      - Number of bins to be used for histogram calculation
  COMP       - Component to display (Data (default), Variance or Error)
  SIGMA      - Number of sigma to clip data before computing histogram
  TITLE      - title string to label the histogram
\end{verbatim}


Default is for autoscaling and for NBINS=20. Note that the presence of
SIGMA overrides ZMIN/ZMAX.



ORAC status is returned.


\item[{\textbf{vector}}] \mbox{}

Vectors are overlaid on an image. The supplied file is displayed
and vectors are then drawn. The vector information is expected
to be stored in the ORAC extension of the supplied file
(in .P and .THETA NDFs) or, preferably, in a catalogue of the
same name as the I image. POLPLOT is used for display if
the catalogue is available.



Recognised options:

\begin{verbatim}
  XMIN/XMAX  - X pixel max and min values
  YMIN/YMAX  - Y pixel max and min values
  XAUTOSCALE - Use autoscaling for X?
  YAUTOSCALE - Use autoscaling for Y?
  ZMIN/ZMAX  - Z-range of greyscale (data units)
  ZAUTOSCALE - Autoscale Z?
  ANGROT     - angle to add to all vectors
  MULTIVECTOR- Plot multi-coloured vectors (yellow with blue trim)?
\end{verbatim}


Default is to autoscale.



ORAC status is returned.

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Display::KAPVIEW_SEE_ALSO}\index{ORAC::Display::KAPVIEW!SEE ALSO}}


\emph{ORAC::Display}, \emph{ORAC::Display::GAIA}

\subsubsection*{REVISION\label{ORAC::Display::KAPVIEW_REVISION}\index{ORAC::Display::KAPVIEW!REVISION}}


\$Id\$

\subsubsection*{COPYRIGHT\label{ORAC::Display::KAPVIEW_COPYRIGHT}\index{ORAC::Display::KAPVIEW!COPYRIGHT}}


Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Inst::Defn\label{ORAC::Inst::Defn}\index{ORAC::Inst::Defn}}


Definition of instrument class dependencies

\subsubsection*{SYNOPSIS\label{ORAC::Inst::Defn_SYNOPSIS}\index{ORAC::Inst::Defn!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Inst::Defn;
\end{verbatim}
\begin{verbatim}
  @pars = orac_determine_inst_classes( $instrument );
  orac_determine_initial_algorithm_engines
  orac_determine_recipe_search_path
  orac_determine_primitive_search_path
  orac_engine_description
  orac_messys_description
  orac_configure_for_instrument( $instrument, \%options );
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Inst::Defn_DESCRIPTION}\index{ORAC::Inst::Defn!DESCRIPTION}}


This module provides all the instrument specific initialisation
information. This is the information required by ORAC-DR in order
to configure itself before the data detection loop can begin.



This module provides information on class hierarchies, recipe
search paths and initialisation or algorithm engines.



All instrument dependencies are specified in this module.

\subsubsection*{FUNCTIONS\label{ORAC::Inst::Defn_FUNCTIONS}\index{ORAC::Inst::Defn!FUNCTIONS}}


The following functions are provided:

\begin{description}

\item[{\textbf{orac\_determine\_inst\_classes}}] \mbox{}

Given an ORAC instrument name, returns the class names to be
used for frames, groups, calibration messaging. The classes
are used so that objects can be instantiated immediately.

\begin{verbatim}
  ($frameclass, $groupclass, $calclass, $instclass) =
        orac_determine_inst_classes( $instrument );
\end{verbatim}


The function dies if the classes can not be used.
An empty list is returned if the instrument is not known
to the system.


\item[{\textbf{orac\_list\_generic\_observing\_modes}}] \mbox{}

Returns a list of the standard observing modes supported
by ORAC-DR. Currently the list includes just "imaging"
and "spectroscopy" (implicitly assumed to be near-infrared).



Specific instruments always have their own modes.



The list is determined by looking in the recipe directory for
directories that contain all lower case characters.  Upper case
characters imply a specific instrument rather than a generic
mode. This is probably over-the-top given that the search path
functions (below) have to assume that they know the answer.


\item[{\textbf{orac\_determine\_recipe\_search\_path}}] \mbox{}

Returns a list of directories that should be searched in order
to locate recipes for the specified instrument.

\begin{verbatim}
  @paths = orac_determine_recipe_search_path( $instrument );
\end{verbatim}


Root location is specified by the \texttt{ORAC\_DIR} environment
variable.


\item[{\textbf{orac\_determine\_primitive\_search\_path}}] \mbox{}

Returns a list of directories that should be searched in order
to locate primitives for the specified instrument.

\begin{verbatim}
  @paths = orac_determine_primitive_search_path( $instrument );
\end{verbatim}


Root location is specified by the \texttt{ORAC\_DIR} environment
variable.


\item[{\textbf{orac\_determine\_calibration\_search\_path}}] \mbox{}

Returns a list of directories that should be searched in order
to locate calibration files for the specified instrument.

\begin{verbatim}
  @paths = orac_determine_calibration_search_path( $instrument );
\end{verbatim}


Root location is specified by the \texttt{ORAC\_CAL\_ROOT} environment
variable. ORAC\_DATA\_CAL is included if it is set explicitly.


\item[{\textbf{orac\_determine\_initial\_algorithm\_engines}}] \mbox{}

For the supplied instrument name, returns a list containing the names
of engines to be launched by the pipeline prior to executing any
recipes. This is used so that engines that are always used will be
available at the start of execution rather than being launched on
demand. This approach provides a slight efficiency gain over starting
each engine on demand.

\begin{verbatim}
  @engines = orac_determine_initial_algorithm_engines( $instrument)
\end{verbatim}


In principal this list can be empty if no pre-launching is required.


\item[{\textbf{orac\_configure\_for\_instrument}}] \mbox{}

This routines configures the user environment (e.g. \%ENV) for the instrument,
it is called by Xoracdr to replace functionality present in the c-shell setup scripts.

\begin{verbatim}
   orac_configure_for_instrument( $instrument, \%options );
\end{verbatim}

\item[{\textbf{orac\_engine\_description}}] \mbox{}

Returns the details for a specified algorithm engine.

\begin{verbatim}
  %details = orac_engine_description("polpack_mon");
\end{verbatim}


The hash that is returned contains information on the
class to be used to launch the engine and the location
of the engine. In future it may also return the messaging
system required for the engine to function. The hash currently
has the following keys

\begin{description}

\item[{CLASS}] \mbox{}

The name of the class to be used for this engine.
(e.g. \texttt{ORAC::Msg::Task::ADAM}).


\item[{PATH}] \mbox{}

The location of the engine in the file system. If this
is a code reference it should be executed immediately
prior to launching the monolith to configure associated
parameters correctly and to return the actual path.
Additionally, if the helper task is executed it returns
a reference to a cleanup subroutine. See \S\ref{ORAC::Inst::Defn_HELPER_TASKS}.


\item[{MESSYS}] \mbox{}

The name of the message system required to contact the engine.
See \S\ref{ORAC::Inst::Defn_orac_messys_description}.

\end{description}


Returns an empty list on error.



If the engine is not specified but is defined in \$ORAC\_REMOTE\_TASK
environment variable, the task is assumed to be DRAMA.


\item[{\textbf{orac\_messys\_description}}] \mbox{}

Returns the details for a specified message system.

\begin{verbatim}
  %details = orac_messys_description("AMS");
\end{verbatim}


The hash that is returned contains information on the
class to be used to initialise the message system.
It has the following keys

\begin{description}

\item[{CLASS}] \mbox{}

The name of the class to be used for this message system
(e.g. \texttt{ORAC::Msg::ADAM::Control}).

\end{description}


Returns an empty list on error.


\item[{\textbf{orac\_remote\_task}}] \mbox{}

Returns the override task names specified by the \$ORAC\_REMOTE\_TASK
environment variable.

\begin{verbatim}
  @tasks = orac_remote_task();
\end{verbatim}
\end{description}
\subsubsection*{HELPER TASKS\label{ORAC::Inst::Defn_HELPER_TASKS}\index{ORAC::Inst::Defn!HELPER TASKS}}


Some algorithm engines need to be configured in a slighlty more complex
way than providing a simple path to the engine. This section
describes specific functions that return the name of the path whilst
also configuring the program before launch. For example, can be used
to create a temporary directory for special output. The helper tasks
accept no arguments and are required to return a path to an
engine and a reference to a subroutine to be exected when the
object has been launched. This allows for cleanup code to be executed
and are usually closures.

\begin{description}

\item[{\textbf{fluxes\_helper}}] \mbox{}

This function configures the fluxes specific environment variables
and creates a temporary output directory for use by fluxes.

\begin{verbatim}
 ($path, $callback) = fluxes_mon_helper;
\end{verbatim}


Returns the path to the monolith and a cleanup function.
The cleanup function is required to change directory back to the
directory that we need to be in (since Fluxes requires the directory
to have special files in it).


\item[{\textbf{p4\_helper}}] \mbox{}

Helper task for the CGS4-DR P4 display system.

\begin{verbatim}
  ($path, $cleanup) = p4_helper;
\end{verbatim}
\end{description}
\subsubsection*{COPYRIGHT\label{ORAC::Inst::Defn_COPYRIGHT}\index{ORAC::Inst::Defn!COPYRIGHT}}


Copyright (C) 1998-2006 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Msg::EngineLaunch\label{ORAC::Msg::EngineLaunch}\index{ORAC::Msg::EngineLaunch}}


Launch engines on demand

\subsubsection*{SYNOPSIS\label{ORAC::Msg::EngineLaunch_SYNOPSIS}\index{ORAC::Msg::EngineLaunch!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Msg::EngineLaunch;
\end{verbatim}
\begin{verbatim}
  $eng = new ORAC::Msg::EngineLaunch;
\end{verbatim}
\begin{verbatim}
  $obj = $eng->engine("polpack_mon");
  $eng->detach("polpack_mon");
  (@ok, @nok) = $eng->contact_all;
\end{verbatim}
\begin{verbatim}
  tie %Mon, "ORAC::Msg::EngineLaunch";
  $obj = $Mon{"polpack_mon"};
  delete $Mon{"polpack_mon"};
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Msg::EngineLaunch_DESCRIPTION}\index{ORAC::Msg::EngineLaunch!DESCRIPTION}}


This class provides a means of launching arbritrary algorithm
engines on demand. If an engine has not previously been
launched the class will start it, if it has been launched it
will retrieve the current object. The algorithm engines will
be \texttt{ORAC::Msg} task objects (eg \emph{ORAC::Msg::ADAM::Task}).
This allows engines to be launched only when required to minimize
resource demand.



It is also possible to tie the class to a hash. This allows
for a non-object oriented approach where the engine can be launched
simply by accessing the engine through the hash.

\subsubsection*{METHODS\label{ORAC::Msg::EngineLaunch_METHODS}\index{ORAC::Msg::EngineLaunch!METHODS}}


The following methods are provided:

\paragraph*{Constructor\label{ORAC::Msg::EngineLaunch_Constructor}\index{ORAC::Msg::EngineLaunch!Constructor}}


Object constructors.

\begin{description}

\item[{\textbf{new}}] \mbox{}

Instantiate a new object ready for launching.

\begin{verbatim}
  $launch = new ORAC::Msg::EngineLaunch( $unique );
\end{verbatim}


Since, in general, it is convenient for all parts of the code
to have access to previously launched engines, the default
behaviour is for the constructor to return the same object reference
each time it is called. If it is required for a completely new object
to be created each time the argument must be set to true.



ORAC-DR usually requires that access is provided to all previously
launched engines for efficiency (and to prevent name clashes).

\end{description}
\paragraph*{Accessor Methods\label{ORAC::Msg::EngineLaunch_Accessor_Methods}\index{ORAC::Msg::EngineLaunch!Accessor Methods}}
\begin{description}

\item[{\textbf{engine}}] \mbox{}

Retrieve the object associated with the specified engine, launching
it if required.

\begin{verbatim}
  $obj = $launch->engine("polpack_mon");
\end{verbatim}


\texttt{undef} is returned if the engine could not be launched.



The engine object can be stored if two arguments are used.
A rudimentary check is made to make sure that the object
is a reference and that the \texttt{contactw} method is supported.
It is not possible to check a true ISA relationship. If the
object does not satisfy this condition it is not stored and
a warning is raised with "-w".

\begin{verbatim}
  $launch->engine("polpack_mon", $object);
\end{verbatim}


Returns a hash reference containing all the currently launched engines
if called without arguments.

\begin{verbatim}
  $launched = $launch->engine;
\end{verbatim}

\item[{\textbf{engine\_id}}] \mbox{}

The message system identifier. This is used by some message systems
(e.g. ADAM) to indicate a specific identifier that should be used
to name the engine in the message system. This allows, for example,
the pipeline to attach to an engine that has been launched
outside of the pipeline infrastructure. For engines launched
by the pipeline each new identifier must be unique for each pipeline
and for each repeat monolith launch (in the case where engines
die and are restarted).



This method is used to store the previous id for each engine so that
a new id can be generated.

\begin{verbatim}
  $id = $launch->engine_id( $engine );
  $launch->engine_id( $engine, $id );
\end{verbatim}


The \texttt{engine\_inc} method should be used to generate a new id.



If no arguments are supplied a reference to the hash of IDs is
returned. \texttt{undef} is returned if an id is requested for an
engine that has not been launched.


\item[{\textbf{messys\_launch\_object}}] \mbox{}

Returns the \texttt{ORAC::Msg::MessysLaunch} object that can be used
to initialise message systems as required by the particular
algorithm engines.

\begin{verbatim}
 $messys = $self->messys_launch_object;
\end{verbatim}
\end{description}
\paragraph*{General Methods\label{ORAC::Msg::EngineLaunch_General_Methods}\index{ORAC::Msg::EngineLaunch!General Methods}}
\begin{description}

\item[{\textbf{contact\_all}}] \mbox{}

Runs the \texttt{contactw} method on each registered engine. Can be used
to make sure that all the registered engines are okay.
If an engine can not be contacted it is removed from the object.



Returns two arrays, one for engines that could be contacted and
one for engines that could not be contacted.

\begin{verbatim}
  ($okay, $notokay) = $launch->contact_all;
\end{verbatim}


In a scalar context simply returns true if all engines could be
contacted. Also returns true if there are no registered engines.

\begin{verbatim}
  $all_okay = $launch->contact_all;
\end{verbatim}


The message system timeout is reduced to 30 seconds whilst
waiting for contact. It is subsequently reset afterwards. This
allows the pipeline configuration of timeout to vary from that
required simply to check that the monolith can be contacted.


\item[{\textbf{detach}}] \mbox{}

Disassociate the named engine from the object. This can be used
if an engine has crashed and it is necessary to launch a new
engine next time.

\begin{verbatim}
  $launch->detach( $engine );
\end{verbatim}

\item[{\textbf{launch}}] \mbox{}

Launch the specified monolith.

\begin{verbatim}
  $obj = $launch->launch( $engine );
\end{verbatim}


The engine object is stored in the class.  Returns undef on error.



The routine does not return until the engine has completed loading
(i.e. the \texttt{contactw} method returns successfully). This is less
efficient than launching all the monoliths and then waiting for
them but it is the price paid for launching on demand.



This overhead can be overcome by pre-launching engines that are
known to be required and launching optional engines on demand.
If multiple engine names are supplied to this method they will
all be launched at once without waiting for each one in turn.
A hash is returned containing all the objects that were launched.

\begin{verbatim}
  %obj = $launch->launch( $engine1, $engine2 );
\end{verbatim}


If multiple engines are launched simultaneously, the status of the
engines must then be checked explicitly using the \texttt{contact\_all}
method.



If the engines are launched outside this infrastructure they can be
registered with the object using the \texttt{engine} method for the object,
and \texttt{engine\_id} method to register the messaging name (if
appropriate).



If a request is made to launch an engine that has been launched
previously the request returns the current engine object. Use
\texttt{detach} to force a reload.


\item[{\textbf{engine\_inc}}] \mbox{}

Return a new ID for the specified engine.

\begin{verbatim}
  $id = $self->engine_inc( $engine );
\end{verbatim}


The current ID is updated (see \texttt{engine\_id} for more details).

\end{description}
\subsubsection*{TIED INTERFACE\label{ORAC::Msg::EngineLaunch_TIED_INTERFACE}\index{ORAC::Msg::EngineLaunch!TIED INTERFACE}}


This class also provides a means of tieing an object to
a standard perl hash allowing for transparent access to
engines.



A hash can be tied to an object by using the \texttt{tie} function:

\begin{verbatim}
  tie %Mon, "ORAC::Msg::Engine::Launch";
\end{verbatim}


It is also possible to tie a hash to an existing object:

\begin{verbatim}
  tie %Mon, ref($object), $object;
\end{verbatim}


The following can be used to retrieve the object associated with
"polpack\_mon" launching the engine if necessary:

\begin{verbatim}
  $object = $Mon{"polpack_mon"};
\end{verbatim}


Engines can be dissassociated from the object using the
standard hash \texttt{delete} command:

\begin{verbatim}
  delete $Mon{"polpack_mon"};
\end{verbatim}


\texttt{exists}, \texttt{keys} and \texttt{each} are supported.



Note that \texttt{exists} will \textit{not} launch a monolith. It can only
be used to check that one has already been launched.



In addition, it is possible to explicitly set entries in the hash. A
rudimentary check is made to check that the stored entry is an object
that can invoke a "contactw" method but it is not possible to check
that the object is of the correct type (since there is currently no
complete inheritance tree for engines). If the argument is not okay
the object a warning will be issued under "-w".

\begin{verbatim}
  $Mon{engine} = $some_object;
\end{verbatim}


A reference to the hash still has access to the tied hash.  A copy of
the hash (e.g. \texttt{\%New = \%Old}) will copy the contents of the hash
without copying the tie.  In order to copy the hash and retain the
tie, it is necessary to tie the new hash rather than copying it.

\begin{verbatim}
  $object = tied %Mon;
  tie %New, ref($object), $object;
\end{verbatim}
\subsubsection*{REVISION\label{ORAC::Msg::EngineLaunch_REVISION}\index{ORAC::Msg::EngineLaunch!REVISION}}


\$Id\$

\subsubsection*{COPYRIGHT\label{ORAC::Msg::EngineLaunch_COPYRIGHT}\index{ORAC::Msg::EngineLaunch!COPYRIGHT}}


Copyright (C) 2001-2005 Particle Physics and Astronomy Research
Council. All Rights Reserved.



This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.



This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.



You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

\subsection{ORAC::Msg::MessysLaunch\label{ORAC::Msg::MessysLaunch}\index{ORAC::Msg::MessysLaunch}}


Generic interface for initialising message systems

\subsubsection*{SYNOPSIS\label{ORAC::Msg::MessysLaunch_SYNOPSIS}\index{ORAC::Msg::MessysLaunch!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Msg::MessysLaunch;
\end{verbatim}
\begin{verbatim}
  $msl = new ORAC::Msg::EngineLaunch;
\end{verbatim}
\begin{verbatim}
  $obj = $msl->messys( 'AMS' );
  %objs = $msl->messys_active;
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Msg::MessysLaunch_DESCRIPTION}\index{ORAC::Msg::MessysLaunch!DESCRIPTION}}


This class provides a generic interface to the messaging systems
supported by ORAC-DR. The knowledge of how to setup and initialise
all the supported messaging systems is included in this class.



The message systems are started on demand (that is, the first
time an object is requested by name). The message systems will
be \texttt{ORAC::Msg::Control} objects (eg \emph{ORAC::Msg::Control::AMS}).



This interface allows message systems to be initialised only
when specific algorithm engines are required (rather than
starting every message system even if none are required).

\subsubsection*{METHODS\label{ORAC::Msg::MessysLaunch_METHODS}\index{ORAC::Msg::MessysLaunch!METHODS}}


The following methods are provided:

\paragraph*{Constructor\label{ORAC::Msg::MessysLaunch_Constructor}\index{ORAC::Msg::MessysLaunch!Constructor}}


Object constructors.

\begin{description}

\item[{\textbf{new}}] \mbox{}

Instantiate a new object ready for launching.

\begin{verbatim}
  $launch = new ORAC::Msg::MessysLaunch( $unique );
\end{verbatim}


Since, in general, it is convenient for all parts of the code to have
access to previously started message systems (and in many cases it is
an error to start 2 identical message systems), the default behaviour
is for the constructor to return the same object reference each time
it is called. If it is required for a completely new object to be
created each time the argument must be set to true.



ORAC-DR usually requires that access is provided to all previously
initialised message systems so that the messaging layer can be
configured by any subsystem.

\end{description}
\paragraph*{Accessor Methods\label{ORAC::Msg::MessysLaunch_Accessor_Methods}\index{ORAC::Msg::MessysLaunch!Accessor Methods}}
\begin{description}

\item[{\textbf{config}}] \mbox{}

Allows the message system configuration to be stored. These options
are used to configure each message system that is initialised.



If it is required to configure message systems that are already
running use the \texttt{configure\_all} method.



Accepts a hash containing the names of the methods to invoke
on the message system object and the options to use.

\begin{verbatim}
  $msl->config( messages => 1,
                   timeout => 600,
                   ... );
\end{verbatim}


Currently, all options are configured at once and any previous
options (even if they have different names) are lost.



Returns a hash with the current configuration.


\item[{\textbf{messys}}] \mbox{}

Retrieve the object associated with the specified message system, initialising
it if required.

\begin{verbatim}
  $obj = $msl->messys("AMS");
\end{verbatim}


\texttt{undef} is returned if the message system could not be initialised.



The message system object can be stored if two arguments are used.  A
rudimentary check is made to make sure that the object is a
reference. It is not possible to check a true ISA relationship \textit{until
the class structure is reorganized}. If the
object does not satisfy this condition it is not stored and a warning
is raised with "-w".

\begin{verbatim}
  $msl->messys("AMS", $object);
\end{verbatim}


Returns a hash reference containing all the currently launched engines
if called without arguments.

\begin{verbatim}
  $launched = $launch->messys;
\end{verbatim}


See also \texttt{messys\_active}.


\item[{\textbf{messys\_active}}] \mbox{}

Returns a hash containing all the message system objects
that have been created.

\begin{verbatim}
 %Messys = $msl->messys_active;
\end{verbatim}

\item[{\textbf{preserve}}] \mbox{}

This method is used to set or retrieve the \texttt{preserve} flag. The
\texttt{preserve} flag controls whether the messys environment variables
should be left unchanged for initialisation or whether the system
should be initialised such that it does not interfere with
non-ORAC-DR environments.



The default is that the message system should be initialised such
that it does not interfere with other external systems. This
is required if multiple ORAC-DR pipelines are to be run on the same
machine by the same user.



If preserve is set to true it may be possible for the pipeline to
interact with algorithm engines launched outside the context of the
pipeline. This is the case when ORAC-DR is configure to interact
with CGS4DR.

\begin{verbatim}
  $msl->preserve(1);
  $preserve = $msl->preserve;
\end{verbatim}
\end{description}
\paragraph*{General Methods\label{ORAC::Msg::MessysLaunch_General_Methods}\index{ORAC::Msg::MessysLaunch!General Methods}}
\begin{description}

\item[{\textbf{configure\_all}}] \mbox{}

Configure all the current message systems using the configuration
options that have been set previously by use of the \texttt{config}
method.

\begin{verbatim}
  $msl->configure_all;
\end{verbatim}

\item[{\textbf{configure\_messys}}] \mbox{}

Configures the named message system using the configuration
options that have been set previously by use of the \texttt{config}
method.

\begin{verbatim}
  $msl->configure_messys( 'AMS' );
\end{verbatim}

\item[{\textbf{init\_messys}}] \mbox{}

Given a message system name (for example 'AMS') initialise the
message system so that it can be used by algorithm engines.

\begin{verbatim}
  $messys_obj = $msl->init_messys( 'AMS' );
\end{verbatim}


Returns the object that was instantiated, or undef on error.



If the message system has been initialised previously that
object is returned.

\end{description}
\subsubsection*{REVISION\label{ORAC::Msg::MessysLaunch_REVISION}\index{ORAC::Msg::MessysLaunch!REVISION}}


\$Id\$

\subsubsection*{COPYRIGHT\label{ORAC::Msg::MessysLaunch_COPYRIGHT}\index{ORAC::Msg::MessysLaunch!COPYRIGHT}}


Copyright (C) 2001-2005 Particle Physics and Astronomy Research
Council. All Rights Reserved.



This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.



This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.



You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

