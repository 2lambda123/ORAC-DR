\subsection{ORAC::Basic\label{ORAC::Basic}\index{ORAC::Basic}}

Recipe parsing and execution subroutines

\subsubsection*{SYNOPSIS\label{ORAC::Basic_SYNOPSIS}\index{ORAC::Basic!SYNOPSIS}}\begin{verbatim}
  use ORAC::Basic;
  orac_setup_display;
  $rec_arr = orac_read_recipe($recipe, $instrument);
  orac_parse_recipe(\@recipe, $instrument);
  orac_add_code_to_recipe(\@recipe);
  orac_execute_recipe(\@recipe, $Frm, $Grp, $Cal, \%Mon);
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Basic_DESCRIPTION}\index{ORAC::Basic!DESCRIPTION}}

Provides the routines for parsing and executing recipes.

\subsubsection*{FUNCTIONS\label{ORAC::Basic_FUNCTIONS}\index{ORAC::Basic!FUNCTIONS}}

The following functions are provided:

\begin{description}
\item[\textbf{orac\_setup\_display}] \mbox{}

Create a new Display object for use by the recipes. This includes
the association of this object with a specific display configuration
file (\emph{disp.dat}). If a configuration file is not in \$ORAC\_DATA\_OUT
one will be copied there from \$ORAC\_DATA\_CAL (or \$ORAC\_DIR
if no file exists in \$ORAC\_DATA\_CAL).



If the \$DISPLAY environment variable is not set, the display
subsystem will not be started.



There are no return arguments.

\item \textbf{\textbf{orac\_execute\_recipe}(reciperef, Frame, Group, Cal, Mon)}

Executes the recipes stored in \$reciperef (an Array reference).
Also needs the current frame, group and calibration objects
as well as the hash containing all the messaging objects.



The following classes are avaiable to primitive writers:

\begin{verbatim}
  ORAC::Print, ORAC::LogFile, ORAC::General, ORAC::Constants,
  ORAC::TempFile and IO::File.
\end{verbatim}


Other classes can be loaded from within the recipe as needed.



The objects accessible to the recipe are:

\begin{verbatim}
  $Grp - the current group.
  $Frm - the current frame
  $Cal - the calibration object
  $Display - the display system (undefined if display not required)
\end{verbatim}


The Global variables listed at the end of this document are also
available.

\item \textbf{\textbf{orac\_read\_recipe}(recipe, instrument)}

Reads the specified recipe from the recipe directory.
An array reference containing the recipe is returned.



The second argument specifies the name of the instrument specific
directory that should be searched.



The location of the recipe is determined first by looking in the
directory specified with \$ENV\{ORAC\_RECIPE\_DIR\} and if none exists
the ORAC repository is searched (\$ENV\{ORAC\_DIR\}/recipes/instrument).
If the recipe can be found in neither location the program aborts.

\item \textbf{\textbf{orac\_read\_primitive}(primitive, instrument)}

Reads the specified primitive from the recipe directory.
An array reference containing the primitive is returned.



The second argument specifies the name of the instrument specific
directory that should be searched.



The location of the recipe is determined first by looking in the
directory specified with \$ENV\{ORAC\_PRIMITIVE\_DIR\} and if none exists
the ORAC repository is searched (\$ENV\{ORAC\_DIR\}/primitives/instrument).
If the recipe can be found in neither location the program aborts.

\item[\textbf{orac\_parse\_arguments}(line)] \mbox{}

Parses argument lists on primitive calls.
Converts a string of form 'arg1=value1 arg2=value2...'
to a hash.

\begin{verbatim}
  my %hash = orac_parse_arguments($string);
\end{verbatim}
\item[\textbf{orac\_parse\_recipe}] \mbox{}

Parses a recipe, reading in the necessary primitives.

\begin{verbatim}
  $parsed = orac_parse_recipe($input, $instrument, $depth);
\end{verbatim}


The input must be a referenced to an array of lines from a recipe or
primitive. The recipe is parsed in place (ie using the array
reference) and will therefore be modified when returning to the
caller.



The instrument name is supplied so that the directory name containing
the primitives can be constructed. See \texttt{orac\_read\_primitive}.



This routine uses recursion to parse the recipe until no more
primitive include directives are present. A recursion depth
of 50 is imposed to deal with out-of-control recipe recursion
(usually where a primitive calls itself). This should not be a
problem for working primitives.



The depth parameter is an integer specifying the current recursion
depth. This should be set to undef (do not even both to supply is)
when called by a user and is incremented by the routine internally.

\begin{verbatim}
  $parsed = orac_parse_recipe( $input, $instrument );
\end{verbatim}


An array reference to the parsed array is returned. If an error 
occurs, the routine \texttt{croaks}.

\item \textbf{\textbf{orac\_add\_code\_to\_recipe}($\backslash$@recipe)}

Post processes the recipe adding status checking code.



Argument is a reference to an array containing the recipe
and the return argument is a reference to an array containing
the processed recipe.

\item[\textbf{orac\_check\_status}] \mbox{}

Provides the code for automatic status checking of recipes.

\item[\textbf{orac\_check\_obey\_status}] \mbox{}

Provides the code for automatic status checking of obeyw()
in recipes.

\item[\textbf{orac\_exit\_normally}] \mbox{}

Exit handler for oracdr.

\item[\textbf{orac\_exit\_abnormally}] \mbox{}

Exit handler when a problem has been encountered.

\end{description}
\subsubsection*{GLOBAL VARIABLES\label{ORAC::Basic_GLOBAL_VARIABLES}\index{ORAC::Basic!GLOBAL VARIABLES}}

This module has the following package variables that can be modified
externally:

\begin{itemize}
\item \$Display

The object associated with the ORAC Display system. This
is of class ORAC::Display. The display system has not been
initialised if this variable has a value of undef. Primitives
should check to see that the variable is defined before
attempting to use it. This variable is set via the 
orac\_setup\_display() subroutine. Do not modify this variable.

\item \$DEBUG

This flag can be used to turn on some debugging features.

\item \$Batch

Flag to indicate whether the groups have been populated before
the recipe is executed (ie whether the pipeline is running in
batch mode or not).

\end{itemize}


These variables are visible to recipes but should not be modified
by them.

\subsubsection*{REVISION\label{ORAC::Basic_REVISION}\index{ORAC::Basic!REVISION}}

\$Id$

\subsubsection*{COPYRIGHT\label{ORAC::Basic_COPYRIGHT}\index{ORAC::Basic!COPYRIGHT}}

Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Convert\label{ORAC::Convert}\index{ORAC::Convert}}

Methods for converting data formats

\subsubsection*{SYNOPSIS\label{ORAC::Convert_SYNOPSIS}\index{ORAC::Convert!SYNOPSIS}}\begin{verbatim}
  use ORAC::Convert
\end{verbatim}
\begin{verbatim}
  $conv = new ORAC::Convert;
  $outfile = $conv->convert($infile, {IN => 'FITS', OUT => 'NDF'});
\end{verbatim}
\begin{verbatim}
  $outfile = $conv->convert($infile, { OUT => 'NDF'});
\end{verbatim}
\begin{verbatim}
  $outfile = $conv->fits2ndf($infile);
\end{verbatim}
\begin{verbatim}
  $conv->infile($infile);
  $outfile = $conv->convert;  # uses infile()
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Convert_DESCRIPTION}\index{ORAC::Convert!DESCRIPTION}}

Provide a system for converting data formats. Currently the
only output format supported are:

\begin{verbatim}
  NDF     - simple NDF files
  HDS     - HDS containers with .HEADER and .Inn NDFs
\end{verbatim}


The only input formats supported are:

\begin{verbatim}
  NDF     - simple NDF files
  FITS    - FITS file
  UKIRTIO - UKIRT I/O file
  HDS     - HDS containers with .HEADER and .Inn NDFs
            In general this can only be converted to a NDF or FITS
            output file if there is only one data frame in the container.
\end{verbatim}


In many cases the NDF format is used as the intermediate format for
all conversions (should probably use PDLs as the intermediate
format....)



Uses the Starlink CONVERT package (via monoliths) where necessary.



Can be used to convert from instrument specific NDF files (eg
multi-frame CGS4 data or I- and O- frames for IRCAM) to HDS formats
usable by the pipeline (either as HDS containers or NDFs with combined
I and O information).

\subsubsection*{METHODS\label{ORAC::Convert_METHODS}\index{ORAC::Convert!METHODS}}

The following methods are provided:

\paragraph*{Constructors\label{ORAC::Convert_Constructors}\index{ORAC::Convert!Constructors}}\begin{description}
\item[\textbf{new}] \mbox{}

Object constructor. Should always be used before initiating a conversion.

\begin{verbatim}
  $Cvt = new ORAC::Convert;
\end{verbatim}


Returns undef if there was an error creating the object. No arguments
are required.

\end{description}
\paragraph*{Accessor Methods\label{ORAC::Convert_Accessor_Methods}\index{ORAC::Convert!Accessor Methods}}

The following methods are available for accessing the 
'instance' data.

\begin{description}
\item[\textbf{infile}] \mbox{}

Method for storing or retreiving the current input filename.
Used by default if omitted from convert() methods.

\begin{verbatim}
  $infile = $Cvt->infile;
\end{verbatim}
\item[\textbf{objref}] \mbox{}

Hash containing convert task objects. These are the actual
ORAC::Msg::ADAM::Task objects related to each Starlink CONVERT
monolith that is required.

\begin{verbatim}
  $mon = $Cvt->objref->{monolith_name};
\end{verbatim}
\item[\textbf{overwrite}] \mbox{}

Method for storing or retreiving the flag governing whether
a file should be overwritten if it already exists.



If false, the file will be converted regardless.

\end{description}
\paragraph*{General Methods\label{ORAC::Convert_General_Methods}\index{ORAC::Convert!General Methods}}\begin{description}
\item[\textbf{convert}] \mbox{}

Convert a file to the format specified by options.

\begin{verbatim}
  $nrefile = $Cvt->convert;
  $newfile = $Cvt->convert($oldfile, { IN => 'FITS', OUT => 'NDF' });
\end{verbatim}


File is optional - uses infile() to retrieve the name if not specified.
The options hash is optional (assumed to be last argument). If not
specified the input format will be guessed and the output format
will be set to NDF.



Recogised keywords in the hash are:

\begin{verbatim}
  IN  => input format (NDF, UKIRTio or FITS)
  OUT => desired output format (NDF or HDS)
\end{verbatim}


If 'IN' is not specified it will try to derive the format from
name.



The output format is set to NDF if non-specified.



Returns the new filename (derived from the input filename).



Output filename is written to the current working directory of the
CONVERT monoliths (defaults to the CWD of the program when the
monoliths were launched - no attempt is made to correct the
CWD of the monoliths before conversion).

\item[\textbf{guessformat}] \mbox{}

Given 'name' try to guess data format.

\begin{verbatim}
  $format = $Cvt->guessformat("test.sdf");
\end{verbatim}


If no name is supplied, infile() is used to retrieve the current
filename.

\item[\textbf{mon}] \mbox{}

Returns a ORAC::Msg::ADAM::Task object using a path of name\_\$\$
in the messaging system.

\begin{verbatim}
  $object = $Cvt->mon($name);
\end{verbatim}


Returns undef if a monolith can not be contacted or fails to start.



Populates the object using the objref() method.

\end{description}
\paragraph*{Data Conversion Methods\label{ORAC::Convert_Data_Conversion_Methods}\index{ORAC::Convert!Data Conversion Methods}}\begin{description}
\item[\textbf{fits2ndf}] \mbox{}

Convert a fits file to an NDF.
Returns the output name.

\begin{verbatim}
  $newfile = $Cvt->fits2ndf;
\end{verbatim}


Retrieves the input filename from the object via the infile()
method.

\item[\textbf{UKIRTio2hds}] \mbox{}

Converts observations that are taken as a header file plus multiple
NDFs into a single HDS container that contains a .HEADER NDF and
.Inn NDFs for each of the nn data files. This is the scheme used for
IRCAM and CGS4 data at UKIRT.

\begin{verbatim}
  $hdsfile = $Cvt->UKIRTio2hds;
\end{verbatim}


This routine assumes the old UKIRT data acquisition system (at least for
IRCAM and CGS4) is generating the data files. The name of the header
file (aka the O-file) must be stored in the object (via the infile()
method) before running this method. The I files are assumed to be in
the directory \texttt{../idir} relative to the header file with a starting
character of 'i' rather than 'o' and are multiple files with
suffixes of '\_1', '\_2' etc. The new output file
is named 'cYYYYMMDD\_NNNNN' where the date is retrieved from the IDATE header
keyword and observation number from the OBSNUM header keyword.



Returns undef on error.

\item[\textbf{hds2ndf}] \mbox{}

Converts frames taken as HDS container files (container file with
.HEADER and .I1) to a simple NDF file. This method only works
for the first frame (.I1).

\begin{verbatim}
  $ndf = $Cvt->hds2ndf;
\end{verbatim}


The resulting NDF file has the FITS headers from both the .HEADER
and the .I1 component. No warning is given if more than one component
exists (all higher numbers are ignored).

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Convert_SEE_ALSO}\index{ORAC::Convert!SEE ALSO}}

The Starlink CONVERT package.

\subsubsection*{REVISION\label{ORAC::Convert_REVISION}\index{ORAC::Convert!REVISION}}

\$Id$

\subsubsection*{COPYRIGHT\label{ORAC::Convert_COPYRIGHT}\index{ORAC::Convert!COPYRIGHT}}

Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Core\label{ORAC::Core}\index{ORAC::Core}}

Core routines for data pipelining

\subsubsection*{SYNOPSIS\label{ORAC::Core_SYNOPSIS}\index{ORAC::Core!SYNOPSIS}}\begin{verbatim}
  use ORAC::Core;
\end{verbatim}
\begin{verbatim}
  orac_process_frame($Frm, $Grp, $Cal,\%Mon,$OverRecipe, $instrument);
\end{verbatim}
\begin{verbatim}
  orac_store_frm_in_correct_grp($Frm, $GrpType, $GrpHash, $GrpArr, $ut);
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Core_DESCRIPTION}\index{ORAC::Core!DESCRIPTION}}

This module contains the core routines that actually handle the 
data processing. Routines are provided for constructing groups
and for processing those groups.

\subsubsection*{SUBROUTINES\label{ORAC::Core_SUBROUTINES}\index{ORAC::Core!SUBROUTINES}}

The following subroutines are available:

\begin{description}
\item \textbf{\textbf{orac\_store\_frm\_in\_correct\_grp}}

Stores the supplied frame into a Grp (usually specified in the Frame),
creating a new Group object if necessary. The Group objects are stored
in a hash (reference supplied) and, optionally, an array (unless undef).
This is so that Groups can be retrieved in the order in which they
were created. The GrpType specifies the type of Group that should be
created (eg \textbf{ORAC::Group::UFTI}, \textbf{ORAC::Group::JCMT} etc). The UT
is supplied purely so that the Group can be named (using the 
file\_from\_bits() method).

\begin{verbatim}
  orac_store_frm_in_correct_grp($Frm, $GrpType, \%Groups, \@Groups,
        $ut, $resume);
  orac_store_frm_in_correct_grp($Frm, $GrpType, \%Groups, undef, 
        $ut, $resume);
\end{verbatim}


The resume flag is used to determine the behaviour of the group when
it is first created. If resume is false, any existing Group file is 
removed before proceeding; if it is true, the Group file is retained
and any coadd information is read using the coaddsread() Group
method.



The current Grp (ie the Group associated with the supplied Frm)
is returned.

\item[\textbf{orac\_process\_frame}] \mbox{}

This is the core \textbf{ORAC-DR} pipeline processing routine.
It processes the supplied frame object that belongs to the group object,
using the supplied calibration object. The instrument name and default
recipe are required for recipe/primitive reading since recipes and
primitives are stored in instrument specific directories.
The \%Mon hash is supplied so that a recipe has full access to
all the monoliths launched for this instrument.

\begin{verbatim}
  orac_process_frame($Frm, $Grp, $Cal, \%Mon, $default_recipe, 
     $instrument);
\end{verbatim}
\end{description}
\subsubsection*{REVISION\label{ORAC::Core_REVISION}\index{ORAC::Core!REVISION}}

\$Id$

\subsubsection*{COPYRIGHT\label{ORAC::Core_COPYRIGHT}\index{ORAC::Core!COPYRIGHT}}

Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Display::Base\label{ORAC::Display::Base}\index{ORAC::Display::Base}}

Base class for ORAC display interface

\subsubsection*{SYNOPSIS\label{ORAC::Display::Base_SYNOPSIS}\index{ORAC::Display::Base!SYNOPSIS}}\begin{verbatim}
  use ORAC::Display::Base;
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Display::Base_DESCRIPTION}\index{ORAC::Display::Base!DESCRIPTION}}

Provides the generic methods for handling ORAC Display devices.
The generic routines (those worth inheriting) deal with display
device name allocation (eg mapping a device number to a real device).

\subsubsection*{PUBLIC METHODS\label{ORAC::Display::Base_PUBLIC_METHODS}\index{ORAC::Display::Base!PUBLIC METHODS}}\paragraph*{Constructor\label{ORAC::Display::Base_Constructor}\index{ORAC::Display::Base!Constructor}}\begin{description}
\item[\textbf{new}] \mbox{}

Base class constructor. Can be called as SUPER::new() from
sub-classes. Accepts a configuration hash as input in order to
initialise extra instance data components of the class that are
required by sub-classes.

\begin{verbatim}
  $a = new ORAC::Display(a => 'b', c => 'd');
\end{verbatim}


This constructor does not attempt to launch a display device.
That is up to the sub-classes.

\end{description}
\paragraph*{Accessor Methods\label{ORAC::Display::Base_Accessor_Methods}\index{ORAC::Display::Base!Accessor Methods}}\begin{description}
\item[\textbf{dev}] \mbox{}

Method for handling the hash of device name mapping. ie Which 
device name (as required for each Display interface, eg '.rtd0',
'xwindows;\$\$') is associated with the ORAC name (eg '0','1','default').



The hash reference is returned when called with no arguments:

\begin{verbatim}
  $href = $self->dev;
\end{verbatim}


The value associated with the supplied key is returned if one
argument is provided:

\begin{verbatim}
  $value = $self->dev('key');
\end{verbatim}


The supplied value is stored in key if two arguments are supplied:

\begin{verbatim}
  $self->dev('key','value');
\end{verbatim}


Undefined values are accepted.

\end{description}
\paragraph*{General Methods\label{ORAC::Display::Base_General_Methods}\index{ORAC::Display::Base!General Methods}}\begin{description}
\item[\textbf{window\_dev}] \mbox{}

Returns the device id (eg GWM device name or RTD window name)
associated with window 'win'. If 'win' is undefined a new
window is launched, the id stored in the hash and the
new id returned. (see the launch\_dev() method). If this
is the first time the routine is called (ie the only window
name present is 'default', the name of the default window
is associated with window win.). We go through this hoop
so that devices will open a window before the user has associated
their user-defined name with the actual window name.

\begin{verbatim}
  $name = $self->window_dev('win');
\end{verbatim}


If the windows were launched with bad status we should 
set the device name to something recognisable as bad
since status is not returned.

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Display::Base_SEE_ALSO}\index{ORAC::Display::Base!SEE ALSO}}

the \emph{ORAC::Display::GAIA} manpage, the \emph{ORAC::Display::KAPVIEW} manpage

\subsubsection*{REVISION\label{ORAC::Display::Base_REVISION}\index{ORAC::Display::Base!REVISION}}

\$Id$

\subsubsection*{COPYRIGHT\label{ORAC::Display::Base_COPYRIGHT}\index{ORAC::Display::Base!COPYRIGHT}}

Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Display::GAIA\label{ORAC::Display::GAIA}\index{ORAC::Display::GAIA}}

ORAC interface to GAIA

\subsubsection*{SYNOPSIS\label{ORAC::Display::GAIA_SYNOPSIS}\index{ORAC::Display::GAIA!SYNOPSIS}}\begin{verbatim}
  $disp = new ORAC::Display::GAIA;
\end{verbatim}
\begin{verbatim}
  $disp->image($file);
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Display::GAIA_DESCRIPTION}\index{ORAC::Display::GAIA!DESCRIPTION}}

ORAC interface to the the GAIA (ESO Skycat) display tool. Provides methods
for displaying images.



Available options are:



IMAGE - display image in GAIA window

\subsubsection*{PUBLIC METHODS\label{ORAC::Display::GAIA_PUBLIC_METHODS}\index{ORAC::Display::GAIA!PUBLIC METHODS}}\paragraph*{Constructor\label{ORAC::Display::GAIA_Constructor}\index{ORAC::Display::GAIA!Constructor}}\begin{description}
\item[\textbf{new}] \mbox{}

Object constructor. The constructor starts up a new version of
GAIA (if one is not running) and connects via a socket.



The program aborts if there is an error launching or contacting
gaia.

\end{description}
\paragraph*{Accessor Methods\label{ORAC::Display::GAIA_Accessor_Methods}\index{ORAC::Display::GAIA!Accessor Methods}}\begin{description}
\item[\textbf{sock}] \mbox{}

Returns or sets the socket to Gaia. Private to this class.

\begin{verbatim}
  $sock = $gaia->sock();
\end{verbatim}


This is usually IO::Socket object. This socket is automatically
added to the IO::Select object returned by the \texttt{sel} method.
(and all previous sockets registered with the IO::Select object
are removed).

\item[\textbf{sel}] \mbox{}

Returns the IO::Select object associated associated with the
current socket.

\begin{verbatim}
  $select = $gaia->sel();
\end{verbatim}


This object is used to determine whether the GAIA process can be
contacted through the established socket connection.

\item[\textbf{use\_remote\_gaia}] \mbox{}

Controls whether we are allowed to connect to a GAIA process that
is already running on a remote machine. By default this is allowed
(true) but in some cases you may not want to connect to a remote
GAIA. For example, at UKIRT, the display must be sent to the machine
running the pipeline and not one of the other GAIAs that are running
on separate machines for QuickLook and general data inspection.

\end{description}
\paragraph*{General Methods\label{ORAC::Display::GAIA_General_Methods}\index{ORAC::Display::GAIA!General Methods}}\begin{description}
\item[\textbf{create\_dev}] \mbox{}

Clone a new GAIA window and associate it with 'win'. This is different
to launching a new display device (ie running up GAIA itself).

\begin{verbatim}
  $status = $Display->create_dev($win, $name);
\end{verbatim}


For GAIA (V $<$= 2.3-2) the device name (\$name) must be an integer.
(enforced if the newdev() method is used).



ORAC status is returned.

\item[\textbf{launch}] \mbox{}

Connect to a pre-existing Gaia process or launch a new Gaia process.
If the first connection attempt fails, launches a new gaia process.
After this, attempts to connect to a new gaia process every 3 seconds
and attempts to launch a new gaia process every 60 seconds.
A maximum of 5 attempts are made (5 minutes) to launch a new Gaia
process before giving up.



There is no return status -- the program croaks if it can not
get a connection to GAIA !!



Whilst it is waiting, does not attempt to keep a the \textsf{Tk$|$Tk}
 entry elsewhere in this document event loop
running.

\item[\textbf{configure}] \mbox{}

Load the startup image into GAIA. Essentially used to test that
GAIA can display images correctly.



Returns ORAC status.

\item[\textbf{send\_to\_gaia}] \mbox{}

Sends the supplied command to gaia. Any response from Gaia is returned.

\begin{verbatim}
  ($status, $return_string) = $obj->send_to_gaia('command');
  ($status, @return_strings) = $obj->send_to_gaia(@commands);
\end{verbatim}


The returned status is translated into an ORAC status (either ORAC\_\_OK
or ORAC\_\_ERROR). On error, the return\_string contains the error message.
The status returned is the status of the last command processed by GAIA.

\item[\textbf{newdev}] \mbox{}

Returns the name to be used for the new GAIA window based on the supplied
window name.

\begin{verbatim}
   $name = $obj->newdev($win);
\end{verbatim}


Currently, for gaia, the argument is ignored. The name is simply returned
as an integer calculated from the number of devices already stored
in the object.

\end{description}
\subsubsection*{DISPLAY METHODS\label{ORAC::Display::GAIA_DISPLAY_METHODS}\index{ORAC::Display::GAIA!DISPLAY METHODS}}\begin{description}
\item[\textbf{image}] \mbox{}

Routine to display images in Gaia. Note that the full file name is required.
If an image name does not include an extension then '.sdf' is appended.
(ie NDF is assumed).



Takes a file name and arguments stored in a hash.

\begin{verbatim}
  $disp->image("filename", \%options)
  $disp->image("filename", { WINDOW => 2 });
\end{verbatim}


Currently no image sectioning is supported.
Display range can be adjusted with ZAUTOSCALE, ZMIN and ZMAX.



Note that for GAIA, ZAUTOSCALE implies a 95 percent cut level and
not 100 percent.



Will attempt to relaunch GAIA if it can not be contacted.
Will attempt to create a new clone window if a clone can not be
contacted even though it has been used previously.



ORAC status is returned.

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Display::GAIA_SEE_ALSO}\index{ORAC::Display::GAIA!SEE ALSO}}

the \emph{ORAC::Display::Base} manpage, the \emph{ORAC::Display::KAPVIEW} manpage, the \emph{ORAC::Display} manpage,
the \emph{IO::Socket} manpage

\subsubsection*{REVISION\label{ORAC::Display::GAIA_REVISION}\index{ORAC::Display::GAIA!REVISION}}

\$Id$

\subsubsection*{COPYRIGHT\label{ORAC::Display::GAIA_COPYRIGHT}\index{ORAC::Display::GAIA!COPYRIGHT}}

Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Display::KAPVIEW\label{ORAC::Display::KAPVIEW}\index{ORAC::Display::KAPVIEW}}

ORACDR interface to Kapview (Kappa)

\subsubsection*{SYNOPSIS\label{ORAC::Display::KAPVIEW_SYNOPSIS}\index{ORAC::Display::KAPVIEW!SYNOPSIS}}\begin{verbatim}
  use ORAC::Display::KAPVIEW;
  $disp = new ORAC::Display::KAPVIEW;
\end{verbatim}
\begin{verbatim}
  $disp->image($file, { XAUTOSCALE => 1});
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Display::KAPVIEW_DESCRIPTION}\index{ORAC::Display::KAPVIEW!DESCRIPTION}}

ORAC interface to Kappa Kapview. Provides methods for displaying images
and spectrum with Kapview.



Available options are:

\begin{verbatim}
 IMAGE - display image using DISPLAY
 GRAPH - display graph using LINPLOT
 SIGMA - display scatter plot with a Y-range of +/- N sigma.
 DATAMODEL - Display data (as points) with a model overlaid
 HISTOGRAM - Histogram of values in data array
 VECTOR - Display image + vectors
\end{verbatim}
\subsubsection*{PUBLIC METHODS\label{ORAC::Display::KAPVIEW_PUBLIC_METHODS}\index{ORAC::Display::KAPVIEW!PUBLIC METHODS}}\paragraph*{Constructor\label{ORAC::Display::KAPVIEW_Constructor}\index{ORAC::Display::KAPVIEW!Constructor}}\begin{description}
\item[\textbf{new}] \mbox{}

Object constructor. The constructor starts up a new version of kapview,
starts a GWM window and displays the startup logo.



The program aborts if there is an error launching kapview.



The message system must be running so that Kapview can be configured.
(AMS is started if needed)

\end{description}
\paragraph*{Accessor Methods\label{ORAC::Display::KAPVIEW_Accessor_Methods}\index{ORAC::Display::KAPVIEW!Accessor Methods}}\begin{description}
\item[\textbf{kappa}] \mbox{}

Messaging object associated with the kappa\_mon monolith.
This is used by some of the modes in order to determine
display related values (eg statistics to determine plotting
ranges for SIGMA, dimension compression with COMPAVE).



A kappa messaging object is created if the object is undefined.



Note also that the HISTOGRAM task is present in the kappa monolith
rather than in the KAPVIEW monolith.

\item[\textbf{ndfpack}] \mbox{}

Messaging object associated with the ndfpack\_mon monolith.
This is used by some of the modes in order to reshape
date arrays (eg in SIGMA mode - reshape is run to convert
to 1-d)



A NdfPack messaging object is created if the object is undefined.

\item[\textbf{polpack}] \mbox{}

Messaging object associated with the polpack\_mon monolith.
This is used by the VECTOR mode to plot vectors from catalogues.



Note that this is technically not part of the KAPVIEW system.
It is here for convenience since in all cases POLPLOT is better
than VECPLOT for vector plotting.



A Polpack messaging object is created if the object is undefined.



Returns undef if polpack\_mon is not available.

\item[\textbf{regions}] \mbox{}

A hash containing the mapping of region name (number) to
AGI picture label.



Returns hash reference in scalar context, full hash in array context.
Contents can be modified by directly using the hash reference
(in order to modify specific entries) or completely rewritten by
supplying a hash as argument.

\begin{verbatim}
  $hashref = $self->regions;
  %hash = $self->regions;
  $self->regions(%hash);
  $self->regions->{Key} = "value";
\end{verbatim}
\item[\textbf{obj}] \mbox{}

Messaging object associated with the Kapview display object.

\end{description}
\paragraph*{General Methods\label{ORAC::Display::KAPVIEW_General_Methods}\index{ORAC::Display::KAPVIEW!General Methods}}\begin{description}
\item[\textbf{newdev}] \mbox{}

Given 'win', calculates a new device name that should be unique for
each 'win'.

\begin{verbatim}
 $dev = $Display->newdev($win);
\end{verbatim}
\item[\textbf{create\_dev}] \mbox{}

Start the GWM window associated with the supplied window.
In general this is used by the startup configuration.
The lookup table is configured by this routine (so that
this routine really does start the GWM window).



Currently the GWM window itself is not started directly
by this routine (since KAPVIEW will automatically open
the specified device if one is not running).



The only reason to use this routine to actually START a window
is that it will give us some control over the colour allocation
and allow us to set the window name.



ORAC status is returned.

\begin{verbatim}
  $status = $Display->create_dev($win);
\end{verbatim}


Currently, the method dies if the device can not be successfully
created.

\item[\textbf{launch}] \mbox{}

This method starts the kapview monolith and stores the associated
Task object.

\item[\textbf{configure}] \mbox{}

Load a startup image. This tests the system to make sure that images
can be displayed and that the colour map is loaded.



Returns ORAC status.

\item[\textbf{config\_regions}] \mbox{}

This method configures the display regions so that they can be
selected later by select\_region.

\begin{verbatim}
  $status = $self->config_regions($window);
\end{verbatim}


A window name must be supplied.



The regions are defined as follows:

\begin{verbatim}
  0 - full screen
  1 - top left
  2 - top right
  3 - bottom left
  4 - bottom right
  5 - left
  6 - right
  7 - top
  8 - bottom
  17:32 - position in 4x4 grid (starting top left)
\end{verbatim}


The picture labels are stored in the regions() array.

\item[\textbf{select\_region}] \mbox{}

Selects the requested region as the current region in the display
system by using a supplied hash.

\begin{verbatim}
  $device = $Display->select_region(%options);
\end{verbatim}


Returns undef without action if the REGION keyword is not available
(since have no idea where to put it) or if REGION is not in the
allowed range.  Otherwise the name of the device containing the selected
region is returned. undef is returned if no arguments are supplied.



If the window name is not supplied (WINDOW) then 'default' is assumed.

\item[\textbf{select\_section}] \mbox{}

This method converts a file name and options hash into
a filename with an attached NDF section.

\begin{verbatim}
  $newfile = $Display->select_section($file, \%options, $dimensionality);
\end{verbatim}


An optional 3rd argument can be used to specify the required 
dimensionality. If the number of dimensions in the data file is
greater than that requested, sections in higher dimensions
are set to 1 by compressing the undesired dimension
(with the assumption that KAPPA will discard axes
with 1 pixel). The desired dimension is specified with the CUT
option. For example, a graph can be displayed from a 2-D image
by displaying a cut in the X direction (averaging over the Ys).



If the number of dimensions in the data file
is fewer than that requested, a warning message is printed
but we continue in the hope that KAPPA will work something out....



The return value is the original filename with the
NDF section attached.



Relevant keywords in options hash:

\begin{verbatim}
  CUT  - Specify the significant dimension[s] (X,Y,3,4,5)
         Should be a comma-separated list specifying 
         dimensionality - number of entries should equal the
         requested dimensionality. For a graph only 1 value
         is required since a graph is 1-D
  XMIN/XMAX - X pixel max and min values
  YMIN/YMAX - Y pixel max and min values
  XAUTOSCALE - Use autoscaling for X?
  YAUTOSCALE - Use autoscaling for Y?
\end{verbatim}


If Xautoscale and Yautoscale are true, no section command is appended.
If the XAUTOSCALE/YAUTOSCALE/nAUTOSCALE keywords can not be found they are
assumed to be true. If CUT is not specified  the first slice is
selected (eg a NDF section of N,1,1,1)



For data arrays with N$>$2, the leading letter is dropped and replaced
by the dimension number. eg:

\begin{verbatim}
  3MIN/3MAX - pixel range of the 3rd dimension
  4AUTOSCALE - autoscale the 4th dimension?
\end{verbatim}


For NDFs the maximum dimensionality is 7.



The bounds of the input file are compared to the supplied bounds.
If any of the requested bounds are exceeded, the maximum value
will be used instead.



Returns undef on error.
The unmodified file name is returned if no options hash can be found.



Returns the following:

\begin{verbatim}
  No CUT requested + auto-scaling:
    returns the original filename
  No CUT requested + some dimension ranges specified
    returns the original filename with an NDF section
    Dimensions above the requested dimensionality are set to the
    min value in the section (1 if not specified)
  CUT requested but dimensionality of data matches requested
    dimensionality.
    Just return the file + any relevant section
  CUT + auto-scaling + image too large
    data file is collapsed down to required size keeping the specified
    dimensions and averaging over the rest. A new temporary filename
    is returned
  CUT + some ranges specified + image too large
    NDF section constructed and then the data file is collapsed
    down to the required size. A new temporary file is generated.
  CUT + range + image + one pixel selected
    If the non-cut dimensions have min=max a section is
    sufficient and no averaging required
\end{verbatim}


The temporary files themselves are added to a global class
array and removed by the destructor.



Note that this routine does not remove the temporary filename.
This is probably a bug. Should probably create some kind of
object that will have a destructor that removes the file rather
than using a simple file name. (an ORAC::Frame::TmpFile)?

\end{description}
\subsubsection*{DISPLAY METHODS\label{ORAC::Display::KAPVIEW_DISPLAY_METHODS}\index{ORAC::Display::KAPVIEW!DISPLAY METHODS}}\begin{description}
\item[\textbf{image}] \mbox{}

Display an image.
Takes a file name and arguments stored in a hash.
Note that currently it does not take a format argument
and NDF is assumed.



Recognised options:

\begin{verbatim}
  XMIN/XMAX - X pixel max and min values
  YMIN/YMAX - Y pixel max and min values
  XAUTOSCALE - Use autoscaling for X?
  YAUTOSCALE - Use autoscaling for Y?
  ZMIN/ZMAX  - Z-range of greyscale (data units)
  ZAUTOSCALE - Autoscale Z?
  COMP       - Component to display (Data (default), Variance or Error)
\end{verbatim}


Default is to autoscale.



ORAC Status is returned.

\item[\textbf{graph}] \mbox{}

Display a 1-D plot.



If the data are not 1-D, a section is taken that assures
1-D (eg NDF section= :,1,1,1 for 4D data)



Takes a file name and arguments stored in a hash.
Note that currently it does not take a format argument
and NDF is assumed.



Display keywords:

\begin{verbatim}
  XMIN/XMAX  - X-pixel range of graph
  XAUTOSCALE - Autoscale pixel range?
  YMIN/YMAX  - Y-pixel range of graph (in pixels)
  YAUTOSCALE - Autoscale Y-axis
  YMIN/YMAX  - Z-range of graph (in data units)
  YAUTOSCALE - Autoscale Z-axis
  CUT        - Decide which direction is the primary axis
               Can be X,Y,3,4,5 (for higher-dimensional data sets)
               For a 1-D data set (or section), this value is ignored
  COMP       - Component to display (Data (default), Variance or Error)
\end{verbatim}


Default is to autoscale. Note that the X/Y cuts are converted
to a 1-D slice before displaying by averaging over the section.



For example:

\begin{verbatim}
   XMIN=5 XMAX=5 YAUTOSCALE=YES
\end{verbatim}


would display column 5 (ie the whole of Y for X=5).
[CUT is irrelevant since the resulting image section is 1-D]

\begin{verbatim}
   XAUTOSCALE=YES YMIN=20 YMAX=30 CUT=X
\end{verbatim}


would display the average of rows 20 and 30 for each X.



Need to add way of controlling line style (eg replace with symbols)



ORAC status is returned.

\item[\textbf{contour}] \mbox{}

Display contours of a 2-D data set.



Recognised options:

\begin{verbatim}
  XMIN/XMAX - X pixel max and min values
  YMIN/YMAX - Y pixel max and min values
  XAUTOSCALE - Use autoscaling for X?
  YAUTOSCALE - Use autoscaling for Y?
  ZMIN/ZMAX  - Z-range of greyscale (data units)
  ZAUTOSCALE - Autoscale Z?
  NCONT      - Number of contours
  COMP       - Component to display (Data (default), Variance or Error)
\end{verbatim}


Default is to autoscale.



ORAC status is returned.

\item[\textbf{sigma}] \mbox{}

Display a scatter plot of the data with Y range of N-sigma (sigma
is derived from the data) with dashed lines overlaid at the X-sigma
points.



By default a range of +/-5 sigma with dashed lines at +/-3 sigma
are used.



These values can be overriden by using the RANGE and DASHED 
keywords.



Takes a file name and arguments stored in a hash.
Note that currently it does not take a format argument
and NDF is assumed.



If we are running KAPPA 0.13, the NDF is converted
to 1-DIM with the kappa RESHAPE command before 
displaying.



ORAC status is returned.

\item[\textbf{datamodel}] \mbox{}

Display mode where the supplied filename is plotted as individual
points and a model is overlaid as a solid line. This can be used
to determine the goodness of fit of data and model.



The model filename is derived from the input filename (a \_model
extension is expected). The data is displayed if the model
file can not be found.



Takes a file name and arguments stored in a hash.
Note that currently it does not take a format argument
and NDF is assumed.



Option keywords:

\begin{verbatim}
  XMIN/XMAX  - X-pixel range of graph
  XAUTOSCALE - Autoscale pixel range?
  ZMIN/ZMAX  - Y-range of graph (in data units)
  ZAUTOSCALE - Autoscale Y-axis
  COMP       - Component to display (Data (default), Variance or Error)
\end{verbatim}


Default is to autoscale on the data (the model may not be visible).



If the input file is greater than 1-D, the section is automatically
converted to 1-D by selecting the ?MIN slice from each of the
higher axes (eg the value specified in YMIN, 3min...)



ORAC status is returned.

\item[\textbf{histogram}] \mbox{}

Display a histogram of the data values present in the 
data array.



Takes a file name and arguments stored in a hash.
Note that currently it does not take a format argument
and NDF is assumed.



Arguments:

\begin{verbatim}
  XMIN/MAX   - minimum/maximum x-pixel value
  XAUTOSCALE - Use full X-range
  YMIN/YMAX  - minimum/maximum x-pixel value
  YAUTOSCALE - use full Y-range
  ZMIN/ZMAX  - Z range of histogram (data units)
  ZAUTOSCALE - use full Z-range
  NBINS      - Number of bins to be used for histogram calculation
  COMP       - Component to display (Data (default), Variance or Error)
\end{verbatim}


Default is for autoscaling and for NBINS=20.



ORAC status is returned.

\item[\textbf{vector}] \mbox{}

Vectors are overlaid on an image. The supplied file is displayed
and vectors are then drawn. The vector information is expected
to be stored in the ORAC extension of the supplied file
(in .P and .THETA NDFs) or, preferably, in a catalogue of the
same name as the I image. POLPLOT is used for display if
the catalogue is available.



Recognised options:

\begin{verbatim}
  XMIN/XMAX  - X pixel max and min values
  YMIN/YMAX  - Y pixel max and min values
  XAUTOSCALE - Use autoscaling for X?
  YAUTOSCALE - Use autoscaling for Y?
  ZMIN/ZMAX  - Z-range of greyscale (data units)
  ZAUTOSCALE - Autoscale Z?
  ANGROT     - angle to add to all vectors
\end{verbatim}


Default is to autoscale.



ORAC status is returned.

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Display::KAPVIEW_SEE_ALSO}\index{ORAC::Display::KAPVIEW!SEE ALSO}}

the \emph{ORAC::Display} manpage, the \emph{ORAC::Display::GAIA} manpage

\subsubsection*{REVISION\label{ORAC::Display::KAPVIEW_REVISION}\index{ORAC::Display::KAPVIEW!REVISION}}

\$Id$

\subsubsection*{COPYRIGHT\label{ORAC::Display::KAPVIEW_COPYRIGHT}\index{ORAC::Display::KAPVIEW!COPYRIGHT}}

Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.

