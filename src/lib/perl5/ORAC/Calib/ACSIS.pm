package ORAC::Calib::ACSIS;

=head1 NAME

ORAC::Calib::ACSIS;

=head1 SYNOPSIS

  use ORAC::Calib::ACSIS;

  $Cal = new ORAC::Calib::ACSIS;

=head1 DESCRIPTION

This module contains methods for specifying ACSIS-specific calibration
objects. It provides a class derived from ORAC::Calib. All the methods
available to ORAC::Calib objects are also available to
ORAC::Calib::ACSIS objects.

=cut

use Carp;
use warnings;
use strict;

use ORAC::Print;

use File::Copy;
use File::Spec;

use base qw/ ORAC::Calib::JCMT /;

use vars qw/ $VERSION /;
$VERSION = '1.0';

__PACKAGE__->CreateBasicAccessors( bad_receptors => { staticindex => 1 },
                                   standard => { staticindex => 1 },
);


=head1 METHODS

The following methods are available:

=head2 Constructor

=over 4

=item B<new>

Sub-classed constructor. Adds knowledge of pointing, reference
spectrum, beam efficiency, and other ACSIS-specific calibration
information.

=cut

sub new {
  my $self = shift;
  my $obj = $self->SUPER::new( @_ );

# This assumes we have a hash object.
  $obj->{BadReceptors} = undef;
  $obj->{BadReceptorsIndex} = undef;
  $obj->{BadReceptorsNoUpdate} = 0;
  $obj->{Standard} = undef;
  $obj->{StandardIndex} = undef;
  $obj->{StandardNoUpdate} = 0;

  return $obj;
}

=back

=head2 Accessors

=over 4

=item B<bad_receptors>

Set or retrieve the name of the system to be used for bad receptor
determination. Allowed values are:

=over 4

=item * master

Use the master index.bad_receptors index file in $ORAC_DATA_CAL.

=item * index

Use the index.bad_receptors_qa index file in $ORAC_DATA_OUT as
generated by the pipeline.

=item * indexormaster

Use both the master index.bad_receptors and pipeline-generated
index.bad_receptors_qa file. Results are 'or'ed together, so any
receptors flagged as bad in either index file will be flagged as bad.

=item * file

Use the contents of the file F<bad_receptors.lis>, which contains a
space-separated list of receptor names in the first line. This file
must be found in $ORAC_DATA_OUT. If the file cannot be found, no
receptors will be flagged.

=item * 'list'

A colon-separated list of receptor names can be supplied.

=back

The default is to use the 'indexormaster' method. The returned value
will always be in upper-case.

=cut

sub bad_receptors {
  my $self = shift;
  # Use the automatically created method
  my $br = $self->bad_receptorscache(map { uc($_) } @_);
  return (defined $br ? $br : "INDEXORMASTER" );
}

=item B<bad_receptorsindex>

Return (or set) the index object associated with the master bad
receptors index file. This index file is used if bad_receptors() is
set to 'MASTER' or 'INDEXORMASTER'.

=item B<bad_receptors_qa_index>

Return (or set) the index object associated with the
pipeline-generated bad receptors index file. This index file is used
if bad_receptors() is set to 'INDEX' or 'INDEXORMASTER'.

=cut

sub bad_receptors_qa_index {
  my $self = shift;
  return $self->GenericIndex( "bad_receptors_qa", "dynamic", @_ );
}

=item B<bad_receptors_list>

Return a list of receptor names that should be masked as bad for the
current observation. The source of this list depends on the setting of
the bad_receptors() accessor.

=cut

sub bad_receptors_list {
  my $self = shift;

  # Retrieve the bad_receptors query system.
  my $sys = $self->bad_receptors;

  # Array to hold the bad receptors.
  my @bad_receptors = ();

  # Go through each system.
  if( $sys eq 'INDEX' or $sys eq 'MASTER' or $sys eq 'INDEXORMASTER' ) {

    # We need to set up some temporary headers for LOFREQ_MIN and
    # LOFREQ_MAX. The "thing" method contains the merged uhdr and hdr,
    # so just stick them in there. The uhdr is in "thingtwo".
    my $lofreq = $self->thing->{'LOFREQS'};
    my $thing2 = $self->thingtwo;
    $thing2->{'LOFREQ_MIN'} = $lofreq;
    $thing2->{'LOFREQ_MAX'} = $lofreq;
    $self->thingtwo( $thing2 );

    my @master_bad = ();
    my @index_bad = ();

    if( $sys =~ /MASTER/ ) {

      my $brposition = $self->bad_receptorsindex->chooseby_negativedt( 'ORACTIME', $self->thing, 0 );

      if( defined( $brposition ) ) {
        # Retrieve the specific entry, and thus the receptors.
        my $brref = $self->bad_receptorsindex->indexentry( $brposition );
        if( exists( $brref->{'DETECTORS'} ) ) {
          @master_bad = split /,/, $brref->{'DETECTORS'};
        } else {
          croak "Unable to obtain DETECTORS from master index file entry $brposition\n";
        }
      }
    }

    if ( $sys =~ /INDEX/ ) {

      # This one also has a modified SURVEY_BR, so set that based on
      # the SURVEY header.
      my $survey = $self->thing->{'SURVEY'};
      my $thing2 = $self->thingtwo;
      if( ! defined( $thing2->{'SURVEY_BR'} ) ) {
        if( defined( $survey ) ) {
          $thing2->{'SURVEY_BR'} = $survey;
        } else {
          $thing2->{'SURVEY_BR'} = 'Telescope';
        }
        $self->thingtwo( $thing2 );
      }

      my $brposition = $self->bad_receptors_qa_index->choosebydt( 'ORACTIME', $self->thing, 0 );

      if( defined( $brposition ) ) {
        # Retrieve the specific entry, and thus the receptors.
        my $brref = $self->bad_receptors_qa_index->indexentry( $brposition );
        if( exists( $brref->{'DETECTORS'} ) ) {
          @index_bad = split /,/, $brref->{'DETECTORS'};
        } else {
          croak "Unable to obtain DETECTORS from QA index file entry $brposition\n";
        }
      }

    }

    # Remove the temporary LOFREQ_MIN and LOFREQ_MAX headers.
    $thing2 = $self->thingtwo;
    delete $thing2->{'LOFREQ_MIN'};
    delete $thing2->{'LOFREQ_MAX'};
    $self->thingtwo( $thing2 );

    # Merge the master and QA bad receptors.
    my %seen = map { $_, 1 } @master_bad, @index_bad;
    @bad_receptors = keys %seen;

  } elsif( $sys eq 'FILE' ) {

    # Look for bad receptors in the bad_receptors.lis file.
    my $file = File::Spec->catfile( $ENV{'ORAC_DATA_OUT'}, "bad_receptors.lis" );
    if( -e $file ) {
      my $fh = new IO::File( "< $file" );
      if( defined( $fh ) ) {
        my $list = <$fh>;
        close $fh;
        @bad_receptors = split( /\s+/, $list );
      }
    }

  } else {

    # Look for bad receptors in $sys itself.
    @bad_receptors = split /:/, $sys;
  }

  return @bad_receptors;
}

=item B<standard>

Retrieve the relevant standard.

=cut

sub standard {
  my $self = shift;

  return $self->standardcache(shift) if @_;

  if( $self->standardnoupdate ) {
    my $cache = $self->standardcache;
    return $cache if defined $cache;
  }

  # We need to convert the transition in the header into something we
  # can use. This means stripping out spaces. Also strip out dashes
  # from the molecule.
  my $transition = $self->thing->{'TRANSITI'};
  my $molecule = $self->thing->{'MOLECULE'};
  my $thing2 = $self->thingtwo;
  $transition =~ s/\s+//g;
  $thing2->{'TRANSITION'} = $transition;
  $molecule =~ s/\s+//g;
  $molecule =~ s/-//g;
  $thing2->{'MOLECULE'} = $molecule;

  $self->thingtwo( $thing2 );

  my $standardfile = $self->standardindex->choosebydt( 'ORACTIME', $self->thing, 0 );

  if( ! defined( $standardfile ) ) {
    return undef;
  }

  my $standardref = $self->standardindex->indexentry( $standardfile );
  if( exists( $standardref->{'INTEGINT'} ) &&
      exists( $standardref->{'PEAK'} ) &&
      exists( $standardref->{'L_BOUND'} ) &&
      exists( $standardref->{'H_BOUND'} ) ) {
    return $standardref;
  } else {
    croak "Unable to obtain INTEGINT, PEAK, L_BOUND, and H_BOUND from index file entry $standardfile\n";
  }
}

=back

=head2 Support Methods

Each of the methods above has a support implementation to obtain
the index file, current name and whether the value can be updated
or not. For method "cal" there will be corresponding methods
"calindex", "calname" and "calnoupdate". "calcache" is an
allowed synonym for "calname".

  $current = $Cal->calcache();
  $index = $Cal->calindex();
  $noup = $Cal->calnoupdate();

=head1 AUTHORS

Brad Cavanagh <b.cavanagh@jach.hawaii.edu>

=head1 COPYRIGHT

Copyright (C) 2007-2009 Science and Technology Facilities Council.
All Rights Reserved.

=cut

1;
